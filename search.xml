<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>JUC高并发编程-共享模型之内存模型（JMM）</title>
    <url>/2022/05/16/2022-05-16-JUC%E9%AB%98%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%EF%BC%88JMM%EF%BC%89/</url>
    <content><![CDATA[<h1 id="内存模型（JMM）"><a href="#内存模型（JMM）" class="headerlink" title="内存模型（JMM）"></a>内存模型（JMM）</h1><span id="more"></span>

<h4 id="Java内存模型"><a href="#Java内存模型" class="headerlink" title="Java内存模型"></a>Java内存模型</h4><p>JMM即Java Memory Model，它定义了主存、工作内存抽象概念，底层对应着CPU寄存器、缓存、硬件内存、CPU指令优化等。</p>
<p>JMM体现在以下几个方面</p>
<ul>
<li>原子性-保证指令不会受到线程上下文切换的影响</li>
<li>可见性-保证指令不会受到cpu缓存的影响</li>
<li>有序性-保证指令不会受cpu指令并行优化的影响</li>
</ul>
<h4 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h4><h5 id="退不出的循环"><a href="#退不出的循环" class="headerlink" title="退不出的循环"></a>退不出的循环</h5><p>先来看一个现象，main线程对run变量的修改对于t线程不可见，导致了t线程无法停止：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="type">boolean</span> <span class="variable">run</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">        <span class="keyword">while</span>(run)&#123;</span><br><span class="line">            <span class="comment">//...</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    t.start();</span><br><span class="line">    </span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line">    run = <span class="literal">false</span>;<span class="comment">//线程t不会如预想的停下来</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>分析：</p>
<ul>
<li>初始状态，t线程刚开始从主存读取了run的值到工作内存。</li>
</ul>
<p><img src="/../images/img84.PNG" alt="img84"></p>
<ul>
<li><p>因为t线程要频繁从主内存中读取run的值，JIT编译器会将run的值缓存至自己g工作内存中的高速缓存中，减少对主存中run的访问，提高效率。</p>
<p><img src="/../images/img85.PNG" alt="img85"></p>
</li>
<li><p>1秒后，main线程修改了run的值，并同步至主存，而t是从自己工作内存中的高速缓存中读取这个变量的值，结果永远是旧值。</p>
</li>
</ul>
<p><img src="/../images/img86.PNG" alt="img86"></p>
<h5 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">volatile</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="variable">run</span> <span class="operator">=</span> <span class="literal">true</span>;<span class="comment">//加入volatile易变关键字</span></span><br></pre></td></tr></table></figure>

<p>它可以用来修饰成员变量和静态变量，它可以避免线程从自己的工作缓存中查找变量的值，必须到主存中获取它的值，线程操作volatile变量都是直接操作主存。</p>
<h4 id="可见性和原子性"><a href="#可见性和原子性" class="headerlink" title="可见性和原子性"></a>可见性和原子性</h4><p>前面的例子体现的实际是可见性，他保证的是在多个线程之间，一个线程对volatile变量的修改对另一个线程可见，不能保证原子性，仅用在一个写线程，多个读线程的情况。</p>
<p>注意：synchronized语句块既可以保证代码块的原子性，也同时保证代码块内变量的可见性，但缺点是synchronized是属于重量级操作，性能相对更低。</p>
<h4 id="有序性"><a href="#有序性" class="headerlink" title="有序性"></a>有序性</h4><p>JVM会在不影响正确性的前提下，可以调整语句的执行顺序。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="type">int</span> i;</span><br><span class="line"><span class="keyword">static</span> <span class="type">int</span> j;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在某个线程内执行如下操作</span></span><br><span class="line">i = ...;</span><br><span class="line">j = ...;</span><br></pre></td></tr></table></figure>

<p>以上执行i，j的顺序不会影响最后结果。这种特性称之为指令重排，多线程下指令重排会影响正确性。</p>
<p><strong>指令重排原理</strong></p>
<p>鱼罐头的故事</p>
<p>加工一条鱼需要50分钟，只能一条鱼    ，一条鱼顺序加工。。。。</p>
<p><img src="/../images/img87.PNG" alt="img87"></p>
<p>可以将每个鱼罐头的加工流程细分为5个步骤：</p>
<ul>
<li>去鳞清洗 10分钟</li>
<li>蒸煮沥水 10分钟</li>
<li>加注汤料 10分钟</li>
<li>杀菌出锅 10分钟</li>
<li>真空封罐 10分钟</li>
</ul>
<p>即使只有一个工人，最理想的情况：他能够在10分钟内同时做好5件事，因为对第一条鱼的真空装罐，不会影响对第二条鱼的杀菌出锅。</p>
<p><strong>指令重排序列优化</strong></p>
<p>事实上，现代处理器会设计为一个时钟周期完成一条执行时间最长的CPU指令。可以想到指令还可以再划分成一个个更小的阶段，例如，每条指令都可以分为：取指令-指令译码-执行指令-内存访问-数据写回这5个阶段。</p>
<p><img src="/../images/img88.PNG" alt="img88"></p>
<h4 id="volatile原理"><a href="#volatile原理" class="headerlink" title="volatile原理"></a>volatile原理</h4><p>volatile的底层实现原理是内存屏障，Memory Barrier（Memory Fence）</p>
<ul>
<li>对volatile变量的写指令后会加入写屏障</li>
<li>对volatile变量的读指令后会加入读屏障</li>
</ul>
<h5 id="如何保证可见性"><a href="#如何保证可见性" class="headerlink" title="如何保证可见性"></a>如何保证可见性</h5><p>写屏障保证在该屏障之前的，对共享变量的改动，都同步到主存中</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">actor2</span><span class="params">(I_Result r)</span>&#123;</span><br><span class="line">    num = <span class="number">2</span>;</span><br><span class="line">    ready = <span class="literal">true</span>;<span class="comment">//ready是volatile赋值带写屏障</span></span><br><span class="line">    <span class="comment">//写屏障</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而读屏障保证在该屏障之后，对共享变量的读取，加载的是主存中最新的数据</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">actor1</span><span class="params">(I_Result r)</span>&#123;</span><br><span class="line">    <span class="comment">//读屏障</span></span><br><span class="line">    <span class="comment">//ready是volatile读取值带读屏障</span></span><br><span class="line">    <span class="keyword">if</span>(ready)&#123;</span><br><span class="line">        r.r1 = num +num;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        r.r1 = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/../images/img89.PNG" alt="img89"></p>
<h5 id="如何保证有序性"><a href="#如何保证有序性" class="headerlink" title="如何保证有序性"></a>如何保证有序性</h5><p>写屏障确保指令重排序时，不会将写屏障之前的代码排在写屏障之后</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">actor2</span><span class="params">(I_Result r)</span>&#123;</span><br><span class="line">    num = <span class="number">2</span>;</span><br><span class="line">    ready = <span class="literal">true</span>;<span class="comment">//ready是volatile赋值带写屏障</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>读屏障会确保指令重排序时，不会将读屏障之后的代码排在读屏障之前</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">actor1</span><span class="params">(I_Result r)</span>&#123;</span><br><span class="line">    <span class="comment">//读屏障</span></span><br><span class="line">    <span class="comment">//ready是volatile读取值带读屏障</span></span><br><span class="line">    <span class="keyword">if</span>(ready)&#123;</span><br><span class="line">        r.r1 = num +num;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        r.r1 = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/../images/img90.PNG" alt="img90"></p>
<p>不能解决指令交错：</p>
<ul>
<li>写屏障仅仅是保证之后的读能够读到最新的结果，但不能保证读跑到它前面去</li>
<li>而有序性的保证知识保证了本线程内相关代码不被重排序</li>
</ul>
<p><img src="/../images/img91.PNG" alt="img91"></p>
<h5 id="double-checked-locking问题"><a href="#double-checked-locking问题" class="headerlink" title="double-checked locking问题"></a>double-checked locking问题</h5><p>以著名的double-checked locking单例模式为例</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Singleton</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Singleton&#123;&#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="type">Singleton</span> <span class="variable">INSTANCE</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(INSTANCE == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span>(Singleton.class)&#123;</span><br><span class="line">                <span class="keyword">if</span>(INSTANCE == <span class="literal">null</span>)&#123;</span><br><span class="line">                    INSTANCE = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上实例实现的特点：</p>
<ul>
<li>懒惰实例化</li>
<li>首次使用getInstance()才使用synchronized加锁，后续使用时无需加锁</li>
<li>有隐含的，但很关键的一点：第一个if使用了INSTANCE变量，是在同步块之外</li>
</ul>
<h4 id="happens-before"><a href="#happens-before" class="headerlink" title="happens-before"></a>happens-before</h4><p>happens-before规定了共享变量的写操作对其他线程的读操作可见，它是可见性与有序性的一套规则总结，抛开一下happens-before规则，JMM并不能保证一个线程对共享变量的写，对于其他线程对该共享变量的读可见。</p>
<p>线程解锁m之前对变量的写，对于接下来对m加锁的其它线程对该变量的读可见。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="type">int</span> x;</span><br><span class="line"><span class="keyword">static</span> <span class="type">Object</span> <span class="variable">m</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(m)&#123;</span><br><span class="line">        x = <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,<span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(,)&#123;</span><br><span class="line">        System.out.println(x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,<span class="string">&quot;t2&quot;</span>).start();</span><br></pre></td></tr></table></figure>

<p>线程对volatile变量的写，对接下来其它线程对该变量的读可见</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">volatile</span> <span class="keyword">static</span> <span class="type">int</span> x;</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">    x = <span class="number">10</span>;</span><br><span class="line">&#125;,<span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">    System.out.println(x);</span><br><span class="line">&#125;,<span class="string">&quot;t2&quot;</span>).start();</span><br></pre></td></tr></table></figure>

<p>线程start前对变量的写，对该线程开始后对该变量的读可见</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="type">int</span> x；</span><br><span class="line"></span><br><span class="line">x = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">    System.out.println();</span><br><span class="line">&#125;,<span class="string">&quot;t2&quot;</span>).start();</span><br></pre></td></tr></table></figure>

<p>线程结束前对变量的写，对其它线程得知它的结束后的读可见（比如其它线程调用t1.isAlive()或t1.join()）等</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="type">int</span> x;</span><br><span class="line"></span><br><span class="line"><span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">    x = <span class="number">10</span>;</span><br><span class="line">&#125;,<span class="string">&quot;t1&quot;</span>);</span><br><span class="line">t1.start();</span><br><span class="line"></span><br><span class="line">t1.join();</span><br><span class="line">System.out.prinln(x);</span><br></pre></td></tr></table></figure>

<p>线程t1打断t2（interrupt）前对变量的写，对于其他线程得知t2被打断后对变量的读可见（通过t2.interrupted或t2.isInterrupted）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="type">int</span> x;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(Thread.currentThread().isInterrupted())&#123;</span><br><span class="line">                System.out.prinln(x);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,<span class="string">&quot;t2&quot;</span>);</span><br><span class="line">    t2.start();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">        x = <span class="number">10</span>;</span><br><span class="line">        t2.interrupted();</span><br><span class="line">    &#125;,<span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(!t2.isInterrupted())&#123;</span><br><span class="line">        Thread.yield();</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对变量默认值（0，false，null）的写，对其它线程对该变量的读可见</p>
<p>具有传递性，如果x hb-&gt;y并且y hb-&gt;z那么有x hb-&gt;z,配合volatile的防指令重排，有下面的例子</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">volatile</span> <span class="keyword">static</span> <span class="type">int</span> x;</span><br><span class="line"><span class="keyword">static</span> <span class="type">int</span> y;</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">    y = <span class="number">10</span>;</span><br><span class="line">    x = <span class="number">20</span></span><br><span class="line">&#125;,<span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">    System.out.println(x);</span><br><span class="line">&#125;,<span class="string">&quot;t2&quot;</span>).start();</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>多线程与高并发</category>
      </categories>
      <tags>
        <tag>多线程与高并发</tag>
      </tags>
  </entry>
  <entry>
    <title>JUC高并发编程-共享模型之不可变</title>
    <url>/2022/05/17/2022-05-17-JUC%E9%AB%98%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-%E5%85%B1%E4%BA%AB%E6%A8%A1%E5%9E%8B%E4%B9%8B%E4%B8%8D%E5%8F%AF%E5%8F%98/</url>
    <content><![CDATA[<h1 id="共享模型之不可变"><a href="#共享模型之不可变" class="headerlink" title="共享模型之不可变"></a>共享模型之不可变</h1><span id="more"></span>

<h4 id="日期转换的问题"><a href="#日期转换的问题" class="headerlink" title="日期转换的问题"></a>日期转换的问题</h4><p>下面的代码在运行时，由于 SimpleDateFormat 不是线程安全的，有很大几率出现 java.lang.NumberFormatException 或者出现不正确的日期解析结果。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">SimpleDateFormat</span> <span class="variable">sdf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;&#123;&#125;&quot;</span>, sdf.parse(<span class="string">&quot;1951-04-21&quot;</span>));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            log.error(<span class="string">&quot;&#123;&#125;&quot;</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        输出：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Exception in thread <span class="string">&quot;Thread-3&quot;</span> Exception in thread <span class="string">&quot;Thread-0&quot;</span> java.lang.NumberFormatException: For input string: <span class="string">&quot;1951.&quot;</span></span><br><span class="line">	at java.base/java.lang.NumberFormatException.forInputString(NumberFormatException.java:<span class="number">65</span>)</span><br><span class="line">	at java.base/java.lang.Long.parseLong(Long.java:<span class="number">692</span>)</span><br><span class="line">	at java.base/java.lang.Long.parseLong(Long.java:<span class="number">817</span>)</span><br><span class="line">	at java.base/java.text.DigitList.getLong(DigitList.java:<span class="number">195</span>)</span><br><span class="line">	at java.base/java.text.DecimalFormat.parse(DecimalFormat.java:<span class="number">2123</span>)</span><br><span class="line">	at java.base/java.text.SimpleDateFormat.subParse(SimpleDateFormat.java:<span class="number">1933</span>)</span><br><span class="line">	at java.base/java.text.SimpleDateFormat.parse(SimpleDateFormat.java:<span class="number">1541</span>)</span><br><span class="line">	at java.base/java.text.DateFormat.parse(DateFormat.java:<span class="number">393</span>)</span><br><span class="line">	at com.heu.test.TestDate.lambda$main$<span class="number">0</span>(TestDate.java:<span class="number">21</span>)</span><br><span class="line">	at java.base/java.lang.Thread.run(Thread.java:<span class="number">834</span>)</span><br></pre></td></tr></table></figure>

<p>如果一个对象不能够修改其内部状态（属性），那么它就是线程安全的，因为不存在并发修改！这样的对象在 java 中有很多，例如在 Java 8 后，提供了一个新的日期格式化类 DateTimeFormatter。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">DateTimeFormatter</span> <span class="variable">dtf</span> <span class="operator">=</span> DateTimeFormatter.ofPattern(<span class="string">&quot;yyyy-MM-dd&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">                <span class="type">LocalDate</span> <span class="variable">date</span> <span class="operator">=</span> dtf.parse(<span class="string">&quot;2018-10-01&quot;</span>, LocalDate::from);</span><br><span class="line">                log.debug(<span class="string">&quot;&#123;&#125;&quot;</span>, date);</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<h4 id="不可变设计"><a href="#不可变设计" class="headerlink" title="不可变设计"></a>不可变设计</h4><p>String类中不可变的体现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">String</span></span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">java</span>.io.Serializable, Comparable&lt;String&gt;, CharSequence &#123;</span><br><span class="line">    <span class="comment">/** The value is used for character storage. */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">char</span> value[];</span><br><span class="line">    <span class="comment">/** Cache the hash code for the string */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> hash; <span class="comment">// Default to 0</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="final-的使用"><a href="#final-的使用" class="headerlink" title="final 的使用"></a>final 的使用</h5><p>发现该类、类中所有属性都是 ﬁnal 的：</p>
<ul>
<li>属性用 ﬁnal 修饰保证了该属性是只读的，不能修改。</li>
<li>类用 ﬁnal 修饰保证了该类中的方法不能被覆盖，防止子类无意间破坏不可变性。</li>
</ul>
<h5 id="保护性拷贝"><a href="#保护性拷贝" class="headerlink" title="保护性拷贝"></a>保护性拷贝</h5><p>有同学会说，使用字符串时，也有一些跟修改相关的方法啊，比如 substring 等，那么下面就看一看这些方法是 如何实现的，就以 substring 为例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">substring</span><span class="params">(<span class="type">int</span> beginIndex, <span class="type">int</span> endIndex)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (beginIndex &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">StringIndexOutOfBoundsException</span>(beginIndex);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (endIndex &gt; value.length) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">StringIndexOutOfBoundsException</span>(endIndex);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">subLen</span> <span class="operator">=</span> endIndex - beginIndex;</span><br><span class="line">        <span class="keyword">if</span> (subLen &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">StringIndexOutOfBoundsException</span>(subLen);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 上面是一些校验，下面才是真正的创建新的String对象</span></span><br><span class="line">        <span class="keyword">return</span> ((beginIndex == <span class="number">0</span>) &amp;&amp; (endIndex == value.length)) ? <span class="built_in">this</span></span><br><span class="line">                : <span class="keyword">new</span> <span class="title class_">String</span>(value, beginIndex, subLen);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>我们发现其内部是调用 String 的构造方法创建了一个新字符串：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">String</span><span class="params">(<span class="type">char</span> value[], <span class="type">int</span> offset, <span class="type">int</span> count)</span> &#123;</span><br><span class="line">       <span class="keyword">if</span> (offset &lt; <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">StringIndexOutOfBoundsException</span>(offset);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span> (count &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="keyword">if</span> (count &lt; <span class="number">0</span>) &#123;</span><br><span class="line">               <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">StringIndexOutOfBoundsException</span>(count);</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">if</span> (offset &lt;= value.length) &#123;</span><br><span class="line">               <span class="built_in">this</span>.value = <span class="string">&quot;&quot;</span>.value;</span><br><span class="line">               <span class="keyword">return</span>;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">// Note: offset or count might be near -1&gt;&gt;&gt;1.</span></span><br><span class="line">       <span class="keyword">if</span> (offset &gt; value.length - count) &#123;</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">StringIndexOutOfBoundsException</span>(offset + count);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">// 上面是一些安全性的校验，下面是给String对象的value赋值，新创建了一个数组来保存String对象的值</span></span><br><span class="line">       <span class="built_in">this</span>.value = Arrays.copyOfRange(value, offset, offset+count);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h4 id="模式之享元"><a href="#模式之享元" class="headerlink" title="模式之享元"></a>模式之享元</h4><h5 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h5><p>享元定义英文名称：Flyweight pattern。当需要重用数量有限的同一类对象时，归类为：Structual patterns。</p>
<h5 id="体现"><a href="#体现" class="headerlink" title="体现"></a>体现</h5><p><strong>包装类</strong><br>在JDK中 Boolean，Byte，Short，Integer，Long，Character 等包装类提供了 valueOf 方法。例如 Long 的 valueOf 会缓存 -128~127 之间的 Long 对象，在这个范围之间会重用对象，大于这个范围，才会新建 Long 对象：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Long <span class="title function_">valueOf</span><span class="params">(<span class="type">long</span> l)</span> &#123;</span><br><span class="line"> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">offset</span> <span class="operator">=</span> <span class="number">128</span>;</span><br><span class="line"> <span class="keyword">if</span> (l &gt;= -<span class="number">128</span> &amp;&amp; l &lt;= <span class="number">127</span>) &#123; <span class="comment">// will cache</span></span><br><span class="line"> <span class="keyword">return</span> LongCache.cache[(<span class="type">int</span>)l + offset];</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Long</span>(l);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>Byte, Short, Long 缓存的范围都是 -128~127。</p>
</li>
<li><p>Character 缓存的范围是 0~127。</p>
</li>
<li><p>Integer 的默认范围是 -128~127，最小值不能变，但最大值可以通过调整虚拟机参数 “-Djava.lang.Integer.IntegerCache.high “来改变。</p>
</li>
<li><p>Boolean 缓存了 TRUE 和 FALSE</p>
</li>
</ul>
<h4 id="final的原理"><a href="#final的原理" class="headerlink" title="final的原理"></a>final的原理</h4><p><strong>设置 final 变量的原理</strong></p>
<p>理解了 volatile 原理，再对比 final 的实现就比较简单了：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestFinal</span> &#123;</span><br><span class="line">	<span class="keyword">final</span> <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>字节码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0: aload_0</span><br><span class="line">1: invokespecial #1 // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">4: aload_0</span><br><span class="line">5: bipush 20</span><br><span class="line">7: putfield #2 // Field a:I</span><br><span class="line"> &lt;-- 写屏障</span><br><span class="line">10: return</span><br></pre></td></tr></table></figure>

<p>final 变量的赋值操作都必须在定义时或者构造器中进行初始化赋值，并且发现 final 变量的赋值也会通过 putfield 指令来完成，同样在这条指令之后也会加入写屏障，保证在其它线程读到它的值时不会出现为 0 的情况。</p>
]]></content>
      <categories>
        <category>多线程与高并发</category>
      </categories>
      <tags>
        <tag>多线程与高并发</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM概述</title>
    <url>/2022/03/14/JVM-%E7%A8%8B%E5%BA%8F%E8%AE%A1%E6%95%B0%E5%99%A8/</url>
    <content><![CDATA[<h3 id="JVM内存模型"><a href="#JVM内存模型" class="headerlink" title="JVM内存模型"></a>JVM内存模型</h3><span id="more"></span>

<h3 id="1、什么是JVM？"><a href="#1、什么是JVM？" class="headerlink" title="1、什么是JVM？"></a>1、什么是JVM？</h3><ul>
<li>JVM是一种用于计算设备的规范，它是一个虚构出来的机器，是通过在实际的计算机上仿真模拟各种功能实现的。</li>
<li>JVM包含一套字节码指令集，一组寄存器，一个栈，一个垃圾回收堆和一个存储方法域。</li>
<li>JVM屏蔽了与具体操作系统平台相关的信息，使java程序只需要生成在java虚拟机上运行的目标代码（字节码），就可以在多种平台上不加修改地运行。</li>
</ul>
<p>JVM在执行字节码时，实际上最终还是把字节码解释成具体平台上的机器指令执行。</p>
<h3 id="2、JDK、JRE、JVM是什么关系？"><a href="#2、JDK、JRE、JVM是什么关系？" class="headerlink" title="2、JDK、JRE、JVM是什么关系？"></a>2、JDK、JRE、JVM是什么关系？</h3><ul>
<li>JRE（Java Runtime Environment），也就是java平台。所有的java程序都要在JRE环境下才能运行。</li>
<li>JDK（Java Development  Kit），是开发者用来编译、调试程序用的开发包。JDK也是JAVA程序需要在JRE上运行的。</li>
<li>JVM（Java Virtual Machine），是JRE的一部分。它是一个虚构出来的计算机，是通过在实际的计算机上仿真模拟各种计算机功能来实现的。</li>
</ul>
<p>JVM有自己完善的硬件架构，如处理器、堆栈、寄存器等，还具有相应的指令系统。</p>
<p>Java语言最重要的特点就是跨平台运行。使用JVM就是为了支持与操作系统无关，实现跨平台。</p>
<h3 id="3、JVM原理"><a href="#3、JVM原理" class="headerlink" title="3、JVM原理"></a>3、JVM原理</h3><ul>
<li>jvm是java的核心和基础，在java编译器和os平台之间的虚拟处理器，可在上面执行字节码程序。</li>
<li>java编译器只要面向jvm，生成jvm能理解的字节码文件。java源文件经编译成字节码程序，通过jvm将每条指令翻译成不同的机器码，通过特定平台运行。</li>
</ul>
<p><img src="/../images/26.png" alt="26"></p>
<h3 id="4、JVM执行程序的过程"><a href="#4、JVM执行程序的过程" class="headerlink" title="4、JVM执行程序的过程"></a>4、JVM执行程序的过程</h3><ul>
<li>加载.class文件</li>
<li>管理并分配内存</li>
<li>执行垃圾收集</li>
</ul>
<p>JRE（java运行时环境）由JVM构造的java程序的运行环，也是Java程序运行的环境，但是他同时一个操作系统的一个应用程序一个进程，因此他也有他自己的运行的生命周期，也有自己的代码和数据空间。JVM在整个jdk中处于最底层，负责于操作系统的交互，用来屏蔽操作系统环境，提供一个完整的Java运行环境，因此也就虚拟计算机。</p>
<p>操作系统装入JVM是通过jdk中Java.exe来完成，<br>通过下面4步来完成JVM环境：</p>
<ul>
<li>创建JVM装载环境和配置</li>
<li>装载JVM.dll</li>
<li>初始化JVM.dll并挂界到JNIENV(JNI调用接口)实例</li>
<li>调用JNIEnv实例装载并处理class类。</li>
</ul>
<h3 id="5、JVM的生命周期"><a href="#5、JVM的生命周期" class="headerlink" title="5、JVM的生命周期"></a>5、JVM的生命周期</h3><ul>
<li><p>JVM实例对应了一个独立运行的java程序它是进程级别</p>
<p>a) 启动。启动一个Java程序时，一个JVM实例就产生了，任何一个拥有public static void<br>main(String[] args)函数的class都可以作为JVM实例运行的起点。<br>b) 运行。main()作为该程序初始线程的起点，任何其他线程均由该线程启动。JVM内部有两种线程：守护线程和非守护线程，main()属于非守护线程，守护线程通常由JVM自己使用，java程序也可以表明自己创建的线程是守护线程。<br>c) 消亡。当程序中的所有非守护线程都终止时，JVM才退出；若安全管理器允许，程序也可以使用Runtime类或者System.exit()来退出。</p>
</li>
<li><p>JVM执行引擎实例则对应了属于用户运行程序的线程它是线程级别的。</p>
</li>
</ul>
<h3 id="6、JVM内存模型"><a href="#6、JVM内存模型" class="headerlink" title="6、JVM内存模型"></a>6、JVM内存模型</h3><ul>
<li>java代码具体执行过程如下图，</li>
</ul>
<p><img src="/../images/27.png" alt="27"></p>
<ul>
<li>运行时数据区，即jvm内存结构图如下图，</li>
</ul>
<p><img src="/../images/28.png" alt="28"></p>
<ul>
<li><p>运行时数据区存储了哪些数据？</p>
</li>
<li><p><input disabled type="checkbox"> 
程序计数器(PC寄存器)</p>
<p>由于在JVM中，多线程是通过线程轮流切换来获得CPU执行时间的，因此，在任一具体时刻，一个CPU的内核只会执行一条线程中的指令，</p>
<p>因此，为了能够使得每个线程都在线程切换后能够恢复在切换之前的程序执行位置，每个线程都需要有自己独立的程序计数器，并且不能互相被干扰，</p>
<p>否则就会影响到程序的正常执行次序。因此，可以这么说，程序计数器是每个线程所私有的。由于程序计数器中存储的数据所占空间的大小不会随程序的执行而发生改变，</p>
<p>因此，对于程序计数器是不会发生内存溢出现象(OutOfMemory)的。</p>
</li>
<li><p><input disabled type="checkbox"> 
java栈</p>
<p>Java栈中存放的是一个个的栈帧，每个栈帧对应一个被调用的方法，在栈帧中包括局部变量表(Local Variables)、操作数栈(Operand Stack)、</p>
<p>指向当前方法所属的类的运行时常量池（运行时常量池的概念在方法区部分会谈到）的引用(Reference to runtime constant pool)、</p>
</li>
</ul>
<p>**方法返回地址(Return Address)**和一些额外的附加信息。当线程执行一个方法时，就会随之创建一个对应的栈帧，并将建立的栈帧压栈。当方法执行完毕之后，便会将栈帧出栈。</p>
<p><img src="/../images/29.png" alt="29"></p>
<ul>
<li><p><input disabled type="checkbox"> 
本地方法栈</p>
<p>本地方法栈与Java栈的作用和原理非常相似。区别只不过是Java栈是为执行Java方法服务的，而本地方法栈则是为执行本地方法（Native Method）服务的。</p>
</li>
<li><p><input disabled type="checkbox"> 
堆</p>
<p>Java中的堆是用来存储对象本身的以及数组（数组引用是存放在Java栈中的）。堆是被所有线程共享的，在JVM中只有一个堆。</p>
</li>
<li><p><input disabled type="checkbox"> 
方法区</p>
<p>与堆一样，是被线程共享的区域。在方法区中，存储了每个类的信息（包括类的名称、方法信息、字段信息）、静态变量、常量以及编译器编译后的代码等。</p>
<p>在Class文件中除了类的字段、方法、接口等描述信息外，还有一项信息是常量池，用来存储编译期间生成的字面量和符号引用。</p>
</li>
</ul>
<p>在方法区中有一个非常重要的部分就是运行时常量池，它是每一个类或接口的常量池的运行时表示形式，在类和接口被加载到JVM后，</p>
<p>对应的运行时常量池就被创建出来。当然并非Class文件常量池中的内容才能进入运行时常量池，在运行期间也可将新的常量放入运行时常量池中，比如String的intern方法。</p>
<h3 id="7、JVM内存溢出的情况"><a href="#7、JVM内存溢出的情况" class="headerlink" title="7、JVM内存溢出的情况"></a>7、JVM内存溢出的情况</h3><p><img src="/../images/30.png" alt="30"></p>
<ul>
<li><p>程序计数器（Program Counter Register）</p>
<p>每条线程都有一个独立的的程序计数器，各线程间的计数器互不影响，因此该区域是线程私有的。该内存区域是唯一一个在Java虚拟机规范中没有规定任何OOM（内存溢出：OutOfMemoryError）情况的区域。</p>
</li>
<li><p>java虚拟机栈（Java Virtual Machine Stacks）</p>
<p>在Java虚拟机规范中，对这个区域规定了两种异常情况：</p>
<p>1、如果线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOverflowError异常。</p>
<p>2、如果虚拟机在动态扩展栈时无法申请到足够的内存空间，则抛出OutOfMemoryError异常。这两种情况存在着一些互相重叠的地方：当栈空间无法继续分配时，到底是内存太小，还是已使用的栈空间太大，其本质上只是对同一件事情的两种描述而已。</p>
<p>在单线程的操作中，无论是由于栈帧太大，还是虚拟机栈空间太小，当栈空间无法分配时，虚拟机抛出的都是StackOverflowError异常，而不会得到OutOfMemoryError异常。</p>
<p>而在多线程环境下，则会抛出OutOfMemoryError异常。</p>
</li>
<li><p>堆（Java Heap）</p>
<p>Java Heap是Java虚拟机所管理的内存中最大的一块，它是所有线程共享的一块内存区域。几乎所有的对象实例和数组都在这类分配内存。Java Heap是垃圾收集器管理的主要区域，因此很多时候也被称为“GC堆”。</p>
<p>根据Java虚拟机规范的规定，Java堆可以处在物理上不连续的内存空间中，只要逻辑上是连续的即可。如果在堆中没有内存可分配时，并且堆也无法扩展时，将会抛出OutOfMemoryError异常。   </p>
</li>
<li><p>方法区域（Method Area）</p>
<p>方法区域，又被称为“永久代”，当方法区无法满足内存分配需求时，将抛出OutOfMemoryError异常。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>项目实战-尚医通 - 项目实战</title>
    <url>/2022/05/26/2022-05-26-%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98-%E5%B0%9A%E5%8C%BB%E9%80%9A/</url>
    <content><![CDATA[<h1 id="项目实战-尚医通"><a href="#项目实战-尚医通" class="headerlink" title="项目实战-尚医通"></a>项目实战-尚医通</h1><span id="more"></span>

<h3 id="MyBatis-Plus入门"><a href="#MyBatis-Plus入门" class="headerlink" title="MyBatis-Plus入门"></a>MyBatis-Plus入门</h3><h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p>Mybatis-Plus是一个MyBatis的增强工具，在MyBatis的基础上只做增强不做改变，为简化开发、提高效率而生。</p>
<ul>
<li>只做增强不做改变，引入它不会对现有工程产生影响。</li>
<li>只需要简单配置，即可快速进行CRUD操作，从而节省大量时间。</li>
<li>热加载、代码生成、分页、性能分析等功能一应俱全。</li>
</ul>
<h4 id="创建并初始化数据库"><a href="#创建并初始化数据库" class="headerlink" title="创建并初始化数据库"></a>创建并初始化数据库</h4><h5 id="创建数据库"><a href="#创建数据库" class="headerlink" title="创建数据库"></a>创建数据库</h5><p>mybatis-plus</p>
<h5 id="创建User表"><a href="#创建User表" class="headerlink" title="创建User表"></a>创建User表</h5><p>其对应数据库Schema脚本如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> <span class="keyword">User</span>(</span><br><span class="line">	id <span class="type">bigint</span>(<span class="number">20</span>)<span class="keyword">not</span> <span class="keyword">null</span> comment <span class="string">&#x27;主键ID&#x27;</span>,</span><br><span class="line">    name <span class="type">varchar</span>(<span class="number">30</span>)<span class="keyword">null</span> <span class="keyword">default</span> <span class="keyword">null</span> comment <span class="string">&#x27;姓名&#x27;</span>,</span><br><span class="line">    age <span class="type">int</span>(<span class="number">11</span>)<span class="keyword">null</span> <span class="keyword">default</span> <span class="keyword">null</span> comment <span class="string">&#x27;年龄&#x27;</span>,</span><br><span class="line">    email <span class="type">varchar</span>(<span class="number">50</span>)<span class="keyword">null</span> <span class="keyword">default</span> <span class="keyword">null</span> comment <span class="string">&#x27;邮箱&#x27;</span>,</span><br><span class="line">    <span class="keyword">primary</span> key (id)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>项目实战</category>
      </categories>
  </entry>
  <entry>
    <title>SpringBoot自动配置的原理及实现</title>
    <url>/2022/03/11/SpringBoot%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE%E7%9A%84%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>springBoot</category>
      </categories>
      <tags>
        <tag>springBoot</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo+github搭建个人博客</title>
    <url>/2022/03/02/hexo+github%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<h3 id="hexo-github保姆级教程搭建个人博客（适合windows系统，linux类似）"><a href="#hexo-github保姆级教程搭建个人博客（适合windows系统，linux类似）" class="headerlink" title="hexo+github保姆级教程搭建个人博客（适合windows系统，linux类似）"></a>hexo+github保姆级教程搭建个人博客（适合windows系统，linux类似）</h3><span id="more"></span>

<h4 id="1、前提条件"><a href="#1、前提条件" class="headerlink" title="1、前提条件"></a>1、前提条件</h4><p>（1）windows系统上安装node.js，自行百度。检验是否安装成功如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">node -v</span><br></pre></td></tr></table></figure>

<p><img src="/../images/1.PNG" alt="1"></p>
<p>（2）安装hexo框架，检验是否安装成功如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm i -g hexo #安装hexo</span><br><span class="line">hexo -v	#查看版本</span><br><span class="line">hexo init #初始化命令</span><br></pre></td></tr></table></figure>

<p><img src="/../images/2.PNG" alt="2"></p>
<p>（3）Git安装。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git --version</span><br></pre></td></tr></table></figure>

<p><img src="/../images/3.PNG" alt="3"></p>
<h4 id="2、准备注册号的github账号，创建本地仓库（https-username-github-io）"><a href="#2、准备注册号的github账号，创建本地仓库（https-username-github-io）" class="headerlink" title="2、准备注册号的github账号，创建本地仓库（https://username.github.io）"></a>2、准备注册号的github账号，创建本地仓库（<a href="https://username.github.io)/">https://username.github.io）</a></h4><p>由于github是国外网站，这一步就得看运气了！</p>
<p>（1）创建本地仓库</p>
<p><img src="/../images/4.png" alt="4"></p>
<p><img src="/../images/5.png" alt="5"></p>
<h4 id="3、生成SSH秘钥（须记住）"><a href="#3、生成SSH秘钥（须记住）" class="headerlink" title="3、生成SSH秘钥（须记住）"></a>3、生成SSH秘钥（须记住）</h4><h4 id="4、生成个人博客"><a href="#4、生成个人博客" class="headerlink" title="4、生成个人博客"></a>4、生成个人博客</h4><h4 id="5、修改及配置博客主题（NEXT）"><a href="#5、修改及配置博客主题（NEXT）" class="headerlink" title="5、修改及配置博客主题（NEXT）"></a>5、修改及配置博客主题（NEXT）</h4>]]></content>
      <categories>
        <category>教程</category>
      </categories>
      <tags>
        <tag>教程</tag>
      </tags>
  </entry>
  <entry>
    <title>springcloud五大核心组件</title>
    <url>/2022/03/03/springcloud%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6/</url>
    <content><![CDATA[<h3 id="SpringCloud五大核心组件"><a href="#SpringCloud五大核心组件" class="headerlink" title="SpringCloud五大核心组件"></a>SpringCloud五大核心组件</h3><span id="more"></span>

<h4 id="1、Eureka（与之对应的是Dubbo框架的zookeeper）"><a href="#1、Eureka（与之对应的是Dubbo框架的zookeeper）" class="headerlink" title="1、Eureka（与之对应的是Dubbo框架的zookeeper）"></a>1、Eureka（与之对应的是Dubbo框架的zookeeper）</h4><p>作用：实现服务治理（服务注册与发现）</p>
<p>简介：Spring Cloud Eureka是Spring Cloud Netflix项目下的服务治理模块。</p>
<p>由两个组件组成：Eureka服务端和Eureka客户端。</p>
<p>Eureka服务端用作服务注册中心。支持集群部署。</p>
<p>Eureka客户端是一个java客户端，用来处理服务注册和发现。</p>
<p>在应用启动时，Eureka客户端向服务端注册自己的服务信息，同时将服务端的服务信息缓存在本地。客户端和服务端周期性的进行心跳交互，以更新服务租约和服务信息。</p>
<p><img src="/../images/6.png" alt="6"></p>
<h4 id="2、Ribbon"><a href="#2、Ribbon" class="headerlink" title="2、Ribbon"></a>2、Ribbon</h4><p>作用：Ribbon，主要提供客户侧的软件负载均衡算法。</p>
<p>简介：Spring Cloud Ribbon是一个基于HTTP和TCP的客户端负载均衡工具，它基于Netflix Ribbon实现。通过Spring Cloud的封装，可以让我们轻松地将面向服务的REST模版请求自动转换成客户端负载均衡的服务调用。</p>
<p>注意，关键点就是将外界的rest调用，根据负载均衡策略转换为微服务调用。Ribbon有比较多的负载均衡策略。</p>
<p><img src="/../images/7.png" alt="7"></p>
<h4 id="3、Hystrix"><a href="#3、Hystrix" class="headerlink" title="3、Hystrix"></a>3、Hystrix</h4><p>作用：断路器，保护系统，控制故障范围。</p>
<p>简介：为了保证其高可用，单个服务通常会集群部署。由于网络原因或者自身的原因，服务并不能保证100%可用，如果单个服务出现问题，调用这个服务就会出现线程阻塞，此时若有大量的请求涌入，Servlet容器的线程资源会被消耗完毕，导致服务瘫痪。服务与服务之间的依赖性，故障会传播，会对整个微服务系统造成灾难性的严重后果，这就是服务故障的“雪崩”效应。</p>
<p><img src="/../images/8.png" alt="8"></p>
<h4 id="4、Zuul"><a href="#4、Zuul" class="headerlink" title="4、Zuul"></a>4、Zuul</h4><p>作用：api网关，路由，负载均衡等多种作用</p>
<p>简介：类似nginx，反向代理的功能，不过netflix自己增加了一些配合其他组件的特性。</p>
<p>在微服务架构中，后端服务往往不直接开放给调用端，而是通过一个API网关根据请求的url，路由到相应的服务。当添加API网关后，在第三方调用端和服务提供方之间就创建了一面墙，这面墙直接与调用方通信进行权限控制，后将请求均衡分发给后台服务端。</p>
<p><img src="/../images/9.png" alt="9"></p>
<h4 id="5、Config"><a href="#5、Config" class="headerlink" title="5、Config"></a>5、Config</h4><p>作用：配置管理</p>
<p>简介：SpringCloud Config提供服务器端和客户端。服务器存储后端的默认实现使用git，因此它轻松支持标签版本的配置环境，以及可以访问用于管理内容的各种工具。</p>
<p>这个还是静态的，得配合Spring Cloud Bus实现动态的配置更新。</p>
<p><img src="/../images/10.png" alt="10"></p>
]]></content>
      <categories>
        <category>springcloud</category>
      </categories>
      <tags>
        <tag>springcloud</tag>
      </tags>
  </entry>
  <entry>
    <title>springcloud</title>
    <url>/2022/03/29/springcloud%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<h3 id="springcloud微服务详解"><a href="#springcloud微服务详解" class="headerlink" title="springcloud微服务详解"></a>springcloud微服务详解</h3><p><strong>整体架构</strong></p>
<p><img src="/../images/81.PNG" alt="81"></p>
<span id="more"></span>

]]></content>
      <categories>
        <category>springcloud</category>
      </categories>
      <tags>
        <tag>springcloud</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring源码解析</title>
    <url>/2022/03/15/Spring%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>反向代理-Nginx</title>
    <url>/2022/03/10/%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86-Nginx/</url>
    <content><![CDATA[<h3 id="Nginx"><a href="#Nginx" class="headerlink" title="Nginx"></a>Nginx</h3><p>Nginx(“engine x”)是一款是由俄罗斯的程序设计师Igor Sysoev所开发高性能的 Web和 反向代理 服务器，也是一个 IMAP&#x2F;POP3&#x2F;SMTP 代理服务器。</p>
<p>在高连接并发的情况下，Nginx是Apache服务器不错的替代品。</p>
<span id="more"></span>

<h3 id="1、请解释一下什么是Nginx"><a href="#1、请解释一下什么是Nginx" class="headerlink" title="1、请解释一下什么是Nginx?"></a>1、请解释一下什么是Nginx?</h3><p>Nginx是一个web服务器和反向代理服务器，用于HTTP、HTTPS、SMTP、POP3和IMAP协议。</p>
<h3 id="2、请列举Nginx的一些特性？"><a href="#2、请列举Nginx的一些特性？" class="headerlink" title="2、请列举Nginx的一些特性？"></a>2、请列举Nginx的一些特性？</h3><ul>
<li>反向代理&#x2F;L7负载均衡器</li>
<li>嵌入式Perl解释器</li>
<li>动态二进制升级</li>
<li>可用于重新编写URL。具有非常好的PCRE</li>
</ul>
<h3 id="3、nginx和apache的区别？"><a href="#3、nginx和apache的区别？" class="headerlink" title="3、nginx和apache的区别？"></a>3、nginx和apache的区别？</h3><ul>
<li>轻量级，同样起web 服务，比apache 占用更少的内存及资源</li>
<li>抗并发，nginx 处理请求是异步非阻塞的，而apache 则是阻塞型的，在高并发下nginx 能保持低资源低消耗高性能</li>
<li>高度模块化的设计，编写模块相对简单</li>
<li>最核心的区别在于apache是同步多进程模型，一个连接对应一个进程；nginx是异步的，多个连接（万级别）可以对应一个进程</li>
</ul>
<h3 id="4、nginx是如何实现高并发的？"><a href="#4、nginx是如何实现高并发的？" class="headerlink" title="4、nginx是如何实现高并发的？"></a>4、nginx是如何实现高并发的？</h3><p>一个主进程，多个工作进程，每个工作进程可以处理多个请求，每进来一个request，会有一个worker进程去处理。但不是全程的处理，处理到可能发生阻塞的地方，比如向上游（后端）服务器转发request，并等待请求返回。那么，这个处理的worker继续处理其他请求，而一旦上游服务器返回了，就会触发这个事件，worker才会来接手，这个request才会接着往下走。由于web server的工作性质决定了每个request的大部份生命都是在网络传输中，实际上花费在server机器上的时间片不多。这是几个进程就解决高并发的秘密所在。即@skoo所说的webserver刚好属于网络io密集型应用，不算是计算密集型。</p>
<h3 id="5、请解释Nginx如何处理HTTP请求？"><a href="#5、请解释Nginx如何处理HTTP请求？" class="headerlink" title="5、请解释Nginx如何处理HTTP请求？"></a>5、请解释Nginx如何处理HTTP请求？</h3><p>Nginx使用反应器模式。主事件循环等待操作系统发出准备事件的信号，这样数据就可以从套接字读取，在该实例中读取到缓冲区并进行处理。单个线程可以提供数万个并发连接。</p>
<h3 id="6、在Nginx中，如何使用未定义的服务器名称来阻止处理请求？"><a href="#6、在Nginx中，如何使用未定义的服务器名称来阻止处理请求？" class="headerlink" title="6、在Nginx中，如何使用未定义的服务器名称来阻止处理请求？"></a>6、在Nginx中，如何使用未定义的服务器名称来阻止处理请求？</h3><p>只需将请求删除的服务器就可以定义为： </p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">Server&#123;</span><br><span class="line">	listen 80;server_name &quot;&quot;;</span><br><span class="line">	return 444;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里，服务器名被保留为一个空字符串，它将在没有“主机”头字段的情况下匹配请求，而一个特殊的Nginx的非标准代码444被返回，从而终止连接。</p>
<h3 id="7、使用反向代理服务器的优点是什么？"><a href="#7、使用反向代理服务器的优点是什么？" class="headerlink" title="7、使用反向代理服务器的优点是什么？"></a>7、使用反向代理服务器的优点是什么？</h3><p>反向代理服务器可以隐藏源服务器的存在和特征。它充当互联网云和web服务器之间的中间层。这对于安全方面来说是很好的，特别是当您使用web托管服务时。</p>
<h3 id="8、请列举Nginx服务器的最佳用途。"><a href="#8、请列举Nginx服务器的最佳用途。" class="headerlink" title="8、请列举Nginx服务器的最佳用途。"></a>8、请列举Nginx服务器的最佳用途。</h3><p>Nginx服务器的最佳用法是在网络上部署动态HTTP内容，使用SCGI、WSGI应用程序服务器、用于脚本的FastCGI处理程序。它还可以作为负载均衡器。</p>
<h3 id="9、请解释Nginx服务器上的Master和Worker进程分别是什么？"><a href="#9、请解释Nginx服务器上的Master和Worker进程分别是什么？" class="headerlink" title="9、请解释Nginx服务器上的Master和Worker进程分别是什么？"></a>9、请解释Nginx服务器上的Master和Worker进程分别是什么？</h3><p>Master进程：读取及评估配置和维持 </p>
<p> Worker进程：处理请求</p>
<h3 id="10、请解释如何通过不同80的端口开启Nginx？"><a href="#10、请解释如何通过不同80的端口开启Nginx？" class="headerlink" title="10、请解释如何通过不同80的端口开启Nginx？"></a>10、请解释如何通过不同80的端口开启Nginx？</h3><p>为了通过一个不同的端口开启Nginx，你必须进入&#x2F;etc&#x2F;Nginx&#x2F;sites-enabled&#x2F;，如果这是默认文件，那么你必须打开名为“default”的文件。编辑文件，并放置在你想要的端口：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Like server&#123;</span><br><span class="line">	listen 81;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="11、请解释是否有可能将Nginx的错误替换为502错误，503？"><a href="#11、请解释是否有可能将Nginx的错误替换为502错误，503？" class="headerlink" title="11、请解释是否有可能将Nginx的错误替换为502错误，503？"></a>11、请解释是否有可能将Nginx的错误替换为502错误，503？</h3><p>502 &#x3D;错误网关 503 &#x3D;服务器超载 有可能，但是您可以确保fastcgi_intercept_errors被设置为ON，并使用错误页面指令。 </p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">Location / &#123;</span><br><span class="line">	fastcgi_pass 127.0.0.1:9001;</span><br><span class="line">	fastcgi_intercept_errors on;</span><br><span class="line">	error_page 502=503/error_page.html;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="12、在Nginx中，解释如何在URL中保留双斜线？"><a href="#12、在Nginx中，解释如何在URL中保留双斜线？" class="headerlink" title="12、在Nginx中，解释如何在URL中保留双斜线？"></a>12、在Nginx中，解释如何在URL中保留双斜线？</h3><p>要在URL中保留双斜线，就必须使用merge_slashes_off; </p>
<p> 语法:merge_slashes [on&#x2F;off] </p>
<p> 默认值: merge_slashes on </p>
<p> 环境: http，server</p>
<h3 id="13、请解释ngx-http-upstream-module的作用是什么？"><a href="#13、请解释ngx-http-upstream-module的作用是什么？" class="headerlink" title="13、请解释ngx_http_upstream_module的作用是什么？"></a>13、请解释ngx_http_upstream_module的作用是什么？</h3><p>ngx_http_upstream_module用于定义可通过fastcgi传递、proxy传递、uwsgi传递、memcached传递和scgi传递指令来引用的服务器组。</p>
<h3 id="14、请解释什么是C10K问题？"><a href="#14、请解释什么是C10K问题？" class="headerlink" title="14、请解释什么是C10K问题？"></a>14、请解释什么是C10K问题？</h3><p>C10K问题是指无法同时处理大量客户端(10,000)的网络套接字。</p>
<h3 id="15、请陈述stub-status和sub-filter指令的作用是什么？"><a href="#15、请陈述stub-status和sub-filter指令的作用是什么？" class="headerlink" title="15、请陈述stub_status和sub_filter指令的作用是什么？"></a>15、请陈述stub_status和sub_filter指令的作用是什么？</h3><ul>
<li>Stub_status指令：该指令用于了解Nginx当前状态的当前状态，如当前的活动连接，接受和处理当前读&#x2F;写&#x2F;等待连接的总数</li>
<li>Sub_filter指令：它用于搜索和替换响应中的内容，并快速修复陈旧的数据</li>
</ul>
<h3 id="16、解释Nginx是否支持将请求压缩到上游？"><a href="#16、解释Nginx是否支持将请求压缩到上游？" class="headerlink" title="16、解释Nginx是否支持将请求压缩到上游？"></a>16、解释Nginx是否支持将请求压缩到上游？</h3><p>您可以使用Nginx模块gunzip将请求压缩到上游。gunzip模块是一个过滤器，它可以对不支持“gzip”编码方法的客户机或服务器使用“内容编码:gzip”来解压缩响应。</p>
<h3 id="17、解释如何在Nginx中获得当前时间？"><a href="#17、解释如何在Nginx中获得当前时间？" class="headerlink" title="17、解释如何在Nginx中获得当前时间？"></a>17、解释如何在Nginx中获得当前时间？</h3><p>要获得Nginx的当前时间，必须使用SSI模块、$date_gmt和$date_local的变量。Proxy_set_header THE-TIME $date_gmt;</p>
<h3 id="18、用Nginx服务器解释-s的目的是什么？"><a href="#18、用Nginx服务器解释-s的目的是什么？" class="headerlink" title="18、用Nginx服务器解释-s的目的是什么？"></a>18、用Nginx服务器解释-s的目的是什么？</h3><p>用于运行Nginx -s参数的可执行文件。</p>
<h3 id="19、解释如何在Nginx服务器上添加模块？"><a href="#19、解释如何在Nginx服务器上添加模块？" class="headerlink" title="19、解释如何在Nginx服务器上添加模块？"></a>19、解释如何在Nginx服务器上添加模块？</h3><p>在编译过程中，必须选择Nginx模块，因为Nginx不支持模块的运行时间选择。</p>
]]></content>
      <categories>
        <category>Nginx</category>
      </categories>
      <tags>
        <tag>Nginx</tag>
      </tags>
  </entry>
  <entry>
    <title>数据库优化</title>
    <url>/2022/03/02/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[<h3 id="数据库的优化（常见方法）"><a href="#数据库的优化（常见方法）" class="headerlink" title="数据库的优化（常见方法）"></a>数据库的优化（常见方法）</h3><p>关于数据库优化，网上有不少资料和方法，但是不少质量参差不齐，有些总结的不够到位，内容冗杂</p>
<p>偶尔发现了这篇文章，总结得很经典，文章流量也很大，所以拿到自己的总结文集中，积累优质文章，提升个人能力，希望对大家今后开发中也有帮助。</p>
<span id="more"></span>

<p>1、对查询进行优化，要尽量避免全表扫描，首先应该考虑在where以及order by涉及的列上建立索引。形如：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tablename；#应该尽量避免这种方式</span><br></pre></td></tr></table></figure>

<p>修改为：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> id <span class="keyword">from</span> tablename <span class="keyword">where</span> name <span class="operator">=</span> <span class="string">&#x27;admin&#x27;</span></span><br></pre></td></tr></table></figure>

<p>2、应该尽量避免在where字句中对字段进行null判断，否则将导致引擎放弃索引而进行全表扫描。形如：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> id <span class="keyword">from</span> tablename <span class="keyword">where</span> num <span class="keyword">is</span> <span class="keyword">null</span>；</span><br></pre></td></tr></table></figure>

<p>最好不要给数据库留null，尽可能使用not null填充数据库。</p>
<p>3、应该尽量避免在where子句中使用！&#x3D;或&lt;&gt;操作符，否则引擎将放弃使用索引进行全表扫描。</p>
<p>4、应尽量避免在where子句中使用or来连接条件，如果一个字段有索引，一个字段没有索引，将导致引擎放弃使用索引而进行全表扫描。形如：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> id <span class="keyword">from</span> tablename <span class="keyword">where</span> num <span class="operator">=</span> <span class="number">10</span> <span class="keyword">or</span> name <span class="operator">=</span> <span class="string">&#x27;admin&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>修改为：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> id <span class="keyword">from</span> tablename <span class="keyword">where</span> num <span class="operator">=</span> <span class="number">10</span></span><br><span class="line"><span class="keyword">union</span> <span class="keyword">all</span></span><br><span class="line"><span class="keyword">select</span> id <span class="keyword">from</span> tablename <span class="keyword">where</span> name <span class="operator">=</span> <span class="string">&#x27;admin&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>5、in和not in也要慎用，否则会全表扫描。形如：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> id <span class="keyword">from</span> tablename <span class="keyword">where</span> num <span class="keyword">in</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>);</span><br></pre></td></tr></table></figure>

<p>对于连续的数值，能用between就不要用in</p>
<p>修改为：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> id <span class="keyword">from</span> tablename <span class="keyword">where</span> num <span class="keyword">between</span> <span class="number">1</span> <span class="keyword">and</span> <span class="number">3</span>; </span><br></pre></td></tr></table></figure>

<p>6、使用索引。索引是提高数据库性能的常用方法，它可以令数据库服务器以比没有索引快得多的速度检索特定的行，尤其是在查询语句当中包含有MAX(),MIN()和ORDERBY这些命令的时候，性能提高更为明显。</p>
<p>一般说来，索引应建立在那些将用于JOIN,WHERE判断和ORDERBY排序的字段上。尽量不要对数据库中某个含有大量重复的值的字段建立索引。对于一个ENUM类型的字段来说，出现大量重复值是很有可能的情况</p>
<p>例如customerinfo中的“province”..字段，在这样的字段上建立索引将不会有什么帮助；相反，还有可能降低数据库的性能。我们在创建表的时候可以同时创建合适的索引，也可以使用ALTERTABLE或CREATEINDEX在以后创建索引。此外，MySQL从版本3.23.23开始支持全文索引和搜索。全文索引在MySQL中是一个FULLTEXT类型索引，但仅能用于MyISAM类型的表。对于一个大的数据库，将数据装载到一个没有FULLTEXT索引的表中，然后再使用ALTERTABLE或CREATEINDEX创建索引，将是非常快的。但如果将数据装载到一个已经有FULLTEXT索引的表中，执行过程将会非常慢。</p>
<p>7、使用外键。锁定表的方法可以维护数据的完整性，但是它却不能保证数据的关联性。这个时候我们就可以使用外键。</p>
<p>例如：外键可以保证每一条销售记录都指向某一个存在的客户。在这里，外键可以把customerinfo表中的CustomerID映射到salesinfo表中CustomerID，任何一条没有合法CustomerID的记录都不会被更新或插入到salesinfo中。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> customerinfo(CustomerIDINT <span class="keyword">NOT</span> <span class="keyword">NULL</span>,PRIMARYKEY(CustomerID))TYPE<span class="operator">=</span>INNODB;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> salesinfo(SalesIDNT <span class="keyword">NOT</span> <span class="keyword">NULL</span>,CustomerIDINT <span class="keyword">NOT</span> <span class="keyword">NULL</span>,PRIMARYKEY(CustomerID,SalesID),</span><br><span class="line">FOREIGNKEY(CustomerID) <span class="keyword">REFERENCES</span> customerinfo(CustomerID) <span class="keyword">ON</span> <span class="keyword">DELETE</span>  CASCADE)TYPE<span class="operator">=</span>INNODB;                       </span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>浅谈微服务、Spring Cloud、Spring Boot三者之间的关系</title>
    <url>/2022/03/03/%E6%B5%85%E8%B0%88%E5%BE%AE%E6%9C%8D%E5%8A%A1%E3%80%81Spring-Cloud%E3%80%81Spring-Boot%E4%B8%89%E8%80%85%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB/</url>
    <content><![CDATA[<h3 id="微服务、Spring-Cloud、Spring-Boot三者之间的关系"><a href="#微服务、Spring-Cloud、Spring-Boot三者之间的关系" class="headerlink" title="微服务、Spring Cloud、Spring Boot三者之间的关系"></a>微服务、Spring Cloud、Spring Boot三者之间的关系</h3><span id="more"></span>

<p>1、SpringBoot专注于快速方便的开发单个个体微服务。</p>
<p>2、SpringCloud是关注全局的微服务协调整理治理框架，它将SpringBoot开发的一个个单体微服务整合并管理起来。</p>
<p>3、为各个服务之间提供，配置管理、服务发现、断路器、路由、微代理、事件总线、全局锁、精选决策、分布式会话等集成服务。</p>
<p>4、SpringBoot可以离开SpringCloud独立开发项目，但是SpringCloud离不开SpringBoot，属于依赖关系。</p>
]]></content>
      <categories>
        <category>spring</category>
      </categories>
      <tags>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title>版本控制-Git</title>
    <url>/2022/03/10/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6-Git/</url>
    <content><![CDATA[<p>Git是一个开源的分布式版本控制系统，用以有效、高速的处理从很小到非常大的项目版本管理。</p>
<p><strong>特点：</strong></p>
<ul>
<li>分支更快、更容易。</li>
<li>支持离线工作；本地提交可以稍后提交到服务器上。</li>
<li>Git 提交都是原子的，且是整个项目范围的，而不像 CVS 中一样是对每个文件的。</li>
<li>Git 中的每个工作树都包含一个具有完整项目历史的仓库。</li>
<li>没有哪一个 Git 仓库会天生比其他仓库更重要。</li>
</ul>
<p>Git 是用于 Linux内核开发的版本控制工具。与常用的版本控制工具 CVS, Subversion 等不同，它采用了分布式版本库的方式，不必服务器端软件支持（wingeddevil注：这得分是用什么样的服务端，使用http协议或者git协议等不太一样。并且在push和pull的时候和服务器端还是有交互的。），使源代码的发布和交流极其方便。 Git 的速度很快，这对于诸如 Linux kernel 这样的大项目来说自然很重要。 Git 最为出色的是它的合并跟踪（merge tracing）能力。</p>
<span id="more"></span>

<h3 id="1、列举工作中常用的几个git命令？"><a href="#1、列举工作中常用的几个git命令？" class="headerlink" title="1、列举工作中常用的几个git命令？"></a>1、列举工作中常用的几个git命令？</h3><p>新增文件的命令：git add file或者git add .<br>提交文件的命令：git commit –m或者git commit –a<br>查看工作区状况：git status –s<br>拉取合并远程分支的操作：git fetch&#x2F;git merge或者git pull<br>查看提交记录命令：git reflog</p>
<h3 id="2、提交时发生冲突，你能解释冲突是如何产生的吗？你是如何解决的？"><a href="#2、提交时发生冲突，你能解释冲突是如何产生的吗？你是如何解决的？" class="headerlink" title="2、提交时发生冲突，你能解释冲突是如何产生的吗？你是如何解决的？"></a>2、提交时发生冲突，你能解释冲突是如何产生的吗？你是如何解决的？</h3><p>开发过程中，我们都有自己的特性分支，所以冲突发生的并不多，但也碰到过。诸如公共类的公共方法，我和别人同时修改同一个文件，他提交后我再提交就会报冲突的错误。</p>
<p>发生冲突，在IDE里面一般都是对比本地文件和远程分支的文件，然后把远程分支上文件的内容手工修改到本地文件，然后再提交冲突的文件使其保证与远程分支的文件一致，这样才会消除冲突，然后再提交自己修改的部分。特别要注意下，修改本地冲突文件使其与远程仓库的文件保持一致后，需要提交后才能消除冲突，否则无法继续提交。必要时可与同事交流，消除冲突。</p>
<p>发生冲突，也可以使用命令。</p>
<ol>
<li>通过git stash命令，把工作区的修改提交到栈区，目的是保存工作区的修改；</li>
<li>通过git pull命令，拉取远程分支上的代码并合并到本地分支，目的是消除冲突；</li>
<li>通过git stash pop命令，把保存在栈区的修改部分合并到最新的工作空间中；</li>
</ol>
<h3 id="3、如果本次提交误操作，如何撤销？"><a href="#3、如果本次提交误操作，如何撤销？" class="headerlink" title="3、如果本次提交误操作，如何撤销？"></a>3、如果本次提交误操作，如何撤销？</h3><p>如果想撤销提交到索引区的文件，可以通过git reset HEAD file；如果想撤销提交到本地仓库的文件，可以通过git reset –soft HEAD^n恢复当前分支的版本库至上一次提交的状态，索引区和工作空间不变更；可以通过git reset –mixed HEAD^n恢复当前分支的版本库和索引区至上一次提交的状态，工作区不变更；可以通过git reset –hard HEAD^n恢复当前分支的版本库、索引区和工作空间至上一次提交的状态。</p>
<h3 id="4、如果我想修改提交的历史信息，应该用什么命令？"><a href="#4、如果我想修改提交的历史信息，应该用什么命令？" class="headerlink" title="4、如果我想修改提交的历史信息，应该用什么命令？"></a>4、如果我想修改提交的历史信息，应该用什么命令？</h3><p>如果修改最近一次提交的历史记录，就可以用<strong>git commit –amend</strong>命令；vim编辑的方式；<br>如果修改之前提交的历史记录，就需要按照下面的步骤：</p>
<p><strong>第一步</strong>：首先查看前三次的提交历史记录：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git log -3</span><br><span class="line">commit a762fcafecbd92bbde088054644e1b0586589c4b (HEAD -&gt; slave)</span><br><span class="line">Author: 18073638 &lt;18073638@cnsuning.com&gt;</span><br><span class="line">Date:   Sat Mar 30 10:58:44 2019 +0800</span><br><span class="line"></span><br><span class="line">    four commit</span><br><span class="line"></span><br><span class="line">commit eedbc93d58780f63dd47f8388f8217892096e89a</span><br><span class="line">Author: 18073638 &lt;18073638@cnsuning.com&gt;</span><br><span class="line">Date:   Thu Mar 28 17:19:52 2019 +0800</span><br><span class="line"></span><br><span class="line">    third commit third commit</span><br><span class="line"></span><br><span class="line">commit 05396135eba85140602107e01e5c211d74f6c739</span><br><span class="line">Author: 18073638 &lt;18073638@cnsuning.com&gt;</span><br><span class="line">Date:   Thu Mar 28 16:56:19 2019 +0800</span><br><span class="line"></span><br><span class="line">    second commit</span><br></pre></td></tr></table></figure>

<p>注意：这里我们想把053961的committer对象信息修改为“second commit second commit”.</p>
<p><strong>第二步</strong>：执行命令git rebase –i HEAD~3，会把前3次的提交记录按照倒叙列出来；</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pick 0539613 second commit</span><br><span class="line">pick eedbc93 third commit third commit</span><br><span class="line">pick a762fca four commit</span><br><span class="line"></span><br><span class="line"># Rebase c8d7ad7..a762fca onto c8d7ad7 (3 commands)</span><br><span class="line">#</span><br><span class="line"># Commands:</span><br><span class="line"># p, pick &lt;commit&gt; = use commit</span><br><span class="line"># r, reword &lt;commit&gt; = use commit, but edit the commit message</span><br><span class="line"># e, edit &lt;commit&gt; = use commit, but stop for amending</span><br><span class="line"># s, squash &lt;commit&gt; = use commit, but meld into previous commit</span><br><span class="line"># f, fixup &lt;commit&gt; = like &quot;squash&quot;, but discard this commit&#x27;s log message</span><br><span class="line"># x, exec &lt;command&gt; = run command (the rest of the line) using shell</span><br><span class="line"># b, break = stop here (continue rebase later with &#x27;git rebase --continue&#x27;)</span><br><span class="line"># d, drop &lt;commit&gt; = remove commit</span><br><span class="line"># l, label &lt;label&gt; = label current HEAD with a name</span><br><span class="line"># t, reset &lt;label&gt; = reset HEAD to a label</span><br><span class="line"># m, merge [-C &lt;commit&gt; | -c &lt;commit&gt;] &lt;label&gt; [# &lt;oneline&gt;]</span><br><span class="line"># .       create a merge commit using the original merge commit&#x27;s</span><br><span class="line"># .       message (or the oneline, if no original merge commit was</span><br><span class="line"># .       specified). Use -c &lt;commit&gt; to reword the commit message.</span><br><span class="line">#</span><br><span class="line"># These lines can be re-ordered; they are executed from top to bottom.</span><br><span class="line">#</span><br><span class="line"># If you remove a line here THAT COMMIT WILL BE LOST.</span><br><span class="line">#</span><br><span class="line"># However, if you remove everything, the rebase will be aborted.</span><br><span class="line">#</span><br><span class="line"># Note that empty commits are commented out</span><br></pre></td></tr></table></figure>

<p>这里把第一行的‘pick’修改为‘edit’，然后esc + :wq退出vim编辑器；</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git rebase -i HEAD~3</span><br><span class="line">Stopped at 0539613...  second commit</span><br><span class="line">You can amend the commit now, with</span><br><span class="line"></span><br><span class="line">  git commit --amend</span><br><span class="line"></span><br><span class="line">Once you are satisfied with your changes, run</span><br><span class="line"></span><br><span class="line">  git rebase --continue</span><br></pre></td></tr></table></figure>

<p><strong>第三步</strong>：根据提示，执行git commit –amend命令，进入vim编辑器并修改提交信息。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git commit --amend</span><br><span class="line">[detached HEAD 20fe643] second commit second commit</span><br><span class="line"> Date: Thu Mar 28 16:56:19 2019 +0800</span><br><span class="line"> 1 file changed, 1 insertion(+)</span><br></pre></td></tr></table></figure>

<p><strong>第四步</strong>：然后执行git rebase –continue命令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">第四步：然后执行git rebase –continue命令</span><br></pre></td></tr></table></figure>

<p>查看修改结果</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git log -3</span><br><span class="line">commit 9024049ef990e79fa61295d5c2b64d70017cf412 (HEAD -&gt; slave)</span><br><span class="line">Author: 18073638 &lt;18073638@cnsuning.com&gt;</span><br><span class="line">Date:   Sat Mar 30 10:58:44 2019 +0800</span><br><span class="line"></span><br><span class="line">    four commit</span><br><span class="line"></span><br><span class="line">commit 79cb4e26dd300591e6352d0488802f43b65c8ba2</span><br><span class="line">Author: 18073638 &lt;18073638@cnsuning.com&gt;</span><br><span class="line">Date:   Thu Mar 28 17:19:52 2019 +0800</span><br><span class="line"></span><br><span class="line">    third commit third commit</span><br><span class="line"></span><br><span class="line">commit 20fe643cbf80cdcc649d732065e8ebf4caf773c7</span><br><span class="line">Author: 18073638 &lt;18073638@cnsuning.com&gt;</span><br><span class="line">Date:   Thu Mar 28 16:56:19 2019 +0800</span><br><span class="line"></span><br><span class="line">    second commit second commit</span><br></pre></td></tr></table></figure>

<p>修改成功。</p>
<h3 id="5、你使用过git-stash命令吗？你一般什么情况下会使用它？"><a href="#5、你使用过git-stash命令吗？你一般什么情况下会使用它？" class="headerlink" title="5、你使用过git stash命令吗？你一般什么情况下会使用它？"></a>5、你使用过git stash命令吗？你一般什么情况下会使用它？</h3><p>命令git stash是把工作区修改的内容存储在栈区。<br>以下几种情况会使用到它：</p>
<ul>
<li>解决冲突文件时，会先执行git stash，然后解决冲突；</li>
<li>遇到紧急开发任务但目前任务不能提交时，会先执行git stash，然后进行紧急任务的开发，然后通过git stash pop取出栈区的内容继续开发；</li>
<li>切换分支时，当前工作空间内容不能提交时，会先执行git stash再进行分支切换；</li>
</ul>
<h3 id="6、如何查看分支提交的历史记录？查看某个文件的历史记录呢？"><a href="#6、如何查看分支提交的历史记录？查看某个文件的历史记录呢？" class="headerlink" title="6、如何查看分支提交的历史记录？查看某个文件的历史记录呢？"></a>6、如何查看分支提交的历史记录？查看某个文件的历史记录呢？</h3><p>查看分支的提交历史记录：</p>
<ul>
<li>命令git log –number：表示查看当前分支前number个详细的提交历史记录；</li>
<li>命令git log –number –pretty&#x3D;oneline：在上个命令的基础上进行简化，只显示sha-1码和提交信息；</li>
<li>命令git reflog –number: 表示查看所有分支前number个简化的提交历史记录；</li>
<li>命令git reflog –number –pretty&#x3D;oneline：显示简化的信息历史信息；<br>如果要查看某文件的提交历史记录，直接在上面命令后面加上文件名即可。<br>注意：如果没有number则显示全部提交次数。</li>
</ul>
<h3 id="7、能不能说一下git-fetch和git-pull命令之间的区别？"><a href="#7、能不能说一下git-fetch和git-pull命令之间的区别？" class="headerlink" title="7、能不能说一下git fetch和git pull命令之间的区别？"></a>7、能不能说一下git fetch和git pull命令之间的区别？</h3><p>简单来说：git fetch branch是把名为branch的远程分支拉取到本地；而git pull branch是在fetch的基础上，把branch分支与当前分支进行merge；因此pull &#x3D; fetch + merge。</p>
<h3 id="8、使用过git-merge和git-rebase吗？它们之间有什么区别？"><a href="#8、使用过git-merge和git-rebase吗？它们之间有什么区别？" class="headerlink" title="8、使用过git merge和git rebase吗？它们之间有什么区别？"></a>8、使用过git merge和git rebase吗？它们之间有什么区别？</h3><p>简单的说，git merge和git rebase都是合并分支的命令。</p>
<p>git merge branch会把branch分支的差异内容pull到本地，然后与本地分支的内容一并形成一个committer对象提交到主分支上，合并后的分支与主分支一致；</p>
<p>git rebase branch会把branch分支优先合并到主分支，然后把本地分支的commit放到主分支后面，合并后的分支就好像从合并后主分支又拉了一个分支一样，本地分支本身不会保留提交历史。</p>
<h3 id="9、能说一下git系统中HEAD、工作树和索引之间的区别吗？"><a href="#9、能说一下git系统中HEAD、工作树和索引之间的区别吗？" class="headerlink" title="9、能说一下git系统中HEAD、工作树和索引之间的区别吗？"></a>9、能说一下git系统中HEAD、工作树和索引之间的区别吗？</h3><p><strong>HEAD文件</strong>包含当前分支的引用（指针）；<br><strong>工作树</strong>是把当前分支检出到工作空间后形成的目录树，一般的开发工作都会基于工作树进行；<br><strong>索引index文件</strong>是对工作树进行代码修改后，通过add命令更新索引文件；GIT系统通过索引index文件生成tree对象；</p>
<h3 id="10、之前项目中是使用的GitFlow工作流程吗？它有什么好处？"><a href="#10、之前项目中是使用的GitFlow工作流程吗？它有什么好处？" class="headerlink" title="10、之前项目中是使用的GitFlow工作流程吗？它有什么好处？"></a>10、之前项目中是使用的GitFlow工作流程吗？它有什么好处？</h3><p>GitFlow可以用来管理分支。GitFlow工作流中常用的分支有下面几类：</p>
<ul>
<li>master分支：最为稳定功能比较完整的随时可发布的代码，即代码开发完成，经过测试，没有明显的bug，才能合并到 master 中。请注意永远不要在 master 分支上直接开发和提交代码，以确保 master 上的代码一直可用；</li>
<li>develop分支；用作平时开发的主分支，并一直存在，永远是功能最新最全的分支，包含所有要发布 到下一个 release 的代码，主要用于合并其他分支，比如 feature 分支； 如果修改代码，新建 feature 分支修改完再合并到 develop 分支。所有的 feature、release 分支都是从 develop 分支上拉的。</li>
<li>feature分支；这个分支主要是用来开发新的功能，一旦开发完成，通过测试没问题（这个测试，测试新功能没问题），我们合并回develop 分支进入下一个 release</li>
<li>release分支；用于发布准备的专门分支。当开发进行到一定程度，或者说快到了既定的发布日，可以发布时，建立一个 release 分支并指定版本号(可以在 finish 的时候添加)。开发人员可以对 release 分支上的代码进行集中测试和修改bug。（这个测试，测试新功能与已有的功能是否有冲突，兼容性）全部完成经过测试没有问题后，将 release 分支上的代码合并到 master 分支和 develop 分支</li>
<li>hotfix分支；用于修复线上代码的bug。<strong>从 master 分支上拉。</strong>完成 hotfix 后，打上 tag 我们合并回 master 和 develop 分支。<br>GitFlow主要工作流程</li>
<li>1.初始化项目为gitflow , 默认创建master分支 , 然后从master拉取第一个develop分支</li>
<li>2.从develop拉取feature分支进行编码开发(多个开发人员拉取多个feature同时进行并行开发 , 互不影响)</li>
<li>3.feature分支完成后 , 合并到develop(不推送 , feature功能完成还未提测 , 推送后会影响其他功能分支的开发)；合并feature到develop , 可以选择删除当前feature , 也可以不删除。但当前feature就不可更改了，必须从release分支继续编码修改</li>
</ul>
<p>4.从develop拉取release分支进行提测 , 提测过程中在release分支上修改BUG<br>5.release分支上线后 , 合并release分支到develop&#x2F;master并推送；合并之后，可选删除当前release分支，若不删除，则当前release不可修改。线上有问题也必须从master拉取hotfix分支进行修改；<br>6.上线之后若发现线上BUG , 从master拉取hotfix进行BUG修改；<br>7.hotfix通过测试上线后，合并hotfix分支到develop&#x2F;master并推送；合并之后，可选删除当前hotfix ，若不删除，则当前hotfix不可修改，若补丁未修复，需要从master拉取新的hotfix继续修改；<br>8.当进行一个feature时 , 若develop分支有变动 , 如其他开发人员完成功能并上线 , 则需要将完成的功能合并到自己分支上，即合并develop到当前feature分支；<br>9.当进行一个release分支时 , 若develop分支有变动 , 如其他开发人员完成功能并上线 , 则需要将完成的功能合并到自己分支上，即合并develop到当前release分支 (!!! 因为当前release分支通过测试后会发布到线上 , 如果不合并最新的develop分支 , 就会发生丢代码的情况)；<br>GitFlow的好处<br>为不同的分支分配一个明确的角色，并定义分支之间如何交互以及什么时间交互；可以帮助大型项目理清分支之间的关系，简化分支的复杂度。</p>
<h3 id="11、使用过git-cherry-pick，有什么作用？"><a href="#11、使用过git-cherry-pick，有什么作用？" class="headerlink" title="11、使用过git cherry-pick，有什么作用？"></a>11、使用过git cherry-pick，有什么作用？</h3><p>命令git cherry-pick可以把branch A的commit复制到branch B上。<br>在branch B上进行命令操作：</p>
<p>复制单个提交：git cherry-pick commitId<br>复制多个提交：git cherry-pick commitId1…commitId3<br>注意：复制多个提交的命令不包含commitId1.</p>
<h3 id="12、git跟其他版本控制器有啥区别？"><a href="#12、git跟其他版本控制器有啥区别？" class="headerlink" title="12、git跟其他版本控制器有啥区别？"></a>12、git跟其他版本控制器有啥区别？</h3><p>GIT是分布式版本控制系统，其他类似于SVN是集中式版本控制系统。<br>分布式区别于集中式在于：每个节点的地位都是平等，拥有自己的版本库，在没有网络的情况下，对工作空间内代码的修改可以提交到本地仓库，此时的本地仓库相当于集中式的远程仓库，可以基于本地仓库进行提交、撤销等常规操作，从而方便日常开发。</p>
<h3 id="13、我们在本地工程常会修改一些配置文件，这些文件不需要被提交，而我们又不想每次执行git-status时都让这些文件显示出来，我们该如何操作？"><a href="#13、我们在本地工程常会修改一些配置文件，这些文件不需要被提交，而我们又不想每次执行git-status时都让这些文件显示出来，我们该如何操作？" class="headerlink" title="13、我们在本地工程常会修改一些配置文件，这些文件不需要被提交，而我们又不想每次执行git status时都让这些文件显示出来，我们该如何操作？"></a>13、我们在本地工程常会修改一些配置文件，这些文件不需要被提交，而我们又不想每次执行git status时都让这些文件显示出来，我们该如何操作？</h3><p>首先利用命令touch .gitignore新建文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ touch .gitignore</span><br></pre></td></tr></table></figure>

<p>然后往文件中添加需要忽略哪些文件夹下的什么类型的文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ vim .gitignore</span><br><span class="line">$ cat .gitignore</span><br><span class="line">/target/class</span><br><span class="line">.settings</span><br><span class="line">.imp</span><br><span class="line">*.ini</span><br></pre></td></tr></table></figure>

<p>注意：忽略&#x2F;target&#x2F;class文件夹下所有后缀名为.settings，.imp的文件，忽略所有后缀名为.ini的文件。</p>
<h3 id="14、如何把本地仓库的内容推向一个空的远程仓库？"><a href="#14、如何把本地仓库的内容推向一个空的远程仓库？" class="headerlink" title="14、如何把本地仓库的内容推向一个空的远程仓库？"></a>14、如何把本地仓库的内容推向一个空的远程仓库？</h3><p>首先确保本地仓库与远程之间是连同的。如果提交失败，则需要进行下面的命令进行连通：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git remote add origin XXXX</span><br></pre></td></tr></table></figure>

<p>注意：XXXX是你的远程仓库地址。<br>如果是第一次推送，则进行下面命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git push -u origin master</span><br></pre></td></tr></table></figure>

<p>注意：-u 是指定origin为默认主分支<br>之后的提交，只需要下面的命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git push origin master</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>JUC高并发编程-共享模型之无锁</title>
    <url>/2022/05/17/2022-05-17-JUC%E9%AB%98%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-%E5%85%B1%E4%BA%AB%E6%A8%A1%E5%9E%8B%E4%B9%8B%E6%97%A0%E9%94%81/</url>
    <content><![CDATA[<h1 id="共享模型之无锁"><a href="#共享模型之无锁" class="headerlink" title="共享模型之无锁"></a>共享模型之无锁</h1><span id="more"></span>

<h4 id="问题提出"><a href="#问题提出" class="headerlink" title="问题提出"></a>问题提出</h4><p>有如下需求，保证 account.withdraw 取款方法的线程安全，先看一个线程不安全的情况：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestCAS</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Account.demo(<span class="keyword">new</span> <span class="title class_">AccountUnsafe</span>(<span class="number">10000</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Account</span>&#123;</span><br><span class="line">    <span class="comment">//获取余额</span></span><br><span class="line">    Integer <span class="title function_">getBalance</span><span class="params">()</span>;</span><br><span class="line">    <span class="comment">//取款</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">withdraw</span><span class="params">(Integer amount)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 方法内会启动 1000 个线程，每个线程做 -10 元 的操作</span></span><br><span class="line"><span class="comment">     * 如果初始余额为 10000 那么正确的结果应当是 0</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">demo</span><span class="params">(Account account)</span> &#123;</span><br><span class="line">        List&lt;Thread&gt; ts = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.nanoTime();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">            ts.add(<span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">                account.withdraw(<span class="number">10</span>);</span><br><span class="line">            &#125;));</span><br><span class="line">        &#125;</span><br><span class="line">        ts.forEach(Thread::start);</span><br><span class="line">        ts.forEach(t-&gt;&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                t.join();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.nanoTime();</span><br><span class="line">        System.out.println(account.getBalance()</span><br><span class="line">                + <span class="string">&quot; cost: &quot;</span> + (end-start)/<span class="number">1000_000</span> + <span class="string">&quot; ms&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AccountUnsafe</span> <span class="keyword">implements</span> <span class="title class_">Account</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Integer balance;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">AccountUnsafe</span><span class="params">(Integer balance)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.balance = balance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">getBalance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> balance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">withdraw</span><span class="params">(Integer amount)</span> &#123;</span><br><span class="line">        balance -= amount;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;				</span><br></pre></td></tr></table></figure>

<h5 id="为什么不安全"><a href="#为什么不安全" class="headerlink" title="为什么不安全"></a>为什么不安全</h5><p>执行withdraw 方法对应的字节码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ALOAD <span class="number">0</span> 													<span class="comment">// &lt;- this</span></span><br><span class="line">ALOAD <span class="number">0</span></span><br><span class="line">GETFIELD com/heu/AccountUnsafe.balance : Ljava/lang/Integer; <span class="comment">// &lt;- this.balance</span></span><br><span class="line">INVOKEVIRTUAL java/lang/Integer.intValue ()I 				<span class="comment">// 拆箱</span></span><br><span class="line">ALOAD <span class="number">1</span> 													<span class="comment">// &lt;- amount</span></span><br><span class="line">INVOKEVIRTUAL java/lang/Integer.intValue ()I				<span class="comment">// 拆箱</span></span><br><span class="line">ISUB 														<span class="comment">// 减法</span></span><br><span class="line">INVOKESTATIC java/lang/Integer.valueOf (I)Ljava/lang/Integer; <span class="comment">// 结果装箱</span></span><br><span class="line">PUTFIELD com/heu/AccountUnsafe.balance : Ljava/lang/Integer;	 <span class="comment">// -&gt; this.balance</span></span><br></pre></td></tr></table></figure>

<p>单核的指令交错</p>
<p>多核的指令交错</p>
<h5 id="解决思路-锁"><a href="#解决思路-锁" class="headerlink" title="解决思路-锁"></a>解决思路-锁</h5><p>首先想到的是给 Account 对象加锁：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">AccountUnsafe</span> <span class="keyword">implements</span> <span class="title class_">Account</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Integer balance;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">AccountUnsafe</span><span class="params">(Integer balance)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.balance = balance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> Integer <span class="title function_">getBalance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> balance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">withdraw</span><span class="params">(Integer amount)</span> &#123;</span><br><span class="line">        balance -= amount;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如上代码加锁会造成线程堵塞，堵塞的时间取决于临界区代码执行的时间，这使用加锁的性能不高，因此可以使用无锁来解决此问题。</p>
<h5 id="解决思路-无锁"><a href="#解决思路-无锁" class="headerlink" title="解决思路-无锁"></a>解决思路-无锁</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AccountUnsafe</span> <span class="keyword">implements</span> <span class="title class_">Account</span> &#123;</span><br><span class="line">    AtomicInteger atomicInteger;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">AccountUnsafe</span><span class="params">(Integer balance)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.atomicInteger = <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(balance);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">getBalance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> atomicInteger.get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">withdraw</span><span class="params">(Integer amount)</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="type">Integer</span> <span class="variable">pre</span> <span class="operator">=</span> getBalance();</span><br><span class="line">            <span class="type">int</span> <span class="variable">next</span> <span class="operator">=</span> pre - amount;</span><br><span class="line">            <span class="comment">//如果当前值等于参数给定的期望值，则将值设置为参数中的传递值。该函数返回一个布尔值，该布尔值使我们了解更新是否完成.</span></span><br><span class="line">            <span class="comment">//compareAndSet方法实际上是做了两步操作，第一步是比较，第二步是把value的值更新，这两步是原子操作，在没有多线程锁的情况下，借助cpu锁保证数据安全。</span></span><br><span class="line">            <span class="keyword">if</span> (atomicInteger.compareAndSet(pre, next)) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="CAS与volatile"><a href="#CAS与volatile" class="headerlink" title="CAS与volatile"></a>CAS与volatile</h4><h5 id="工作方式"><a href="#工作方式" class="headerlink" title="工作方式"></a>工作方式</h5><p>前面的AtomicInteger的解决方法，内部并没有用锁来保护共享变量的线程安全。那么它是如何实现的？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">withdraw</span><span class="params">(Integer amount)</span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">prev</span> <span class="operator">=</span> balance.get();</span><br><span class="line">        <span class="type">int</span> <span class="variable">next</span> <span class="operator">=</span> prev - amount;</span><br><span class="line">        <span class="keyword">if</span>(balance.compareAndSet(prev,next))&#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中的关键是compareAndSet，它的简称就是CAS（也有Compare And Swap的说法），它必须是原子操作。</p>
<p><img src="/../images/img92.PNG" alt="img92"></p>
<h5 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h5><p>获取共享变量时，为了保证该变量的可见性，需要使用volatile修饰。</p>
<p>它可以用来修饰成员变量和静态成员变量，它可以避免线程从自己的工作缓存中查找变量的值，必须到主存中获取它的值，线程操作volatile变量都是直接操作主存，即一个线程对volatile变量的修改，对另一个线程可见。</p>
<p>注意：volatile仅仅保证了共享变量的可见性，让其它线程能够看到最新值，但不能解决指令交错问题（不能保证原子性）。</p>
<p>CAS必须借助volatile才能读取到共享变量的最新值来实现比较并交换的效果。</p>
<h5 id="为什么无锁效率高"><a href="#为什么无锁效率高" class="headerlink" title="为什么无锁效率高"></a>为什么无锁效率高</h5><ul>
<li><p>无锁情况下，即使重试失败，线程始终在高速运行，没有停歇，而 synchronized 会让线程在没有获得锁的时候，发生上下文切换，进入阻塞。</p>
</li>
<li><p>打个比喻：线程就好像高速跑道上的赛车，高速运行时，速度超快，一旦发生上下文切换，就好比赛车要减速、熄火，等被唤醒又得重新打火、启动、加速… 恢复到高速运行，代价比较大。</p>
</li>
<li><p>但无锁情况下，因为线程要保持运行，需要额外 CPU 的支持，CPU 在这里就好比高速跑道，没有额外的跑道，线程想高速运行也无从谈起，虽然不会进入阻塞，但由于没有分到时间片，仍然会进入可运行状态，还是会导致上下文切换。</p>
</li>
</ul>
<h5 id="CAS的特点"><a href="#CAS的特点" class="headerlink" title="CAS的特点"></a>CAS的特点</h5><p>结合 CAS 和 volatile 可以实现无锁并发，适用于线程数少、多核 CPU 的场景下。</p>
<ul>
<li><p>CAS 是基于乐观锁的思想：最乐观的估计，不怕别的线程来修改共享变量，就算改了也没关系，吃亏点再重试呗。</p>
</li>
<li><p>synchronized 是基于悲观锁的思想：最悲观的估计，得防着其它线程来修改共享变量，我上了锁你们都别想改，我改完了解开锁，你们才有机会。</p>
</li>
<li><p>CAS 体现的是无锁并发、无阻塞并发，请仔细体会这两句话的意思。</p>
<ul>
<li>因为没有使用 synchronized，所以线程不会陷入阻塞，这是效率提升的因素之一。</li>
<li>但如果竞争激烈(写操作多)，可以想到重试必然频繁发生，反而效率会受影响。</li>
</ul>
</li>
</ul>
<h4 id="原子整数"><a href="#原子整数" class="headerlink" title="原子整数"></a>原子整数</h4><p>java.util.concurrent.atomic 并发包提供了一些并发工具类，这里把它分成五类，分别是：</p>
<p>原子类</p>
<ul>
<li>AtomicInteger：整型原子类</li>
<li>AtomicLong：长整型原子类</li>
<li>AtomicBoolean：布尔型原子类</li>
</ul>
<p>原子引用</p>
<p>原子数组</p>
<p>字段更新器</p>
<p>原子累加器</p>
<p>以AtomicInteger为例</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">AtomicInteger</span> <span class="variable">i</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="comment">// 获取并自增（i = 0, 结果 i = 1, 返回 0），类似于 i++</span></span><br><span class="line">        System.out.println(i.getAndIncrement());</span><br><span class="line">        <span class="comment">// 自增并获取（i = 1, 结果 i = 2, 返回 2），类似于 ++i</span></span><br><span class="line">        System.out.println(i.incrementAndGet());</span><br><span class="line">        <span class="comment">// 自减并获取（i = 2, 结果 i = 1, 返回 1），类似于 --i</span></span><br><span class="line">        System.out.println(i.decrementAndGet());</span><br><span class="line">        <span class="comment">// 获取并自减（i = 1, 结果 i = 0, 返回 1），类似于 i--</span></span><br><span class="line">        System.out.println(i.getAndDecrement());</span><br><span class="line">        <span class="comment">// 获取并加值（i = 0, 结果 i = 5, 返回 0）</span></span><br><span class="line">        System.out.println(i.getAndAdd(<span class="number">5</span>));</span><br><span class="line">        <span class="comment">// 加值并获取（i = 5, 结果 i = 0, 返回 0）</span></span><br><span class="line">        System.out.println(i.addAndGet(-<span class="number">5</span>));</span><br><span class="line">        <span class="comment">// 获取并更新（i = 0, p 为 i 的当前值, 结果 i = -2, 返回 0）</span></span><br><span class="line">        <span class="comment">// 函数式编程接口，其中函数中的操作能保证原子，但函数需要无副作用</span></span><br><span class="line">        System.out.println(i.getAndUpdate(p -&gt; p - <span class="number">2</span>));</span><br><span class="line">        <span class="comment">// 更新并获取（i = -2, p 为 i 的当前值, 结果 i = 0, 返回 0）</span></span><br><span class="line">        <span class="comment">// 函数式编程接口，其中函数中的操作能保证原子，但函数需要无副作用</span></span><br><span class="line">        System.out.println(i.updateAndGet(p -&gt; p + <span class="number">2</span>));</span><br><span class="line">        <span class="comment">// 获取并计算（i = 0, p 为 i 的当前值, x 为参数1, 结果 i = 10, 返回 0）</span></span><br><span class="line">        <span class="comment">// 函数式编程接口，其中函数中的操作能保证原子，但函数需要无副作用</span></span><br><span class="line">        <span class="comment">// getAndUpdate 如果在 lambda 中引用了外部的局部变量，要保证该局部变量是 final 的</span></span><br><span class="line">        <span class="comment">// getAndAccumulate 可以通过 参数1 来引用外部的局部变量，但因为其不在 lambda 中因此不必是 final</span></span><br><span class="line">        System.out.println(i.getAndAccumulate(<span class="number">10</span>, (p, x) -&gt; p + x));</span><br><span class="line">        <span class="comment">// 计算并获取（i = 10, p 为 i 的当前值, x 为参数1值, 结果 i = 0, 返回 0）</span></span><br><span class="line">        <span class="comment">// 函数式编程接口，其中函数中的操作能保证原子，但函数需要无副作用</span></span><br><span class="line">        System.out.println(i.accumulateAndGet(-<span class="number">10</span>, (p, x) -&gt; p + x));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h4 id="原子引用"><a href="#原子引用" class="headerlink" title="原子引用"></a>原子引用</h4><p>为什么需要原子引用类型</p>
<p>保证引用类型的共享变量是线程安全的（确保这个原子引用没有引用过别人）。基本类型原子类只能更新一个变量，如果需要原子更新多个变量，需要使用引用类型原子类。</p>
<ul>
<li>AtomicReference</li>
<li>AtomicMarkableReference</li>
<li>AtomicStampedReference</li>
</ul>
<p>如下方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">DecimalAccountUnsafe</span> <span class="keyword">implements</span> <span class="title class_">DecimalAccount</span> &#123;</span><br><span class="line">    BigDecimal balance;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">DecimalAccountUnsafe</span><span class="params">(BigDecimal balance)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.balance = balance;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> BigDecimal <span class="title function_">getBalance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> balance;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 取款任务</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">withdraw</span><span class="params">(BigDecimal amount)</span> &#123;</span><br><span class="line">        <span class="type">BigDecimal</span> <span class="variable">balance</span> <span class="operator">=</span> <span class="built_in">this</span>.getBalance();</span><br><span class="line">        <span class="built_in">this</span>.balance = balance.subtract(amount);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当执行 withdraw 方法时，可能会有线程安全问题，我们可以加锁解决或者是使用无锁的方式 CAS 来解决，这里的解决方式是用AtomicReference 原子引用解决。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">DecimalAccountCas</span> <span class="keyword">implements</span> <span class="title class_">DecimalAccount</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> AtomicReference&lt;BigDecimal&gt; balance;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">DecimalAccountCas</span><span class="params">(BigDecimal balance)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.balance = <span class="keyword">new</span> <span class="title class_">AtomicReference</span>&lt;&gt;(balance);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> BigDecimal <span class="title function_">getBalance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> balance.get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">withdraw</span><span class="params">(BigDecimal amount)</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="type">BigDecimal</span> <span class="variable">preVal</span> <span class="operator">=</span> balance.get();</span><br><span class="line">            <span class="type">BigDecimal</span> <span class="variable">nextVal</span> <span class="operator">=</span> preVal.subtract(amount);</span><br><span class="line">            <span class="keyword">if</span>(balance.compareAndSet(preVal, nextVal)) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>ABA问题</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> AtomicReference&lt;String&gt; ref = <span class="keyword">new</span> <span class="title class_">AtomicReference</span>&lt;&gt;(<span class="string">&quot;A&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;main start...&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">preVal</span> <span class="operator">=</span> ref.get();</span><br><span class="line">        other();</span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        log.debug(<span class="string">&quot;change A-&gt;C &#123;&#125;&quot;</span>, ref.compareAndSet(preVal, <span class="string">&quot;C&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">other</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;change A-&gt;B &#123;&#125;&quot;</span>, ref.compareAndSet(ref.get(), <span class="string">&quot;B&quot;</span>));</span><br><span class="line">        &#125;, <span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;change B-&gt;A &#123;&#125;&quot;</span>, ref.compareAndSet(ref.get(), <span class="string">&quot;A&quot;</span>));</span><br><span class="line">        &#125;, <span class="string">&quot;t2&quot;</span>).start();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>主线程仅能判断出共享变量的值与最初值 A 是否相同，不能感知到这种从 A 改为 B 又改回 A 的情况，如果主线程希望只要有其它线程【动过了】共享变量，那么自己的 cas 就算失败的话，这时，仅比较值是不够的，需要再加一个版本号。使用AtomicStampedReference来解决。</p>
<p><strong>AtomicStampedReference</strong></p>
<p>使用 AtomicStampedReference 加 stamp （版本号或者时间戳）的方式解决 ABA 问题。代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestAtomicStampedReference</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> AtomicStampedReference&lt;String&gt; ref = <span class="keyword">new</span> <span class="title class_">AtomicStampedReference</span>&lt;&gt;(<span class="string">&quot;A&quot;</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;main start...&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">preVal</span> <span class="operator">=</span> ref.getReference();</span><br><span class="line">        <span class="type">int</span> <span class="variable">stamp</span> <span class="operator">=</span> ref.getStamp();</span><br><span class="line">        log.info(<span class="string">&quot;main 拿到的版本号 &#123;&#125;&quot;</span>,stamp);</span><br><span class="line">        other();</span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        log.info(<span class="string">&quot;修改后的版本号 &#123;&#125;&quot;</span>,ref.getStamp());</span><br><span class="line">        log.info(<span class="string">&quot;change A-&gt;C:&#123;&#125;&quot;</span>, ref.compareAndSet(preVal, <span class="string">&quot;C&quot;</span>, stamp, stamp + <span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">other</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">stamp</span> <span class="operator">=</span> ref.getStamp();</span><br><span class="line">            log.info(<span class="string">&quot;&#123;&#125;&quot;</span>,stamp);</span><br><span class="line">            log.info(<span class="string">&quot;change A-&gt;B:&#123;&#125;&quot;</span>, ref.compareAndSet(ref.getReference(), <span class="string">&quot;B&quot;</span>, stamp, stamp + <span class="number">1</span>));</span><br><span class="line">        &#125;).start();</span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">stamp</span> <span class="operator">=</span> ref.getStamp();</span><br><span class="line">            log.info(<span class="string">&quot;&#123;&#125;&quot;</span>,stamp);</span><br><span class="line">            log.debug(<span class="string">&quot;change B-&gt;A:&#123;&#125;&quot;</span>, ref.compareAndSet(ref.getReference(), <span class="string">&quot;A&quot;</span>,stamp,stamp + <span class="number">1</span>));</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">16</span>:<span class="number">48</span>:<span class="number">22.772</span> [main] DEBUG com.heu.test.TestAtomicStampedReference - main start...</span><br><span class="line"><span class="number">16</span>:<span class="number">48</span>:<span class="number">22.782</span> [main] INFO com.heu.test.TestAtomicStampedReference - main 拿到的版本号 <span class="number">0</span></span><br><span class="line"><span class="number">16</span>:<span class="number">48</span>:<span class="number">22.788</span> [Thread-<span class="number">0</span>] INFO com.heu.test.TestAtomicStampedReference - <span class="number">0</span></span><br><span class="line"><span class="number">16</span>:<span class="number">48</span>:<span class="number">22.788</span> [Thread-<span class="number">0</span>] INFO com.heu.test.TestAtomicStampedReference - change A-&gt;B:<span class="literal">true</span></span><br><span class="line"><span class="number">16</span>:<span class="number">48</span>:<span class="number">23.792</span> [Thread-<span class="number">1</span>] INFO com.heu.test.TestAtomicStampedReference - <span class="number">1</span></span><br><span class="line"><span class="number">16</span>:<span class="number">48</span>:<span class="number">23.792</span> [Thread-<span class="number">1</span>] DEBUG com.heu.test.TestAtomicStampedReference - change B-&gt;A:<span class="literal">true</span></span><br><span class="line"><span class="number">16</span>:<span class="number">48</span>:<span class="number">24.793</span> [main] INFO com.heu.test.TestAtomicStampedReference - 修改后的版本号 <span class="number">2</span></span><br></pre></td></tr></table></figure>

<p><strong>AtomicMarkableReference</strong></p>
<p>AtomicStampedReference 可以给原子引用加上版本号，追踪原子引用整个的变化过程，如：A -&gt; B -&gt; A -&gt;C，通过AtomicStampedReference可以知道，引用变量中途被更改了几次。但是有时候，并不关心引用变量更改了几次，只是单纯的关心是否更改过，所以就有了AtomicMarkableReference 。</p>
<h4 id="原子数组"><a href="#原子数组" class="headerlink" title="原子数组"></a>原子数组</h4><p>使用原子的方式更新数组里的某个元素：</p>
<ul>
<li>AtomicIntegerArray：整形数组原子类</li>
<li>AtomicLongArray：长整形数组原子类</li>
<li>AtomicReferenceArray ：引用类型数组原子类</li>
</ul>
<p>使用原子数组可以保证元素的线程安全。</p>
<p>上面三个类提供的方法几乎相同，所以这里以 AtomicIntegerArray 为例子来介绍，代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestAtomicIntegerArray</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//不安全的数组</span></span><br><span class="line">        demo(</span><br><span class="line">                ()-&gt;<span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">10</span>],</span><br><span class="line">                (array)-&gt;array.length,</span><br><span class="line">                (array, index) -&gt; array[index]++,</span><br><span class="line">                array-&gt; System.out.println(Arrays.toString(array))</span><br><span class="line">        );</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//安全的数组</span></span><br><span class="line">        demo(</span><br><span class="line">            	()-&gt;<span class="keyword">new</span> <span class="title class_">AtomicIntegerArray</span>(<span class="number">10</span>),</span><br><span class="line">                (array) -&gt; array.length(),</span><br><span class="line">                (array, index) -&gt; array.getAndIncrement(index),</span><br><span class="line">                (array) -&gt; System.out.println(array)</span><br><span class="line">        );        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> &lt;T&gt; <span class="keyword">void</span> <span class="title function_">demo</span><span class="params">(</span></span><br><span class="line"><span class="params">        Supplier&lt;T&gt; arraySupplier,</span></span><br><span class="line"><span class="params">        Function&lt;T,Integer&gt; lengthFun,</span></span><br><span class="line"><span class="params">        BiConsumer&lt;T,Integer&gt; putConsumer,</span></span><br><span class="line"><span class="params">        Consumer&lt;T&gt; printConsumer)</span> &#123;</span><br><span class="line">        ArrayList&lt;Thread&gt; ts = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">T</span> <span class="variable">array</span> <span class="operator">=</span> arraySupplier.get();</span><br><span class="line">        <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> lengthFun.apply(array);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">            ts.add(<span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">10000</span>; j++) &#123;</span><br><span class="line">                    putConsumer.accept(array,j%length);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;));</span><br><span class="line">        &#125;</span><br><span class="line">        ts.forEach(t-&gt;t.start());</span><br><span class="line">        ts.forEach(t-&gt;&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                t.join();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        printConsumer.accept(array);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">[9470, 9579, 9616, 9594, 9566, 9633, 9605, 9611, 9892, 9879]</span><br><span class="line"></span><br><span class="line">[10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000]</span><br></pre></td></tr></table></figure>

<h4 id="字段更新器"><a href="#字段更新器" class="headerlink" title="字段更新器"></a>字段更新器</h4><ul>
<li>AtomicReferenceFieldUpdater &#x2F;&#x2F; 域 字段</li>
<li>AtomicIntegerFieldUpdater</li>
<li>AtomicLongFieldUpdater</li>
</ul>
<p>利用字段更新器，可以针对对象的某个域（Field）进行原子操作，只能配合 volatile 修饰的字段使用，否则会出现异常。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Exception in thread <span class="string">&quot;main&quot;</span> java.lang.IllegalArgumentException: Must be <span class="keyword">volatile</span> type。</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestFieldUpdater</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">int</span> field;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        AtomicIntegerFieldUpdater&lt;TestFieldUpdater&gt; fieldUpdater = AtomicIntegerFieldUpdater.newUpdater(TestFieldUpdater.class, <span class="string">&quot;field&quot;</span>);</span><br><span class="line">        <span class="type">TestFieldUpdater</span> <span class="variable">updater</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TestFieldUpdater</span>();</span><br><span class="line">        fieldUpdater.compareAndSet(updater, <span class="number">0</span>, <span class="number">10</span>);</span><br><span class="line">        <span class="comment">// 修改成功 field = 10</span></span><br><span class="line">        System.out.println(updater.field);</span><br><span class="line">        <span class="comment">// 修改成功 field = 20</span></span><br><span class="line">        fieldUpdater.compareAndSet(updater, <span class="number">10</span>, <span class="number">20</span>);</span><br><span class="line">        System.out.println(updater.field);</span><br><span class="line">        <span class="comment">// 修改失败 field = 20</span></span><br><span class="line">        fieldUpdater.compareAndSet(updater, <span class="number">10</span>, <span class="number">30</span>);</span><br><span class="line">        System.out.println(updater.field);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">10</span> </span><br><span class="line"><span class="number">20</span> </span><br><span class="line"><span class="number">20</span></span><br></pre></td></tr></table></figure>

<h4 id="原子累加器"><a href="#原子累加器" class="headerlink" title="原子累加器"></a>原子累加器</h4><p><strong>AtomicLong Vs LongAdder</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestLongAdder</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            demo(()-&gt;<span class="keyword">new</span> <span class="title class_">AtomicLong</span>(<span class="number">0</span>),(ref)-&gt;ref.getAndIncrement());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            demo(()-&gt;<span class="keyword">new</span> <span class="title class_">LongAdder</span>(),(ref)-&gt;ref.increment());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> &lt;T&gt; <span class="keyword">void</span> <span class="title function_">demo</span><span class="params">(Supplier&lt;T&gt; supplier, Consumer&lt;T&gt; consumer)</span> &#123;</span><br><span class="line">        ArrayList&lt;Thread&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="type">T</span> <span class="variable">adder</span> <span class="operator">=</span> supplier.get();</span><br><span class="line">        <span class="comment">// 4 个线程，每人累加 50 万</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">            list.add(<span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">500000</span>; j++) &#123;</span><br><span class="line">                    consumer.accept(adder);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.nanoTime();</span><br><span class="line">        list.forEach(t -&gt; t.start());</span><br><span class="line">        list.forEach(t -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                t.join();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.nanoTime();</span><br><span class="line">        System.out.println(adder + <span class="string">&quot; cost:&quot;</span> + (end - start)/<span class="number">1000_000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">2000000</span> cost:<span class="number">80</span></span><br><span class="line"><span class="number">2000000</span> cost:<span class="number">76</span></span><br><span class="line"><span class="number">2000000</span> cost:<span class="number">60</span></span><br><span class="line"><span class="number">2000000</span> cost:<span class="number">56</span></span><br><span class="line"><span class="number">2000000</span> cost:<span class="number">52</span></span><br><span class="line"><span class="number">2000000</span> cost:<span class="number">32</span></span><br><span class="line"><span class="number">2000000</span> cost:<span class="number">5</span></span><br><span class="line"><span class="number">2000000</span> cost:<span class="number">8</span></span><br><span class="line"><span class="number">2000000</span> cost:<span class="number">8</span></span><br><span class="line"><span class="number">2000000</span> cost:<span class="number">20</span></span><br></pre></td></tr></table></figure>

<p>结论：</p>
<p>执行代码后，发现使用 LongAdder 比 AtomicLong 快2，3倍，使用 LongAdder 性能提升的原因很简单，就是在有竞争时，设置多个累加单元(但不会超过cpu的核心数)，Therad-0 累加 Cell[0]，而 Thread-1 累加Cell[1]… 最后将结果汇总。这样它们在累加时操作的不同的 Cell 变量，因此减少了 CAS 重试失败，从而提高性能。    </p>
<h4 id="CAS锁"><a href="#CAS锁" class="headerlink" title="CAS锁"></a>CAS锁</h4><p>使用 cas 实现一个自旋锁</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestLockCas</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">AtomicInteger</span> <span class="variable">state</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="number">0</span>); <span class="comment">// 如果 state 值为 0 表示没上锁, 1 表示上锁</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(state.compareAndSet(<span class="number">0</span>, <span class="number">1</span>)) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span> &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;unlock...&quot;</span>);</span><br><span class="line">        state.set(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Code_13_LockCas</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Code_13_LockCas</span>();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            log.info(<span class="string">&quot;begin...&quot;</span>);</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                log.info(<span class="string">&quot;上锁成功&quot;</span>);</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            log.info(<span class="string">&quot;begin...&quot;</span>);</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                log.info(<span class="string">&quot;上锁成功&quot;</span>);</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;t2&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;	</span><br></pre></td></tr></table></figure>

<h4 id="LongAdder原理"><a href="#LongAdder原理" class="headerlink" title="LongAdder原理"></a>LongAdder原理</h4><p>LongAdder 类有几个关键域，在public class LongAdder extends Striped64 implements Serializable {}，下面的变量属于 Striped64 被 LongAdder 继承：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 累加单元数组, 懒惰初始化</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">volatile</span> Cell[] cells;</span><br><span class="line"><span class="comment">// 基础值, 如果没有竞争, 则用 cas 累加这个域</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="type">long</span> base;</span><br><span class="line"><span class="comment">// 在 cells 创建或扩容时, 置为 1, 表示加锁</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="type">int</span> cellsBusy;</span><br></pre></td></tr></table></figure>

<h5 id="原理之伪共享"><a href="#原理之伪共享" class="headerlink" title="原理之伪共享"></a>原理之伪共享</h5><p>其中 Cell 即为累加单元。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 防止缓存行伪共享</span></span><br><span class="line"><span class="meta">@sun</span>.misc.Contended</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Cell</span> &#123;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">long</span> value;</span><br><span class="line">    Cell(<span class="type">long</span> x) &#123; value = x; &#125;</span><br><span class="line">    <span class="comment">// 最重要的方法, 用 cas 方式进行累加, prev 表示旧值, next 表示新值</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">cas</span><span class="params">(<span class="type">long</span> prev, <span class="type">long</span> next)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> UNSAFE.compareAndSwapLong(<span class="built_in">this</span>, valueOffset, prev, next);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 省略不重要代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>要想讨论 @sun.misc.Contended 注解的重要意义得从缓存说起，缓存与内存的速度比较</p>
<p>因为 CPU 与 内存的速度差异很大，需要靠预读数据至缓存来提升效率。缓存离 cpu 越近速度越快。 而缓存以缓存行为单位，每个缓存行对应着一块内存，一般是 64 byte（8 个 long），缓存的加入会造成数据副本的产生，即同一份数据会缓存在不同核心的缓存行中，CPU 要保证数据的一致性，如果某个 CPU 核心更改了数据，其它 CPU 核心对应的整个缓存行必须失效。</p>
<p>因为 Cell 是数组形式，在内存中是连续存储的，一个 Cell 为 24 字节（16 字节的对象头和 8 字节的 value），因 此缓存行可以存下 2 个的 Cell 对象。这样问题来了： Core-0 要修改 Cell[0]，Core-1 要修改 Cell[1]，无论谁修改成功，都会导致对方 Core 的缓存行失效，比如 Core-0 中 Cell[0]&#x3D;6000, Cell[1]&#x3D;8000 要累加 Cell[0]&#x3D;6001, Cell[1]&#x3D;8000 ，这会让 Core-1 的缓存行失效，而@sun.misc.Contended 就是用来解决这个问题，它的原理是在使用此注解的对象或字段的前后各增加 128 字节大小的padding，从而让 CPU 将对象预读至缓存时占用不同的缓存行，这样，不会造成对方缓存行的失效。</p>
<h5 id="add-方法分析"><a href="#add-方法分析" class="headerlink" title="add 方法分析"></a>add 方法分析</h5><p>LongAdder 进行累加操作是调用 increment 方法，它又调用 add 方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">increment</span><span class="params">()</span> &#123;</span><br><span class="line">        add(<span class="number">1L</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>第一步：add 方法分析</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">long</span> x)</span> &#123;</span><br><span class="line">        <span class="comment">// as 为累加单元数组, b 为基础值, x 为累加值</span></span><br><span class="line">        Cell[] as; <span class="type">long</span> b, v; <span class="type">int</span> m; Cell a;</span><br><span class="line">        <span class="comment">// 进入 if 的两个条件</span></span><br><span class="line">        <span class="comment">// 1. as 有值, 表示已经发生过竞争, 进入 if</span></span><br><span class="line">        <span class="comment">// 2. cas 给 base 累加时失败了, 表示 base 发生了竞争, 进入 if</span></span><br><span class="line">        <span class="comment">// 3. 如果 as 没有创建, 然后 cas 累加成功就返回，累加到 base 中 不存在线程竞争的时候用到。</span></span><br><span class="line">        <span class="keyword">if</span> ((as = cells) != <span class="literal">null</span> || !casBase(b = base, b + x)) &#123;</span><br><span class="line">            <span class="comment">// uncontended 表示 cell 是否有竞争，这里赋值为 true 表示有竞争</span></span><br><span class="line">            <span class="type">boolean</span> <span class="variable">uncontended</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (</span><br><span class="line">                <span class="comment">// as 还没有创建</span></span><br><span class="line">                    as == <span class="literal">null</span> || (m = as.length - <span class="number">1</span>) &lt; <span class="number">0</span> ||</span><br><span class="line">                            <span class="comment">// 当前线程对应的 cell 还没有被创建，a为当线程的cell</span></span><br><span class="line">                            (a = as[getProbe() &amp; m]) == <span class="literal">null</span> ||</span><br><span class="line">       <span class="comment">// 给当前线程的 cell 累加失败 uncontended=false ( a 为当前线程的 cell )</span></span><br><span class="line">                            !(uncontended = a.cas(v = a.value, v + x))</span><br><span class="line">            ) &#123;</span><br><span class="line">                <span class="comment">// 当 cells 为空时，累加操作失败会调用方法，</span></span><br><span class="line">                <span class="comment">// 当 cells 不为空，当前线程的 cell 创建了但是累加失败了会调用方法，</span></span><br><span class="line">                <span class="comment">// 当 cells 不为空，当前线程 cell 没创建会调用这个方法</span></span><br><span class="line">                <span class="comment">// 进入 cell 数组创建、cell 创建的流程</span></span><br><span class="line">                longAccumulate(x, <span class="literal">null</span>, uncontended);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>第二步：longAccumulate 方法分析</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">longAccumulate</span><span class="params">(<span class="type">long</span> x, LongBinaryOperator fn,</span></span><br><span class="line"><span class="params">                              <span class="type">boolean</span> wasUncontended)</span> &#123;</span><br><span class="line">        <span class="type">int</span> h;</span><br><span class="line">        <span class="comment">// 当前线程还没有对应的 cell, 需要随机生成一个 h 值用来将当前线程绑定到 cell</span></span><br><span class="line">        <span class="keyword">if</span> ((h = getProbe()) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 初始化 probe</span></span><br><span class="line">            ThreadLocalRandom.current();</span><br><span class="line">            <span class="comment">// h 对应新的 probe 值, 用来对应 cell</span></span><br><span class="line">            h = getProbe();</span><br><span class="line">            wasUncontended = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// collide 为 true 表示需要扩容</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">collide</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            Cell[] as; Cell a; <span class="type">int</span> n; <span class="type">long</span> v;</span><br><span class="line">            <span class="comment">// 已经有了 cells</span></span><br><span class="line">            <span class="keyword">if</span> ((as = cells) != <span class="literal">null</span> &amp;&amp; (n = as.length) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 但是还没有当前线程对应的 cell</span></span><br><span class="line">                <span class="keyword">if</span> ((a = as[(n - <span class="number">1</span>) &amp; h]) == <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// 为 cellsBusy 加锁, 创建 cell, cell 的初始累加值为 x</span></span><br><span class="line">                    <span class="comment">// 成功则 break, 否则继续 continue 循环</span></span><br><span class="line">                    <span class="keyword">if</span> (cellsBusy == <span class="number">0</span>) &#123;       <span class="comment">// Try to attach new Cell</span></span><br><span class="line">                        <span class="type">Cell</span> <span class="variable">r</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cell</span>(x);   <span class="comment">// Optimistically create</span></span><br><span class="line">                        <span class="keyword">if</span> (cellsBusy == <span class="number">0</span> &amp;&amp; casCellsBusy()) &#123;</span><br><span class="line">                            <span class="type">boolean</span> <span class="variable">created</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">                            <span class="keyword">try</span> &#123;               <span class="comment">// Recheck under lock</span></span><br><span class="line">                                Cell[] rs; <span class="type">int</span> m, j;</span><br><span class="line">                                <span class="keyword">if</span> ((rs = cells) != <span class="literal">null</span> &amp;&amp;</span><br><span class="line">                                    (m = rs.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">                                    <span class="comment">// 判断槽位确实是空的</span></span><br><span class="line">                                    rs[j = (m - <span class="number">1</span>) &amp; h] == <span class="literal">null</span>) &#123;</span><br><span class="line">                                    rs[j] = r;</span><br><span class="line">                                    created = <span class="literal">true</span>;</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                                cellsBusy = <span class="number">0</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="keyword">if</span> (created)</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            <span class="keyword">continue</span>;           <span class="comment">// Slot is now non-empty</span></span><br><span class="line">                        &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 有竞争, 改变线程对应的 cell 来重试 cas</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (!wasUncontended)</span><br><span class="line">                    wasUncontended = <span class="literal">true</span>;</span><br><span class="line">                    <span class="comment">// cas 尝试累加, fn 配合 LongAccumulator 不为 null, 配合 LongAdder 为 null</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (a.cas(v = a.value, ((fn == <span class="literal">null</span>) ? v + x : fn.applyAsLong(v, x))))</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                    <span class="comment">// 如果 cells 长度已经超过了最大长度, 或者已经扩容, 改变线程对应的 cell 来重试 cas</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (n &gt;= NCPU || cells != as)</span><br><span class="line">                    collide = <span class="literal">false</span>;</span><br><span class="line">                    <span class="comment">// 确保 collide 为 false 进入此分支, 就不会进入下面的 else if 进行扩容了</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (!collide)</span><br><span class="line">                    collide = <span class="literal">true</span>;</span><br><span class="line">                    <span class="comment">// 加锁</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (cellsBusy == <span class="number">0</span> &amp;&amp; casCellsBusy()) &#123;</span><br><span class="line">                    <span class="comment">// 加锁成功, 扩容</span></span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 改变线程对应的 cell</span></span><br><span class="line">                h = advanceProbe(h);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 还没有 cells, cells==as是指没有其它线程修改cells，as和cells引用相同的对象，使用casCellsBusy()尝试给 cellsBusy 加锁</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (cellsBusy == <span class="number">0</span> &amp;&amp; cells == as &amp;&amp; casCellsBusy()) &#123;</span><br><span class="line">                <span class="comment">// 加锁成功, 初始化 cells, 最开始长度为 2, 并填充一个 cell</span></span><br><span class="line">                <span class="comment">// 成功则 break;</span></span><br><span class="line">                <span class="type">boolean</span> <span class="variable">init</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">try</span> &#123;                           <span class="comment">// Initialize table</span></span><br><span class="line">                    <span class="keyword">if</span> (cells == as) &#123;</span><br><span class="line">                        Cell[] rs = <span class="keyword">new</span> <span class="title class_">Cell</span>[<span class="number">2</span>];</span><br><span class="line">                        rs[h &amp; <span class="number">1</span>] = <span class="keyword">new</span> <span class="title class_">Cell</span>(x);</span><br><span class="line">                        cells = rs;</span><br><span class="line">                        init = <span class="literal">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    cellsBusy = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (init)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 上两种情况失败, 尝试给 base 使用casBase累加</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (casBase(v = base, ((fn == <span class="literal">null</span>) ? v + x : fn.applyAsLong(v, x))))</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h5 id="sum-方法分析"><a href="#sum-方法分析" class="headerlink" title="sum 方法分析"></a>sum 方法分析</h5><p>获取最终结果通过 sum 方法，将各个累加单元的值加起来就得到了总的结果：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">long</span> <span class="title function_">sum</span><span class="params">()</span> &#123;</span><br><span class="line">        Cell[] as = cells; Cell a;</span><br><span class="line">        <span class="type">long</span> <span class="variable">sum</span> <span class="operator">=</span> base;</span><br><span class="line">        <span class="keyword">if</span> (as != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; as.length; ++i) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((a = as[i]) != <span class="literal">null</span>)</span><br><span class="line">                    sum += a.value;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h4 id="Unsafe方法"><a href="#Unsafe方法" class="headerlink" title="Unsafe方法"></a>Unsafe方法</h4><h5 id="Unsafe-对象的获取"><a href="#Unsafe-对象的获取" class="headerlink" title="Unsafe 对象的获取"></a>Unsafe 对象的获取</h5><p>Unsafe 对象提供了非常底层的操作内存、线程的方法，Unsafe 对象不能直接调用，只能通过反射获得。LockSupport 的 park 方法，CAS 相关的方法底层都是通过Unsafe类来实现的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> NoSuchFieldException, IllegalAccessException &#123;</span><br><span class="line">		<span class="comment">// Unsafe 使用了单例模式，unsafe 对象是类中的一个私有的变量 </span></span><br><span class="line">        <span class="type">Field</span> <span class="variable">theUnsafe</span> <span class="operator">=</span> Unsafe.class.getDeclaredField(<span class="string">&quot;theUnsafe&quot;</span>);</span><br><span class="line">        theUnsafe.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        <span class="type">Unsafe</span> <span class="variable">unsafe</span> <span class="operator">=</span> (Unsafe)theUnsafe.get(<span class="literal">null</span>);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h5 id="Unsafe-模拟实现-cas-操作"><a href="#Unsafe-模拟实现-cas-操作" class="headerlink" title="Unsafe 模拟实现 cas 操作"></a>Unsafe 模拟实现 cas 操作</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UnsafeTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> NoSuchFieldException, IllegalAccessException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建 unsafe 对象</span></span><br><span class="line">        <span class="type">Field</span> <span class="variable">theUnsafe</span> <span class="operator">=</span> Unsafe.class.getDeclaredField(<span class="string">&quot;theUnsafe&quot;</span>);</span><br><span class="line">        theUnsafe.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        <span class="type">Unsafe</span> <span class="variable">unsafe</span> <span class="operator">=</span> (Unsafe)theUnsafe.get(<span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 拿到偏移量</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">idOffset</span> <span class="operator">=</span> unsafe.objectFieldOffset(Teacher.class.getDeclaredField(<span class="string">&quot;id&quot;</span>));</span><br><span class="line">        <span class="type">long</span> <span class="variable">nameOffset</span> <span class="operator">=</span> unsafe.objectFieldOffset(Teacher.class.getDeclaredField(<span class="string">&quot;name&quot;</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 进行 cas 操作</span></span><br><span class="line">        <span class="type">Teacher</span> <span class="variable">teacher</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Teacher</span>();</span><br><span class="line">        unsafe.compareAndSwapLong(teacher, idOffset, <span class="number">0</span>, <span class="number">100</span>);</span><br><span class="line">        unsafe.compareAndSwapObject(teacher, nameOffset, <span class="literal">null</span>, <span class="string">&quot;lisi&quot;</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(teacher);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Teacher</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> String name;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="Unsafe-模拟实现原子整数"><a href="#Unsafe-模拟实现原子整数" class="headerlink" title="Unsafe 模拟实现原子整数"></a>Unsafe 模拟实现原子整数</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UnsafeAccessor</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Account.demo(<span class="keyword">new</span> <span class="title class_">MyAtomicInteger</span>(<span class="number">10000</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyAtomicInteger</span> <span class="keyword">implements</span> <span class="title class_">Account</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> Integer value;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Unsafe</span> <span class="variable">UNSAFE</span> <span class="operator">=</span> Unsafe.getUnsafe();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> valueOffset;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            valueOffset = UNSAFE.objectFieldOffset</span><br><span class="line">                    (AtomicInteger.class.getDeclaredField(<span class="string">&quot;value&quot;</span>));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception ex) &#123; <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(ex); &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyAtomicInteger</span><span class="params">(Integer value)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">get</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">decrement</span><span class="params">(Integer amount)</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="type">Integer</span> <span class="variable">preVal</span> <span class="operator">=</span> <span class="built_in">this</span>.value;</span><br><span class="line">            <span class="type">Integer</span> <span class="variable">nextVal</span> <span class="operator">=</span> preVal - amount;</span><br><span class="line">            <span class="keyword">if</span>(UNSAFE.compareAndSwapObject(<span class="built_in">this</span>, valueOffset, preVal, nextVal)) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">getBalance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">withdraw</span><span class="params">(Integer amount)</span> &#123;</span><br><span class="line">        decrement(amount);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>多线程与高并发</category>
      </categories>
      <tags>
        <tag>多线程与高并发</tag>
      </tags>
  </entry>
  <entry>
    <title>java集合-HashMap源码解析 - HashMap源码解析</title>
    <url>/2022/05/19/2022-05-19-java%E9%9B%86%E5%90%88-HashMap%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</url>
    <content><![CDATA[<h1 id="HashMap源码解析"><a href="#HashMap源码解析" class="headerlink" title="HashMap源码解析"></a>HashMap源码解析</h1><span id="more"></span>

<h4 id="HashMap简介"><a href="#HashMap简介" class="headerlink" title="HashMap简介"></a>HashMap简介</h4><p>HashMap 主要用来存放键值对，它基于哈希表的 Map 接口实现，是常用的 Java 集合之一，是非线程安全的。</p>
<p><code>HashMap</code> 可以存储 null 的 key 和 value，但 null 作为键只能有一个，null 作为值可以有多个</p>
<p>JDK1.8 之前 HashMap 由 数组+链表 组成的，数组是 HashMap 的主体，链表则是主要为了解决哈希冲突而存在的（“拉链法”解决冲突）。 JDK1.8 以后的 <code>HashMap</code> 在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为 8）（将链表转换成红黑树前会判断，如果当前数组的长度小于 64，那么会选择先进行数组扩容，而不是转换为红黑树）时，将链表转化为红黑树，以减少搜索时间。</p>
<p><code>HashMap</code> 默认的初始化大小为 16。之后每次扩充，容量变为原来的 2 倍。并且， <code>HashMap</code> 总是使用 2 的幂作为哈希表的大小。</p>
<h4 id="底层数据结构分析"><a href="#底层数据结构分析" class="headerlink" title="底层数据结构分析"></a>底层数据结构分析</h4><h5 id="JDK1-8之前"><a href="#JDK1-8之前" class="headerlink" title="JDK1.8之前"></a>JDK1.8之前</h5><p>HashMap 主要用来存放键值对，它基于哈希表的 Map 接口实现，是常用的 Java 集合之一，是非线程安全的。</p>
<p><code>HashMap</code> 可以存储 null 的 key 和 value，但 null 作为键只能有一个，null 作为值可以有多个</p>
<p>JDK1.8 之前 HashMap 由 数组+链表 组成的，数组是 HashMap 的主体，链表则是主要为了解决哈希冲突而存在的（“拉链法”解决冲突）。 JDK1.8 以后的 <code>HashMap</code> 在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为 8）（将链表转换成红黑树前会判断，如果当前数组的长度小于 64，那么会选择先进行数组扩容，而不是转换为红黑树）时，将链表转化为红黑树，以减少搜索时间。</p>
<p><code>HashMap</code> 默认的初始化大小为 16。之后每次扩充，容量变为原来的 2 倍。并且， <code>HashMap</code> 总是使用 2 的幂作为哈希表的大小。</p>
<p><strong>JDK 1.8 HashMap 的 hash 方法源码:</strong></p>
<p>JDK 1.8 的 hash 方法 相比于 JDK 1.7 hash 方法更加简化，但是原理不变。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">  <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">hash</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">    <span class="type">int</span> h;</span><br><span class="line">    <span class="comment">// key.hashCode()：返回散列值也就是hashcode</span></span><br><span class="line">    <span class="comment">// ^ ：按位异或</span></span><br><span class="line">    <span class="comment">// &gt;&gt;&gt;:无符号右移，忽略符号位，空位都以0补齐</span></span><br><span class="line">    <span class="keyword">return</span> (key == <span class="literal">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对比一下 JDK1.7 的 HashMap 的 hash 方法源码.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="type">int</span> <span class="title function_">hash</span><span class="params">(<span class="type">int</span> h)</span> &#123;</span><br><span class="line">    <span class="comment">// This function ensures that hashCodes that differ only by</span></span><br><span class="line">    <span class="comment">// constant multiples at each bit position have a bounded</span></span><br><span class="line">    <span class="comment">// number of collisions (approximately 8 at default load factor).</span></span><br><span class="line"></span><br><span class="line">    h ^= (h &gt;&gt;&gt; <span class="number">20</span>) ^ (h &gt;&gt;&gt; <span class="number">12</span>);</span><br><span class="line">    <span class="keyword">return</span> h ^ (h &gt;&gt;&gt; <span class="number">7</span>) ^ (h &gt;&gt;&gt; <span class="number">4</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>相比于 JDK1.8 的 hash 方法 ，JDK 1.7 的 hash 方法的性能会稍差一点点，因为毕竟扰动了 4 次。</p>
<p>所谓 <strong>“拉链法”</strong> 就是：将链表和数组相结合。也就是说创建一个链表数组，数组中每一格就是一个链表。若遇到哈希冲突，则将冲突的值加到链表中即可。</p>
<p><img src="/../images/img96.png" alt="img96"></p>
<h5 id="JDK1-8之后"><a href="#JDK1-8之后" class="headerlink" title="JDK1.8之后"></a>JDK1.8之后</h5><p>相比于之前的版本，JDK1.8 以后在解决哈希冲突时有了较大的变化。</p>
<p>当链表长度大于阈值（默认为 8）时，会首先调用 <code>treeifyBin()</code>方法。这个方法会根据 HashMap 数组来决定是否转换为红黑树。只有当数组长度大于或者等于 64 的情况下，才会执行转换红黑树操作，以减少搜索时间。否则，就是只是执行 <code>resize()</code> 方法对数组扩容。相关源码这里就不贴了，重点关注 <code>treeifyBin()</code>方法即可！</p>
<p><img src="/../images/img97.png" alt="img97"></p>
<p><strong>类的属性：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HashMap</span>&lt;K,V&gt; <span class="keyword">extends</span> <span class="title class_">AbstractMap</span>&lt;K,V&gt; <span class="keyword">implements</span> <span class="title class_">Map</span>&lt;K,V&gt;, Cloneable, Serializable &#123;</span><br><span class="line">    <span class="comment">// 序列号</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">362498820763181265L</span>;</span><br><span class="line">    <span class="comment">// 默认的初始容量是16</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">DEFAULT_INITIAL_CAPACITY</span> <span class="operator">=</span> <span class="number">1</span> &lt;&lt; <span class="number">4</span>;</span><br><span class="line">    <span class="comment">// 最大容量</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAXIMUM_CAPACITY</span> <span class="operator">=</span> <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line">    <span class="comment">// 默认的填充因子</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">float</span> <span class="variable">DEFAULT_LOAD_FACTOR</span> <span class="operator">=</span> <span class="number">0.75f</span>;</span><br><span class="line">    <span class="comment">// 当桶(bucket)上的结点数大于这个值时会转成红黑树</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">TREEIFY_THRESHOLD</span> <span class="operator">=</span> <span class="number">8</span>;</span><br><span class="line">    <span class="comment">// 当桶(bucket)上的结点数小于这个值时树转链表</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">UNTREEIFY_THRESHOLD</span> <span class="operator">=</span> <span class="number">6</span>;</span><br><span class="line">    <span class="comment">// 桶中结构转化为红黑树对应的table的最小容量</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MIN_TREEIFY_CAPACITY</span> <span class="operator">=</span> <span class="number">64</span>;</span><br><span class="line">    <span class="comment">// 存储元素的数组，总是2的幂次倍</span></span><br><span class="line">    <span class="keyword">transient</span> Node&lt;k,v&gt;[] table;</span><br><span class="line">    <span class="comment">// 存放具体元素的集</span></span><br><span class="line">    <span class="keyword">transient</span> Set&lt;map.entry&lt;k,v&gt;&gt; entrySet;</span><br><span class="line">    <span class="comment">// 存放元素的个数，注意这个不等于数组的长度。</span></span><br><span class="line">    <span class="keyword">transient</span> <span class="type">int</span> size;</span><br><span class="line">    <span class="comment">// 每次扩容和更改map结构的计数器</span></span><br><span class="line">    <span class="keyword">transient</span> <span class="type">int</span> modCount;</span><br><span class="line">    <span class="comment">// 临界值(容量*填充因子) 当实际大小超过临界值时，会进行扩容</span></span><br><span class="line">    <span class="type">int</span> threshold;</span><br><span class="line">    <span class="comment">// 加载因子</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">float</span> loadFactor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p><strong>loadFactor 加载因子</strong></p>
<p>loadFactor 加载因子是控制数组存放数据的疏密程度，loadFactor 越趋近于 1，那么 数组中存放的数据(entry)也就越多，也就越密，也就是会让链表的长度增加，loadFactor 越小，也就是趋近于 0，数组中存放的数据(entry)也就越少，也就越稀疏。</p>
<p><strong>loadFactor 太大导致查找元素效率低，太小导致数组的利用率低，存放的数据会很分散。loadFactor 的默认值为 0.75f 是官方给出的一个比较好的临界值</strong>。</p>
<p>给定的默认容量为 16，负载因子为 0.75。Map 在使用过程中不断的往里面存放数据，当数量达到了 16 * 0.75 &#x3D; 12 就需要将当前 16 的容量进行扩容，而扩容这个过程涉及到 rehash、复制数据等操作，所以非常消耗性能。</p>
</li>
<li><p><strong>threshold</strong></p>
<p><strong>threshold &#x3D; capacity * loadFactor</strong>，<strong>当 Size&gt;&#x3D;threshold</strong>的时候，那么就要考虑对数组的扩增了，也就是说，这个的意思就是 <strong>衡量数组是否需要扩增的一个标准</strong>。</p>
</li>
</ul>
<p><strong>Node 节点类源码:</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 继承自 Map.Entry&lt;K,V&gt;</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Node</span>&lt;K,V&gt; <span class="keyword">implements</span> <span class="title class_">Map</span>.Entry&lt;K,V&gt; &#123;</span><br><span class="line">       <span class="keyword">final</span> <span class="type">int</span> hash;<span class="comment">// 哈希值，存放元素到hashmap中时用来与其他元素hash值比较</span></span><br><span class="line">       <span class="keyword">final</span> K key;<span class="comment">//键</span></span><br><span class="line">       V value;<span class="comment">//值</span></span><br><span class="line">       <span class="comment">// 指向下一个节点</span></span><br><span class="line">       Node&lt;K,V&gt; next;</span><br><span class="line">       Node(<span class="type">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">            <span class="built_in">this</span>.hash = hash;</span><br><span class="line">            <span class="built_in">this</span>.key = key;</span><br><span class="line">            <span class="built_in">this</span>.value = value;</span><br><span class="line">            <span class="built_in">this</span>.next = next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">final</span> K <span class="title function_">getKey</span><span class="params">()</span>        &#123; <span class="keyword">return</span> key; &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">final</span> V <span class="title function_">getValue</span><span class="params">()</span>      &#123; <span class="keyword">return</span> value; &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">final</span> String <span class="title function_">toString</span><span class="params">()</span> &#123; <span class="keyword">return</span> key + <span class="string">&quot;=&quot;</span> + value; &#125;</span><br><span class="line">        <span class="comment">// 重写hashCode()方法</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> Objects.hashCode(key) ^ Objects.hashCode(value);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">final</span> V <span class="title function_">setValue</span><span class="params">(V newValue)</span> &#123;</span><br><span class="line">            <span class="type">V</span> <span class="variable">oldValue</span> <span class="operator">=</span> value;</span><br><span class="line">            value = newValue;</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 重写 equals() 方法</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (o == <span class="built_in">this</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (o <span class="keyword">instanceof</span> Map.Entry) &#123;</span><br><span class="line">                Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o;</span><br><span class="line">                <span class="keyword">if</span> (Objects.equals(key, e.getKey()) &amp;&amp;</span><br><span class="line">                    Objects.equals(value, e.getValue()))</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>树节点类源码:</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">TreeNode</span>&lt;K,V&gt; <span class="keyword">extends</span> <span class="title class_">LinkedHashMap</span>.Entry&lt;K,V&gt; &#123;</span><br><span class="line">        TreeNode&lt;K,V&gt; parent;  <span class="comment">// 父</span></span><br><span class="line">        TreeNode&lt;K,V&gt; left;    <span class="comment">// 左</span></span><br><span class="line">        TreeNode&lt;K,V&gt; right;   <span class="comment">// 右</span></span><br><span class="line">        TreeNode&lt;K,V&gt; prev;    <span class="comment">// needed to unlink next upon deletion</span></span><br><span class="line">        <span class="type">boolean</span> red;           <span class="comment">// 判断颜色</span></span><br><span class="line">        TreeNode(<span class="type">int</span> hash, K key, V val, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">            <span class="built_in">super</span>(hash, key, val, next);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 返回根节点</span></span><br><span class="line">        <span class="keyword">final</span> TreeNode&lt;K,V&gt; <span class="title function_">root</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (TreeNode&lt;K,V&gt; r = <span class="built_in">this</span>, p;;) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((p = r.parent) == <span class="literal">null</span>)</span><br><span class="line">                    <span class="keyword">return</span> r;</span><br><span class="line">                r = p;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>

<h4 id="HashMap源码分析"><a href="#HashMap源码分析" class="headerlink" title="HashMap源码分析"></a>HashMap源码分析</h4><h5 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h5><p>HashMap 中有四个构造方法，它们分别如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 默认构造函数。</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">HashMap</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.loadFactor = DEFAULT_LOAD_FACTOR; <span class="comment">// all   other fields defaulted</span></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 包含另一个“Map”的构造函数</span></span><br><span class="line"> <span class="keyword">public</span> <span class="title function_">HashMap</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> &#123;</span><br><span class="line">     <span class="built_in">this</span>.loadFactor = DEFAULT_LOAD_FACTOR;</span><br><span class="line">     putMapEntries(m, <span class="literal">false</span>);<span class="comment">//下面会分析到这个方法</span></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 指定“容量大小”的构造函数</span></span><br><span class="line"> <span class="keyword">public</span> <span class="title function_">HashMap</span><span class="params">(<span class="type">int</span> initialCapacity)</span> &#123;</span><br><span class="line">     <span class="built_in">this</span>(initialCapacity, DEFAULT_LOAD_FACTOR);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 指定“容量大小”和“加载因子”的构造函数</span></span><br><span class="line"> <span class="keyword">public</span> <span class="title function_">HashMap</span><span class="params">(<span class="type">int</span> initialCapacity, <span class="type">float</span> loadFactor)</span> &#123;</span><br><span class="line">     <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Illegal initial capacity: &quot;</span> + initialCapacity);</span><br><span class="line">     <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">         initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">     <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Illegal load factor: &quot;</span> + loadFactor);</span><br><span class="line">     <span class="built_in">this</span>.loadFactor = loadFactor;</span><br><span class="line">     <span class="built_in">this</span>.threshold = tableSizeFor(initialCapacity);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p><strong>putMapEntries 方法：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">putMapEntries</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m, <span class="type">boolean</span> evict)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">s</span> <span class="operator">=</span> m.size();</span><br><span class="line">    <span class="keyword">if</span> (s &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 判断table是否已经初始化</span></span><br><span class="line">        <span class="keyword">if</span> (table == <span class="literal">null</span>) &#123; <span class="comment">// pre-size</span></span><br><span class="line">            <span class="comment">// 未初始化，s为m的实际元素个数</span></span><br><span class="line">            <span class="type">float</span> <span class="variable">ft</span> <span class="operator">=</span> ((<span class="type">float</span>)s / loadFactor) + <span class="number">1.0F</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> ((ft &lt; (<span class="type">float</span>)MAXIMUM_CAPACITY) ?</span><br><span class="line">                    (<span class="type">int</span>)ft : MAXIMUM_CAPACITY);</span><br><span class="line">            <span class="comment">// 计算得到的t大于阈值，则初始化阈值</span></span><br><span class="line">            <span class="keyword">if</span> (t &gt; threshold)</span><br><span class="line">                threshold = tableSizeFor(t);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 已初始化，并且m元素个数大于阈值，进行扩容处理</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (s &gt; threshold)</span><br><span class="line">            resize();</span><br><span class="line">        <span class="comment">// 将m中的所有元素添加至HashMap中</span></span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;? <span class="keyword">extends</span> <span class="title class_">K</span>, ? <span class="keyword">extends</span> <span class="title class_">V</span>&gt; e : m.entrySet()) &#123;</span><br><span class="line">            <span class="type">K</span> <span class="variable">key</span> <span class="operator">=</span> e.getKey();</span><br><span class="line">            <span class="type">V</span> <span class="variable">value</span> <span class="operator">=</span> e.getValue();</span><br><span class="line">            putVal(hash(key), key, value, <span class="literal">false</span>, evict);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="put方法"><a href="#put方法" class="headerlink" title="put方法"></a>put方法</h5><p>HashMap 只提供了 put 用于添加元素，putVal 方法只是给 put 方法调用的一个方法，并没有提供给用户使用。</p>
<p><strong>对 putVal 方法添加元素的分析如下：</strong></p>
<ol>
<li>如果定位到的数组位置没有元素 就直接插入。</li>
<li>如果定位到的数组位置有元素就和要插入的 key 比较，如果 key 相同就直接覆盖，如果 key 不相同，就判断 p 是否是一个树节点，如果是就调用<code>e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value)</code>将元素添加进入。如果不是就遍历链表插入(插入的是链表尾部)。</li>
</ol>
<p><img src="/../images/img98.png" alt="img98"></p>
<p>说明:上图有两个小问题：</p>
<ul>
<li>直接覆盖之后应该就会 return，不会有后续操作。参考 JDK8 HashMap.java 658 行（<a href="https://github.com/Snailclimb/JavaGuide/issues/608">issue#608</a>）。</li>
<li>当链表长度大于阈值（默认为 8）并且 HashMap 数组长度超过 64 的时候才会执行链表转红黑树的操作，否则就只是对数组扩容。参考 HashMap 的 <code>treeifyBin()</code> 方法（<a href="https://github.com/Snailclimb/JavaGuide/issues/1087">issue#1087</a>）。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">put</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="literal">false</span>, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> V <span class="title function_">putVal</span><span class="params">(<span class="type">int</span> hash, K key, V value, <span class="type">boolean</span> onlyIfAbsent,</span></span><br><span class="line"><span class="params">                   <span class="type">boolean</span> evict)</span> &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="type">int</span> n, i;</span><br><span class="line">    <span class="comment">// table未初始化或者长度为0，进行扩容</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) == <span class="literal">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">        n = (tab = resize()).length;</span><br><span class="line">    <span class="comment">// (n - 1) &amp; hash 确定元素存放在哪个桶中，桶为空，新生成结点放入桶中(此时，这个结点是放在数组中)</span></span><br><span class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="literal">null</span>)</span><br><span class="line">        tab[i] = newNode(hash, key, value, <span class="literal">null</span>);</span><br><span class="line">    <span class="comment">// 桶中已经存在元素</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        Node&lt;K,V&gt; e; K k;</span><br><span class="line">        <span class="comment">// 比较桶中第一个元素(数组中的结点)的hash值相等，key相等</span></span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                <span class="comment">// 将第一个元素赋值给e，用e来记录</span></span><br><span class="line">                e = p;</span><br><span class="line">        <span class="comment">// hash值不相等，即key不相等；为红黑树结点</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">            <span class="comment">// 放入树中</span></span><br><span class="line">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="built_in">this</span>, tab, hash, key, value);</span><br><span class="line">        <span class="comment">// 为链表结点</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 在链表最末插入结点</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">binCount</span> <span class="operator">=</span> <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                <span class="comment">// 到达链表的尾部</span></span><br><span class="line">                <span class="keyword">if</span> ((e = p.next) == <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// 在尾部插入新结点</span></span><br><span class="line">                    p.next = newNode(hash, key, value, <span class="literal">null</span>);</span><br><span class="line">                    <span class="comment">// 结点数量达到阈值(默认为 8 )，执行 treeifyBin 方法</span></span><br><span class="line">                    <span class="comment">// 这个方法会根据 HashMap 数组来决定是否转换为红黑树。</span></span><br><span class="line">                    <span class="comment">// 只有当数组长度大于或者等于 64 的情况下，才会执行转换红黑树操作，以减少搜索时间。否则，就是只是对数组扩容。</span></span><br><span class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                        treeifyBin(tab, hash);</span><br><span class="line">                    <span class="comment">// 跳出循环</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 判断链表中结点的key值与插入的元素的key值是否相等</span></span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="comment">// 相等，跳出循环</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="comment">// 用于遍历桶中的链表，与前面的e = p.next组合，可以遍历链表</span></span><br><span class="line">                p = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 表示在桶中找到key值、hash值与插入元素相等的结点</span></span><br><span class="line">        <span class="keyword">if</span> (e != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 记录e的value</span></span><br><span class="line">            <span class="type">V</span> <span class="variable">oldValue</span> <span class="operator">=</span> e.value;</span><br><span class="line">            <span class="comment">// onlyIfAbsent为false或者旧值为null</span></span><br><span class="line">            <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="literal">null</span>)</span><br><span class="line">                <span class="comment">//用新值替换旧值</span></span><br><span class="line">                e.value = value;</span><br><span class="line">            <span class="comment">// 访问后回调</span></span><br><span class="line">            afterNodeAccess(e);</span><br><span class="line">            <span class="comment">// 返回旧值</span></span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 结构性修改</span></span><br><span class="line">    ++modCount;</span><br><span class="line">    <span class="comment">// 实际大小大于阈值则扩容</span></span><br><span class="line">    <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">        resize();</span><br><span class="line">    <span class="comment">// 插入后回调</span></span><br><span class="line">    afterNodeInsertion(evict);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>我们再来对比一下 JDK1.7 put 方法的代码</strong></p>
<p><strong>对于 put 方法的分析如下：</strong></p>
<ul>
<li>① 如果定位到的数组位置没有元素 就直接插入。</li>
<li>② 如果定位到的数组位置有元素，遍历以这个元素为头结点的链表，依次和插入的 key 比较，如果 key 相同就直接覆盖，不同就采用头插法插入元素。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">put</span><span class="params">(K key, V value)</span></span><br><span class="line">    <span class="keyword">if</span> (table == EMPTY_TABLE) &#123;</span><br><span class="line">    inflateTable(threshold);</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">if</span> (key == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">return</span> putForNullKey(value);</span><br><span class="line">    <span class="type">int</span> <span class="variable">hash</span> <span class="operator">=</span> hash(key);</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> indexFor(hash, table.length);</span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[i]; e != <span class="literal">null</span>; e = e.next) &#123; <span class="comment">// 先遍历</span></span><br><span class="line">        Object k;</span><br><span class="line">        <span class="keyword">if</span> (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123;</span><br><span class="line">            <span class="type">V</span> <span class="variable">oldValue</span> <span class="operator">=</span> e.value;</span><br><span class="line">            e.value = value;</span><br><span class="line">            e.recordAccess(<span class="built_in">this</span>);</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    modCount++;</span><br><span class="line">    addEntry(hash, key, value, i);  <span class="comment">// 再插入</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="get方法"><a href="#get方法" class="headerlink" title="get方法"></a>get方法</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">get</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="keyword">return</span> (e = getNode(hash(key), key)) == <span class="literal">null</span> ? <span class="literal">null</span> : e.value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title function_">getNode</span><span class="params">(<span class="type">int</span> hash, Object key)</span> &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; <span class="type">int</span> n; K k;</span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="literal">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">        (first = tab[(n - <span class="number">1</span>) &amp; hash]) != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 数组元素相等</span></span><br><span class="line">        <span class="keyword">if</span> (first.hash == hash &amp;&amp; <span class="comment">// always check first node</span></span><br><span class="line">            ((k = first.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            <span class="keyword">return</span> first;</span><br><span class="line">        <span class="comment">// 桶中不止一个节点</span></span><br><span class="line">        <span class="keyword">if</span> ((e = first.next) != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 在树中get</span></span><br><span class="line">            <span class="keyword">if</span> (first <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                <span class="keyword">return</span> ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span><br><span class="line">            <span class="comment">// 在链表中get</span></span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">return</span> e;</span><br><span class="line">            &#125; <span class="keyword">while</span> ((e = e.next) != <span class="literal">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="resize方法"><a href="#resize方法" class="headerlink" title="resize方法"></a>resize方法</h5><p>进行扩容，会伴随着一次重新 hash 分配，并且会遍历 hash 表中所有的元素，是非常耗时的。在编写程序中，要尽量避免 resize。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">    <span class="type">int</span> <span class="variable">oldCap</span> <span class="operator">=</span> (oldTab == <span class="literal">null</span>) ? <span class="number">0</span> : oldTab.length;</span><br><span class="line">    <span class="type">int</span> <span class="variable">oldThr</span> <span class="operator">=</span> threshold;</span><br><span class="line">    <span class="type">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 超过最大值就不再扩充了，就只好随你碰撞去吧</span></span><br><span class="line">        <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">            threshold = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">return</span> oldTab;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 没超过最大值，就扩充为原来的2倍</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp; oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">            newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double threshold</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) <span class="comment">// initial capacity was placed in threshold</span></span><br><span class="line">        newCap = oldThr;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// signifies using defaults</span></span><br><span class="line">        newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">        newThr = (<span class="type">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 计算新的resize上限</span></span><br><span class="line">    <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="type">float</span> <span class="variable">ft</span> <span class="operator">=</span> (<span class="type">float</span>)newCap * loadFactor;</span><br><span class="line">        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="type">float</span>)MAXIMUM_CAPACITY ? (<span class="type">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line">    threshold = newThr;</span><br><span class="line">    <span class="meta">@SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)</span></span><br><span class="line">        Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> <span class="title class_">Node</span>[newCap];</span><br><span class="line">    table = newTab;</span><br><span class="line">    <span class="keyword">if</span> (oldTab != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 把每个bucket都移动到新的buckets中</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">            Node&lt;K,V&gt; e;</span><br><span class="line">            <span class="keyword">if</span> ((e = oldTab[j]) != <span class="literal">null</span>) &#123;</span><br><span class="line">                oldTab[j] = <span class="literal">null</span>;</span><br><span class="line">                <span class="keyword">if</span> (e.next == <span class="literal">null</span>)</span><br><span class="line">                    newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                    ((TreeNode&lt;K,V&gt;)e).split(<span class="built_in">this</span>, newTab, j, oldCap);</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    Node&lt;K,V&gt; loHead = <span class="literal">null</span>, loTail = <span class="literal">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; hiHead = <span class="literal">null</span>, hiTail = <span class="literal">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; next;</span><br><span class="line">                    <span class="keyword">do</span> &#123;</span><br><span class="line">                        next = e.next;</span><br><span class="line">                        <span class="comment">// 原索引</span></span><br><span class="line">                        <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (loTail == <span class="literal">null</span>)</span><br><span class="line">                                loHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                loTail.next = e;</span><br><span class="line">                            loTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">// 原索引+oldCap</span></span><br><span class="line">                        <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="keyword">if</span> (hiTail == <span class="literal">null</span>)</span><br><span class="line">                                hiHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                hiTail.next = e;</span><br><span class="line">                            hiTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">while</span> ((e = next) != <span class="literal">null</span>);</span><br><span class="line">                    <span class="comment">// 原索引放到bucket里</span></span><br><span class="line">                    <span class="keyword">if</span> (loTail != <span class="literal">null</span>) &#123;</span><br><span class="line">                        loTail.next = <span class="literal">null</span>;</span><br><span class="line">                        newTab[j] = loHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 原索引+oldCap放到bucket里</span></span><br><span class="line">                    <span class="keyword">if</span> (hiTail != <span class="literal">null</span>) &#123;</span><br><span class="line">                        hiTail.next = <span class="literal">null</span>;</span><br><span class="line">                        newTab[j + oldCap] = hiHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newTab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="HashMap常见测试方法"><a href="#HashMap常见测试方法" class="headerlink" title="HashMap常见测试方法"></a>HashMap常见测试方法</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Collection;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HashMapDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        HashMap&lt;String, String&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, String&gt;();</span><br><span class="line">        <span class="comment">// 键不能重复，值可以重复</span></span><br><span class="line">        map.put(<span class="string">&quot;san&quot;</span>, <span class="string">&quot;张三&quot;</span>);</span><br><span class="line">        map.put(<span class="string">&quot;si&quot;</span>, <span class="string">&quot;李四&quot;</span>);</span><br><span class="line">        map.put(<span class="string">&quot;wu&quot;</span>, <span class="string">&quot;王五&quot;</span>);</span><br><span class="line">        map.put(<span class="string">&quot;wang&quot;</span>, <span class="string">&quot;老王&quot;</span>);</span><br><span class="line">        map.put(<span class="string">&quot;wang&quot;</span>, <span class="string">&quot;老王2&quot;</span>);<span class="comment">// 老王被覆盖</span></span><br><span class="line">        map.put(<span class="string">&quot;lao&quot;</span>, <span class="string">&quot;老王&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;-------直接输出hashmap:-------&quot;</span>);</span><br><span class="line">        System.out.println(map);</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 遍历HashMap</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="comment">// 1.获取Map中的所有键</span></span><br><span class="line">        System.out.println(<span class="string">&quot;-------foreach获取Map中所有的键:------&quot;</span>);</span><br><span class="line">        Set&lt;String&gt; keys = map.keySet();</span><br><span class="line">        <span class="keyword">for</span> (String key : keys) &#123;</span><br><span class="line">            System.out.print(key+<span class="string">&quot;  &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();<span class="comment">//换行</span></span><br><span class="line">        <span class="comment">// 2.获取Map中所有值</span></span><br><span class="line">        System.out.println(<span class="string">&quot;-------foreach获取Map中所有的值:------&quot;</span>);</span><br><span class="line">        Collection&lt;String&gt; values = map.values();</span><br><span class="line">        <span class="keyword">for</span> (String value : values) &#123;</span><br><span class="line">            System.out.print(value+<span class="string">&quot;  &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();<span class="comment">//换行</span></span><br><span class="line">        <span class="comment">// 3.得到key的值的同时得到key所对应的值</span></span><br><span class="line">        System.out.println(<span class="string">&quot;-------得到key的值的同时得到key所对应的值:-------&quot;</span>);</span><br><span class="line">        Set&lt;String&gt; keys2 = map.keySet();</span><br><span class="line">        <span class="keyword">for</span> (String key : keys2) &#123;</span><br><span class="line">            System.out.print(key + <span class="string">&quot;：&quot;</span> + map.get(key)+<span class="string">&quot;   &quot;</span>);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 如果既要遍历key又要value，那么建议这种方式，因为如果先获取keySet然后再执行map.get(key)，map内部会执行两次遍历。</span></span><br><span class="line"><span class="comment">         * 一次是在获取keySet的时候，一次是在遍历所有key的时候。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="comment">// 当我调用put(key,value)方法的时候，首先会把key和value封装到</span></span><br><span class="line">        <span class="comment">// Entry这个静态内部类对象中，把Entry对象再添加到数组中，所以我们想获取</span></span><br><span class="line">        <span class="comment">// map中的所有键值对，我们只要获取数组中的所有Entry对象，接下来</span></span><br><span class="line">        <span class="comment">// 调用Entry对象中的getKey()和getValue()方法就能获取键值对了</span></span><br><span class="line">        Set&lt;java.util.Map.Entry&lt;String, String&gt;&gt; entrys = map.entrySet();</span><br><span class="line">        <span class="keyword">for</span> (java.util.Map.Entry&lt;String, String&gt; entry : entrys) &#123;</span><br><span class="line">            System.out.println(entry.getKey() + <span class="string">&quot;--&quot;</span> + entry.getValue());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * HashMap其他常用方法</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        System.out.println(<span class="string">&quot;after map.size()：&quot;</span>+map.size());</span><br><span class="line">        System.out.println(<span class="string">&quot;after map.isEmpty()：&quot;</span>+map.isEmpty());</span><br><span class="line">        System.out.println(map.remove(<span class="string">&quot;san&quot;</span>));</span><br><span class="line">        System.out.println(<span class="string">&quot;after map.remove()：&quot;</span>+map);</span><br><span class="line">        System.out.println(<span class="string">&quot;after map.get(si)：&quot;</span>+map.get(<span class="string">&quot;si&quot;</span>));</span><br><span class="line">        System.out.println(<span class="string">&quot;after map.containsKey(si)：&quot;</span>+map.containsKey(<span class="string">&quot;si&quot;</span>));</span><br><span class="line">        System.out.println(<span class="string">&quot;after containsValue(李四)：&quot;</span>+map.containsValue(<span class="string">&quot;李四&quot;</span>));</span><br><span class="line">        System.out.println(map.replace(<span class="string">&quot;si&quot;</span>, <span class="string">&quot;李四2&quot;</span>));</span><br><span class="line">        System.out.println(<span class="string">&quot;after map.replace(si, 李四2):&quot;</span>+map);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>集合</category>
      </categories>
  </entry>
  <entry>
    <title>二叉搜索树、红黑树 - 数据结构</title>
    <url>/2022/05/23/2022-05-23-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E3%80%81%E7%BA%A2%E9%BB%91%E6%A0%91/</url>
    <content><![CDATA[<h1 id="二叉搜索树、红黑树"><a href="#二叉搜索树、红黑树" class="headerlink" title="二叉搜索树、红黑树"></a>二叉搜索树、红黑树</h1><span id="more"></span>

<h4 id="二叉搜索树（二叉排序树）"><a href="#二叉搜索树（二叉排序树）" class="headerlink" title="二叉搜索树（二叉排序树）"></a>二叉搜索树（二叉排序树）</h4><h5 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h5><p>二叉搜索树又称二叉排序树，具有以下性质：</p>
<ul>
<li>若它的左子树不为空，则左子树上所有节点的值都小于根节点的值</li>
<li>若它的右子树不为空，则右子树上所有节点的值都大于根节点的值</li>
<li>它的左右子树也分别为二叉搜索树</li>
</ul>
<p>注意：二叉搜索树中序遍历的结果是有序的。</p>
<p><img src="/../images/h.png" alt="h"></p>
<h5 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h5><h6 id="查找元素"><a href="#查找元素" class="headerlink" title="查找元素"></a>查找元素</h6><p><strong>思路：</strong>二叉搜索树的左子树永远是比根节点小的，而它的右子树则都是比根节点大的值。当前节点比要找的大就往左走，当前元素比要找的小就往右走。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Node <span class="title function_">search</span><span class="params">(<span class="type">int</span> key)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">Node</span> <span class="variable">cur</span> <span class="operator">=</span> root;</span><br><span class="line">    	<span class="keyword">while</span>(cur != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(cur.val == key)&#123;</span><br><span class="line">                <span class="keyword">return</span> cur;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(cur.val &gt; key)&#123;</span><br><span class="line">                cur = cur.left;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                cur = cur.right</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="插入元素"><a href="#插入元素" class="headerlink" title="插入元素"></a>插入元素</h6><p>如果是空树直接把元素插入root位置就好了。</p>
<p><strong>思路：</strong>因为是二叉搜索树就不能插入重复的元素了，且每次插入都是插入到叶子节点的位置。定义一个 cur 从root开始，插入的元素比当前位置元素小就往左走，比当前位置元素大就往右走，直到为空，所以就需要再定义一个变量parent 记住 cur 的前面的位置。最后再判断插入到parent 的左子树还是右子树位置。<br><img src="/../images/i.png" alt="i"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">insert</span><span class="params">(<span class="type">int</span> key)</span>&#123;</span><br><span class="line">    <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(key);</span><br><span class="line">    	<span class="keyword">if</span>(root == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="built_in">this</span>.root = node;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    	<span class="type">Node</span> <span class="variable">parent</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    	<span class="type">Node</span> <span class="variable">cur</span> <span class="operator">=</span> root;</span><br><span class="line">    	<span class="keyword">while</span>(cur != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(cur.val == key)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(cur.val &gt; key)&#123;</span><br><span class="line">                parent = cur;</span><br><span class="line">                cur = cur.left;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                parent = cur;</span><br><span class="line">                cur = cur.right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    	<span class="keyword">if</span>(parent.val &gt; key)&#123;</span><br><span class="line">            parent.left = node;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            parent.right = node;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="删除元素"><a href="#删除元素" class="headerlink" title="删除元素"></a>删除元素</h6><p>删除元素是一个比较难的点，要考虑到很多种情况</p>
<ol>
<li>cur.left &#x3D;&#x3D; null<ul>
<li>cur是root，则root &#x3D; cur.right</li>
<li>cur不是root，则cur是parent.left，则parent.left &#x3D; cur.right</li>
<li>cur不是root，则cur是parent.right，则parent.right &#x3D; cur.right</li>
</ul>
</li>
<li>cur.right &#x3D;&#x3D; null<ul>
<li>cur是root，则root &#x3D; cur.left</li>
<li>cur不是root，则cur是parent.left，则parent.left &#x3D; cur.left</li>
<li>cur不是root，则cur是parent.right，则parent.right &#x3D; cur.left</li>
</ul>
</li>
<li>cur.left !&#x3D; null &amp;&amp; cur.right !&#x3D; null<ul>
<li>找到要删除节点，右树最左边的节点或者找到左树最右边的节点，替换这个两个节点的val值</li>
<li>这样才能保证，删除后左树一定比根节点小，右树一定比根节点大</li>
</ul>
</li>
</ol>
<p><img src="/../images/j.png" alt="j"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">remove</span><span class="params">(<span class="type">int</span> key)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">this</span>.root == <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">Node</span> <span class="variable">parent</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">Node</span> <span class="variable">cur</span> <span class="operator">=</span> <span class="built_in">this</span>.root;</span><br><span class="line">    <span class="keyword">while</span>(cur != <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(cur.val == key)&#123;</span><br><span class="line">            removeKey(parent,cur);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(cur.val &lt; key)&#123;</span><br><span class="line">            parent = cur;</span><br><span class="line">            cur = cur.right;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            parent = cur;</span><br><span class="line">            cur = cur.left;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">removeKey</span><span class="params">(Node parent,Node cur)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(cur.left == <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">this</span>.root == cur)&#123;</span><br><span class="line">            <span class="built_in">this</span>.root == <span class="built_in">this</span>.root.left;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(cur == parent.left)&#123;</span><br><span class="line">            parent.left = cur.right;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            parent.right = cur.right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(cur.right == <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">this</span>.root == cur)&#123;</span><br><span class="line">            <span class="built_in">this</span>.root = <span class="built_in">this</span>.root.left;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(cur == parent.left)&#123;</span><br><span class="line">            parent.left = cur.left;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            parent.right = cur.left;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;<span class="comment">//左右都不为空</span></span><br><span class="line">        <span class="type">Node</span> <span class="variable">targetParent</span> <span class="operator">=</span> cur;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">target</span> <span class="operator">=</span> cur.right;</span><br><span class="line">        <span class="keyword">while</span>(target.left != left)&#123;</span><br><span class="line">            targetParent = target;</span><br><span class="line">            target = target.left;</span><br><span class="line">        &#125;</span><br><span class="line">        cur.val = target.val;</span><br><span class="line">        <span class="keyword">if</span>(targetParent.left == target)&#123;</span><br><span class="line">            targetParent.left = target.right;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            targetParent.right = target.right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="性能分析"><a href="#性能分析" class="headerlink" title="性能分析"></a>性能分析</h6><p>插入和删除操作都必须先查找，查找效率代表了二叉搜索树中各个操作的性能<br>对有n个结点的二叉搜索树，若每个元素查找的概率相等，则二叉搜索树平均查找长度是结点在二叉搜索树的深度的函数，即结点越深，则比较次数越多。<br>但对于同一个关键码集合，如果各关键码插入的次序不同，可能得到不同结构的二叉搜索树：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">最好情况：二叉搜索树为完全二叉树，其平均比较次数为O(logn)</span><br></pre></td></tr></table></figure>

<p><img src="/../images/k.png" alt="k"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">最坏情况：二叉搜索树退化为单支树，其平均比较次数为：O</span><br></pre></td></tr></table></figure>

<p><img src="/../images/l.png" alt="l"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BinarySearchTree</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">        <span class="type">int</span> val;</span><br><span class="line">        Node left;</span><br><span class="line">        Node right;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(<span class="type">int</span> val)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.val = val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">Node</span> <span class="variable">root</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查找某个节点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Node <span class="title function_">search</span><span class="params">(<span class="type">int</span> key)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">cur</span> <span class="operator">=</span> root;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(cur.val == key) &#123;</span><br><span class="line">                <span class="keyword">return</span> cur;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(cur.val &gt; key) &#123;</span><br><span class="line">                cur = cur.left;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                cur = cur.right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 插入元素</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">insert</span><span class="params">(<span class="type">int</span> key)</span> &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(key);</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="built_in">this</span>.root = node;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">parent</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">cur</span> <span class="operator">=</span> root;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(cur.val == key) &#123;</span><br><span class="line">                <span class="comment">//有相同的元素直接return</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(cur.val &gt; key) &#123;</span><br><span class="line">                parent = cur;</span><br><span class="line">                cur = cur.left;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                parent = cur;</span><br><span class="line">                cur = cur.right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (parent.val &gt; key) &#123;</span><br><span class="line">            parent.left = node;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            parent.right = node;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 删除元素</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">remove</span><span class="params">(<span class="type">int</span> key)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">this</span>.root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">parent</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">cur</span> <span class="operator">=</span> <span class="built_in">this</span>.root;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(cur.val == key) &#123;</span><br><span class="line">                removeKey(parent,cur);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(cur.val &lt; key) &#123;</span><br><span class="line">                parent = cur;</span><br><span class="line">                cur = cur.right;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                parent = cur;</span><br><span class="line">                cur = cur.left;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">removeKey</span><span class="params">(Node parent,Node cur)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(cur.left == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(cur == <span class="built_in">this</span>.root) &#123;</span><br><span class="line">                <span class="built_in">this</span>.root = <span class="built_in">this</span>.root.right;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(cur == parent.left) &#123;</span><br><span class="line">                parent.left = cur.right;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                parent.right = cur.right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(cur.right == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">this</span>.root == cur) &#123;</span><br><span class="line">                <span class="built_in">this</span>.root = <span class="built_in">this</span>.root.left;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(cur == parent.left) &#123;</span><br><span class="line">                parent.left = cur.left;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                parent.right = cur.left;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="type">Node</span> <span class="variable">targetParent</span> <span class="operator">=</span> cur;</span><br><span class="line">            <span class="type">Node</span> <span class="variable">target</span> <span class="operator">=</span> cur.right;</span><br><span class="line">            <span class="keyword">while</span> (target.left != <span class="literal">null</span>) &#123;</span><br><span class="line">                targetParent = target;</span><br><span class="line">                target = target.left;</span><br><span class="line">            &#125;</span><br><span class="line">            cur.val = target.val;</span><br><span class="line">            <span class="keyword">if</span>(targetParent.left == target) &#123;</span><br><span class="line">                targetParent.left = target.right;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                targetParent.right = target.right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="红黑树原理"><a href="#红黑树原理" class="headerlink" title="红黑树原理"></a>红黑树原理</h4><h5 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h5><h6 id="红黑树的引入"><a href="#红黑树的引入" class="headerlink" title="红黑树的引入"></a>红黑树的引入</h6><p><strong>有了二叉搜索树，为什么还需要平衡二叉树？</strong></p>
<ul>
<li>在学习二叉搜索树、平衡二叉树时，我们不止一次提到，二叉搜索树容易退化成一条链</li>
<li>这时，查找的时间复杂度从O（logN）也将退化成O（N）</li>
<li>引入对左右子树高度差有限制的平衡二叉树，保证查找操作的最坏时间复杂度也为O ( logN)</li>
</ul>
<p><strong>有了平衡二叉树，为什么还需要红黑树？</strong></p>
<ul>
<li><p>AVL的左右子树高度差不能超过1，每次进行插入&#x2F;删除操作时，几乎都需要通过旋转操作保持平衡</p>
</li>
<li><p>在频繁进行插入&#x2F;删除的场景中，频繁的旋转操作使得AVL的性能大打折扣</p>
</li>
<li><p>红黑树通过牺牲严格的平衡，换取插入&#x2F;删除时少量的旋转操作，<strong>整体性能</strong>优于AVL</p>
<ul>
<li>红黑树插入时的不平衡，不超过两次旋转就可以解决；删除时的不平衡，不超过三次旋转就能解决</li>
</ul>
</li>
<li><p>红黑树的红黑规则，保证最坏的情况下，也能在O（logN）时间内完成查找操作。</p>
</li>
</ul>
<h6 id="红黑规则"><a href="#红黑规则" class="headerlink" title="红黑规则"></a>红黑规则</h6><p>一棵典型的红黑树，如图所示</p>
<p><img src="/../images/m.png" alt="m"></p>
<p>从图示，可以发现红黑树的一些规律：</p>
<ul>
<li>节点不是红色就是黑色，根节点是黑色</li>
<li>红黑树的叶子节点并非传统的叶子节点，红黑树的叶子节点是null节点（空节点）且为黑色</li>
<li>同一路径，不存在连续的红色节点</li>
</ul>
<p>红黑规则</p>
<ol>
<li>节点不是黑色，就是红色（非黑即红）</li>
<li>根节点为黑色</li>
<li>叶节点为黑色（叶节点是指末梢的空节点 <code>Nil</code>或<code>Null</code>）</li>
<li>一个节点为红色，则其两个子节点必须是黑色的（根到叶子的所有路径，不可能存在两个连续的红色节点）</li>
<li>每个节点到叶子节点的所有路径，都包含相同数目的黑色节点（相同的黑色高度）</li>
</ol>
<p>注意：</p>
<ul>
<li>约束4和5，保证了红黑树的<strong>大致平衡</strong>：根到叶子的所有路径中，最长路径不会超过最短路径的2倍。</li>
<li>使得红黑树在最坏的情况下，也能有O（logN）的查找效率<ul>
<li>黑色高度为3时，最短路径：黑色→ 黑色 → 黑色，最长路径：黑色→  红色 →黑色 → 红色 → 黑色</li>
<li>最短路径的长度为2（不算Nil的叶子节点），最长路径为4</li>
</ul>
</li>
<li>关于叶子节点：Java实现中，null代表空节点，无法看到黑色的空节点，反而能看到传统的红色叶子节点</li>
<li>默认新插入的节点为红色：因为父节点为黑色的概率较大，插入新节点为红色，可以避免颜色冲突</li>
</ul>
<h6 id="红黑树的应用"><a href="#红黑树的应用" class="headerlink" title="红黑树的应用"></a>红黑树的应用</h6><ul>
<li>Java中，TreeMap、TreeSet都使用红黑树作为底层数据结构</li>
<li>JDK 1.8开始，HashMap也引入了红黑树：当冲突的链表长度超过8时，自动转为红黑树</li>
<li>Linux底层的CFS进程调度算法中，vruntime使用红黑树进行存储。</li>
<li>多路复用技术的Epoll，其核心结构是红黑树 + 双向链表。</li>
</ul>
<h5 id="红黑树的左旋右旋"><a href="#红黑树的左旋右旋" class="headerlink" title="红黑树的左旋右旋"></a>红黑树的左旋右旋</h5><h6 id="红黑树的定义"><a href="#红黑树的定义" class="headerlink" title="红黑树的定义"></a>红黑树的定义</h6><ul>
<li>上一章节可知，红黑树要比二叉搜索树多一个颜色属性</li>
<li>同时，为了方便确认插入位置，还可以多一个parent属性，用于表示当前节点的父节点</li>
<li>因此，红黑树节点的定义如下：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">RedBlackTreeNode</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> val;</span><br><span class="line">    <span class="keyword">public</span> RedBlackTreeNode left;</span><br><span class="line">    <span class="keyword">public</span> RedBlackTreeNode right;</span><br><span class="line">    <span class="comment">// 记录节点颜色的color属性，暂定true表示红色</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> color;</span><br><span class="line">    <span class="comment">// 为了方便迭代插入，所需的parent属性</span></span><br><span class="line">    <span class="keyword">public</span> RedBlackTreeNode parent;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 一些构造函数，根据实际需求构建</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">RedBlackTreeNode</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>红黑树中，有一个root属性，用于记录当前红黑树的根节点</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedBlackTree</span> &#123;</span><br><span class="line">    <span class="comment">// 当前红黑树的根节点，默认为null</span></span><br><span class="line">    <span class="keyword">private</span> RedBlackTreeNode root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>当红黑规则不满足时，需要对节点进行<strong>变色或旋转</strong>操作</li>
</ul>
<h6 id="红黑树的左旋"><a href="#红黑树的左旋" class="headerlink" title="红黑树的左旋"></a>红黑树的左旋</h6><p>对于一棵红黑树，它满足红黑树的5条特性。插入或删除节点之后，红黑树就发生了变化，很可能不再完全满足红黑树的5条特性了，也就是不再是一棵红黑树了，而是一棵普通的二叉搜索树。这时候，为了使二叉搜索树重新变成红黑树，就需要对二叉搜索树进行操作，使它满足红黑树的5条特性。</p>
<p>以某个节点作为支点(旋转节点)，其右子节点变为旋转节点的父节点，右子节点的左子节点变为旋转节点的右子节点，旋转节点的左子节点保持不变。右子节点的左子节点相当于从右子节点上“断开”，重新连接到旋转节点上。</p>
<p>为了不失一般性，可以看下图中的例子。左边是左旋前的红黑树局部结构，先不考虑整体，只看局部，左旋前不满足红黑树的特性5。</p>
<p>左旋时，旋转节点为节点50，左旋后，旋转节点的右子节点70变为旋转节点50的父节点，右子节点的左子节点60从右子节点70上“断开”，成为旋转节点50的右子节点。</p>
<p>左旋后，结构如右图，这个局部重新满足了红黑树的特性5，达到目的。</p>
<p><img src="/../images/n.png" alt="n">再看另一个左旋的例子，左边是左旋前的局部结构，以节点10作为旋转节点，左旋后，旋转节点的右子节点20成为旋转节点10的父节点，右子节点的左子节点(这里是一个叶子节点NIL)从右子节点上“断开”，成为旋转节点10的右子节点。</p>
<p><img src="/../images/o.png" alt="o"></p>
<p>具体实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">leftRotate</span><span class="params">(RedBlackTreeNode p)</span> &#123;</span><br><span class="line">    <span class="comment">// 在当前节点不为null时，才进行左旋操作</span></span><br><span class="line">    <span class="keyword">if</span> (p != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 先记录p的右儿子</span></span><br><span class="line">        <span class="type">RedBlackTreeNode</span> <span class="variable">rightChild</span> <span class="operator">=</span> p.right;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1. 空出右儿子的左子树</span></span><br><span class="line">        p.right = rightChild.left;</span><br><span class="line">        <span class="comment">// 左子树不为空，需要更新父节点</span></span><br><span class="line">        <span class="keyword">if</span> (rightChild.left != <span class="literal">null</span>) &#123;</span><br><span class="line">            rightChild.left.parent = p;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 空出节点p的父节点</span></span><br><span class="line">        rightChild.parent = p.parent;</span><br><span class="line">        <span class="comment">// 父节点指向右儿子</span></span><br><span class="line">        <span class="keyword">if</span> (p.parent == <span class="literal">null</span>) &#123; <span class="comment">// 右儿子成为新的根节点</span></span><br><span class="line">            <span class="built_in">this</span>.root = rightChild;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (p == p.parent.left) &#123; <span class="comment">// 右儿子成为父节点的左儿子</span></span><br><span class="line">            p.parent.left = rightChild;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// 右儿子成为父节点的右儿子</span></span><br><span class="line">            p.parent.right = rightChild;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 右儿子和节点p成功会师，节点p成为左子树</span></span><br><span class="line">        rightChild.left = p;</span><br><span class="line">        p.parent = rightChild;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="红黑树的右旋"><a href="#红黑树的右旋" class="headerlink" title="红黑树的右旋"></a>红黑树的右旋</h6><p>以某个节点作为支点(旋转节点)，其左子节点变为旋转节点的父节点，左子节点的右子节点变为旋转节点的左子节点，旋转节点的右子节点保持不变。左子节点的右子节点相当于从左子节点上“断开”，重新连接到旋转节点上。</p>
<p>不难看出，左旋和右旋是相反的，可逆的。</p>
<p>下图中的例子仍然是红黑树的局部，左边的结构不满足红黑树的特性5。</p>
<p>右旋时，旋转节点为节点70，右旋后，旋转节点的左子节点50变为旋转节点70的父节点，左子节点的右子节点60从左子节点50上“断开”，成为旋转节点70的左子节点。右旋后(右图)，重新满足了红黑树的特性5。<br><img src="/../images/p.png" alt="p"></p>
<p>同样再看一个右旋的例子，左边是右旋前的局部结构，以节点30作为旋转节点，右旋后，旋转节点的左子节点20成为旋转节点30的父节点，左子节点的右子节点(这里是一个叶子节点NIL)从左子节点上“断开”，成为旋转节点30的左子节点。</p>
<p><img src="/../images/q.png" alt="q"></p>
<p>具体实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">rightRotate</span><span class="params">(RedBlackTreeNode p)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (p != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 记录p的左儿子</span></span><br><span class="line">        <span class="type">RedBlackTreeNode</span> <span class="variable">leftChild</span> <span class="operator">=</span> p.left;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1. 空出左儿子的右子树</span></span><br><span class="line">        p.left = leftChild.right;</span><br><span class="line">        <span class="comment">// 右子树不为空，需要更新父节点</span></span><br><span class="line">        <span class="keyword">if</span> (leftChild.right != <span class="literal">null</span>) &#123;</span><br><span class="line">            leftChild.right.parent = p;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 空出节点p的父节点</span></span><br><span class="line">        leftChild.parent = p.parent;</span><br><span class="line">        <span class="comment">// 父节点指向左儿子</span></span><br><span class="line">        <span class="keyword">if</span> (p.parent == <span class="literal">null</span>) &#123; <span class="comment">// 左儿子成为整棵树根节点</span></span><br><span class="line">            <span class="built_in">this</span>.root = leftChild;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (p.parent.left == p) &#123; <span class="comment">// 左儿子成为父节点左儿子</span></span><br><span class="line">            p.parent.left = leftChild;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// 左儿子成为父节点的右儿子</span></span><br><span class="line">            p.parent.right = leftChild;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 顺利会师</span></span><br><span class="line">        leftChild.right = p;</span><br><span class="line">        p.parent = leftChild;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="红黑树的变色操作"><a href="#红黑树的变色操作" class="headerlink" title="红黑树的变色操作"></a>红黑树的变色操作</h5><p>当对红黑树进行插入或删除节点之后，如果不再完全满足红黑树的5条特性，除了旋转，变色也可以使二叉搜索树重新满足红黑树的5条特性。</p>
<p>变色：将节点的颜色由红变黑或由黑变红。</p>
<p>向红黑树中插入节点时，新节点的颜色都设置为红色。不管新节点是什么颜色，特性3都不可能被破坏，特性1、2、4都有可能被破坏。如果插入的节点是黑色，则一定会破坏特性5，需要进行调整，如果插入的节点是红色，则一定不会破坏特性5。所以将新节点设置为红色，可以降低破坏红黑树特性的可能性。</p>
<h6 id="添加节点"><a href="#添加节点" class="headerlink" title="添加节点"></a>添加节点</h6><p>如下的左图是红黑树的一个局部，一开始是满足红黑树的特性的，在其中插入了红色节点10，两个红节点连在一起了，不再满足红黑树的特性4。</p>
<p><img src="/../images/r.png" alt="r"></p>
<p>通过变色，先将节点20变成黑色，特性4满足了，但又不满足特性5，所以继续将节点30变成红色，节点40变成黑色。</p>
<p><img src="/../images/s.png" alt="s"></p>
<p>经过3次变色后，从局部看，已经重新满足了红黑树的特性。但是，从整棵树来看，还不一定满足红黑树的特性，如果节点30的父节点也是红色，则还需要继续对这棵树进行调整(上面的左旋和右旋例子中也有这种情况)。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fixAfterInsert</span><span class="params">(RedBlackTreeNode x)</span> &#123;</span><br><span class="line">    <span class="comment">// 新插入的节点，默认为红色</span></span><br><span class="line">    x.color = RED;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// p不为null、不是整棵树的根节点、父亲为红色，需要调整</span></span><br><span class="line">    <span class="keyword">while</span> (x != <span class="literal">null</span> &amp;&amp; <span class="built_in">this</span>.root != x &amp;&amp; x.parent.color == RED) &#123;</span><br><span class="line">        <span class="comment">// 父亲是祖父的左儿子</span></span><br><span class="line">        <span class="keyword">if</span> (parentOf(x) == parentOf(parentOf(x)).left) &#123;</span><br><span class="line">            <span class="comment">// 父亲和叔叔都是红色</span></span><br><span class="line">            <span class="type">RedBlackTreeNode</span> <span class="variable">uncle</span> <span class="operator">=</span> parentOf(parentOf(x)).right;</span><br><span class="line">            <span class="keyword">if</span> (uncle.color == RED) &#123;</span><br><span class="line">                <span class="comment">// 父亲和叔叔都变成黑色</span></span><br><span class="line">                parentOf(x).color = BLACK;</span><br><span class="line">                uncle.color = BLACK;</span><br><span class="line">                <span class="comment">// 祖父变成红色，继续从祖父开始进行调整</span></span><br><span class="line">                parentOf(parentOf(x)).color = RED;</span><br><span class="line">                x = parentOf(parentOf(x));</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">// 叔叔为黑色</span></span><br><span class="line">                <span class="comment">// 自己是父亲的右儿子，需要对父亲左旋</span></span><br><span class="line">                <span class="keyword">if</span> (x == parentOf(x).right) &#123;</span><br><span class="line">                    x = parentOf(x);</span><br><span class="line">                    leftRotate(x);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 自己是父亲的左儿子，变色后右旋，保持黑色高度</span></span><br><span class="line">                parentOf(x).color = BLACK;</span><br><span class="line">                parentOf(parentOf(x)).color = RED;</span><br><span class="line">                rightRotate(parentOf(parentOf(x)));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">//父亲是祖父的右儿子</span></span><br><span class="line">            <span class="type">RedBlackTreeNode</span> <span class="variable">uncle</span> <span class="operator">=</span> parentOf(parentOf(x)).left;</span><br><span class="line">            <span class="comment">// 父亲和叔叔都是红色</span></span><br><span class="line">            <span class="keyword">if</span> (uncle.color == RED) &#123;</span><br><span class="line">                <span class="comment">// 叔叔和父亲变成黑色</span></span><br><span class="line">                parentOf(x).color = BLACK;</span><br><span class="line">                uncle.color = BLACK;</span><br><span class="line">                <span class="comment">// 祖父变为红色，从祖父开始继续调整</span></span><br><span class="line">                parentOf(parentOf(x)).color = RED;</span><br><span class="line">                x = parentOf(parentOf(x));</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 自己是父亲的左儿子，以父亲为中心右旋</span></span><br><span class="line">                <span class="keyword">if</span> (parentOf(x).left == x) &#123;</span><br><span class="line">                    x = parentOf(x);</span><br><span class="line">                    rightRotate(x);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 自己是父亲的右儿子，变色后左旋，保持黑色高度</span></span><br><span class="line">                parentOf(x).color = BLACK;</span><br><span class="line">                parentOf(parentOf(x)).color = RED;</span><br><span class="line">                leftRotate(parentOf(parentOf(x)));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 最后将根节点置为黑色，以满足红黑规则1，又不会破坏规则5</span></span><br><span class="line">    <span class="built_in">this</span>.root.color = BLACK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> RedBlackTreeNode <span class="title function_">parentOf</span><span class="params">(RedBlackTreeNode p)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (p == <span class="literal">null</span> ? <span class="literal">null</span> : p.parent);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="删除节点"><a href="#删除节点" class="headerlink" title="删除节点"></a>删除节点</h6><p>如下的左图是红黑树的一个局部，一开始是满足红黑树的特性的，将节点90删除后，不再满足红黑树的特性5。</p>
<p><img src="/../images/t.png" alt="t"></p>
<p>通过变色，先将节点80变成黑色，但仍不满足特性5，继续将节点70变成红色，重新满足了红黑树的特性。</p>
<p><img src="/../images/u.png" alt="u"></p>
<p>经过两次变色，重新满足了红黑树的特性，对于这个例子，只要局部满足了，整棵树一定是满足红黑树的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fixAfterDeletion</span><span class="params">(RedBlackTreeNode x)</span> &#123;</span><br><span class="line">    <span class="comment">// x不是根节点且颜色为黑色，开始循环调整</span></span><br><span class="line">    <span class="keyword">while</span> (x != root &amp;&amp; x.color == BLACK) &#123;</span><br><span class="line">        <span class="comment">// x是父亲的左儿子</span></span><br><span class="line">        <span class="keyword">if</span> (x == parentOf(x).left) &#123;</span><br><span class="line">            <span class="type">RedBlackTreeNode</span> <span class="variable">brother</span> <span class="operator">=</span> parentOf(x).right;</span><br><span class="line">            <span class="comment">// 兄弟为红色</span></span><br><span class="line">            <span class="keyword">if</span> (brother.color == RED) &#123;</span><br><span class="line">                <span class="comment">// 兄弟变成黑色，父节点变成红色</span></span><br><span class="line">                brother.color = BLACK;</span><br><span class="line">                parentOf(x).color = RED;</span><br><span class="line">                <span class="comment">// 父节点左旋，恢复左子树的黑色高度</span></span><br><span class="line">                leftRotate(parentOf(x));</span><br><span class="line">                <span class="comment">// 更新兄弟</span></span><br><span class="line">                brother = parentOf(x).right;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 兄弟为黑色，左右侄子为黑色</span></span><br><span class="line">            <span class="keyword">if</span> (brother.left.color == BLACK &amp;&amp; brother.right.color == BLACK) &#123;</span><br><span class="line">                <span class="comment">// 兄弟变成红色</span></span><br><span class="line">                brother.color = RED;</span><br><span class="line">                <span class="comment">// 从父节点开始继续调整</span></span><br><span class="line">                x = parentOf(x);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 右侄子为黑色（左侄子为红色）</span></span><br><span class="line">                <span class="keyword">if</span> (brother.right.color == BLACK) &#123;</span><br><span class="line">                    <span class="comment">// 左侄子变为黑色，兄弟变成红色</span></span><br><span class="line">                    brother.left.color = BLACK;</span><br><span class="line">                    brother.color = RED;</span><br><span class="line">                    <span class="comment">// 兄弟右旋，恢复右子树黑色高度</span></span><br><span class="line">                    rightRotate(brother);</span><br><span class="line">                    <span class="comment">// 左侄子成为新的兄弟</span></span><br><span class="line">                    brother = parentOf(x).right;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 右侄子为红色，兄弟变成父节点颜色</span></span><br><span class="line">                brother.color = parentOf(x).color;</span><br><span class="line">                <span class="comment">// 父节点和右侄子变成黑色</span></span><br><span class="line">                parentOf(x).color = BLACK;</span><br><span class="line">                brother.right.color = BLACK;</span><br><span class="line">                <span class="comment">// 父节点左旋</span></span><br><span class="line">                leftRotate(parentOf(x));</span><br><span class="line">                <span class="comment">// x指向根节点</span></span><br><span class="line">                x = root;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">RedBlackTreeNode</span> <span class="variable">brother</span> <span class="operator">=</span> parentOf(x).left;</span><br><span class="line">            <span class="comment">// 兄弟为红色</span></span><br><span class="line">            <span class="keyword">if</span> (brother.color == RED) &#123;</span><br><span class="line">                <span class="comment">// 兄弟变黑色，父亲变红色</span></span><br><span class="line">                brother.color = BLACK;</span><br><span class="line">                parentOf(x).color = RED;</span><br><span class="line">                <span class="comment">// 父亲右旋，恢复红黑色高度</span></span><br><span class="line">                rightRotate(parentOf(x));</span><br><span class="line">                <span class="comment">// 更新兄弟为右侄子</span></span><br><span class="line">                brother = parentOf(x).left;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 兄弟的左右儿子为黑色</span></span><br><span class="line">            <span class="keyword">if</span> (brother.left.color == BLACK &amp;&amp; brother.right.color == BLACK) &#123;</span><br><span class="line">                <span class="comment">// 兄弟变为红色</span></span><br><span class="line">                brother.color = RED;</span><br><span class="line">                <span class="comment">// x指向父节点，继续进行调整</span></span><br><span class="line">                x = parentOf(x);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 左侄子为黑色(右侄子为红色)</span></span><br><span class="line">                <span class="keyword">if</span> (brother.left.color == BLACK) &#123;</span><br><span class="line">                    <span class="comment">// 右侄子变黑色，兄弟变红色</span></span><br><span class="line">                    brother.right.color = BLACK;</span><br><span class="line">                    brother.color = RED;</span><br><span class="line">                    <span class="comment">// 对兄弟左旋</span></span><br><span class="line">                    leftRotate(brother);</span><br><span class="line">                    <span class="comment">// 右侄子成为新的兄弟</span></span><br><span class="line">                    brother = parentOf(x).left;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 左侄子为红色，兄弟改为父节点颜色</span></span><br><span class="line">                brother.color = parentOf(x).color;</span><br><span class="line">                <span class="comment">// 父节点和左侄子变成黑色</span></span><br><span class="line">                brother.left.color = BLACK;</span><br><span class="line">                parentOf(x).color = BLACK;</span><br><span class="line">                <span class="comment">// 兄弟节点上提(右旋父节点)</span></span><br><span class="line">                rightRotate(parentOf(x));</span><br><span class="line">                <span class="comment">// x指向根节点</span></span><br><span class="line">                x = root;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 更新x为黑色</span></span><br><span class="line">    x.color = BLACK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
  </entry>
  <entry>
    <title>java基础知识-常见Q/A - java</title>
    <url>/2022/05/25/2022-05-25-java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86-%E5%B8%B8%E8%A7%81QA/</url>
    <content><![CDATA[<h1 id="常见Q-x2F-A"><a href="#常见Q-x2F-A" class="headerlink" title="常见Q&#x2F;A"></a>常见Q&#x2F;A</h1><span id="more"></span>

<h3 id="Java-中应该使用什么数据类型来代表价格"><a href="#Java-中应该使用什么数据类型来代表价格" class="headerlink" title="Java 中应该使用什么数据类型来代表价格?"></a>Java 中应该使用什么数据类型来代表价格?</h3><p>如果不是特别关心内存和性能的话，使用BigDecimal，否则使用预定义精度的 double 类型。</p>
<h3 id="怎么将-byte-转换为-String"><a href="#怎么将-byte-转换为-String" class="headerlink" title="怎么将 byte 转换为 String?"></a>怎么将 byte 转换为 String?</h3><p>可以使用 String 接收 byte[] 参数的构造器来进行转换，需要注意的点是要使用的正确的编码，否则会使用平台默认编码，这个编码可能跟原来的编码相同，也可能不同。</p>
<h3 id="Java-中怎样将-bytes-转换为-long-类型"><a href="#Java-中怎样将-bytes-转换为-long-类型" class="headerlink" title="Java 中怎样将 bytes 转换为 long 类型?"></a>Java 中怎样将 bytes 转换为 long 类型?</h3><p>String接收bytes的构造器转成String，再Long.parseLong。</p>
<h3 id="我们能将-int-强制转换为-byte-类型的变量吗-如果该值大于-byte-类型的范围，将会出现什么现象"><a href="#我们能将-int-强制转换为-byte-类型的变量吗-如果该值大于-byte-类型的范围，将会出现什么现象" class="headerlink" title="我们能将 int 强制转换为 byte 类型的变量吗? 如果该值大于 byte 类型的范围，将会出现什么现象?"></a>我们能将 int 强制转换为 byte 类型的变量吗? 如果该值大于 byte 类型的范围，将会出现什么现象?</h3><p>是的，我们可以做强制转换，但是 Java 中 int 是 32 位的，而 byte 是 8 位的，所以，如果强制转化是，int 类型的高 24 位将会被丢弃，byte 类型的范围是从 -128 到 127。</p>
<h3 id="存在两个类，B-继承-A，C-继承-B，我们能将-B-转换为-C-么-如-C-x3D-C-B；"><a href="#存在两个类，B-继承-A，C-继承-B，我们能将-B-转换为-C-么-如-C-x3D-C-B；" class="headerlink" title="存在两个类，B 继承 A，C 继承 B，我们能将 B 转换为 C 么? 如 C &#x3D; (C) B；"></a>存在两个类，B 继承 A，C 继承 B，我们能将 B 转换为 C 么? 如 C &#x3D; (C) B；</h3><p>可以，向下转型。但是不建议使用，容易出现类型转型异常。</p>
<h3 id="哪个类包含-clone-方法-是-Cloneable-还是-Object"><a href="#哪个类包含-clone-方法-是-Cloneable-还是-Object" class="headerlink" title="哪个类包含 clone 方法? 是 Cloneable 还是 Object?"></a>哪个类包含 clone 方法? 是 Cloneable 还是 Object?</h3><p>java.lang.Cloneable 是一个标示性接口，不包含任何方法，clone 方法在 object 类中定义。并且需要知道 clone() 方法是一个本地方法，这意味着它是由 c 或 c++ 或 其他本地语言实现的。</p>
<h3 id="Java-中-操作符是线程安全的吗"><a href="#Java-中-操作符是线程安全的吗" class="headerlink" title="Java 中 ++ 操作符是线程安全的吗?"></a>Java 中 ++ 操作符是线程安全的吗?</h3><p>不是线程安全的操作。它涉及到多个指令，如读取变量值，增加，然后存储回内存，这个过程可能会出现多个线程交差。还会存在竞态条件(读取-修改-写入)。</p>
<h3 id="a-x3D-a-b-与-a-x3D-b-的区别"><a href="#a-x3D-a-b-与-a-x3D-b-的区别" class="headerlink" title="a &#x3D; a + b 与 a +&#x3D; b 的区别"></a>a &#x3D; a + b 与 a +&#x3D; b 的区别</h3><p>+&#x3D; 隐式的将加操作的结果类型强制转换为持有结果的类型。如果两个整型相加，如 byte、short 或者 int，首先会将它们提升到 int 类型，然后在执行加法操作。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">byte</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">127</span>;</span><br><span class="line"><span class="type">byte</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">127</span>;</span><br><span class="line">b = a + b; <span class="comment">// error : cannot convert from int to byte</span></span><br><span class="line">b += a; <span class="comment">// ok</span></span><br></pre></td></tr></table></figure>

<p>(因为 a+b 操作会将 a、b 提升为 int 类型，所以将 int 类型赋值给 byte 就会编译出错)</p>
<h3 id="我能在不进行强制转换的情况下将一个-double-值赋值给-long-类型的变量吗"><a href="#我能在不进行强制转换的情况下将一个-double-值赋值给-long-类型的变量吗" class="headerlink" title="我能在不进行强制转换的情况下将一个 double 值赋值给 long 类型的变量吗?"></a>我能在不进行强制转换的情况下将一个 double 值赋值给 long 类型的变量吗?</h3><p>不行，你不能在没有强制类型转换的前提下将一个 double 值赋值给 long 类型的变量，因为 double 类型的范围比 long 类型更广，所以必须要进行强制转换。</p>
<h3 id="3-0-1-x3D-x3D-0-3-将会返回什么-true-还是-false"><a href="#3-0-1-x3D-x3D-0-3-将会返回什么-true-还是-false" class="headerlink" title="3*0.1 &#x3D;&#x3D; 0.3 将会返回什么? true 还是 false?"></a>3*0.1 &#x3D;&#x3D; 0.3 将会返回什么? true 还是 false?</h3><p>false，因为有些浮点数不能完全精确的表示出来。</p>
<h3 id="int-和-Integer-哪个会占用更多的内存"><a href="#int-和-Integer-哪个会占用更多的内存" class="headerlink" title="int 和 Integer 哪个会占用更多的内存?"></a>int 和 Integer 哪个会占用更多的内存?</h3><p>Integer 对象会占用更多的内存。Integer 是一个对象，需要存储对象的元数据。但是 int 是一个原始类型的数据，所以占用的空间更少。</p>
<h3 id="为什么-Java-中的-String-是不可变的-Immutable"><a href="#为什么-Java-中的-String-是不可变的-Immutable" class="headerlink" title="为什么 Java 中的 String 是不可变的(Immutable)?"></a>为什么 Java 中的 String 是不可变的(Immutable)?</h3><p>Java 中的 String 不可变是因为 Java 的设计者认为字符串使用非常频繁，将字符串设置为不可变可以允许多个客户端之间共享相同的字符串。</p>
<h3 id="我们能在-Switch-中使用-String-吗"><a href="#我们能在-Switch-中使用-String-吗" class="headerlink" title="我们能在 Switch 中使用 String 吗?"></a>我们能在 Switch 中使用 String 吗?</h3><p>从 Java 7 开始，我们可以在 switch case 中使用字符串，但这仅仅是一个语法糖。内部实现在 switch 中使用字符串的 hash code。</p>
<h3 id="Java-中的构造器链是什么"><a href="#Java-中的构造器链是什么" class="headerlink" title="Java 中的构造器链是什么?"></a>Java 中的构造器链是什么?</h3><p>当你从一个构造器中调用另一个构造器，就是Java 中的构造器链。这种情况只在重载了类的构造器的时候才会出现。</p>
<h3 id="枚举类"><a href="#枚举类" class="headerlink" title="枚举类"></a>枚举类</h3><p>JDK1.5出现 每个枚举值都需要调用一次构造函数。</p>
<h3 id="什么是不可变对象-immutable-object-Java-中怎么创建一个不可变对象"><a href="#什么是不可变对象-immutable-object-Java-中怎么创建一个不可变对象" class="headerlink" title="什么是不可变对象(immutable object)? Java 中怎么创建一个不可变对象?"></a>什么是不可变对象(immutable object)? Java 中怎么创建一个不可变对象?</h3><p>不可变对象指对象一旦被创建，状态就不能再改变。任何修改都会创建一个新的对象，如 String、Integer及其它包装类。</p>
<p>如何在Java中写出Immutable的类?</p>
<p>要写出这样的类，需要遵循以下几个原则:</p>
<ul>
<li>immutable对象的状态在创建之后就不能发生改变，任何对它的改变都应该产生一个新的对象。</li>
<li>Immutable类的所有的属性都应该是final的。</li>
<li>对象必须被正确的创建，比如: 对象引用在对象创建过程中不能泄露(leak)。</li>
<li>对象应该是final的，以此来限制子类继承父类，以避免子类改变了父类的immutable特性。</li>
<li>如果类中包含mutable类对象，那么返回给客户端的时候，返回该对象的一个拷贝，而不是该对象本身(该条可以归为第一条中的一个特例)</li>
</ul>
<h3 id="我们能创建一个包含可变对象的不可变对象吗"><a href="#我们能创建一个包含可变对象的不可变对象吗" class="headerlink" title="我们能创建一个包含可变对象的不可变对象吗?"></a>我们能创建一个包含可变对象的不可变对象吗?</h3><p>是的，我们是可以创建一个包含可变对象的不可变对象的，你只需要谨慎一点，不要共享可变对象的引用就可以了，如果需要变化时，就返回原对象的一个拷贝。最常见的例子就是对象中包含一个日期对象的引用。</p>
<h3 id="有没有可能两个不相等的对象有相同的-hashcode"><a href="#有没有可能两个不相等的对象有相同的-hashcode" class="headerlink" title="有没有可能两个不相等的对象有相同的 hashcode?"></a>有没有可能两个不相等的对象有相同的 hashcode?</h3><p>有可能，两个不相等的对象可能会有相同的 hashcode 值，这就是为什么在 hashmap 中会有冲突。相等 hashcode 值的规定只是说如果两个对象相等，必须有相同的hashcode 值，但是没有关于不相等对象的任何规定。</p>
<h3 id="两个相同的对象会有不同的-hash-code-吗"><a href="#两个相同的对象会有不同的-hash-code-吗" class="headerlink" title="两个相同的对象会有不同的 hash code 吗?"></a>两个相同的对象会有不同的 hash code 吗?</h3><p>不能，根据 hash code 的规定，这是不可能的。</p>
<h3 id="我们可以在-hashcode-中使用随机数字吗"><a href="#我们可以在-hashcode-中使用随机数字吗" class="headerlink" title="我们可以在 hashcode() 中使用随机数字吗?"></a>我们可以在 hashcode() 中使用随机数字吗?</h3><p>不行，因为对象的 hashcode 值必须是相同的。</p>
<h3 id="Java-中，Comparator-与-Comparable-有什么不同"><a href="#Java-中，Comparator-与-Comparable-有什么不同" class="headerlink" title="Java 中，Comparator 与 Comparable 有什么不同?"></a>Java 中，Comparator 与 Comparable 有什么不同?</h3><p>Comparable 接口用于定义对象的自然顺序，而 comparator 通常用于定义用户定制的顺序。Comparable 总是只有一个，但是可以有多个 comparator 来定义对象的顺序。</p>
<h3 id="为什么在重写-equals-方法的时候需要重写-hashCode-方法"><a href="#为什么在重写-equals-方法的时候需要重写-hashCode-方法" class="headerlink" title="为什么在重写 equals 方法的时候需要重写 hashCode 方法?"></a>为什么在重写 equals 方法的时候需要重写 hashCode 方法?</h3><p>因为有强制的规范指定需要同时重写 hashcode 与 equals 是方法，许多容器类，如 HashMap、HashSet 都依赖于 hashcode 与 equals 的规定。</p>
<h3 id="“a-x3D-x3D-b”和”a-equals-b-”有什么区别"><a href="#“a-x3D-x3D-b”和”a-equals-b-”有什么区别" class="headerlink" title="“a&#x3D;&#x3D;b”和”a.equals(b)”有什么区别?"></a>“a&#x3D;&#x3D;b”和”a.equals(b)”有什么区别?</h3><p>如果 a 和 b 都是对象，则 a&#x3D;&#x3D;b 是比较两个对象的引用，只有当 a 和 b 指向的是堆中的同一个对象才会返回 true，而 a.equals(b) 是进行逻辑比较，所以通常需要重写该方法来提供逻辑一致性的比较。例如，String 类重写 equals() 方法，所以可以用于两个不同对象，但是包含的字母相同的比较。</p>
<h3 id="a-hashCode-有什么用-与-a-equals-b-有什么关系"><a href="#a-hashCode-有什么用-与-a-equals-b-有什么关系" class="headerlink" title="a.hashCode() 有什么用? 与 a.equals(b) 有什么关系?"></a>a.hashCode() 有什么用? 与 a.equals(b) 有什么关系?</h3><p>简介: hashCode() 方法是相应对象整型的 hash 值。它常用于基于 hash 的集合类，如 Hashtable、HashMap、LinkedHashMap等等。它与 equals() 方法关系特别紧密。根据 Java 规范，两个使用 equals() 方法来判断相等的对象，必须具有相同的 hash code。</p>
<p>1.hashcode的作用</p>
<p>List和Set，如何保证Set不重复呢? 通过迭代使用equals方法来判断，数据量小还可以接受，数据量大怎么解决? 引入hashcode，实际上hashcode扮演的角色就是寻址，大大减少查询匹配次数。                                                        </p>
<p>2.hashcode重要吗？</p>
<p>对于数组、List集合就是一个累赘。而对于hashmap, hashset, hashtable就异常重要了。</p>
<p>3.equals方法遵循的原则</p>
<ul>
<li>对称性 若x.equals(y)true，则y.equals(x)true</li>
<li>自反性 x.equals(x)必须true</li>
<li>传递性 若x.equals(y)true,y.equals(z)true,则x.equals(z)必为true</li>
<li>一致性 只要x,y内容不变，无论调用多少次结果不变</li>
<li>其他 x.equals(null) 永远false，x.equals(和x数据类型不同)始终false</li>
</ul>
<h3 id="final、finalize-和-finally-的不同之处"><a href="#final、finalize-和-finally-的不同之处" class="headerlink" title="final、finalize 和 finally 的不同之处?"></a>final、finalize 和 finally 的不同之处?</h3><ul>
<li>final 是一个修饰符，可以修饰变量、方法和类。如果 final 修饰变量，意味着该变量的值在初始化后不能被改变。</li>
<li>Java 技术允许使用 finalize() 方法在垃圾收集器将对象从内存中清除出去之前做必要的清理工作。这个方法是由垃圾收集器在确定这个对象没有被引用时对这个对象调用的，但是什么时候调用 finalize 没有保证。</li>
<li>finally 是一个关键字，与 try 和 catch 一起用于异常的处理。finally 块一定会被执行，无论在 try 块中是否有发生异常。</li>
</ul>
<h3 id="Java-中的编译期常量是什么-使用它又什么风险"><a href="#Java-中的编译期常量是什么-使用它又什么风险" class="headerlink" title="Java 中的编译期常量是什么? 使用它又什么风险?"></a>Java 中的编译期常量是什么? 使用它又什么风险?</h3><p>变量也就是我们所说的编译期常量，这里的 public 可选的。实际上这些变量在编译时会被替换掉，因为编译器知道这些变量的值，并且知道这些变量在运行时不能改变。这种方式存在的一个问题是你使用了一个内部的或第三方库中的公有编译时常量，但是这个值后面被其他人改变了，但是你的客户端仍然在使用老的值，甚至你已经部署了一个新的jar。为了避免这种情况，当你在更新依赖 JAR 文件时，确保重新编译你的程序。</p>
<h3 id="静态内部类与顶级类有什么区别"><a href="#静态内部类与顶级类有什么区别" class="headerlink" title="静态内部类与顶级类有什么区别?"></a>静态内部类与顶级类有什么区别?</h3><p>一个公共的顶级类的源文件名称与类名相同，而嵌套静态类没有这个要求。一个嵌套类位于顶级类内部，需要使用顶级类的名称来引用嵌套静态类，如 HashMap.Entry 是一个嵌套静态类，HashMap 是一个顶级类，Entry是一个嵌套静态类。</p>
<h3 id="Java-中，Serializable-与-Externalizable-的区别"><a href="#Java-中，Serializable-与-Externalizable-的区别" class="headerlink" title="Java 中，Serializable 与 Externalizable 的区别?"></a>Java 中，Serializable 与 Externalizable 的区别?</h3><p>Serializable 接口是一个序列化 Java 类的接口，以便于它们可以在网络上传输或者可以将它们的状态保存在磁盘上，是 JVM 内嵌的默认序列化方式，成本高、脆弱而且不安全。Externalizable 允许你控制整个序列化过程，指定特定的二进制格式，增加安全机制。</p>
<h3 id="说出-JDK-1-7-中的三个新特性"><a href="#说出-JDK-1-7-中的三个新特性" class="headerlink" title="说出 JDK 1.7 中的三个新特性?"></a>说出 JDK 1.7 中的三个新特性?</h3><p>虽然 JDK 1.7 不像 JDK 5 和 8 一样的大版本，但是，还是有很多新的特性，如 try-with-resource 语句，这样你在使用流或者资源的时候，就不需要手动关闭，Java 会自动关闭。Fork-Join 池某种程度上实现 Java 版的 Map-reduce。允许 Switch 中有 String 变量和文本。菱形操作符(&lt;&gt;)用于泛型推断，不再需要在变量声明的右边申明泛型，因此可以写出可读写更强、更简洁的代码。另一个值得一提的特性是改善异常处理，如允许在同一个 catch 块中捕获多个异常。</p>
<h3 id="说出-5-个-JDK-1-8-引入的新特性"><a href="#说出-5-个-JDK-1-8-引入的新特性" class="headerlink" title="说出 5 个 JDK 1.8 引入的新特性?"></a>说出 5 个 JDK 1.8 引入的新特性?</h3><p>Java 8 在 Java 历史上是一个开创新的版本，下面 JDK 8 中 5 个主要的特性:  Lambda 表达式，允许像对象一样传递匿名函数 Stream API，充分利用现代多核 CPU，可以写出很简洁的代码 Date 与 Time API，最终，有一个稳定、简单的日期和时间库可供你使用 扩展方法，现在，接口中可以有静态、默认方法。 重复注解，现在你可以将相同的注解在同一类型上使用多次。</p>
<p>下述包含 Java 面试过程中关于 SOLID 的设计原则，OOP 基础，如类，对象，接口，继承，多态，封装，抽象以及更高级的一些概念，如组合、聚合及关联。也包含了 GOF 设计模式的问题。</p>
<h3 id="接口是什么-为什么要使用接口而不是直接使用具体类"><a href="#接口是什么-为什么要使用接口而不是直接使用具体类" class="headerlink" title="接口是什么? 为什么要使用接口而不是直接使用具体类?"></a>接口是什么? 为什么要使用接口而不是直接使用具体类?</h3><p>接口用于定义 API。它定义了类必须得遵循的规则。同时，它提供了一种抽象，因为客户端只使用接口，这样可以有多重实现，如 List 接口，你可以使用可随机访问的 ArrayList，也可以使用方便插入和删除的 LinkedList。接口中不允许普通方法，以此来保证抽象，但是 Java 8 中你可以在接口声明静态方法和默认普通方法。</p>
<h3 id="Java-中，抽象类与接口之间有什么不同"><a href="#Java-中，抽象类与接口之间有什么不同" class="headerlink" title="Java 中，抽象类与接口之间有什么不同?"></a>Java 中，抽象类与接口之间有什么不同?</h3><p>Java 中，抽象类和接口有很多不同之处，但是最重要的一个是 Java 中限制一个类只能继承一个类，但是可以实现多个接口。抽象类可以很好的定义一个家族类的默认行为，而接口能更好的定义类型，有助于后面实现多态机制。</p>
<h3 id="Object有哪些公用方法"><a href="#Object有哪些公用方法" class="headerlink" title="Object有哪些公用方法?"></a>Object有哪些公用方法?</h3><p>clone equals hashcode wait notify notifyall finalize toString getClass 除了clone和finalize其他均为公共方法。</p>
<p>11个方法，wait被重载了两次。</p>
<h3 id="equals与-x3D-x3D-的区别"><a href="#equals与-x3D-x3D-的区别" class="headerlink" title="equals与&#x3D;&#x3D;的区别"></a>equals与&#x3D;&#x3D;的区别</h3><p>区别1. &#x3D;&#x3D;是一个运算符 equals是Object类的方法</p>
<p>区别2. 比较时的区别</p>
<ul>
<li>用于基本类型的变量比较时: &#x3D;&#x3D;用于比较值是否相等，equals不能直接用于基本数据类型的比较，需要转换为其对应的包装类型。</li>
<li>用于引用类型的比较时。&#x3D;&#x3D;和equals都是比较栈内存中的地址是否相等 。相等为true 否则为false。但是通常会重写equals方法去实现对象内容的比较。</li>
</ul>
<h3 id="String、StringBuffer与StringBuilder的区别"><a href="#String、StringBuffer与StringBuilder的区别" class="headerlink" title="String、StringBuffer与StringBuilder的区别"></a>String、StringBuffer与StringBuilder的区别</h3><p>第一点: 可变和适用范围。String对象是不可变的，而StringBuffer和StringBuilder是可变字符序列。每次对String的操作相当于生成一个新的String对象，而对StringBuffer和StringBuilder的操作是对对象本身的操作，而不会生成新的对象，所以对于频繁改变内容的字符串避免使用String，因为频繁的生成对象将会对系统性能产生影响。</p>
<p>第二点: 线程安全。String由于有final修饰，是immutable的，安全性是简单而纯粹的。StringBuilder和StringBuffer的区别在于StringBuilder不保证同步，也就是说如果需要线程安全需要使用StringBuffer，不需要同步的StringBuilder效率更高。</p>
<h3 id="接口与抽象类"><a href="#接口与抽象类" class="headerlink" title="接口与抽象类"></a>接口与抽象类</h3><ul>
<li>一个子类只能继承一个抽象类, 但能实现多个接口</li>
<li>抽象类可以有构造方法, 接口没有构造方法</li>
<li>抽象类可以有普通成员变量, 接口没有普通成员变量</li>
<li>抽象类和接口都可有静态成员变量, 抽象类中静态成员变量访问类型任意，接口只能public static final(默认)</li>
<li>抽象类可以没有抽象方法, 抽象类可以有普通方法；接口在JDK8之前都是抽象方法，在JDK8可以有default方法，在JDK9中允许有私有普通方法</li>
<li>抽象类可以有静态方法；接口在JDK8之前不能有静态方法，在JDK8中可以有静态方法，且只能被接口类直接调用（不能被实现类的对象调用）</li>
<li>抽象类中的方法可以是public、protected; 接口方法在JDK8之前只有public abstract，在JDK8可以有default方法，在JDK9中允许有private方法</li>
</ul>
<h3 id="抽象类和最终类"><a href="#抽象类和最终类" class="headerlink" title="抽象类和最终类"></a>抽象类和最终类</h3><p>抽象类可以没有抽象方法, 最终类可以没有最终方法。</p>
<p>最终类不能被继承, 最终方法不能被重写(可以重载)</p>
<h3 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h3><p>相关的关键字 throw、throws、try…catch、finally</p>
<ul>
<li>throws 用在方法签名上, 以便抛出的异常可以被调用者处理</li>
<li>throw 方法内部通过throw抛出异常</li>
<li>try 用于检测包住的语句块, 若有异常, catch子句捕获并执行catch块</li>
</ul>
<h3 id="关于finally"><a href="#关于finally" class="headerlink" title="关于finally"></a>关于finally</h3><ul>
<li>finally不管有没有异常都要处理</li>
<li>当try和catch中有return时，finally仍然会执行，finally比return先执行</li>
<li>不管有木有异常抛出, finally在return返回前执行</li>
<li>finally是在return后面的表达式运算后执行的(此时并没有返回运算后的值，而是先把要返回的值保存起来，管finally中的代码怎么样，返回的值都不会改变，仍然是之前保存的值)，所以函数返回值是在finally执行前确定的</li>
</ul>
<p>注意: finally中最好不要包含return，否则程序会提前退出，返回值不是try或catch中保存的返回值</p>
<p>finally不执行的几种情况: 程序提前终止如调用了System.exit, 病毒，断电。</p>
<h3 id="受检查异常和运行时异常"><a href="#受检查异常和运行时异常" class="headerlink" title="受检查异常和运行时异常"></a>受检查异常和运行时异常</h3><ul>
<li><p>受检查的异常(checked exceptions),其必须被try…catch语句块所捕获, 或者在方法签名里通过throws子句声明。受检查的异常必须在编译时被捕捉处理,命名为Checked Exception是因为Java编译器要进行检查, Java虚拟机也要进行检查, 以确保这个规则得到遵守。</p>
<p>常见的checked exception: ClassNotFoundException IOException FileNotFoundException EOFException</p>
</li>
<li><p>运行时异常(runtime exceptions), 需要程序员自己分析代码决定是否捕获和处理,比如空指针,被0除…</p>
<p>常见的runtime exception: NullPointerException ArithmeticException ClassCastException IllegalArgumentException IllegalStateException IndexOutOfBoundsException NoSuchElementException</p>
</li>
<li><p>Error的，则属于严重错误，如系统崩溃、虚拟机错误、动态链接失败等，这些错误无法恢复或者不可能捕捉，将导致应用程序中断，Error不需要捕获。</p>
</li>
</ul>
<h3 id="super出现在父类的子类中。有三种存在方式"><a href="#super出现在父类的子类中。有三种存在方式" class="headerlink" title="super出现在父类的子类中。有三种存在方式"></a>super出现在父类的子类中。有三种存在方式</h3><ul>
<li>super.xxx(xxx为变量名或对象名)意思是获取父类中xxx的变量或引用</li>
<li>super.xxx(); (xxx为方法名)意思是直接访问并调用父类中的方法</li>
<li>super() 调用父类构造</li>
</ul>
<p>注: super只能指代其直接父类</p>
<h3 id="this-amp-super-在构造方法中的区别"><a href="#this-amp-super-在构造方法中的区别" class="headerlink" title="this() &amp; super()在构造方法中的区别"></a>this() &amp; super()在构造方法中的区别</h3><ul>
<li>调用super()必须写在子类构造方法的第一行, 否则编译不通过</li>
<li>super从子类调用父类构造, this在同一类中调用其他构造均需要放在第一行</li>
<li>尽管可以用this调用一个构造器, 却不能调用2个</li>
<li>this和super不能出现在同一个构造器中, 否则编译不通过</li>
<li>this()、super()都指的对象,不可以在static环境中使用</li>
<li>本质this指向本对象的指针。super是一个关键字</li>
</ul>
<h3 id="构造内部类和静态内部类对象"><a href="#构造内部类和静态内部类对象" class="headerlink" title="构造内部类和静态内部类对象"></a>构造内部类和静态内部类对象</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Enclosingone</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Insideone</span> &#123;&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Insideone</span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">	<span class="comment">// 构造内部类对象需要外部类的引用</span></span><br><span class="line">	Enclosingone.<span class="type">Insideone</span> <span class="variable">obj1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Enclosingone</span>().<span class="keyword">new</span> <span class="title class_">Insideone</span>();</span><br><span class="line">	<span class="comment">// 构造静态内部类的对象</span></span><br><span class="line">	Enclosingone.<span class="type">Insideone</span> <span class="variable">obj2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Enclosingone</span>.Insideone();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>静态内部类不需要有指向外部类的引用。但非静态内部类需要持有对外部类的引用。非静态内部类能够访问外部类的静态和非静态成员。静态内部类不能访问外部类的非静态成员，只能访问外部类的静态成员。</p>
<h3 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h3><p>声明为static和transient类型的数据不能被序列化， 反序列化需要一个无参构造函数。</p>
<h3 id="Java移位运算符"><a href="#Java移位运算符" class="headerlink" title="Java移位运算符"></a>Java移位运算符</h3><ul>
<li><code>&lt;&lt;</code> :左移运算符,<code>x &lt;&lt; 1</code>,相当于x乘以2(不溢出的情况下),低位补0</li>
<li><code>&gt;&gt;</code> :带符号右移,<code>x &gt;&gt; 1</code>,相当于x除以2,正数高位补0,负数高位补1</li>
<li><code>&gt;&gt;&gt;</code> :无符号右移,忽略符号位,空位都以0补齐</li>
</ul>
<h3 id="形参-amp-实参"><a href="#形参-amp-实参" class="headerlink" title="形参&amp;实参"></a>形参&amp;实参</h3><p>形式参数可被视为local variable.形参和局部变量一样都不能离开方法。只有在方法中使用，不会在方法外可见。 形式参数只能用final修饰符，其它任何修饰符都会引起编译器错误。但是用这个修饰符也有一定的限制，就是在方法中不能对参数做任何修改。不过一般情况下，一个方法的形参不用final修饰。只有在特殊情况下，那就是: 方法内部类。一个方法内的内部类如果使用了这个方法的参数或者局部变量的话，这个参数或局部变量应该是final。 形参的值在调用时根据调用者更改，实参则用自身的值更改形参的值(指针、引用皆在此列)，也就是说真正被传递的是实参。</p>
<h3 id="局部变量为什么要初始化"><a href="#局部变量为什么要初始化" class="headerlink" title="局部变量为什么要初始化"></a>局部变量为什么要初始化</h3><p>局部变量是指类方法中的变量，必须初始化。局部变量运行时被分配在栈中，量大，生命周期短，如果虚拟机给每个局部变量都初始化一下，是一笔很大的开销，但变量不初始化为默认值就使用是不安全的。出于速度和安全性两个方面的综合考虑，解决方案就是虚拟机不初始化，但要求编写者一定要在使用前给变量赋值。</p>
<h3 id="Java语言的鲁棒性"><a href="#Java语言的鲁棒性" class="headerlink" title="Java语言的鲁棒性"></a>Java语言的鲁棒性</h3><p>Java在编译和运行程序时，都要对可能出现的问题进行检查，以消除错误的产生。它提供自动垃圾收集来进行内存管理，防止程序员在管理内存时容易产生的错误。通过集成的面向对象的例外处理机制，在编译时，Java揭示出可能出现但未被处理的异常，帮助程序员正确地进行选择以防止系统的崩溃。另外，Java在编译时还可捕获类型声明中的许多常见错误，防止动态运行时不匹配问题的出现。</p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
  </entry>
  <entry>
    <title>JUC高并发编程-基础知识</title>
    <url>/2022/03/15/JUC%E9%AB%98%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<h3 id="JUC高并发编程"><a href="#JUC高并发编程" class="headerlink" title="JUC高并发编程"></a>JUC高并发编程</h3><span id="more"></span>

<h3 id="1-进程与线程"><a href="#1-进程与线程" class="headerlink" title="1.进程与线程"></a>1.进程与线程</h3><h4 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h4><ul>
<li>程序由指令和数据组成，但这些指令要运行，数据要读写，就必须将指令加载至CPU，数据加载至内存。在指令运行过程中还需要用到磁盘、网络等设备。进程就是用来加载指令、管理内存、管理IO的。</li>
<li>当一个程序被运行，从磁盘加载这个程序的代码至内存，这时就开启了一个进程。</li>
<li>进程就可以视为程序的一个实例。大部分程序可以同时运行多个实例，也有的程序只能启动一个实例进程。</li>
</ul>
<h4 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h4><ul>
<li>一个进程之内可以分为一个到多个线程。</li>
<li>一个线程就是一个指令流，将指令流中的一条条指令以一定的顺序交给CPU执行。</li>
<li>Java中，线程作为最小调度单位，进程作为资源分配的最小单位。在windows中进程是不活动的，只是作为线程的容器。</li>
</ul>
<h4 id="二者对比"><a href="#二者对比" class="headerlink" title="二者对比"></a>二者对比</h4><ul>
<li>进程基本上相互独立的，而线程存在于进程内，是进程的一个子集。</li>
<li>进程拥有共享的资源，如内存空间等，供其内部的线程共享。</li>
<li>进程间通信比较复杂。<ul>
<li>同一台计算机的进程通信称为IPC</li>
<li>不同计算机之间的进程通信，需要通过网络，并遵守共同的协议，例如HTTP</li>
</ul>
</li>
<li>线程通信相对简单，因为它们共享进程内的内存，一个例子是多个线程可以访问同一个共享变量。</li>
<li>线程更轻量，线程上下文切换成本一般上要比进程上下文切换低。</li>
</ul>
<h4 id="并行与并发"><a href="#并行与并发" class="headerlink" title="并行与并发"></a>并行与并发</h4><p><strong>并发</strong>（concurrent）</p>
<p>单核cpu下，线程实际还是串行执行的。操作系统中有一个组件叫任务调度器，将cpu的时间片分给不同的线程使用，只是由于cpu在线程间（时间片很短）的切换非常快，人类感觉是同时运行的。总结一句话：微观串行，宏观并行。</p>
<p>一般会将这种线程轮流使用cpu的做法称为并发，concurrent。</p>
<p><strong>并行</strong>（parallel）</p>
<p>多核cpu下，每个核（core）都可以调度运行线程，这时候线程可以是并行的。</p>
<p><strong>例子</strong></p>
<ul>
<li>家庭主妇做饭、打扫卫生、给孩子喂奶，她一个人轮流交替做着多件事，这时就是并发。</li>
<li>家庭主妇雇了个保姆，她们一起做这些事，这时既有并发，也有并行（这时会产生竞争，例如锅只有一口，一个人用锅时，另一个人就得等待）。</li>
<li>雇了3个保姆，一个专做饭、一个专打扫卫生、一个专喂奶，互不干扰，这时就是并行。</li>
</ul>
<h4 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h4><p><strong>案例1：异步调用</strong></p>
<p>从方法调用的角度来讲，如果</p>
<ul>
<li>需要等待结果返回，才能继续运行就是同步</li>
<li>不需要等待结果返回，就能好继续运行就是异步</li>
</ul>
<p>注意：同步在多线程中还有另外一层意思，是让多个线程步调一致。</p>
<ol>
<li><p><strong>设计</strong></p>
<p>多线程可以让方法执行变为异步的比如读取磁盘文件时，假设读取操作花费了5秒钟，如果没有线程调度机制，这5秒调用者什么都做不了，其代码都得暂停…</p>
</li>
<li><p><strong>结论</strong></p>
<ul>
<li>比如在项目中，视频文件需要转换格式等操作比较费时，这时开一个新线程处理视频转换，避免阻塞主线程。</li>
<li>tomcat的异步servlet也是类似的，让用户线程处理耗时较长的操作，避免阻塞tomcat的工作线程。</li>
<li>ui程序中，开线程进行其他操作，避免阻塞ui线程。</li>
</ul>
</li>
</ol>
<p><strong>案例2：提高效率</strong></p>
<p>充分利用多核cpu的优势，提高运行效率。想象下面的场景，执行3个计算，最后将计算结果汇总。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">计算1 花费10ms</span><br><span class="line"></span><br><span class="line">计算2 花费11ms</span><br><span class="line"></span><br><span class="line">计算3 花费9ms</span><br><span class="line"></span><br><span class="line">汇总需要1ms</span><br></pre></td></tr></table></figure>

<ul>
<li><p>如果是串行执行，那么总共花费的时间是10ms+11ms+9ms+1ms&#x3D;31ms</p>
<ul>
<li>如果是四核cpu，各个核心分别使用线程1执行计算1，线程2执行计算2，线程3执行计算3，那么3个线程是并行的，花费时间只取决于最长的那个线程运行的时间，即11ms最后加上汇总时间只会花费12ms。</li>
</ul>
<p>注意：需要在多核cpu才能提高效率，单核仍然是轮流执行。</p>
<ol>
<li><p><strong>设计</strong></p>
<p>案例1</p>
</li>
<li><p><strong>结论</strong></p>
</li>
</ol>
<ul>
<li>单核cpu下，多线程不能实际提高程序运行效率，只是为了能够在不同的任务之间切换，不同线程轮流使用cpu，不至于一个线程总占用cpu，别的线程没法干活。</li>
<li>多核cpu可以并行跑多个线程，但能否提高程序运行效率还是要分情况的。</li>
<li>IO操作不占用cpu，只是我们一般拷贝文件使用的是【阻塞IO】，这时相当于线程虽然不用cpu，但需要一直等待IO结束，没能充分利用线程。所有才有后面的【非阻塞IO】和【异步IO】优化。</li>
</ul>
</li>
</ul>
<h3 id="2-Java线程"><a href="#2-Java线程" class="headerlink" title="2.Java线程"></a>2.Java线程</h3><h4 id="创建和运行线程"><a href="#创建和运行线程" class="headerlink" title="创建和运行线程"></a>创建和运行线程</h4><p><strong>方法一：直接使用Thread</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建线程对象</span></span><br><span class="line"><span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>()&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//要执行的任务</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//启动线程</span></span><br><span class="line">t.start();</span><br></pre></td></tr></table></figure>

<p>例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//构造方法的参数是给线程指定名字，推荐</span></span><br><span class="line"><span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="string">&quot;t1&quot;</span>)&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//要执行的任务</span></span><br><span class="line">        log.debug(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//启动线程</span></span><br><span class="line">t.start();</span><br></pre></td></tr></table></figure>

<p><strong>方法二：使用Runnable配合Thread</strong></p>
<p>把【线程】和【任务】分开</p>
<ul>
<li>Thread代表线程</li>
<li>Runnable代表可运行的任务（线程要执行的代码）</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Runnable</span> <span class="variable">runnable</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Runnable</span>()&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//要执行的任务</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//创建线程对象</span></span><br><span class="line"><span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(runnable);</span><br><span class="line"><span class="comment">//启动线程</span></span><br><span class="line">t.start();</span><br></pre></td></tr></table></figure>

<p>例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建任务对象</span></span><br><span class="line"><span class="type">Runnable</span> <span class="variable">task2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Runnable</span>()&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//要执行的任务</span></span><br><span class="line">        log.debug(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//创建线程对象</span></span><br><span class="line"><span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(task2,<span class="string">&quot;t2&quot;</span>);</span><br><span class="line"><span class="comment">//启动线程</span></span><br><span class="line">t.start();</span><br></pre></td></tr></table></figure>

<p>Java8以后可以使用lambda精简代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建任务对象</span></span><br><span class="line"><span class="type">Runnable</span> <span class="variable">task2</span> <span class="operator">=</span> ()-&gt;log.debug(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"><span class="comment">//参数1是任务对象；参数2是线程名字，推荐</span></span><br><span class="line"><span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(task2,<span class="string">&quot;t2&quot;</span>);</span><br><span class="line">t2.start();</span><br></pre></td></tr></table></figure>

<p>原理之Thread与Runnable的关系</p>
<p>分析Thread的源码，理清它与Runnable的关系</p>
<p><strong>小结</strong></p>
<ul>
<li>方法1是把线程和任务合并在了一起，方法2是把线程和任务分开了。</li>
<li>用Runnable更容易与线程池等高级API结合。</li>
<li>用Runnable让任务脱离了Thread继承体系，更灵活。</li>
</ul>
<p><strong>方法三：FutureTask配合Thread</strong></p>
<p>FutureTask能够接收Callable；类型的参数，用来处理有返回结果的情况。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建任务对象</span></span><br><span class="line">FutureTask&lt;Integer&gt; task3 = <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;&gt;(()-&gt;&#123;</span><br><span class="line">    log.debug(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">100</span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//参数1是任务对象；参数2是线程名字</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(task3,<span class="string">&quot;t3&quot;</span>).start();</span><br><span class="line"><span class="comment">//主线程阻塞，同步等待task执行完毕的结果</span></span><br><span class="line"><span class="type">Integer</span> <span class="variable">result</span> <span class="operator">=</span> task3.get();</span><br><span class="line">log.debug(<span class="string">&quot;结果是：&#123;&#125;&quot;</span>,result);</span><br></pre></td></tr></table></figure>

<h4 id="观察多个线程同时运行"><a href="#观察多个线程同时运行" class="headerlink" title="观察多个线程同时运行"></a>观察多个线程同时运行</h4><ul>
<li>交替执行</li>
<li>谁先谁后，不由我们控制</li>
</ul>
<h4 id="查看进程线程的方法"><a href="#查看进程线程的方法" class="headerlink" title="查看进程线程的方法"></a>查看进程线程的方法</h4><p><strong>Windows</strong></p>
<ul>
<li>任务管理器可以查看进程和线程数，也可以用来杀死进程</li>
<li>tasklist查看进程</li>
<li>taskkill杀死进程</li>
</ul>
<p><strong>Linux</strong></p>
<ul>
<li>ps -ef查看所有进程</li>
<li>ps -fT -p<PID>查看某个进程（PID）的所有线程</PID></li>
<li>kill杀死进程</li>
<li>top按大写H切换是否显示线程</li>
<li>top -H -p<PID>查看某个进程（PID）的所有线程</PID></li>
</ul>
<p><strong>Java</strong></p>
<ul>
<li>jps命令查看所有Java进程</li>
<li>jstack<PID>查看某个Java进程（PID）的所有线程状态</PID></li>
<li>jconsole来查看某个java进程中线程的运行情况（图形界面）</li>
</ul>
<h4 id="原理之线程运行"><a href="#原理之线程运行" class="headerlink" title="原理之线程运行"></a>原理之线程运行</h4><p><strong>栈与栈帧</strong></p>
<p>Java虚拟机栈</p>
<p>JVM中由堆、栈、方法区锁组成，其中栈内存是给谁用的？其实就是线程，每个线程启动后，虚拟机就会为其分配一块栈内存。</p>
<ul>
<li>每个栈由多个栈帧组成，对应着每次方法调用时所占的内存</li>
<li>每个线程只能有一个活动栈，对应着当前正在执行的那个方法</li>
</ul>
<p><strong>线程上下文切换</strong></p>
<p>因为以下一些原因导致cpu不在执行当前的线程，转而执行另一个线程的代码</p>
<ul>
<li>线程的cpu时间片用完</li>
<li>垃圾回收</li>
<li>有更高优先级的线程需要运行</li>
<li>线程自己调用了sleep、yield、wait、join、park、synchronized、lock等方法程序</li>
</ul>
<p>当Context Switch发生时，需要操作系统保存当前线程的状态，并恢复另一个线程的状态，java中对应的概念是程序计数器，它的作用是记住下一条jvm指令的执行地址，是线程私有的。</p>
<ul>
<li>状态包括程序计数器、虚拟机栈中每个栈帧的信息，如局部变量、操作数栈、返回地址等</li>
<li>Context Switch频繁发生会影响性能</li>
</ul>
<h4 id="常见方法"><a href="#常见方法" class="headerlink" title="常见方法"></a>常见方法</h4><p><img src="/../images/img44.PNG" alt="img44"></p>
<p><img src="/../images/img48.PNG" alt="img48"></p>
<h4 id="start与run"><a href="#start与run" class="headerlink" title="start与run"></a><strong>start与run</strong></h4><p>public static void main(String[] args){<br>    Thread t1 &#x3D; new Thread(){<br>        @Override<br>        public void run(){<br>            log.debug(Thread.currentThread().getName());<br>            FileReader.read(Constants.MP4_FULL_PATH);<br>        }<br>    };<br>}<br>    t1.run();<br>    log.debug(“do other things……”);</p>
<h4 id="sleep与yield"><a href="#sleep与yield" class="headerlink" title="sleep与yield"></a><strong>sleep与yield</strong></h4><p><strong>sleep</strong></p>
<ol>
<li>调用sleep会让当前线程从Running进入TimedWaiting状态。</li>
<li>其它线程可以使用interrupt方法打断正在睡眠的线程，这时sleep方法会抛出InterruptedException。</li>
<li>睡眠结束后的线程未必会立刻得到执行。</li>
<li>建议用TimeUnit的sleep代替Thread的sleep来获得更好的可读性。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="string">&quot;t1&quot;</span>)&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">            &#125;<span class="keyword">catch</span>(InterruptedException)&#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    t1.start();</span><br><span class="line">	log.debug(<span class="string">&quot;t1的状态:&#123;&#125;&quot;</span>+t1.getState());</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        Thread.sleep(<span class="number">500</span>);</span><br><span class="line">    &#125;<span class="keyword">catch</span>(InterruptException e)&#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    log.debug(<span class="string">&quot;t1的状态:&#123;&#125;&quot;</span>+t1.getState());	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>yield</strong></p>
<ol>
<li>调用yield会让当前线程从Running进入Runnable状态，然后调度执行其它同优先级的进程。如果这时没有同优先级的线程，那么不能保证让当前线程暂停的效果。</li>
<li>具体的实现依赖于操作系统的任务调度器。</li>
</ol>
<h5 id="线程优先级"><a href="#线程优先级" class="headerlink" title="线程优先级"></a><strong>线程优先级</strong></h5><ul>
<li>线程优先级会提示调度器优先调度该线程，但它仅仅是一个提示，调度器可以忽略它。</li>
<li>如果cpu比较忙，那么优先级高的线程会获得更多的时间片，但cpu闲时，优先级几乎没作用。</li>
</ul>
<p>不使用yield</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(Stirng[] args)</span>&#123;</span><br><span class="line">    <span class="type">Runnable</span> <span class="variable">task1</span> <span class="operator">=</span> ()-&gt;&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(;;)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;-----&gt;1&quot;</span> + count++);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="type">Runnable</span> <span class="variable">task2</span> <span class="operator">=</span> ()-&gt;&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(;;)&#123;</span><br><span class="line">            Thread.yield();</span><br><span class="line">            System.out.prinln(<span class="string">&quot;------&gt;2&quot;</span> + count++);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(task1,<span class="string">&quot;t1&quot;</span>);</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(task2,<span class="string">&quot;t2&quot;</span>);</span><br><span class="line">    t1.setPriority(Thread.MIN_PRIORITY);</span><br><span class="line">    t2.setPriority(Thread.MIN_PRIORITY);</span><br><span class="line">    t1.start();</span><br><span class="line">    t2.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="案例-防止CPU占用100"><a href="#案例-防止CPU占用100" class="headerlink" title="案例-防止CPU占用100%"></a><strong>案例-防止CPU占用100%</strong></h5><p><strong>sleep实现</strong></p>
<p>在没有利用cpu来计算时，不要让while（true）空转浪费cpu，这时可以使用yield或sleep来让出cpu的使用权给其它程序。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">	<span class="keyword">try</span>&#123;</span><br><span class="line">        Thread.sleep(<span class="number">50</span>);</span><br><span class="line">    &#125;<span class="keyword">catch</span>(InterruptedExcetion e)&#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>可以用wait或条件变量达到类似的结果</li>
<li>不同的是，后两种都需要加锁，并且需要相应的唤醒操作，一般使用于要进行同步的场景</li>
<li>sleep适用于无需锁同步的场景</li>
</ul>
<h4 id="join方法详解"><a href="#join方法详解" class="headerlink" title="join方法详解"></a><strong>join方法详解</strong></h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">    test1();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="title function_">test1</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException&#123;</span><br><span class="line">    log.debug(<span class="string">&quot;开始&quot;</span>);</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(&#123;</span><br><span class="line">        log.debug(<span class="string">&quot;开始&quot;</span>);</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">        log.debug(<span class="string">&quot;结束&quot;</span>);</span><br><span class="line">        r = <span class="number">10</span>;</span><br><span class="line">    &#125;,<span class="string">&quot;t1&quot;</span>);</span><br><span class="line">    t1.start();</span><br><span class="line">    t1.join();</span><br><span class="line">    log.debug(<span class="string">&quot;结果为：&#123;&#125;&quot;</span>,r);</span><br><span class="line">    log.debug(<span class="string">&quot;结束&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[main]-开始</span><br><span class="line">[t1]-开始</span><br><span class="line">[main]-结果为：0</span><br><span class="line">[main]-结束</span><br><span class="line">[t1]-结束</span><br></pre></td></tr></table></figure>

<p>分析：</p>
<ul>
<li>因为主线程和线程t1是并行执行的，t1线程需要1秒后才能计算出r&#x3D;10</li>
<li>而主线程一开始就要打印r的结果，所以只能打印出r&#x3D;0</li>
</ul>
<p>join方法加在start方法之后即可。</p>
<h6 id="应用之同步（案例1）"><a href="#应用之同步（案例1）" class="headerlink" title="应用之同步（案例1）"></a>应用之同步（案例1）</h6><p>以调用方角度来讲，如果</p>
<ul>
<li>需要等待结果返回，才能继续运行就是同步</li>
<li>不需要等待结果返回，就能继续运行就是异步</li>
</ul>
<p><img src="/../images/img45.PNG" alt="img45"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="type">int</span> <span class="variable">r1</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="type">int</span> <span class="variable">r2</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException&#123;</span><br><span class="line">    test2();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test3</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException&#123;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">        r1 = <span class="number">10</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">        sleep(<span class="number">2</span>);</span><br><span class="line">        r1 = <span class="number">20</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMills();</span><br><span class="line">    t1.start();</span><br><span class="line">    t2.start();</span><br><span class="line">    log.debug(<span class="string">&quot;join begin&quot;</span>);</span><br><span class="line">    t1.join();</span><br><span class="line">    log.debug(<span class="string">&quot;t1 join end&quot;</span>);</span><br><span class="line">    t2.join();</span><br><span class="line">    log.debug(<span class="string">&quot;t2 join end&quot;</span>);</span><br><span class="line">    <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMills();</span><br><span class="line">    log.debug(<span class="string">&quot;r1:&#123;&#125; r2:&#123;&#125; cost:&#123;&#125;&quot;</span>,r1,r2,end-start);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//因为线程是同步的，01开始t1和t2同时启动</span><br><span class="line">01--join begin</span><br><span class="line">02--t1 join end</span><br><span class="line">03--t2 join end</span><br><span class="line">04--r1::10 r2:20 cost:2002</span><br></pre></td></tr></table></figure>

<p><img src="/../images/img46.PNG" alt="img46"></p>
<h6 id="有时效的join"><a href="#有时效的join" class="headerlink" title="有时效的join"></a>有时效的join</h6><p>等够时间</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="type">int</span> <span class="variable">r1</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="type">int</span> <span class="variable">r2</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">    test3();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test3</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException&#123;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">        r1 = <span class="number">10</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMills();</span><br><span class="line">    t1.start();</span><br><span class="line">    <span class="comment">//线程执行结束会导致join结束</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMills();</span><br><span class="line">    log.debug(<span class="string">&quot;r1:&#123;&#125; r2:&#123;&#125; cost:&#123;&#125;&quot;</span>,r1,r2,end-start);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">r1:10 r2:0 cost:1010</span><br></pre></td></tr></table></figure>

<h4 id="interrupt方法详解"><a href="#interrupt方法详解" class="headerlink" title="interrupt方法详解"></a>interrupt方法详解</h4><p><strong>打断sleep，wait，join的线程</strong></p>
<p>阻塞</p>
<p>打断sleep的线程，会清空打断状态，以sleep为例</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException&#123;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;,<span class="string">&quot;t1&quot;</span>);</span><br><span class="line">    t1.start();</span><br><span class="line">    </span><br><span class="line">    sleep(<span class="number">0.5</span>);</span><br><span class="line">    t1.interrupt();</span><br><span class="line">    log.debug(<span class="string">&quot;打断状态：&#123;&#125;&quot;</span>,t1.isInterrupted());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="设计模式之两阶段终止–interrupt"><a href="#设计模式之两阶段终止–interrupt" class="headerlink" title="设计模式之两阶段终止–interrupt"></a>设计模式之两阶段终止–interrupt</h5><p>Two Phase Termination</p>
<p>在一个线程T1如何优雅终止线程T2？</p>
<p><strong>错误思路</strong></p>
<ul>
<li><p>使用线程对象的stop()方法停止线程</p>
<p>stop方法会真正杀死线程，如果这时线程锁住了共享资源，那么当它被杀死后就再也没有机会释放锁，其它线程将永远无法获取锁。</p>
</li>
<li><p>使用System.exit(init)方法停止线程</p>
<p>目的仅是停止一个线程，但这种做法会让整个程序都停止。</p>
</li>
</ul>
<h5 id="设计模式之两阶段终止–interrupt-分析"><a href="#设计模式之两阶段终止–interrupt-分析" class="headerlink" title="设计模式之两阶段终止–interrupt-分析"></a>设计模式之两阶段终止–interrupt-分析</h5><p><img src="/../images/img47.PNG" alt="img47"></p>
<h5 id="设计模式之两阶段终止–interrupt-实现"><a href="#设计模式之两阶段终止–interrupt-实现" class="headerlink" title="设计模式之两阶段终止–interrupt-实现"></a>设计模式之两阶段终止–interrupt-实现</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">TwoPhaseTermination</span> <span class="variable">tpt</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TwoPhaseTermination</span>();</span><br><span class="line">        tpt.start();</span><br><span class="line">        </span><br><span class="line">        Thread.sleep(<span class="number">3500</span>);</span><br><span class="line">        tpt.stop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TwoPhaseTermination</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Thread monitor;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//启动监控线程</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span>&#123;</span><br><span class="line">        monitor = <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">                <span class="type">Thread</span> <span class="variable">current</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">                <span class="keyword">if</span>(current.isInterrupted())&#123;</span><br><span class="line">                    log.debug(<span class="string">&quot;料理后事&quot;</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">try</span>&#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);<span class="comment">//情况1</span></span><br><span class="line">                    log.debug(<span class="string">&quot;执行监控记录&quot;</span>);<span class="comment">//情况2	</span></span><br><span class="line">                &#125;<span class="keyword">catch</span>(InterrputedException e)&#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                    <span class="comment">//重新设置打断标记		</span></span><br><span class="line">                    current.interrupt();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        monitor.start();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//停止监控线程</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">stop</span><span class="params">()</span>&#123;</span><br><span class="line">        monitor.interrupt();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="打断park线程"><a href="#打断park线程" class="headerlink" title="打断park线程"></a>打断park线程</h5><p>打断park线程，不会清空打断状态</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test3</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException&#123;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">        log.debug(<span class="string">&quot;park....&quot;</span>);</span><br><span class="line">        LockSupport.park();</span><br><span class="line">        log.debug(<span class="string">&quot;unpark....&quot;</span>);</span><br><span class="line">        log.debug(<span class="string">&quot;打断状态：&#123;&#125;&quot;</span>,Thread.currentThread().isInterrupted());</span><br><span class="line">    &#125;,<span class="string">&quot;t1&quot;</span>);</span><br><span class="line">    t1.start();</span><br><span class="line">    </span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line">    t1.interrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果打断标记已经是true，则park会失效。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">log.debug(<span class="string">&quot;打断状态：&#123;&#125;&quot;</span>,Thread.currentThread().isInterrupted());</span><br></pre></td></tr></table></figure>

<h4 id="不推荐的方法"><a href="#不推荐的方法" class="headerlink" title="不推荐的方法"></a>不推荐的方法</h4><p>还有一些不推荐的方法，这些方法已经过时，容易破坏同步代码块，造成线程死锁。</p>
<table>
<thead>
<tr>
<th align="center">方法名</th>
<th align="center">static</th>
<th align="center">功能说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">stop()</td>
<td align="center"></td>
<td align="center">停止线程运行</td>
</tr>
<tr>
<td align="center">suspend()</td>
<td align="center"></td>
<td align="center">挂起（暂停）线程运行</td>
</tr>
<tr>
<td align="center">resume()</td>
<td align="center"></td>
<td align="center">恢复线程运行</td>
</tr>
</tbody></table>
<h4 id="守护线程"><a href="#守护线程" class="headerlink" title="守护线程"></a>守护线程</h4><p>默认情况下，java进程需要等待所有线程运行结束，才会结束。有一种特殊的线程叫守护线程，只要其它非守护线程运行结束了，即使守护线程的代码没有执行完，也会强制结束。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(Thread.currentThread().isInterrupted())&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        log.debug(<span class="string">&quot;结束&quot;</span>);</span><br><span class="line">    &#125;,<span class="string">&quot;t1&quot;</span>);</span><br><span class="line">    t1.setDaemon(<span class="literal">true</span>);<span class="comment">//守护线程</span></span><br><span class="line">    t1.start();</span><br><span class="line">    </span><br><span class="line">    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">    log.debug(<span class="string">&quot;结果&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">log.debug(<span class="string">&quot;开始运行...&quot;</span>);</span><br><span class="line"><span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">    log.debug(<span class="string">&quot;开始运行...&quot;</span>);</span><br><span class="line">    sleep(<span class="number">2</span>);</span><br><span class="line">    log.debug(<span class="string">&quot;运行结束...&quot;</span>);</span><br><span class="line">&#125;,<span class="string">&quot;daemon&quot;</span>);</span><br><span class="line"><span class="comment">//设置该线程为守护线程</span></span><br><span class="line">t1.setDaemon(<span class="literal">true</span>);</span><br><span class="line">t1.start();</span><br><span class="line"></span><br><span class="line">sleep(<span class="number">1</span>);</span><br><span class="line">log.debug(<span class="string">&quot;运行结束...&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[main]-开始运行</span><br><span class="line">[daemon]-开始运行</span><br><span class="line">[main]-运行结束</span><br></pre></td></tr></table></figure>

<p>注意：</p>
<ul>
<li>垃圾回收器线程就是一种守护线程</li>
<li>Tomcat中的Acceptor和Poller线程都是守护线程，所以Tomcat接收到shutdown命令后，不会等待它们处理完当前请求。</li>
</ul>
<h4 id="五种状态"><a href="#五种状态" class="headerlink" title="五种状态"></a>五种状态</h4><p><strong>从操作系统层面描述</strong></p>
<p><img src="/../images/img49.PNG" alt="img49"></p>
<ul>
<li><p>【初始状态】仅是在语言层面创建了线程对象，还未与操作系统线程关联。</p>
</li>
<li><p>【可运行状态】（就绪状态）指该线程已经被创建（与操作系统线程关联），可以由CPU调度执行。</p>
</li>
<li><p>【运行状态】指获取了CPU时间片运行中的状态。</p>
<p>当CPU时间片用完，会从【运行状态】转换至【可运行状态】，会导致线程的上下文切换。</p>
</li>
<li><p>【阻塞状态】</p>
<ul>
<li>如果调用了阻塞API，如BIO读写文件，这时该线程实际不会用到CPU，会导致线程上下文切换，进入【阻塞状态】。</li>
<li>等BIO操作完毕，会由操作系统唤醒阻塞的线程，转换至【可运行状态】。</li>
<li>与【可运行状态】的区别是，对【阻塞状态】的线程来说只要它们一直不唤醒，调度器就一直不会考虑调度它们。</li>
</ul>
</li>
<li><p>【终止状态】表示线程已经执行完毕，生命周期已经结束，不会再转换为其它状态。</p>
</li>
</ul>
<p><strong>从Java API层面描述</strong></p>
<p>根据Thread.State枚举，分为六种状态</p>
<p><img src="/../images/img50.PNG" alt="img50"></p>
<ul>
<li>NEW线程刚被创建，但是还没有调用start()方法</li>
<li>RUNNABLE当调用了start()方法之后，Java API层面的RUNNABLE状态涵盖了操作系统层面的【可运行状态】、【运行状态】和【阻塞状态】（由于BIO导致的线程阻塞，在Java里无法区分，仍然认为是可行的）</li>
<li>BLOCKED、WAITING、TIME_WAITING都是Java API层面对【阻塞状态】的细分。</li>
<li>TERMINATED当线程代码运行结束</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestState</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="string">&quot;t1&quot;</span>)&#123;</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">                log.debug(<span class="string">&quot;running....&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        </span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="string">&quot;t2&quot;</span>)&#123;</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">                <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">                    </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        t2.start();</span><br><span class="line">        </span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="string">&quot;t3&quot;</span>)&#123;</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">                log.debug(<span class="string">&quot;running....&quot;</span>);</span><br><span class="line">            &#125; </span><br><span class="line">        &#125;;</span><br><span class="line">        t3.start();</span><br><span class="line">        </span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="string">&quot;t4&quot;</span>)&#123;</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">                <span class="keyword">synchronized</span>(TestState.class)&#123;</span><br><span class="line">                    <span class="keyword">try</span>&#123;</span><br><span class="line">                        Thread.sleep(<span class="number">1000000</span>);</span><br><span class="line">                    &#125;<span class="keyword">catch</span>(InterruptedException e)&#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        t4.start();</span><br><span class="line">        </span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t5</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="string">&quot;t5&quot;</span>)&#123;</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">                <span class="keyword">try</span>&#123;</span><br><span class="line">                    t2.join();</span><br><span class="line">                &#125;<span class="keyword">catch</span>(InterruptedException e)&#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        t5.start();</span><br><span class="line">        </span><br><span class="line">         <span class="type">Thread</span> <span class="variable">t6</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="string">&quot;t6&quot;</span>)&#123;</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">                <span class="keyword">synchronized</span>(TestState.class)&#123;</span><br><span class="line">                	<span class="keyword">try</span>&#123;</span><br><span class="line">                    	Thread.sleep(<span class="number">1000000</span>);</span><br><span class="line">                	&#125;<span class="keyword">catch</span>(InterruptedException e)&#123;</span><br><span class="line">                   		e.printStackTrace();</span><br><span class="line">                	&#125;</span><br><span class="line">              	&#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        t6.start();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            Thread.sleep(<span class="number">500</span>);</span><br><span class="line">        &#125;<span class="keyword">catch</span>(InterruptedException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        log.debug(<span class="string">&quot;t1 state()&quot;</span>,t1.getState());</span><br><span class="line">        log.debug(<span class="string">&quot;t2 state()&quot;</span>,t2.getState());</span><br><span class="line">        log.debug(<span class="string">&quot;t3 state()&quot;</span>,t3.getState());</span><br><span class="line">        log.debug(<span class="string">&quot;t4 state()&quot;</span>,t4.getState());</span><br><span class="line">        log.debug(<span class="string">&quot;t5 state()&quot;</span>,t5.getState());</span><br><span class="line">        log.debug(<span class="string">&quot;t6 state()&quot;</span>,t6.getState());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="案例-应用之统筹（烧水泡茶）"><a href="#案例-应用之统筹（烧水泡茶）" class="headerlink" title="案例-应用之统筹（烧水泡茶）"></a>案例-应用之统筹（烧水泡茶）</h4><p><img src="/../images/img51.PNG" alt="img51"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            log.debug(<span class="string">&quot;洗水壶&quot;</span>);</span><br><span class="line">            sleep(<span class="number">1</span>);</span><br><span class="line">            log.debug(<span class="string">&quot;烧开水&quot;</span>);</span><br><span class="line">            sleep(<span class="number">5</span>);</span><br><span class="line">        &#125;,<span class="string">&quot;老王&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            log.debug(<span class="string">&quot;洗茶壶&quot;</span>);</span><br><span class="line">            sleep(<span class="number">1</span>);</span><br><span class="line">            log.debug(<span class="string">&quot;洗茶杯&quot;</span>);</span><br><span class="line">            sleep(<span class="number">2</span>);</span><br><span class="line">            log.debug(<span class="string">&quot;拿茶叶&quot;</span>);</span><br><span class="line">            sleep(<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                t1.join</span><br><span class="line">            &#125;<span class="keyword">catch</span>(InterruptedException e)&#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;小王&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>多线程与高并发</category>
      </categories>
      <tags>
        <tag>多线程与高并发</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis常见面试题（一）</title>
    <url>/2022/03/09/Redis%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
    <content><![CDATA[<h3 id="Redis-常见面试题（一）"><a href="#Redis-常见面试题（一）" class="headerlink" title="Redis-常见面试题（一）"></a>Redis-常见面试题（一）</h3><span id="more"></span>

<h3 id="1、什么是Redis？（Remote-Dictionary-Server）"><a href="#1、什么是Redis？（Remote-Dictionary-Server）" class="headerlink" title="1、什么是Redis？（Remote Dictionary Server）"></a>1、什么是Redis？（Remote Dictionary Server）</h3><p>Redis是一个使用C语言编写的，开源的高性能非关系型（NoSQL）的key-value数据库。</p>
<p>Redis可以存储键和五种不同类型的值之间的映射。键的类型只能是字符串，值支持五种数据类型：字符串、列表、集合、散列表、有序集合。</p>
<p>与传统数据库不同的是：</p>
<p>（1）Redis的数据是存储在内存中的，所以读写速度非常快。因此Redis被广泛应用于缓存方向，每秒可以处理超过10万次读写操作，是已知最快的key-value数据库。</p>
<p>（2）另外，Redis也经常用来做分布式锁。</p>
<p>（3）除此之外，Redis支持事务、持久化、LUA脚本、LRU驱动事件、多种集群方案。</p>
<hr>
<h3 id="2、Redis有哪些优缺点？"><a href="#2、Redis有哪些优缺点？" class="headerlink" title="2、Redis有哪些优缺点？"></a>2、Redis有哪些优缺点？</h3><p>优点</p>
<ul>
<li>读写性能优异，Redis读的速度是110000次&#x2F;s，写的速度是81000&#x2F;s。</li>
<li>支持数据持久化，支持AOF和RDB两种持久化方式。</li>
<li>支持事务，Redis的所有操作都是原子性的，同时Redis还支持对几个操作合并后的原子性执行。</li>
<li>数据结构丰富，除了支持string类型的value，还支持hash、set、zset、list等数据结构。</li>
<li>支持主从复制，主机会自动将数据同步到从机，可以进行读写分离。</li>
</ul>
<p>缺点</p>
<ul>
<li><p>数据库容量受到物理内存的限制，不能用作海量数据的高性能读写，因此Redis适合的场景主要局限在较小数据量的高性能操作和运算上。</p>
</li>
<li><p>Redis不具备自动容错和恢复功能，主机从机的宕机都会导致前端部分读写请求失败，需要等待机器重启或手动切换前端的ip才能恢复。</p>
</li>
<li><p>主机宕机，宕机前有部分数据未能同步到从机，切换ip后还会引入数据不一致问题，降低了系统的可用性。</p>
</li>
<li><p>Redi较难支持在线扩容，在集群容量达到上限时，在线扩容会变得很复杂。为避免这一问题，运维人员在系统上线时必须确保有足够的空间，这对资源造成很大的浪费。</p>
</li>
</ul>
<hr>
<h3 id="3、为什么要用Redis-x2F-为什么要用缓存？"><a href="#3、为什么要用Redis-x2F-为什么要用缓存？" class="headerlink" title="3、为什么要用Redis&#x2F;为什么要用缓存？"></a>3、为什么要用Redis&#x2F;为什么要用缓存？</h3><p>主要从”高性能”和”高并发”两点来看待这个问题。</p>
<h4 id="高性能"><a href="#高性能" class="headerlink" title="高性能"></a>高性能</h4><p>加入用户第一次访问数据库的某些数据，这个过程会比较慢，因为是从硬盘上读取的。将该用户访问的数据存在缓存中，这样下一次访问这些数据的时候就可以直接从缓存中获取。操作缓存就是直接操作内存，所以速度很快。如果数据库中对应的数据改变后，同步改变缓存中相应的数据即可。</p>
<p><img src="/../images/11.png" alt="11"></p>
<h4 id="高并发"><a href="#高并发" class="headerlink" title="高并发"></a>高并发</h4><p>直接操作缓存能够承受的请求是远远大于直接访问数据库的，所以我们可以考虑把数据库中的部分数据转移到缓存中去，这样用户的一部分请求会直接到缓存这里而不经过数据库。</p>
<p><img src="/../images/12.png" alt="12"></p>
<hr>
<h3 id="4、为什么要用Redis而不用map-x2F-guava做缓存？"><a href="#4、为什么要用Redis而不用map-x2F-guava做缓存？" class="headerlink" title="4、为什么要用Redis而不用map&#x2F;guava做缓存？"></a>4、为什么要用Redis而不用map&#x2F;guava做缓存？</h3><p>缓存分为本地缓存和分布式缓存。以JAVA为例，使用自带的map或者guava实现的是本地缓存，最主要的特点是轻量以及快速，生命周期随着JVM的销毁而结束，并且在多实例的情况下，每个实例都需要各自保存一份缓存，缓存不具有一致性。</p>
<p>使用Redis或者memcached之类的称为分布式缓存，在多实例的情况下，各实例公用一份缓存数据，缓存具有一致性。缺点就是需要保持redis或memcached服务的高可用，整个程序架构上较为复杂。</p>
<hr>
<h3 id="5、Redis为什么这么快？"><a href="#5、Redis为什么这么快？" class="headerlink" title="5、Redis为什么这么快？"></a>5、Redis为什么这么快？</h3><ol>
<li><p>完全基于内存，绝大部分请求是纯粹的内存操作，非常快速。数据存在内存中，类似于HashMap，HashMap的优势就是查找和操作的时间复杂度都是O（1）。</p>
</li>
<li><p>数据结构简单，对数据操作也简单，Redis中的数据结构是专门进行设计的。</p>
</li>
<li><p>采用单线程，避免了不必要的上下文切换和竞争条件，也不存在多进程和多线程导致的切换而消耗CPU，不用去考虑各种锁的问题，不存在加锁释放锁的操作，没有因为出现死锁而导致的性能消耗。</p>
</li>
<li><p>使用多路复用I&#x2F;O模型，非阻塞IO。</p>
</li>
<li><p>使用底层模型不同，它们之间底层实现方式以及与客户端之间通信的应用协议不一样，Redis直接自己构建了VM机制，因为一般的系统调用系统函数的话，会浪费一定的时间去移动和请求。</p>
</li>
</ol>
<hr>
<h3 id="6、Redis常见的数据类型"><a href="#6、Redis常见的数据类型" class="headerlink" title="6、Redis常见的数据类型"></a>6、Redis常见的数据类型</h3><p>Redis主要有5种数据类型，包括String，List，Set，Zset，Hash。</p>
<table>
<thead>
<tr>
<th align="center">数据类型</th>
<th align="center">可存储的值</th>
<th align="center">操作</th>
<th align="center">应用场景</th>
</tr>
</thead>
<tbody><tr>
<td align="center">String</td>
<td align="center">字符串、整数或者浮点数</td>
<td align="center">对整个字符串或者字符串的其中一部分执行操作</td>
<td align="center">做简单的键值对缓存</td>
</tr>
<tr>
<td align="center">List</td>
<td align="center">列表</td>
<td align="center">从两端压入或者弹出元素，对单个或者多个元素进行修剪，只保留一个范围内的元素</td>
<td align="center">存储一些列表型的数据结构，类似粉丝列表、文章的评论列表之类的数据</td>
</tr>
<tr>
<td align="center">Set</td>
<td align="center">无序集合</td>
<td align="center">添加、获取、移除单个元素，检查一个元素是否存在于集合中，计算交集、并集、差集，从集合里面随机获取元素</td>
<td align="center">交集，并集，差集的操作，比如交集，可以把两个人的粉丝列表整一个交集</td>
</tr>
<tr>
<td align="center">Hash</td>
<td align="center">包含键值对的无序散列表</td>
<td align="center">添加、获取、移除单个键值对，获取所有键值对，检查某个键是否存在</td>
<td align="center">结构化的数据，比如一个对象</td>
</tr>
<tr>
<td align="center">Zset</td>
<td align="center">有序集合</td>
<td align="center">添加、获取、删除元素，根据分值范围或者成员来获取元素，计算一个键的排名</td>
<td align="center">去重但可以排序，如获取排名前几名的用户</td>
</tr>
</tbody></table>
<hr>
<h3 id="7、Redis的应用场景"><a href="#7、Redis的应用场景" class="headerlink" title="7、Redis的应用场景"></a>7、Redis的应用场景</h3><ol>
<li><p>缓存</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">String类型</span><br></pre></td></tr></table></figure>

<ul>
<li>例如：热点数据缓存（报表、明星出轨）、对象缓存、全页缓存、可以提升热点数据的访问数据。</li>
</ul>
</li>
<li><p>数据共享分布式</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">String类型，因为Redis是分布式的独立服务，可以在多个应用之间共享</span><br></pre></td></tr></table></figure>

<ul>
<li><p>例如：分布式session</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span> </span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.session<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span> </span><br><span class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-session-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>分布式锁</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">String类型setnx方法，只有不存在时才能添加成功，返回true</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">getLock</span><span class="params">(String key)</span> &#123;</span><br><span class="line">    <span class="type">Long</span> <span class="variable">flag</span> <span class="operator">=</span> jedis.setnx(key, <span class="string">&quot;1&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (flag == <span class="number">1</span>) &#123;</span><br><span class="line">        jedis.expire(key, <span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">return</span> <span class="variable">flag</span> <span class="operator">=</span>= <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">releaseLock</span><span class="params">(String key)</span> &#123;</span><br><span class="line">    jedis.del(key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>全局ID</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">incrby userid <span class="number">1000</span>  #<span class="type">int</span>类型，incrby，利用原子性</span><br></pre></td></tr></table></figure>
</li>
<li><p>计数器</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int类型，incr方法</span><br></pre></td></tr></table></figure>

<p>例如：文章的阅读量、微博点赞数、允许一定的延迟，先写入Redis再定时同步到数据库</p>
</li>
<li><p>限流</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int类型。incr方法</span><br></pre></td></tr></table></figure>

<p>以访问者的ip和其他信息作为key，访问一次增加一次计数，超过次数则返回false</p>
</li>
<li><p>位统计</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">String类型的bitcount</span><br><span class="line">字符是以8位二进制存储的</span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set</span> k1 a</span><br><span class="line">setbit k1 <span class="number">6</span> <span class="number">1</span></span><br><span class="line">setbit k1 <span class="number">7</span> <span class="number">0</span></span><br><span class="line"><span class="keyword">get</span> k1 </span><br><span class="line"><span class="comment">/* 6 7 代表的a的二进制位的修改</span></span><br><span class="line"><span class="comment">a 对应的ASCII码是97，转换为二进制数据是01100001</span></span><br><span class="line"><span class="comment">b 对应的ASCII码是98，转换为二进制数据是01100010</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">因为bit非常节省空间（1 MB=8388608 bit），可以用来做大数据量的统计。</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>例如：在线用户统计、留存用户统计</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">setbit onlineusers <span class="number">01</span> </span><br><span class="line">setbit onlineusers <span class="number">11</span> </span><br><span class="line">setbit onlineusers <span class="number">20</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>购物车</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">String或hash。所有String可以做的hash都可以做</span><br></pre></td></tr></table></figure>

<p><img src="/../images/13.png" alt="13"></p>
<p>key：用户id；</p>
<p>filed：商品id；</p>
<p>value：商品数量；</p>
<p>+1：hincr；</p>
<p>-1：hdecr；</p>
<p>全选：hgetall；</p>
<p>商品数：hlen。</p>
</li>
<li><p>用户消息时间线</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">list，双向链表，直接作为timeline。插入有序。</span><br></pre></td></tr></table></figure>
</li>
<li><p>消息队列</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">List提供了两个阻塞的弹出操作：blpop/brpop 可以设置超时时间</span><br></pre></td></tr></table></figure>

<p>blpop：blpop key1 timeout 移除并获取列表的第一个元素，如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止。</p>
<p>brpop：brpop key1 timeout 移除并获取列表的最后一个元素，如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止。</p>
<p>上面的操作。其实就是java的阻塞队列。学习的东西越多。学习成本越低</p>
<p>队列：先进先除：rpush blpop，左头右尾，右边进入队列，左边出队列</p>
<p>栈：先进后出：rpush brpop</p>
</li>
<li><p>抽奖</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">spop myset	#自带一个随机获得值</span><br></pre></td></tr></table></figure>
</li>
<li><p>点赞、签到、打卡</p>
<p><img src="/../images/14.png" alt="14"></p>
<ul>
<li>假如上面微博id是t1001，用户id是u3001</li>
<li>用like：t1001来维护t1001这条微博的所有点赞用户</li>
<li>点赞了这条微博：sadd like：t1001 u3001</li>
<li>取消点赞：srem like :t1001 u3001</li>
<li>是否点赞：sismember like：t1001 u3001</li>
<li>点赞的所有用户：smembers like：t1001</li>
<li>点赞数：scard like：t1001</li>
</ul>
</li>
<li><p>商品标签</p>
<p><img src="/../images/15.png" alt="15"></p>
<p>用tags：i5001来维护商品的所有标签。</p>
<ul>
<li>sadd tags：i5001 画面清晰细腻</li>
<li>sadd tags：i5001 真彩清晰显示屏</li>
<li>sadd tags：i5001 流程至极</li>
</ul>
</li>
<li><p>商品筛选</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="operator">/</span><span class="operator">/</span> 获取差集</span><br><span class="line">sdiff set1 set2</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span> 获取交集（<span class="keyword">intersection</span> ）</span><br><span class="line">sinter set1 set2</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span> 获取并集</span><br><span class="line">sunion set1 set2</span><br></pre></td></tr></table></figure>

<p>假如：iphone 11上市</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">sadd brand:apple iPhone11</span><br><span class="line"></span><br><span class="line">sadd brand:ios iPhone11</span><br><span class="line"></span><br><span class="line">sad screensize:<span class="number">6.0</span><span class="number">-6.24</span> iPhone11</span><br><span class="line"></span><br><span class="line">sad screentype:lcd iPhone <span class="number">11</span></span><br><span class="line"></span><br><span class="line">#筛选商品，苹果的、ios的、屏幕在<span class="number">6.0</span><span class="number">-6.24</span>之间的，屏幕材质是LCD屏幕</span><br><span class="line">sinter brand:apple brand:ios screensize:<span class="number">6.0</span><span class="number">-6.24</span> screentype:lcd</span><br></pre></td></tr></table></figure>
</li>
<li><p>用户关注、推荐模型</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">follow 关注 fans 粉丝</span><br></pre></td></tr></table></figure>

<ul>
<li>相互关注：<ul>
<li>sadd 1：follow 2</li>
<li>sadd 2：fans 1</li>
<li>sadd 1：fans 2</li>
<li>sadd 2：follow 1</li>
</ul>
</li>
<li>我关注的人也关注了他：<ul>
<li>sinter：follow 2：fans</li>
</ul>
</li>
<li>可能认识的人：<ul>
<li>用户1可能认识的人（差集）：sdiff 2：follow 1：follow</li>
<li>用户2可能认识的人（差集）：sdiff 1：follow 2：follow</li>
</ul>
</li>
</ul>
</li>
<li><p>排行榜</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">zincrby hotNews	：20190926 1 n6001	#id为6001的新闻点击数加1</span><br><span class="line">zrevrange hotNews:20190926 0 15 withscores	#获取今天点击最多的15条</span><br></pre></td></tr></table></figure></li>
</ol>
<hr>
<h3 id="8、Redis持久化（RDB和AOF）"><a href="#8、Redis持久化（RDB和AOF）" class="headerlink" title="8、Redis持久化（RDB和AOF）"></a>8、Redis持久化（RDB和AOF）</h3><p>持久化就是把内存的数据写到磁盘中去，防止服务宕机了内存数据丢失。</p>
<p>各自的优缺点：</p>
<h4 id="RDB：Redis-DataBase"><a href="#RDB：Redis-DataBase" class="headerlink" title="RDB：Redis DataBase"></a>RDB：Redis DataBase</h4><p>RDB是redis默认的持久化方式。按照一定的时间将内存的数据以快照的形式保存在硬盘中，对应产生的数据文件dump.rdb。通过配置文件中的save参数来定义快照的周期。</p>
<p><img src="/../images/16.png" alt="16"></p>
<p>优点：</p>
<ul>
<li>只有一个文件dump.rdb，方便持久化。</li>
<li>容灾性好，一个文件可以保存到安全的磁盘。</li>
<li>性能最大化，fork子进程来完成写操作，让主进程继续处理命令，所以是IO最大化。使用单独子进程来进行持久化，主进程不会进行任何IO操作，保证了reds的高性能。</li>
<li>相对于数据集大时，比AOF的启动效率更高。</li>
</ul>
<p>缺点：</p>
<ul>
<li>数据安全性低。RDB是间隔一段时间进行持久化，如果持久化之间redis发生故障，会发生数据丢失。所以这种方式更适合数据要求不严谨的时候。</li>
<li>AOF（appendonly file）持久化方式：是指所有的命令行记录以redis命令请求协议的格式完全持久化存储为aof文件。</li>
</ul>
<h4 id="AOF：持久化"><a href="#AOF：持久化" class="headerlink" title="AOF：持久化"></a>AOF：持久化</h4><p>AOF持久化，则是将Redis执行的每次写命令记录到单独的日志中，当重启Redis会重新将持久化日志中的文件恢复数据。当两种方式同时开启时，数据恢复Redis会优先选择AOF恢复。</p>
<p><img src="/../images/17.png" alt="17"></p>
<p>优点：</p>
<ul>
<li>数据安全，aof持久化可以配置appendsync属性，有always，每次进行命令操作就记录到aof文件中一次。</li>
<li>通过append模式写文件，即使中途服务器宕机，也可以通过redis-check-aof工具解决数据一致性问题。</li>
<li>AOF机制的rewrite模式。AOF文件没被rewrite之前，可以删除其中的某些命令。</li>
</ul>
<p>缺点：</p>
<ul>
<li>AOF文件比RDB文件大，恢复速度慢。</li>
<li>数据集大的时候，比rdb启动效率低。</li>
</ul>
<p>区别：</p>
<ul>
<li>AOF文件比RDB文件更新频率高，优先使用AOF还原数据。</li>
<li>AOF比RDB更安全也更大。</li>
<li>RDB性能比AOF好。</li>
<li>如果两个都配了优先加载AOF。</li>
</ul>
<h4 id="如何选择合适的持久化方式？"><a href="#如何选择合适的持久化方式？" class="headerlink" title="如何选择合适的持久化方式？"></a>如何选择合适的持久化方式？</h4><ul>
<li>一般来说，如果想达到足以媲美PostgreSQL的数据安全性，应该同时使用两种持久化功能。在这种情况下，当redis重启的时候，会优先载入AOF文件来恢复原始的数据，因为在通常情况下，AOF文件保存的数据集要比RDB文件保存的数据集要完整。</li>
<li>如果你非常关心你的数据，但仍然可以承受数分钟以内数据的丢失，那么你可以使用RDB持久化。</li>
<li>有很多用户只使用AOF持久化，但并不推荐这种方式，因为定时生成RDB快照（snopshot）非常便于进行数据库备份，并且RDB恢复数据集的速度也要比AOF恢复的速度要快，除此之外，使用RDB还可以避免AOF程序的bug。</li>
<li>如果你只希望你的数据在服务器运行的时候存在，你也可以不适用任何持久化方式。</li>
</ul>
<h4 id="Redis持久化数据和缓存怎么扩容？"><a href="#Redis持久化数据和缓存怎么扩容？" class="headerlink" title="Redis持久化数据和缓存怎么扩容？"></a>Redis持久化数据和缓存怎么扩容？</h4><ul>
<li>如果Redis被当做缓存使用，使用一致性哈希实现动态扩容缩容。</li>
<li>如果Redis被当做一个持久化存储使用，必须使用固定的keys-to-nodes映射关系，节点的数量一旦确定不能变化，否则的话（即redis节点需要动态变化的情况），必须使用可以在运行时进行数据再平衡的一套系统，而当前只有redis集群可以做到这样。</li>
</ul>
<hr>
<h3 id="9、Redis过期键的删除策略"><a href="#9、Redis过期键的删除策略" class="headerlink" title="9、Redis过期键的删除策略"></a>9、Redis过期键的删除策略</h3><p>过期策略通常有一下三种：</p>
<ul>
<li>定时过期：每个设置过期时间的key都需要创建一个定时器，到过期时间就会立即删除。该策略可以立即清除过期的数据，对内存很友好；但是会占用大量的CPU资源去处理过期的数据，从而影响缓存的相应时间和吞吐量。</li>
<li>惰性过期：只有当访问一个key时，才会判断该key是否已经过期，过期则清除。该策略可以最大化地节省CPU资源，却对内存很不友好。极端情况可能出现大量的过期key没有再次被访问，从而不会被清除，占用大量内存。</li>
</ul>
<p><img src="/../images/18.png" alt="18"></p>
<ul>
<li><p>定期过期：activeExpireCycle函数实现。每隔一段时间，会扫描一定数量的数据库的expires字典中一定数量的key，并清除其中已经过期的key。该策略是前两者的一个折中方案。通过调整定时扫描的时间间隔和每次扫描的限定耗时，可以在不同情况下使得CPU和内存资源达到最优的平衡效果。</p>
<p>（expires字典会保存所有设置了过期时间的key的过期时间数据，其中，key是指向键空间中的某个键的指针，value是改键的毫秒精度的UNIX时间戳的过期时间。键空间是指该Redis集群中保存的所有键。）</p>
</li>
</ul>
<p>Redis中同时使用了惰性过期和定期过期策略。</p>
<h4 id="Redis-key的过期时间和永久有效分别怎么设置？"><a href="#Redis-key的过期时间和永久有效分别怎么设置？" class="headerlink" title="Redis key的过期时间和永久有效分别怎么设置？"></a>Redis key的过期时间和永久有效分别怎么设置？</h4><p>EXPIRE和PERSIST命令。</p>
<h4 id="我们知道通过expire来设置key-的过期时间，那么对过期的数据怎么处理呢"><a href="#我们知道通过expire来设置key-的过期时间，那么对过期的数据怎么处理呢" class="headerlink" title="我们知道通过expire来设置key 的过期时间，那么对过期的数据怎么处理呢?"></a>我们知道通过expire来设置key 的过期时间，那么对过期的数据怎么处理呢?</h4><p>除了缓存服务器自带的缓存失效策略之外，我们还可以根据具体的业务需求进行自定义缓存淘汰，常见的策略有两种：</p>
<ul>
<li>定时去清理过期的缓存；</li>
<li>当有用户请求过来时，再判断这个请求所用到的缓存是否过期，过期的话就去底层系统得到新数据并更新缓存。</li>
</ul>
<hr>
<p>​    </p>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis常见面试题（三）</title>
    <url>/2022/03/11/Redis%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%88%E4%B8%89%EF%BC%89/</url>
    <content><![CDATA[<h3 id="Redis-常见面试题（三）"><a href="#Redis-常见面试题（三）" class="headerlink" title="Redis-常见面试题（三）"></a>Redis-常见面试题（三）</h3><span id="more"></span>

<h3 id="分区"><a href="#分区" class="headerlink" title="分区"></a>分区</h3><h3 id="1、Redis是单线程的，如何提高多核CPU的利用率？"><a href="#1、Redis是单线程的，如何提高多核CPU的利用率？" class="headerlink" title="1、Redis是单线程的，如何提高多核CPU的利用率？"></a>1、Redis是单线程的，如何提高多核CPU的利用率？</h3><p>可以在同一个服务器部署多个Redis的实例，并把它们当做不同的服务器来使用，在某些时候，无论如何一个服务器是不够的，所以，如果你想使用多个CPU，你可以考虑一下分片（shard）。</p>
<h3 id="2、为什么要做Redis分区？"><a href="#2、为什么要做Redis分区？" class="headerlink" title="2、为什么要做Redis分区？"></a>2、为什么要做Redis分区？</h3><p>分区可以让Redis管理更大的内存，Redis将可以使用所有机器的内存。如果没有分区，你最多使用一台机器的内存。分区使Redis的计算能力通过简单地增加计算机得到成倍提升，Redis的网络带宽也会随着计算机和网卡的增加而成倍增长。</p>
<h3 id="3、你知道有哪些Redis分区实现方案？"><a href="#3、你知道有哪些Redis分区实现方案？" class="headerlink" title="3、你知道有哪些Redis分区实现方案？"></a>3、你知道有哪些Redis分区实现方案？</h3><ul>
<li>客户端分区就是在客户端已经决定数据会被储存到哪个redis节点读取。大多数客户端已经实现了客户端分区。</li>
<li>代理分区意味着客户端将请求发送给代理，然后代理决定去哪个节点写数据或读数据。代理根据分区规则请求哪些Redis实例，然后根据redis的相应结果返回客户端。Redis和Memcached的一种代理实现就是Twenproxy。</li>
<li>查询路由（Query Route）的意思就是客户端随机地请求任意一个Redis 实例，然后由Redis请求转发给正确的Redis节点。Redis Cluster实现了一种混合形式的查询路由，但并不是直接将请求从一个redis节点转发到另一个Redis节点，而是在客户端的帮助下直接redirected到正确的节点。</li>
</ul>
<h3 id="4、Redis分区有什么缺点？"><a href="#4、Redis分区有什么缺点？" class="headerlink" title="4、Redis分区有什么缺点？"></a>4、Redis分区有什么缺点？</h3><ul>
<li>涉及多个key的操作通常不会支持。例如你不能对两个集合求交集，因为它们可能被存储到不同的Redis实例。</li>
<li>同时操作多个key，则不能使用Redis事务。</li>
<li>分区使用的粒度是key，不能使用一个非常长的排序key存储一个数据集。</li>
<li>当使用分区的时候，数据处理会非常复杂，例如为了备份你必须从不同的Redis实例和主机同时收集RDB&#x2F;AOF文件。</li>
<li>分区时动态扩容或缩容可能非常复杂，Redis集群在运行时增加或者删除Redis节点，能做到最大程度对用户透明地数据再平衡，但其他一些客户端分区或者代理分区方法则不支持这种特性。然而，有一种预分片的技术也可以很好解决这个问题。</li>
</ul>
<hr>
<h3 id="分布式问题"><a href="#分布式问题" class="headerlink" title="分布式问题"></a>分布式问题</h3><h3 id="5、Redis实现分布式锁"><a href="#5、Redis实现分布式锁" class="headerlink" title="5、Redis实现分布式锁"></a>5、Redis实现分布式锁</h3><p>Redis为单进程单线程模式，采用队列模式将并发访问变成串行访问，且客户端对Redis的连接并不存在竞争关系，Redis中可以使用SETNX命令实现分布式锁。</p>
<p>当且仅当key不存在，将key的值设置为value。若给定的key已经存在，则SETNX不做任何动作。</p>
<p><img src="/../images/25.png" alt="25"></p>
<p>使用SETNX完成同步锁的流程以及注意事项如下：</p>
<p>使用SETNX命令获取锁，若返回0（key已经存在，锁已经存在）则获取失败，反之获取成功。</p>
<p>为了防止获取锁后程序出现异常，导致其他进程&#x2F;线程调用SETNX命令总是返回0而进入死锁状态，需要为该key设置一个合理的过期时间。</p>
<p>释放锁，使用DEL命令将锁数据删除。</p>
<h3 id="6、如何解决Redis的并发竞争key问题？"><a href="#6、如何解决Redis的并发竞争key问题？" class="headerlink" title="6、如何解决Redis的并发竞争key问题？"></a>6、如何解决Redis的并发竞争key问题？</h3><p>所谓Redis的并发竞争key的问题也就是多个系统同时对一个key进行操作，但是最后执行的顺序和我们期望的顺序不同，这样也就导致了结果的不同。</p>
<p>推荐一种方案：分布式锁（zookeeper和redis都可以实现分布式锁）。</p>
<h3 id="7、分布式Redis是前期还是后期规模上来了在做好？为什么？"><a href="#7、分布式Redis是前期还是后期规模上来了在做好？为什么？" class="headerlink" title="7、分布式Redis是前期还是后期规模上来了在做好？为什么？"></a>7、分布式Redis是前期还是后期规模上来了在做好？为什么？</h3><p>既然Redis是如此的轻量，为防止以后的扩容，最好的办法就是一开始就启动较多实例。即便你只有一台服务器，你也可以一开始就让Redis以分布式的方式运行，使用分区，在同一台服务器上启动多个实例。</p>
<p>一开始就多设置几个Redis实例，这样的话，当你的数据不断增长，需要更多Redis服务器时，你需要做的仅仅是将Redis实例从一台服务迁移到另一台服务器而已。一旦你添加了另一台服务器，你需要将你一半的Redis实例从第一台机器迁移到第二台机器。</p>
<h3 id="8、什么是RedLock？"><a href="#8、什么是RedLock？" class="headerlink" title="8、什么是RedLock？"></a>8、什么是RedLock？</h3><p>Redis官方提出的一种权威的基于Redis实现分布式锁的方式，此种方式比原先的单节点的方法更安全。它可以保证以下特性：</p>
<ol>
<li>安全特性：互斥访问，即永远只有一个client能拿到锁。</li>
<li>避免死锁：最终client都可能拿到锁，不会出现死锁情况。</li>
<li>容错性：只要大部分Redis节点存活就可以正常提供服务。</li>
</ol>
<hr>
<h3 id="缓存异常"><a href="#缓存异常" class="headerlink" title="缓存异常"></a>缓存异常</h3><h3 id="9、缓存雪崩"><a href="#9、缓存雪崩" class="headerlink" title="9、缓存雪崩"></a>9、缓存雪崩</h3><p>缓存雪崩是指缓存同一时间大面积的失效，所以，后面的请求都会落到数据库上，造成数据库短时间内承受大量请求而崩掉。</p>
<p>解决方案：</p>
<ol>
<li>缓存数据的过期时间设置随机，防止同一时间大量数据过期现象发生。</li>
<li>一般并发量不是特别多的时候，使用最多的解决方案是加锁排队。</li>
<li>给每一个缓存数据增加相应的缓存标记，记录缓存的是否失效，如果缓存标记失效，则更新数据缓存。</li>
</ol>
<h3 id="10、缓存穿透"><a href="#10、缓存穿透" class="headerlink" title="10、缓存穿透"></a>10、缓存穿透</h3><p>缓存穿透是指缓存和数据库中都没有的数据，导致所有的请求都落到数据库上，造成数据库短时间内承受大量请求而崩掉。</p>
<p>解决方案：</p>
<ol>
<li>接口层增加校验，如用户鉴权校验，id做基础校验，id&lt;&#x3D;0的直接拦截。</li>
<li>从缓存取不到的数据，在数据库中也没有取到，这时也可以将key-value对写为key-null，缓存有效时间可以设置短点，如30秒（设置太长会导致正常情况也没法使用）。这样可以防止攻击用户反复用同一个id暴力攻击。</li>
<li>采用布隆过滤器，将所有可能存在的数据哈希到一个足够大的 bitmap 中，一个一定不存在的数据会被这个 bitmap 拦截掉，从而避免了对底层存储系统的查询压力。</li>
</ol>
<h3 id="附加"><a href="#附加" class="headerlink" title="附加"></a>附加</h3><p>对于空间的利用到达了一种极致，那就是Bitmap和布隆过滤器(Bloom Filter)。</p>
<p>Bitmap：典型的就是哈希表。</p>
<p>缺点是，Bitmap对于每个元素只能记录1bit信息，如果还想完成额外的功能，恐怕只能靠牺牲更多的空间、时间来完成了。</p>
<h4 id="布隆过滤器"><a href="#布隆过滤器" class="headerlink" title="布隆过滤器"></a>布隆过滤器</h4><p>就是引入了k(k&gt;1)k(k&gt;1)个相互独立的哈希函数，保证在给定的空间、误判率下，完成元素判重的过程。</p>
<p>它的优点是空间效率和查询时间都远远超过一般的算法，缺点是有一定的误识别率和删除困难。</p>
<p>Bloom-Filter算法的核心思想就是利用多个不同的Hash函数来解决“冲突”。</p>
<p>Hash存在一个冲突（碰撞）的问题，用同一个Hash得到的两个URL的值有可能相同。为了减少冲突，我们可以多引入几个Hash，如果通过其中的一个Hash值我们得出某元素不在集合中，那么该元素肯定不在集合中。只有在所有的Hash函数告诉我们该元素在集合中时，才能确定该元素存在于集合中。这便是Bloom-Filter的基本思想。</p>
<p>Bloom-Filter一般用于在大数据量的集合中判定某元素是否存在。</p>
<h3 id="11、缓存击穿"><a href="#11、缓存击穿" class="headerlink" title="11、缓存击穿"></a>11、缓存击穿</h3><p>缓存击穿是指缓存中没有但数据库中有的数据（一般是缓存时间到期），这时由于并发用户特别多，同时读缓存没读到数据，又同时去数据库去取数据，引起数据库压力瞬间增大，造成过大压力。和缓存雪崩不同的是，缓存击穿指并发查同一条数据，缓存雪崩是不同数据都过期了，很多数据都查不到从而查数据库。</p>
<p>解决方案：</p>
<ol>
<li>设置热点数据永远不过期。</li>
<li>加互斥锁，互斥锁。</li>
</ol>
<h3 id="12、缓存预热"><a href="#12、缓存预热" class="headerlink" title="12、缓存预热"></a>12、缓存预热</h3><p>缓存预热就是系统上线后，将相关的缓存数据直接加载到缓存系统。这样就可以避免在用户请求的时候，先查询数据库，然后再将数据缓存的问题！用户直接查询事先被预热的缓存数据！</p>
<p>解决方案：</p>
<ol>
<li>直接写个缓存刷新页面，上线时手工操作一下；</li>
<li>数据量不大，可以在项目启动的时候自动进行加载；</li>
<li>定时刷新缓存；</li>
</ol>
<h3 id="13、缓存降级"><a href="#13、缓存降级" class="headerlink" title="13、缓存降级"></a>13、缓存降级</h3><p>当访问量剧增、服务出现问题（如响应时间慢或不响应）或非核心服务影响到核心流程的性能时，仍然需要保证服务还是可用的，即使是有损服务。系统可以根据一些关键数据进行自动降级，也可以配置开关实现人工降级。</p>
<p>缓存降级的最终目的是保证核心服务可用，即使是有损的。而且有些服务是无法降级的（如加入购物车、结算）。</p>
<p>在进行降级之前要对系统进行梳理，看看系统是不是可以丢卒保帅；从而梳理出哪些必须誓死保护，哪些可降级；比如可以参考日志级别设置预案：</p>
<ol>
<li>一般：比如有些服务偶尔因为网络抖动或者服务正在上线而超时，可以自动降级；</li>
<li>警告：有些服务在一段时间内成功率有波动（如在95~100%之间），可以自动降级或人工降级，并发送告警；</li>
<li>错误：比如可用率低于90%，或者数据库连接池被打爆了，或者访问量突然猛增到系统能承受的最大阀值，此时可以根据情况自动降级或者人工降级；</li>
<li>严重错误：比如因为特殊原因数据错误了，此时需要紧急人工降级。</li>
</ol>
<p>服务降级的目的，是为了防止Redis服务故障，导致数据库跟着一起发生雪崩问题。因此，对于不重要的缓存数据，可以采取服务降级策略，例如一个比较常见的做法就是，Redis出现问题，不去数据库查询，而是直接返回默认值给用户。</p>
<h3 id="14、热点数据和冷数据"><a href="#14、热点数据和冷数据" class="headerlink" title="14、热点数据和冷数据"></a>14、热点数据和冷数据</h3><p>热点数据，缓存才有价值。</p>
<p>对于冷数据而言，大部分数据可能还没有再次访问到就已经被挤出内存，不仅占用内存，而且价值不大。频繁修改的数据，看情况考虑使用缓存。</p>
<p>对于热点数据，比如我们的某IM产品，生日祝福模块，当天的寿星列表，缓存以后可能读取数十万次。再举个例子，某导航产品，我们将导航信息，缓存以后可能读取数百万次。</p>
<p>数据更新前至少读取两次，缓存才有意义。这个是最基本的策略，如果缓存还没有起作用就失效了，那就没有太大价值了。</p>
<p>那存不存在，修改频率很高，但是又不得不考虑缓存的场景呢？有！比如，这个读取接口对数据库的压力很大，但是又是热点数据，这个时候就需要考虑通过缓存手段，减少数据库的压力，比如我们的某助手产品的，点赞数，收藏数，分享数等是非常典型的热点数据，但是又不断变化，此时就需要将数据同步保存到Redis缓存，减少数据库压力。</p>
<h3 id="15、缓存热点key"><a href="#15、缓存热点key" class="headerlink" title="15、缓存热点key"></a>15、缓存热点key</h3><p>缓存中的一个Key(比如一个促销商品)，在某个时间点过期的时候，恰好在这个时间点对这个Key有大量的并发请求过来，这些请求发现缓存过期一般都会从后端DB加载数据并回设到缓存，这个时候大并发的请求可能会瞬间把后端DB压垮。</p>
<p>解决方案：</p>
<p>对缓存查询加锁，如果KEY不存在，就加锁，然后查DB入缓存，然后解锁；其他进程如果发现有锁就等待，然后等解锁后返回数据或者进入DB查询。</p>
<hr>
<h3 id="常用工具"><a href="#常用工具" class="headerlink" title="常用工具"></a>常用工具</h3><h3 id="16、Redis支持的Java客户端都有哪些？官方推荐使用哪个？"><a href="#16、Redis支持的Java客户端都有哪些？官方推荐使用哪个？" class="headerlink" title="16、Redis支持的Java客户端都有哪些？官方推荐使用哪个？"></a>16、Redis支持的Java客户端都有哪些？官方推荐使用哪个？</h3><p>Redisson、Jedis、lettuce等等。官方推荐使用Redisson。</p>
<h3 id="17、Redis和Redisson有什么关系？"><a href="#17、Redis和Redisson有什么关系？" class="headerlink" title="17、Redis和Redisson有什么关系？"></a>17、Redis和Redisson有什么关系？</h3><p>Redisson是一个高级的分布式协调Redis客服端，能帮助用户在分布式环境中轻松实现一些Java的对象 (Bloom filter, BitSet, Set, SetMultimap, ScoredSortedSet, SortedSet, Map, ConcurrentMap, List, ListMultimap, Queue, BlockingQueue, Deque, BlockingDeque, Semaphore, Lock, ReadWriteLock, AtomicLong, CountDownLatch, Publish &#x2F; Subscribe, HyperLogLog)。</p>
<h3 id="18、Jedis和Redisson对比有什么缺点？"><a href="#18、Jedis和Redisson对比有什么缺点？" class="headerlink" title="18、Jedis和Redisson对比有什么缺点？"></a>18、Jedis和Redisson对比有什么缺点？</h3><p>Jedis是Redis的Java实现的客户端，其API提供了比较全面的Redis命令的支持；Redisson实现了分布式和可扩展的Java数据结构，和Jedis相比，功能较为简单，不支持字符串操作，不支持排序、事务、管道、分区等Redis特性。Redisson的宗旨是促进使用者对Redis的关注分离，从而让使用者能够将精力更集中地放在处理业务逻辑上。</p>
<hr>
<h3 id="其他问题"><a href="#其他问题" class="headerlink" title="其他问题"></a>其他问题</h3><h3 id="19、Redis和Memcached的区别"><a href="#19、Redis和Memcached的区别" class="headerlink" title="19、Redis和Memcached的区别"></a>19、Redis和Memcached的区别</h3><p>两者都是非关系型内存键值数据库，现在公司一般都是用 Redis 来实现缓存，而且 Redis 自身也越来越强大了！Redis 与 Memcached 主要有以下不同：</p>
<table>
<thead>
<tr>
<th align="center">对比参数</th>
<th align="center">Redis</th>
<th align="center">Memcached</th>
</tr>
</thead>
<tbody><tr>
<td align="center">类型</td>
<td align="center">支持内存  、非关系型数据库</td>
<td align="center">支持内存 、键值对形式 、缓存形式</td>
</tr>
<tr>
<td align="center">数据存储类型</td>
<td align="center">String 、List 、Set 、Hash 、Zset</td>
<td align="center">文本型、二进制型</td>
</tr>
<tr>
<td align="center">查询类型</td>
<td align="center">批量操作、事务支持、每个类型不同的CRUD</td>
<td align="center">常用的CRUD、少量的其它命令</td>
</tr>
<tr>
<td align="center">附加功能</td>
<td align="center">发布&#x2F;订阅模式、主从分区、序列化支持、脚本支持（LUA脚本）</td>
<td align="center">多线程服务支持</td>
</tr>
<tr>
<td align="center">网络IO模型</td>
<td align="center">单线程的多路IO复用模型</td>
<td align="center">多线程，非阻塞IO模式</td>
</tr>
<tr>
<td align="center">事件库</td>
<td align="center">自封转简易事件库AeEvent</td>
<td align="center">贵族血统的LibEvent事件库</td>
</tr>
<tr>
<td align="center">持久化支持</td>
<td align="center">RDB、AOF</td>
<td align="center">不支持</td>
</tr>
<tr>
<td align="center">集群模式</td>
<td align="center">原生支持cluster模式，可以实现主从复制，读写分离</td>
<td align="center">没有原生的集群模式，需要依靠客户端来实现往集群中分片写入数据</td>
</tr>
<tr>
<td align="center">内存管理机制</td>
<td align="center">在Redis中，并不是所有的数据都一直存储在内存中，可以将一些很久没用的value交换到磁盘</td>
<td align="center">数据会一直在内存中，将内存分割成特定长度的块来存储数据，以完全解决内存碎片问题，但是这种方式会使得内存的利用率不高。</td>
</tr>
<tr>
<td align="center">使用场景</td>
<td align="center">复杂数据结构、有持久化、高可用需求，value存储内容很大</td>
<td align="center">纯key-value，数据量非常大，并发量非常大的业务</td>
</tr>
</tbody></table>
<ul>
<li>memcached所有的值均是简单的字符串，redis作为其替代者，支持更为丰富的数据类型。</li>
<li>redis的速度比memcached快很多。</li>
<li>redis可以持久化其数据。</li>
</ul>
<h3 id="20、如何保证缓存与数据库双写时的数据一致性？"><a href="#20、如何保证缓存与数据库双写时的数据一致性？" class="headerlink" title="20、如何保证缓存与数据库双写时的数据一致性？"></a>20、如何保证缓存与数据库双写时的数据一致性？</h3><p>你只要用缓存，就可能会涉及到缓存与数据库双存储双写，你只要是双写，就一定会有数据一致性的问题，那么你如何解决一致性问题？</p>
<p>一般来说，就是如果你的系统不是严格要求缓存+数据库必须一致性的话，缓存可以稍微的跟数据库偶尔有不一致的情况，最好不要做这个方案，读请求和写请求串行化，串到一个内存队列里去，这样就可以保证一定不会出现不一致的情况</p>
<p>串行化之后，就会导致系统的吞吐量会大幅度的降低，用比正常情况下多几倍的机器去支撑线上的一个请求。</p>
<p>还有一种方式就是可能会暂时产生不一致的情况，但是发生的几率特别小，就是<strong>先更新数据库，然后再删除缓存。</strong></p>
<table>
<thead>
<tr>
<th align="center">问题场景</th>
<th align="center">描述</th>
<th align="center">解决</th>
</tr>
</thead>
<tbody><tr>
<td align="center">先写缓存，再写数据库，缓存写成功，数据库写失败</td>
<td align="center">缓存写成功，但写数据库失败或者响应延迟，则下次读取缓存时，就会出现脏读</td>
<td align="center">这个写缓存的方式本身就是错误的，需要改为先写数据库，把旧缓存置为失效；读取数据的时候，如果缓存不存在，则读取数据库再写缓存。</td>
</tr>
<tr>
<td align="center">先写数据库，再写缓存，数据库写成功，缓存写失败</td>
<td align="center">写数据库成功，但写缓存失败，则下次读取缓存时，则读不到数据</td>
<td align="center">缓存使用时，假如读缓存失败，先读数据库，再回写缓存的方式实现</td>
</tr>
<tr>
<td align="center">需要缓存异步刷新</td>
<td align="center">指数据库操作和写缓存不在一个操作步骤中，比如在分布式场景下，无法做到同时写缓存或需要异步刷新</td>
<td align="center">确定哪些数据适合此类场景，根据经验值确定合理的数据不一致时间，用户刷新的时间间隔</td>
</tr>
</tbody></table>
<h3 id="21、Redis常见性能问题和解决方案？"><a href="#21、Redis常见性能问题和解决方案？" class="headerlink" title="21、Redis常见性能问题和解决方案？"></a>21、Redis常见性能问题和解决方案？</h3><ol>
<li>Master最好不要做任何持久化工作，包括内存快照和AOF日志文件，特别是不要启用内存快照做持久化。</li>
<li>如果数据比较关键，某个Slave开启AOF备份数据，策略为每秒同步一次。</li>
<li>为了主从复制的速度和连接的稳定性，Slave和Master最好在同一个局域网内。</li>
<li>尽量避免在压力较大的主库上增加从库。</li>
<li>Master调用BGREWRITEAOF重写AOF文件，AOF在重写的时候会占大量的CPU和内存资源，导致服务load过高，出现短暂服务暂停现象。</li>
<li>为了Master的稳定性，主从复制不要用图状结构，用单向链表结构更稳定，即主从关系为：Master&lt;–Slave1&lt;–Slave2&lt;–Slave3…，这样的结构也方便解决单点故障问题，实现Slave对Master的替换，也即，如果Master挂了，可以立马启用Slave1做Master，其他不变。</li>
</ol>
<h3 id="22、Redis官方为什么不提供Windows版本？"><a href="#22、Redis官方为什么不提供Windows版本？" class="headerlink" title="22、Redis官方为什么不提供Windows版本？"></a>22、Redis官方为什么不提供Windows版本？</h3><p>因为目前Linux版本已经相当稳定，而且用户量很大，无需开发windows版本，反而会带来兼容性等问题。</p>
<h3 id="23、一个字符串类型的值能存储最大容量是多少？（512M）"><a href="#23、一个字符串类型的值能存储最大容量是多少？（512M）" class="headerlink" title="23、一个字符串类型的值能存储最大容量是多少？（512M）"></a>23、一个字符串类型的值能存储最大容量是多少？（512M）</h3><h3 id="24、Redis如何做大量数据插入？"><a href="#24、Redis如何做大量数据插入？" class="headerlink" title="24、Redis如何做大量数据插入？"></a>24、Redis如何做大量数据插入？</h3><p>Redis2.6开始redis-cli支持一种新的被称之为pipe mode的新模式用于执行大量数据插入工作。</p>
<h3 id="25、假如Redis里面有1个亿key，其中有10w个key是以某个固定的已知的前缀开头，如何将他们全部找出来？"><a href="#25、假如Redis里面有1个亿key，其中有10w个key是以某个固定的已知的前缀开头，如何将他们全部找出来？" class="headerlink" title="25、假如Redis里面有1个亿key，其中有10w个key是以某个固定的已知的前缀开头，如何将他们全部找出来？"></a>25、假如Redis里面有1个亿key，其中有10w个key是以某个固定的已知的前缀开头，如何将他们全部找出来？</h3><p>使用keys指令可以扫出指定模式的key列表。</p>
<p>对方接着追问：如果这个redis正在给线上的业务提供服务，那使用keys指令会有什么问题？</p>
<p>这个时候你要回答redis关键的一个特性：redis的单线程的。keys指令会导致线程阻塞一段时间，线上服务会停顿，直到指令执行完毕，服务才能恢复。这个时候可以使用scan指令，scan指令可以无阻塞的提取出指定模式的key列表，但是会有一定的重复概率，在客户端做一次去重就可以了，但是整体所花费的时间会比直接用keys指令长。</p>
<h3 id="26、使用Redis做过异步队列吗？是如何实现的？"><a href="#26、使用Redis做过异步队列吗？是如何实现的？" class="headerlink" title="26、使用Redis做过异步队列吗？是如何实现的？"></a>26、使用Redis做过异步队列吗？是如何实现的？</h3><p>使用list类型保存数据信息，rpush生产消息，lpop消费消息，当lpop没有消息时，可以sleep一段时间，然后再检查有没有信息，如果不想sleep的话，可以使用blpop, 在没有信息的时候，会一直阻塞，直到信息的到来。redis可以通过pub&#x2F;sub主题订阅模式实现一个生产者，多个消费者，当然也存在一定的缺点，当消费者下线时，生产的消息会丢失。</p>
<h3 id="27、Redis如何实现延时队列？"><a href="#27、Redis如何实现延时队列？" class="headerlink" title="27、Redis如何实现延时队列？"></a>27、Redis如何实现延时队列？</h3><p>使用sortedset，使用时间戳做score, 消息内容作为key,调用zadd来生产消息，消费者使用zrangbyscore获取n秒之前的数据做轮询处理。</p>
<h3 id="28、Redis回收进程如何工作的？"><a href="#28、Redis回收进程如何工作的？" class="headerlink" title="28、Redis回收进程如何工作的？"></a>28、Redis回收进程如何工作的？</h3><ol>
<li>一个客户端运行了新的命令，添加了新的数据。</li>
<li>Redis检查内存使用情况，如果大于maxmemory的限制， 则根据设定好的策略进行回收。</li>
<li>一个新的命令被执行，等等。</li>
<li>所以我们不断地穿越内存限制的边界，通过不断达到边界然后不断地回收回到边界以下。</li>
</ol>
<p>如果一个命令的结果导致大量内存被使用（例如很大的集合的交集保存到一个新的键），不用多久内存限制就会被这个内存使用量超越。</p>
<h3 id="29、Redis回收使用的是什么算法？"><a href="#29、Redis回收使用的是什么算法？" class="headerlink" title="29、Redis回收使用的是什么算法？"></a>29、Redis回收使用的是什么算法？</h3><p>LRU算法。</p>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis常见面试题（二）</title>
    <url>/2022/03/09/Redis%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
    <content><![CDATA[<h3 id="Redis-常见面试题（二）"><a href="#Redis-常见面试题（二）" class="headerlink" title="Redis-常见面试题（二）"></a>Redis-常见面试题（二）</h3><span id="more"></span>

<h3 id="内存相关"><a href="#内存相关" class="headerlink" title="内存相关"></a>内存相关</h3><h3 id="1、MySQL里有2000w数据，redis中只存20w的数据，如何保证redis的数据都是热点数据？"><a href="#1、MySQL里有2000w数据，redis中只存20w的数据，如何保证redis的数据都是热点数据？" class="headerlink" title="1、MySQL里有2000w数据，redis中只存20w的数据，如何保证redis的数据都是热点数据？"></a>1、MySQL里有2000w数据，redis中只存20w的数据，如何保证redis的数据都是热点数据？</h3><p>redis内存数据集大小上升到一定大小的时候，就会施行数据淘汰策略。</p>
<h3 id="2、Redis的内存淘汰策略有哪些？"><a href="#2、Redis的内存淘汰策略有哪些？" class="headerlink" title="2、Redis的内存淘汰策略有哪些？"></a>2、Redis的内存淘汰策略有哪些？</h3><p>Redis的内存淘汰策略是指在Redis的用于缓存的内存不足时，怎么处理需要重新写入且需要申请额外空间的数据。</p>
<p>全局的键空间选择性移除：</p>
<ul>
<li>noeviction：当内存不足以容纳新写入数据时，新写入操作会报错。</li>
<li>allkeys-lru：当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的key。（最常用）</li>
<li>allkeys-random：当内存不足以容纳新写入数据时，在设置了过期时间的空间中，有更早过期时间的可以优先移除。</li>
</ul>
<p>设置过期时间的键空间选择性移除：</p>
<ul>
<li>volatile-lru：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，移除最近最少使用的key。</li>
<li>volatile-random：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，随机移除某个key。</li>
<li>volatile-ttl：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，有更早过期时间的key优先移除。</li>
</ul>
<p>总结：</p>
<ul>
<li>Redis的内存淘汰策略的选取并不会影响过期的key的处理。</li>
<li>内存淘汰策略用于处理内存不足时的需要申请额外空间的数据。</li>
<li>过期策略用于处理过期的缓存数据。</li>
</ul>
<h3 id="3、Redis主要消耗什么物理资源？（内存）"><a href="#3、Redis主要消耗什么物理资源？（内存）" class="headerlink" title="3、Redis主要消耗什么物理资源？（内存）"></a>3、Redis主要消耗什么物理资源？（内存）</h3><h3 id="4、Redis的内存用完了会发生什么？"><a href="#4、Redis的内存用完了会发生什么？" class="headerlink" title="4、Redis的内存用完了会发生什么？"></a>4、Redis的内存用完了会发生什么？</h3><p>如果达到设置的上限，Redis的写命令会返回错误信息（但是读命令还可以正常返回）或者你可以配置内存淘汰机制，当Redis达到内存上限时会冲刷掉旧的内容。</p>
<h3 id="5、Redis如何做内存优化？"><a href="#5、Redis如何做内存优化？" class="headerlink" title="5、Redis如何做内存优化？"></a>5、Redis如何做内存优化？</h3><p>可以好好利用Hash，List，Zset，Set等数据结构，因为通常情况下，很多小的key-value可以用更紧凑的方式存放在一起。尽可能使用散列表，散列表使用的内存非常小，所以你应该尽可能的将你的数据模型抽象到一个散列表里面。例如，你的web系统中有一个用户对象，不要为这个用户的名称，姓氏，邮箱，密码设置单独的key，而是应该把这个用户的所有信息存储到一张散列表中。</p>
<hr>
<h3 id="线程模型"><a href="#线程模型" class="headerlink" title="线程模型"></a>线程模型</h3><h3 id="6、Redis线程模型"><a href="#6、Redis线程模型" class="headerlink" title="6、Redis线程模型"></a>6、Redis线程模型</h3><p>Redis基于Reactor模式开发了网络事件处理器，这个处理器被称为文件事件处理器（file event handler）。它的组成结构为4部分：多个套接字、IO多路复用程序、文件事件分派器、事件处理器。因为文件事件分派器队列的消费是单线程的，所以Redis才叫单线程模型。</p>
<ul>
<li>文件事件处理器使用I&#x2F;O多路复用程序来同时监听多个套接字，并根据套接字目前执行的任务来为套接字关联不同的事件处理器。</li>
<li>当被监听的套接字准备好执行连接应答、读取、写入、关闭等操作时，与操作相对应的文件事件就会产生，这时文件事件处理器就会调用套接字之前关联好的事件处理器来处理这些事情。</li>
</ul>
<p>虽然文件事件处理器以单线程方式运行，但通过使用I&#x2F;O多路复用程序来监听多个套接字，文件事件处理器既实现了高性能的网络通信模型，又可以很好的与redis服务器中其它同样以单线程方式运行的模块进行对接，这保持了Redis内部单线程设计的简单性。</p>
<hr>
<h3 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h3><h3 id="7、什么是事务？"><a href="#7、什么是事务？" class="headerlink" title="7、什么是事务？"></a>7、什么是事务？</h3><p>事务是一个单独的隔离操作：事务中的所有命令都会序列化、按顺序执行。事务在执行过程中，不会被其它客户端发送来的命令请求所打断。</p>
<p>事务是一个原子操作：事务中的命令要么全部被执行，要么全部不执行。</p>
<h3 id="8、Redis事务的概念"><a href="#8、Redis事务的概念" class="headerlink" title="8、Redis事务的概念"></a>8、Redis事务的概念</h3><p>Redis事务的本质是是通过MULTI、EXEC、WATCH等一组命令的集合。事务一次执行多个命令 ，一个事务中所有的命令都会被序列化。在事务的执行过程中，会按照顺序串行化执行队列中的命令，其它客户端提交的命令请求不会插入到事务执行名列序列中。</p>
<p>Redis事务就是一次性、顺序性、排他性的执行一个队列中的一系列命令。</p>
<h3 id="9、Redis事务的三个阶段"><a href="#9、Redis事务的三个阶段" class="headerlink" title="9、Redis事务的三个阶段"></a>9、Redis事务的三个阶段</h3><ol>
<li>事务开始MULTI</li>
<li>命令入队</li>
<li>事务执行EXEC</li>
</ol>
<p>事务执行过程中，如果服务端收到有EXEC、DISCARD、WATCH、MULTI之外的请求，将会把请求放入队列中排队。</p>
<h3 id="10、事务管理概述（ACID）"><a href="#10、事务管理概述（ACID）" class="headerlink" title="10、事务管理概述（ACID）"></a>10、事务管理概述（ACID）</h3><ul>
<li>原子性（Automicity）</li>
</ul>
<p>原子性是指事务是一个不可分割的工作单位，事务中的操作要么都发生，要么都不发生。</p>
<ul>
<li>一致性（Consistency）</li>
</ul>
<p>事务前后数据的完整性必须保证一致。</p>
<ul>
<li>隔离性（Isolation）</li>
</ul>
<p>多个事务并行执行时，一个事务的执行不应影响其他事务的执行。</p>
<ul>
<li>持久性</li>
</ul>
<p>持久性是指一个事务一旦被提交，它对数据库中的数据的改变是永久性的，接下来即使数据库发生故障也不应该对其有任何影响。</p>
<p>Redis的事务总是具有ACID中的一致性和隔离性，其他特性是不支持的。当服务器运行在AOF持久化模式下，并且appendfsync时，事务也具有耐久性。</p>
<h3 id="11、Redis事务支持隔离性吗？"><a href="#11、Redis事务支持隔离性吗？" class="headerlink" title="11、Redis事务支持隔离性吗？"></a>11、Redis事务支持隔离性吗？</h3><p>Redis是单线程程序，并且它保证在执行事务时，不会对事务进行中断，事务可以运行直到执行完所有事务队列中的命令为止。</p>
<h3 id="12、Redis事务保证原子性吗？支持回滚吗？"><a href="#12、Redis事务保证原子性吗？支持回滚吗？" class="headerlink" title="12、Redis事务保证原子性吗？支持回滚吗？"></a>12、Redis事务保证原子性吗？支持回滚吗？</h3><p>Redis中，单条命令是原子性执行的，但事务不保证原子性，且没有回滚。事务中任意命令执行失败，其余的命令仍会执行。</p>
<h3 id="13、Redis事务其它实现"><a href="#13、Redis事务其它实现" class="headerlink" title="13、Redis事务其它实现"></a>13、Redis事务其它实现</h3><ul>
<li>基于Lua脚本，Redis可以保证脚本内的命令一次性、按命令执行，其同时也不提供事务运行错误的回滚，执行过程中如果部分命令运行错误，剩下的，命令还是会继续执行。</li>
<li>基于中间标记变量，通过另外的标记变量来标识事务是否完成，读取数据时先读取该标记变量，判断是否事务执行完成。但这样会需要额外写代码实现，比较繁琐。</li>
</ul>
<hr>
<h3 id="集群方案"><a href="#集群方案" class="headerlink" title="集群方案"></a>集群方案</h3><h3 id="14、哨兵模式（sentinel）"><a href="#14、哨兵模式（sentinel）" class="headerlink" title="14、哨兵模式（sentinel）"></a>14、哨兵模式（sentinel）</h3><p><img src="/../images/19.png" alt="19"></p>
<ol>
<li><p>哨兵的介绍</p>
<p>sentinel，中文名是哨兵。哨兵是redis集群机构中非常重要的一个组件，主要有一下功能：</p>
<ul>
<li>集群监控：负责监控redis master和slave进程是否正常工作。</li>
<li>消息通知：如果某个redis实例有故障，那么哨兵负责发送消息作为警报通知给管理员。</li>
<li>故障转移：如果master node挂掉，会自动转移到slave node上。</li>
<li>配置中心：如果故障转移发生了，通知client客户端新的master地址。</li>
</ul>
</li>
<li><p>哨兵用于实现redis集群的高可用，本身也是分布式的，作为一个哨兵集群去运行，互相协同工作</p>
<ul>
<li>故障转移时，判断一个master node是否宕机了，需要大部分的哨兵都同意才行，涉及到了分布式选举的问题。</li>
<li>即使部分哨兵节点挂掉了，哨兵集群还是能正常工作的，因为如果一个作为高可用机制重要组成成分的故障转移系统本身是单点的，那就很坑了。</li>
</ul>
</li>
<li><p>哨兵的核心知识</p>
<ul>
<li>哨兵至少需要3个实例，来保证自己的健壮性。</li>
<li>哨兵+redis主从的部署架构，是不保证数据零丢失的，只能保证集群的高可用性。</li>
<li>对于哨兵+redis主从这种复杂的部署结构，尽量在测试环境和生产环境，都进行充足的测试和演练。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="15、官方Redis-Cluster方案（服务端路由查询）"><a href="#15、官方Redis-Cluster方案（服务端路由查询）" class="headerlink" title="15、官方Redis Cluster方案（服务端路由查询）"></a>15、官方Redis Cluster方案（服务端路由查询）</h3><p><img src="/../images/20.png" alt="20"></p>
<h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p>Redis Cluster是一种服务算sharding技术。Redis Cluster并没有使用一致性hash，而是采用slot（槽）的概念，一共分成16384个槽。将求情发送到任意节点，接收到请求的节点会将查询请求发送到正确的节点上执行。</p>
<h4 id="方案说明"><a href="#方案说明" class="headerlink" title="方案说明"></a>方案说明</h4><ol>
<li>通过hash的方式，将数据分片，每个节点均分存储一定哈希槽的数据，默认分配了16384个槽位。</li>
<li>每份数据分片会存储在多个互为主从的多节点上。</li>
<li>数据写入先写主节点，在同步到从节点（支持配置为阻塞同步）。</li>
<li>同一分片多个节点的数据不保持一致性。</li>
<li>读取数据时，当客户端的key没有分配在该节点时，redis会返回转向指令，指向正确的节点。</li>
<li>扩容时需要把旧节点的数据迁移到新节点。</li>
</ol>
<p>在redis cluster架构下，每个redis要放开两个端口号，比如一个是6379，另一个是加1w的端口号，比如16379。</p>
<p>16379端口号是用来进行节点间通信的，也就是cluster bus的东西，cluster bus的通信，用来进行故障检测，配置更新，故障转移授权。cluster bus用了另外一种二进制的协议，gossip协议，用于节点间进行高效的数据交换，占用更少的网络带宽和处理时间。</p>
<h4 id="节点间的内部通信机制"><a href="#节点间的内部通信机制" class="headerlink" title="节点间的内部通信机制"></a>节点间的内部通信机制</h4><p>基本通信原理</p>
<p>集群元数据的维护有两种方式：集中式、Gossip式。</p>
<p>分布式寻址算法</p>
<ul>
<li>hash算法（大量缓存重建）</li>
<li>一致性hash算法（自动缓存迁移）+虚拟节点（自动负载均衡）</li>
<li>redis cluster的hash slot算法</li>
</ul>
<p>优点</p>
<ul>
<li>无中心结构，支持动态扩容，对业务透明</li>
<li>只能使用0号数据库</li>
<li>不支持批量操作（pipeline管道操作）</li>
<li>分布式逻辑和存储模块耦合</li>
</ul>
<h3 id="16、基于客户端分配"><a href="#16、基于客户端分配" class="headerlink" title="16、基于客户端分配"></a>16、基于客户端分配</h3><p><img src="/../images/21.jpeg" alt="21"></p>
<h4 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h4><p>Redis Sharding是Redis Cluster出来之前，业界普遍使用的多Redis实例集群方法。其主要思想是采用哈希算法将Redis数据的key进行散列，通过hash函数，特定的key会映射到特定的Redis节点上。java redis客户端驱动jedis，支持Redis Sharding功能。</p>
<p>优点</p>
<ul>
<li>优势在于非常简单，服务端的Redis实例彼此独立，相互关联，每个Redis实例像单服务器一样运行，非常容易线性扩展，系统的灵活性很强。</li>
</ul>
<p>缺点</p>
<ul>
<li>由于sharding处理放到客户端，规模进一步扩大时给运维带来挑战。</li>
<li>客户端sharding不支持动态增删节点。服务端Redis实例群拓扑结构有变化时，每个客户都需要更新调整。连接不能共享，当应用规模增大时，资源浪费制约优化。</li>
</ul>
<h3 id="17、基于代理服务器分片"><a href="#17、基于代理服务器分片" class="headerlink" title="17、基于代理服务器分片"></a>17、基于代理服务器分片</h3><p><img src="/../images/22.jpeg" alt="22"></p>
<h4 id="简介-2"><a href="#简介-2" class="headerlink" title="简介"></a>简介</h4><p>客户端发送请求到一个代理组件，代理解析客户端的数据，并将请求转发至正确的节点，最后将结果回复给客户端。</p>
<h4 id="特征"><a href="#特征" class="headerlink" title="特征"></a>特征</h4><ul>
<li>透明接入，业务程序不用关心后端Redis实例，切换成本低</li>
<li>Proxy的逻辑和存储的逻辑是隔离的</li>
<li>代理层多了一次转发，性能有所损耗</li>
</ul>
<h4 id="业务开源方案"><a href="#业务开源方案" class="headerlink" title="业务开源方案"></a>业务开源方案</h4><ul>
<li>Twitter开源的Twenproxy</li>
<li>豌豆荚开源的Codis</li>
</ul>
<h3 id="18、Redis的主从架构"><a href="#18、Redis的主从架构" class="headerlink" title="18、Redis的主从架构"></a>18、Redis的主从架构</h3><p>单机的redis，能够承载的QPS大概就在上千万到几万不等。对于缓存来说，一般都支持读高并发的。因此架构做成主从（master-slave）架构，一主多从，主负责写，并且将数据复制到其他的slave节点，从节点负责读。所有的读请求全部走从节点。这样也可以很轻松实现水平扩容，支持读高并发。</p>
<p><img src="/../images/23.png" alt="23"></p>
<p>redis replication-&gt;主从架构-&gt;读写分离-&gt;水平扩容支持读高并发</p>
<h4 id="redis-replication的核心机制"><a href="#redis-replication的核心机制" class="headerlink" title="redis replication的核心机制"></a>redis replication的核心机制</h4><ul>
<li>redis采用异步方式复制数据到slave节点，不过从redis2.8开始，slave node会周期性地确认自己每次复制的数据量。</li>
<li>一个master node是可以配置多个slave node的。</li>
<li>slave node可以连接其他的slave node。</li>
<li>slave node做复制的时候，不会block master node的正常工作。</li>
<li>slave node在做复制的时候，也不会对自己的查询的操作，他会用旧的数据集来提供服务；但是复制完成的时候，需要删除数据集，加载新的数据集，这个时候，就会暂停对外服务。</li>
<li>slave node主要用来进行横向扩容，做读写分离，扩容的slave node可以提纲哦吞吐量。</li>
</ul>
<p>注意，如果采用了主从架构，那么建议必须开启 master node 的持久化，不建议用 slave node 作为 master node 的数据热备，因为那样的话，如果你关掉 master 的持久化，可能在 master 宕机重启的时候数据是空的，然后可能一经过复制， slave node 的数据也丢了。</p>
<p>另外，master 的各种备份方案，也需要做。万一本地的所有文件丢失了，从备份中挑选一份 rdb 去恢复master，这样才能确保启动的时候，是有数据的，即使采用了后续讲解的高可用机制，slave node 可以自动接管 master node，但也可能 sentinel 还没检测到 master failure，master node 就自动重启了，还是可能导致上面所有的 slave node 数据被清空。</p>
<h4 id="redis主从复制的核心原理"><a href="#redis主从复制的核心原理" class="headerlink" title="redis主从复制的核心原理"></a>redis主从复制的核心原理</h4><p>当启动一个slave node的时候，它会发送一个<code>PSYNC</code>命令给master node。</p>
<p>如果这是slave node初次连接到master node，那么会触发一次<code>full resynchronization</code>全量复制。此时，master会启动一个后台程序，开始生成一份<code>RDB</code>快照文件，同时还会将从客户端client新收到的所有写命令缓存在内存中。<code>RDB</code>文件生成完毕后，master会将这个<code>RDB</code>发送给slave，slave会写入本地磁盘，然后再从本地磁盘加载到内存中，接着master会将内存中缓存的写命令发送给slave，slave也会同步这些数据。slave node如果跟master node有网络故障，断开了连接，会自动重连，连接之后master node仅会复制给slave部分缺失的数据。</p>
<p><img src="/../images/24.png" alt="24"></p>
<p>过程原理</p>
<ul>
<li>当从库和主库建立MS关系后，会向主数据库发送<code>SYNC</code>命令。</li>
<li>主库接收到SYNC命令后，会开始在后台保存快照（RDB持久化过程），并将期间接收到的命令缓存起来。</li>
<li>当快照完成后，主Redis会将快照文件和所有缓存的写命令发送给从Redis。</li>
<li>从Redis接收到后，会载入快照文件并且执行收到的缓存命令。</li>
<li>主Redis每当接收到写命令时就会将命令发送给从Redis，从而保证数据的一致。</li>
</ul>
<p>缺点</p>
<ul>
<li>所有的slave节点数据的复制和同步都由master节点处理，会造成master节点压力过大。</li>
</ul>
<h3 id="19、Redis集群的主从复制模型是怎样的？"><a href="#19、Redis集群的主从复制模型是怎样的？" class="headerlink" title="19、Redis集群的主从复制模型是怎样的？"></a>19、Redis集群的主从复制模型是怎样的？</h3><p>为了使在部分节点失败或者大部分节点无法通信的情况下集群仍然可用，所以集群使用了主从复制模型，每个节点都会有N-1个复制品。</p>
<h3 id="20、生产环境中redis是怎么部署的？"><a href="#20、生产环境中redis是怎么部署的？" class="headerlink" title="20、生产环境中redis是怎么部署的？"></a>20、生产环境中redis是怎么部署的？</h3><p>redis cluster，10 台机器，5 台机器部署了 redis 主实例，另外 5 台机器部署了 redis 的从实例，每个主实例挂了一个从实例，5 个节点对外提供读写服务，每个节点的读写高峰qps可能可以达到每秒 5 万，5 台机器最多是 25 万读写请求&#x2F;s。</p>
<p>机器是什么配置？32G 内存+ 8 核 CPU + 1T 磁盘，但是分配给 redis 进程的是10g内存，一般线上生产环境，redis 的内存尽量不要超过 10g，超过 10g 可能会有问题。</p>
<p>5 台机器对外提供读写，一共有 50g 内存。</p>
<p>因为每个主实例都挂了一个从实例，所以是高可用的，任何一个主实例宕机，都会自动故障迁移，redis 从实例会自动变成主实例继续提供读写服务。</p>
<p>你往内存里写的是什么数据？每条数据的大小是多少？商品数据，每条数据是 10kb。100 条数据是 1mb，10 万条数据是 1g。常驻内存的是 200 万条商品数据，占用内存是 20g，仅仅不到总内存的 50%。目前高峰期每秒就是 3500 左右的请求量。</p>
<p>其实大型的公司，会有基础架构的 team 负责缓存集群的运维。</p>
<h3 id="21、说说Redis哈希槽的概念？"><a href="#21、说说Redis哈希槽的概念？" class="headerlink" title="21、说说Redis哈希槽的概念？"></a>21、说说Redis哈希槽的概念？</h3><p>Redis集群没有使用一致性hash,而是引入了哈希槽的概念，Redis集群有16384个哈希槽，每个key通过CRC16校验后对16384取模来决定放置哪个槽，集群的每个节点负责一部分hash槽。</p>
<h3 id="22、Redis集群会有写操作丢失吗？"><a href="#22、Redis集群会有写操作丢失吗？" class="headerlink" title="22、Redis集群会有写操作丢失吗？"></a>22、Redis集群会有写操作丢失吗？</h3><p>Redis并不能保证数据的强一致性，这意味这在实际中集群在特定的条件下可能会丢失写操作。</p>
<h3 id="23、Redis集群之间是如何复制的？"><a href="#23、Redis集群之间是如何复制的？" class="headerlink" title="23、Redis集群之间是如何复制的？"></a>23、Redis集群之间是如何复制的？</h3><p>异步复制。</p>
<h3 id="24、Redis集群最大节点个数是多少？"><a href="#24、Redis集群最大节点个数是多少？" class="headerlink" title="24、Redis集群最大节点个数是多少？"></a>24、Redis集群最大节点个数是多少？</h3><p>16384个。</p>
<h3 id="25、Redis集群如何选择数据库？"><a href="#25、Redis集群如何选择数据库？" class="headerlink" title="25、Redis集群如何选择数据库？"></a>25、Redis集群如何选择数据库？</h3><p>Redis集群目前无法做数据库选择，默认在0数据库。</p>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>项目实战-仿牛客网社区开发</title>
    <url>/2022/03/25/%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/</url>
    <content><![CDATA[<p><strong>仿牛客网社区论坛</strong></p>
<span id="more"></span>

<p>项目名称：仿牛客网社区论坛</p>
<p>项目开发语言：JAVA</p>
<p>开发环境：Windows7+、Centos7</p>
<p>集成开发工具：IntelliJ IDEA 2019</p>
<p>文件传输：Xshell 5</p>
<p>版本控制工具：Git</p>
<p>数据库可视化工具：Navicat</p>
<p>数据库系统：MySQL 5.5、Redis 6.2</p>
<p>应用服务器：Apache Tomcat 8.x</p>
<p>构建工具：Apache Maven 3.x</p>
<p>项目核心技术：Spring、SpringMVC、MyBatis、SpringBoot、Redis、Kafka、Elasticsearch、Spring security、Spring Actuator</p>
<p>项目核心功能：SSM—-社区首页开发</p>
<p>​                            SpringBoot—-社区登录模块、过滤敏感词、事务管理等.</p>
<p>​                            Redis—–整合springboot，高性能存储.</p>
<p>​                            Kafka——构建TB级别异步消息系统.</p>
<p>​                            Elasticsearch—–开发社区搜索功能.</p>
<p>​                            项目进阶—–整合spring security，构建高效安全的企业业务.</p>
<h3 id="配置文件application-properties"><a href="#配置文件application-properties" class="headerlink" title="配置文件application.properties"></a>配置文件application.properties</h3><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment"># ServerProperties</span></span><br><span class="line"><span class="attr">server.port</span>=<span class="string">8080</span></span><br><span class="line"><span class="attr">server.servlet.context-path</span>=<span class="string">/community</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"># ThymeleafProperties</span></span><br><span class="line"><span class="attr">spring.thymeleaf.cache</span>=<span class="string">false</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"># DataSourceProperties</span></span><br><span class="line"><span class="attr">spring.datasource.driver-class-name</span>=<span class="string">com.mysql.jdbc.Driver</span></span><br><span class="line"><span class="attr">spring.datasource.url</span>=<span class="string">jdbc:mysql://localhost:3306/community?characterEncoding=utf-8&amp;useSSL=false&amp;serverTimezone=Hongkong</span></span><br><span class="line"><span class="attr">spring.datasource.username</span>=<span class="string">root</span></span><br><span class="line"><span class="attr">spring.datasource.password</span>=<span class="string">root</span></span><br><span class="line"><span class="attr">spring.datasource.type</span>=<span class="string">com.zaxxer.hikari.HikariDataSource</span></span><br><span class="line"><span class="attr">spring.datasource.hikari.maximum-pool-size</span>=<span class="string">15</span></span><br><span class="line"><span class="attr">spring.datasource.hikari.minimum-idle</span>=<span class="string">5</span></span><br><span class="line"><span class="attr">spring.datasource.hikari.idle-timeout</span>=<span class="string">30000</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"># MyBatisProperties</span></span><br><span class="line"><span class="attr">mybatis.mapper-locations</span>=<span class="string">classpath:mapper/*.xml</span></span><br><span class="line"><span class="attr">mybatis.type-aliases-package</span>=<span class="string">com.tzd.community.entity</span></span><br><span class="line"><span class="attr">mybatis.configuration.use-generated-keys</span>=<span class="string">true</span></span><br><span class="line"><span class="attr">mybatis.configuration.map-underscore-to-camel-case</span>=<span class="string">true</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"># logger</span></span><br><span class="line"><span class="comment">#logging.level.com.tzd.community=debug</span></span><br><span class="line"><span class="comment">#logging.file.path=h:/community/community.log</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"># MailProperties</span></span><br><span class="line"><span class="attr">spring.mail.host</span>=<span class="string">smtp.sina.com</span></span><br><span class="line"><span class="attr">spring.mail.port</span>=<span class="string">465</span></span><br><span class="line"><span class="attr">spring.mail.username</span>=<span class="string">tianzedeng@sina.cn</span></span><br><span class="line"><span class="attr">spring.mail.password</span>=<span class="string">a39cbaa2835b8880</span></span><br><span class="line"><span class="attr">spring.mail.protocol</span>=<span class="string">smtps</span></span><br><span class="line"><span class="attr">spring.mail.properties.mail.smtp.ssl.enable</span>=<span class="string">true</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"># community</span></span><br><span class="line"><span class="attr">community.path.domain</span>=<span class="string">http://localhost:8080</span></span><br><span class="line"><span class="attr">community.path.upload</span>=<span class="string">h:/project/data/upload</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"># RedisProperties</span></span><br><span class="line"><span class="attr">spring.redis.database</span>=<span class="string">11</span></span><br><span class="line"><span class="attr">spring.redis.host</span>=<span class="string">localhost</span></span><br><span class="line"><span class="attr">spring.redis.port</span>=<span class="string">6379</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"># 注意：一定要关闭虚拟机的防火墙！！！！</span></span><br><span class="line"><span class="comment"># KafkaProperties</span></span><br><span class="line"><span class="attr">spring.kafka.bootstrap-servers</span>=<span class="string">192.168.66.3:9092</span></span><br><span class="line"><span class="attr">spring.kafka.consumer.group-id</span>=<span class="string">test-consumer-group</span></span><br><span class="line"><span class="attr">spring.kafka.consumer.enable-auto-commit</span>=<span class="string">true</span></span><br><span class="line"><span class="attr">spring.kafka.consumer.auto-commit-interval</span>=<span class="string">3000</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"># ElasticsearchProperties(注意springboot和es的版本问题)</span></span><br><span class="line"><span class="attr">spring.data.elasticsearch.cluster-name</span>=<span class="string">tzd</span></span><br><span class="line"><span class="attr">spring.data.elasticsearch.cluster-nodes</span>=<span class="string">127.0.0.1:9300</span></span><br><span class="line"></span><br><span class="line"><span class="attr">spring.main.allow-bean-definition-overriding</span>=<span class="string">true</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"># TaskExecutionProperties</span></span><br><span class="line"><span class="attr">spring.task.execution.pool.core-size</span>=<span class="string">5</span></span><br><span class="line"><span class="attr">spring.task.execution.pool.max-size</span>=<span class="string">15</span></span><br><span class="line"><span class="attr">spring.task.execution.pool.queue-capacity</span>=<span class="string">100</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"># TaskSchedulingProperties</span></span><br><span class="line"><span class="attr">spring.task.scheduling.pool.size</span>=<span class="string">5</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"># QuartzProperties</span></span><br><span class="line"><span class="attr">spring.quartz.job-store-type</span>=<span class="string">jdbc</span></span><br><span class="line"><span class="attr">spring.quartz.scheduler-name</span>=<span class="string">communityScheduler</span></span><br><span class="line"><span class="attr">spring.quartz.properties.org.quartz.scheduler.instanceId</span>=<span class="string">AUTO</span></span><br><span class="line"><span class="attr">spring.quartz.properties.org.quartz.jobStore.class</span>=<span class="string">org.quartz.impl.jdbcjobstore.JobStoreTX</span></span><br><span class="line"><span class="attr">spring.quartz.properties.org.quartz.jobStore.driverDelegateClass</span>=<span class="string">org.quartz.impl.jdbcjobstore.StdJDBCDelegate</span></span><br><span class="line"><span class="attr">spring.quartz.properties.org.quartz.jobStore.isClustered</span>=<span class="string">true</span></span><br><span class="line"><span class="attr">spring.quartz.properties.org.quartz.threadPool.class</span>=<span class="string">org.quartz.simpl.SimpleThreadPool</span></span><br><span class="line"><span class="attr">spring.quartz.properties.org.quartz.threadPool.threadCount</span>=<span class="string">5</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"># wk</span></span><br><span class="line"><span class="attr">wk.image.command</span>=<span class="string">e:/wkhtmltopdf/bin/wkhtmltoimage</span></span><br><span class="line"><span class="attr">wk.image.storage</span>=<span class="string">h:/project/data/wk-images</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"># qiniu</span></span><br><span class="line"><span class="attr">qiniu.key.access</span>=<span class="string">Y7cn8X71N5ujSHSb71ZZrQTrSzmCGbajvuAWqh5s</span></span><br><span class="line"><span class="attr">qiniu.key.secret</span>=<span class="string">4GzMiXe0L9rkgzUzaF4661PlmgWMheuLxEsBUvNX</span></span><br><span class="line"><span class="attr">qiniu.bucket.header.name</span>=<span class="string">tianzedeng</span></span><br><span class="line"><span class="attr">qiniu.bucket.header.url</span>=<span class="string">http://raiibt9ye.hb-bkt.clouddn.com</span></span><br><span class="line"><span class="attr">qiniu.bucket.share.name</span>=<span class="string">tianzhedeng</span></span><br><span class="line"><span class="attr">qiniu.bucket.share.url</span>=<span class="string">http://raijyoyfg.hb-bkt.clouddn.com</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"># caffine</span></span><br><span class="line"><span class="attr">caffeine.posts.max-size</span>=<span class="string">15</span></span><br><span class="line"><span class="attr">caffeine.posts.expire-seconds</span>=<span class="string">180</span></span><br></pre></td></tr></table></figure>

<h3 id="pom-xml依赖文件"><a href="#pom-xml依赖文件" class="headerlink" title="pom.xml依赖文件"></a>pom.xml依赖文件</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span> <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.1.5.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">relativePath</span>/&gt;</span> <span class="comment">&lt;!-- lookup parent from repository --&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.tzd.community<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>community<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">name</span>&gt;</span>community<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">description</span>&gt;</span>community<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">java.version</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-aop<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-thymeleaf<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-devtools<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.47<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis.spring.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-mail<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.6.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.commons<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-lang3<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.github.penggle<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>kaptcha<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.3.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>fastjson<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.62<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.kafka<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-kafka<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-elasticsearch<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-security<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.thymeleaf.extras<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>thymeleaf-extras-springsecurity5<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-quartz<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.qiniu<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>qiniu-java-sdk<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">version</span>&gt;</span>7.2.23<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.github.ben-manes.caffeine<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>caffeine<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.8.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">   <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line">   <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-resources-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-surefire-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.22.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">skipTests</span>&gt;</span></span><br><span class="line">                  true</span><br><span class="line">               <span class="tag">&lt;/<span class="name">skipTests</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="社区首页开发"><a href="#社区首页开发" class="headerlink" title="社区首页开发"></a>社区首页开发</h3><p>首页index.html代码如下：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!doctype <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span> <span class="attr">xmlns:th</span>=<span class="string">&quot;http://www.thymeleaf.org&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1, shrink-to-fit=no&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">&lt;!--访问该页面时，在此处生成CSRF令牌--&gt;</span></span><br><span class="line">	<span class="comment">&lt;!--&lt;meta name=&quot;_csrf&quot; th:content=&quot;$&#123;_csrf.token&#125;&quot;&gt;</span></span><br><span class="line"><span class="comment">	&lt;meta name=&quot;_csrf_header&quot; th:content=&quot;$&#123;_csrf.headerName&#125;&quot; &gt;--&gt;</span></span><br><span class="line"></span><br><span class="line">	<span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;icon&quot;</span> <span class="attr">href</span>=<span class="string">&quot;https://static.nowcoder.com/images/logo_87_87.png&quot;</span>/&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">href</span>=<span class="string">&quot;https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css&quot;</span> <span class="attr">crossorigin</span>=<span class="string">&quot;anonymous&quot;</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">th:href</span>=<span class="string">&quot;@&#123;/css/global.css&#125;&quot;</span> /&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">title</span>&gt;</span>牛客网-首页<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span>	</span><br><span class="line">	<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;nk-container&quot;</span>&gt;</span></span><br><span class="line">		<span class="comment">&lt;!-- 头部 --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">header</span> <span class="attr">class</span>=<span class="string">&quot;bg-dark sticky-top&quot;</span> <span class="attr">th:fragment</span>=<span class="string">&quot;header&quot;</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;container&quot;</span>&gt;</span></span><br><span class="line">				<span class="comment">&lt;!-- 导航 --&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">nav</span> <span class="attr">class</span>=<span class="string">&quot;navbar navbar-expand-lg navbar-dark&quot;</span>&gt;</span></span><br><span class="line">					<span class="comment">&lt;!-- logo --&gt;</span></span><br><span class="line">					<span class="tag">&lt;<span class="name">a</span> <span class="attr">class</span>=<span class="string">&quot;navbar-brand&quot;</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">					<span class="tag">&lt;<span class="name">button</span> <span class="attr">class</span>=<span class="string">&quot;navbar-toggler&quot;</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">data-toggle</span>=<span class="string">&quot;collapse&quot;</span> <span class="attr">data-target</span>=<span class="string">&quot;#navbarSupportedContent&quot;</span> <span class="attr">aria-controls</span>=<span class="string">&quot;navbarSupportedContent&quot;</span> <span class="attr">aria-expanded</span>=<span class="string">&quot;false&quot;</span> <span class="attr">aria-label</span>=<span class="string">&quot;Toggle navigation&quot;</span>&gt;</span></span><br><span class="line">						<span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;navbar-toggler-icon&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">					<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">					<span class="comment">&lt;!-- 功能 --&gt;</span></span><br><span class="line">					<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;collapse navbar-collapse&quot;</span> <span class="attr">id</span>=<span class="string">&quot;navbarSupportedContent&quot;</span>&gt;</span></span><br><span class="line">						<span class="tag">&lt;<span class="name">ul</span> <span class="attr">class</span>=<span class="string">&quot;navbar-nav mr-auto&quot;</span>&gt;</span></span><br><span class="line">							<span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">&quot;nav-item ml-3 btn-group-vertical&quot;</span>&gt;</span></span><br><span class="line">								<span class="tag">&lt;<span class="name">a</span> <span class="attr">class</span>=<span class="string">&quot;nav-link&quot;</span> <span class="attr">th:href</span>=<span class="string">&quot;@&#123;/index&#125;&quot;</span>&gt;</span>首页<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">							<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">							<span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">&quot;nav-item ml-3 btn-group-vertical&quot;</span> <span class="attr">th:if</span>=<span class="string">&quot;$&#123;loginUser!=null&#125;&quot;</span>&gt;</span></span><br><span class="line">								<span class="tag">&lt;<span class="name">a</span> <span class="attr">class</span>=<span class="string">&quot;nav-link position-relative&quot;</span> <span class="attr">th:href</span>=<span class="string">&quot;@&#123;/letter/list&#125;&quot;</span>&gt;</span>消息<span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;badge badge-danger&quot;</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;allUnreadCount!=0?allUnreadCount:&#x27;&#x27;&#125;&quot;</span>&gt;</span>12<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">							<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">							<span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">&quot;nav-item ml-3 btn-group-vertical&quot;</span> <span class="attr">th:if</span>=<span class="string">&quot;$&#123;loginUser==null&#125;&quot;</span>&gt;</span></span><br><span class="line">								<span class="tag">&lt;<span class="name">a</span> <span class="attr">class</span>=<span class="string">&quot;nav-link&quot;</span> <span class="attr">th:href</span>=<span class="string">&quot;@&#123;/register&#125;&quot;</span>&gt;</span>注册<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">							<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">							<span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">&quot;nav-item ml-3 btn-group-vertical&quot;</span> <span class="attr">th:if</span>=<span class="string">&quot;$&#123;loginUser==null&#125;&quot;</span>&gt;</span></span><br><span class="line">								<span class="tag">&lt;<span class="name">a</span> <span class="attr">class</span>=<span class="string">&quot;nav-link&quot;</span> <span class="attr">th:href</span>=<span class="string">&quot;@&#123;/login&#125;&quot;</span>&gt;</span>登录<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">							<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">							<span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">&quot;nav-item ml-3 btn-group-vertical dropdown&quot;</span> <span class="attr">th:if</span>=<span class="string">&quot;$&#123;loginUser!=null&#125;&quot;</span>&gt;</span></span><br><span class="line">								<span class="tag">&lt;<span class="name">a</span> <span class="attr">class</span>=<span class="string">&quot;nav-link dropdown-toggle&quot;</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span> <span class="attr">id</span>=<span class="string">&quot;navbarDropdown&quot;</span> <span class="attr">role</span>=<span class="string">&quot;button&quot;</span> <span class="attr">data-toggle</span>=<span class="string">&quot;dropdown&quot;</span> <span class="attr">aria-haspopup</span>=<span class="string">&quot;true&quot;</span> <span class="attr">aria-expanded</span>=<span class="string">&quot;false&quot;</span>&gt;</span></span><br><span class="line">									<span class="tag">&lt;<span class="name">img</span> <span class="attr">th:src</span>=<span class="string">&quot;$&#123;loginUser.headerUrl&#125;&quot;</span> <span class="attr">class</span>=<span class="string">&quot;rounded-circle&quot;</span> <span class="attr">style</span>=<span class="string">&quot;width:30px;&quot;</span>/&gt;</span></span><br><span class="line">								<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">								<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;dropdown-menu&quot;</span> <span class="attr">aria-labelledby</span>=<span class="string">&quot;navbarDropdown&quot;</span>&gt;</span></span><br><span class="line">									<span class="tag">&lt;<span class="name">a</span> <span class="attr">class</span>=<span class="string">&quot;dropdown-item text-center&quot;</span> <span class="attr">th:href</span>=<span class="string">&quot;@&#123;|/user/profile/$&#123;loginUser.id&#125;|&#125;&quot;</span>&gt;</span>个人主页<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">									<span class="tag">&lt;<span class="name">a</span> <span class="attr">class</span>=<span class="string">&quot;dropdown-item text-center&quot;</span> <span class="attr">th:href</span>=<span class="string">&quot;@&#123;/user/setting&#125;&quot;</span>&gt;</span>账号设置<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">									<span class="tag">&lt;<span class="name">a</span> <span class="attr">class</span>=<span class="string">&quot;dropdown-item text-center&quot;</span> <span class="attr">th:href</span>=<span class="string">&quot;@&#123;/logout&#125;&quot;</span>&gt;</span>退出登录<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">									<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;dropdown-divider&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">									<span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;dropdown-item text-center text-secondary&quot;</span> <span class="attr">th:utext</span>=<span class="string">&quot;$&#123;loginUser.username&#125;&quot;</span>&gt;</span>nowcoder<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">								<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">							<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">						<span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">						<span class="comment">&lt;!-- 搜索 --&gt;</span></span><br><span class="line">						<span class="tag">&lt;<span class="name">form</span> <span class="attr">class</span>=<span class="string">&quot;form-inline my-2 my-lg-0&quot;</span> <span class="attr">method</span>=<span class="string">&quot;get&quot;</span> <span class="attr">th:action</span>=<span class="string">&quot;@&#123;/search&#125;&quot;</span>&gt;</span></span><br><span class="line">							<span class="tag">&lt;<span class="name">input</span> <span class="attr">class</span>=<span class="string">&quot;form-control mr-sm-2&quot;</span> <span class="attr">type</span>=<span class="string">&quot;search&quot;</span> <span class="attr">aria-label</span>=<span class="string">&quot;Search&quot;</span> <span class="attr">name</span>=<span class="string">&quot;keyword&quot;</span> <span class="attr">th:value</span>=<span class="string">&quot;$&#123;keyword&#125;&quot;</span>/&gt;</span></span><br><span class="line">							<span class="tag">&lt;<span class="name">button</span> <span class="attr">class</span>=<span class="string">&quot;btn btn-outline-light my-2 my-sm-0&quot;</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span>&gt;</span>搜索<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">						<span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line">					<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;/<span class="name">nav</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">header</span>&gt;</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">&lt;!-- 内容 --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;main&quot;</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;container&quot;</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;position-relative&quot;</span>&gt;</span></span><br><span class="line">					<span class="comment">&lt;!-- 筛选条件 --&gt;</span></span><br><span class="line">					<span class="tag">&lt;<span class="name">ul</span> <span class="attr">class</span>=<span class="string">&quot;nav nav-tabs mb-3&quot;</span>&gt;</span></span><br><span class="line">						<span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">&quot;nav-item&quot;</span>&gt;</span></span><br><span class="line">							<span class="tag">&lt;<span class="name">a</span> <span class="attr">th:class</span>=<span class="string">&quot;|nav-link $&#123;orderMode==0?&#x27;active&#x27;:&#x27;&#x27;&#125;|&quot;</span> <span class="attr">th:href</span>=<span class="string">&quot;@&#123;/index(orderMode=0)&#125;&quot;</span>&gt;</span>最新<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">						<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">						<span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">&quot;nav-item&quot;</span>&gt;</span></span><br><span class="line">							<span class="tag">&lt;<span class="name">a</span> <span class="attr">th:class</span>=<span class="string">&quot;|nav-link $&#123;orderMode==1?&#x27;active&#x27;:&#x27;&#x27;&#125;|&quot;</span>  <span class="attr">th:href</span>=<span class="string">&quot;@&#123;/index(orderMode=1)&#125;&quot;</span>&gt;</span>最热<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">						<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">					<span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">					<span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">class</span>=<span class="string">&quot;btn btn-primary btn-sm position-absolute rt-0&quot;</span> <span class="attr">data-toggle</span>=<span class="string">&quot;modal&quot;</span> <span class="attr">data-target</span>=<span class="string">&quot;#publishModal&quot;</span> <span class="attr">th:if</span>=<span class="string">&quot;$&#123;loginUser!=null&#125;&quot;</span>&gt;</span>我要发布<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">				<span class="comment">&lt;!-- 弹出框 --&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;modal fade&quot;</span> <span class="attr">id</span>=<span class="string">&quot;publishModal&quot;</span> <span class="attr">tabindex</span>=<span class="string">&quot;-1&quot;</span> <span class="attr">role</span>=<span class="string">&quot;dialog&quot;</span> <span class="attr">aria-labelledby</span>=<span class="string">&quot;publishModalLabel&quot;</span> <span class="attr">aria-hidden</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line">					<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;modal-dialog modal-lg&quot;</span> <span class="attr">role</span>=<span class="string">&quot;document&quot;</span>&gt;</span></span><br><span class="line">						<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;modal-content&quot;</span>&gt;</span></span><br><span class="line">							<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;modal-header&quot;</span>&gt;</span></span><br><span class="line">								<span class="tag">&lt;<span class="name">h5</span> <span class="attr">class</span>=<span class="string">&quot;modal-title&quot;</span> <span class="attr">id</span>=<span class="string">&quot;publishModalLabel&quot;</span>&gt;</span>新帖发布<span class="tag">&lt;/<span class="name">h5</span>&gt;</span></span><br><span class="line">								<span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">class</span>=<span class="string">&quot;close&quot;</span> <span class="attr">data-dismiss</span>=<span class="string">&quot;modal&quot;</span> <span class="attr">aria-label</span>=<span class="string">&quot;Close&quot;</span>&gt;</span></span><br><span class="line">									<span class="tag">&lt;<span class="name">span</span> <span class="attr">aria-hidden</span>=<span class="string">&quot;true&quot;</span>&gt;</span><span class="symbol">&amp;times;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">								<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">							<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">							<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;modal-body&quot;</span>&gt;</span></span><br><span class="line">								<span class="tag">&lt;<span class="name">form</span>&gt;</span></span><br><span class="line">									<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;form-group&quot;</span>&gt;</span></span><br><span class="line">										<span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;recipient-name&quot;</span> <span class="attr">class</span>=<span class="string">&quot;col-form-label&quot;</span>&gt;</span>标题：<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">										<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">class</span>=<span class="string">&quot;form-control&quot;</span> <span class="attr">id</span>=<span class="string">&quot;recipient-name&quot;</span>&gt;</span></span><br><span class="line">									<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">									<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;form-group&quot;</span>&gt;</span></span><br><span class="line">										<span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;message-text&quot;</span> <span class="attr">class</span>=<span class="string">&quot;col-form-label&quot;</span>&gt;</span>正文：<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">										<span class="tag">&lt;<span class="name">textarea</span> <span class="attr">class</span>=<span class="string">&quot;form-control&quot;</span> <span class="attr">id</span>=<span class="string">&quot;message-text&quot;</span> <span class="attr">rows</span>=<span class="string">&quot;15&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">textarea</span>&gt;</span></span><br><span class="line">									<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">								<span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line">							<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">							<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;modal-footer&quot;</span>&gt;</span></span><br><span class="line">								<span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">class</span>=<span class="string">&quot;btn btn-secondary&quot;</span> <span class="attr">data-dismiss</span>=<span class="string">&quot;modal&quot;</span>&gt;</span>取消<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">								<span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">class</span>=<span class="string">&quot;btn btn-primary&quot;</span> <span class="attr">id</span>=<span class="string">&quot;publishBtn&quot;</span>&gt;</span>发布<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">							<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">						<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">					<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">				<span class="comment">&lt;!-- 提示框 --&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;modal fade&quot;</span> <span class="attr">id</span>=<span class="string">&quot;hintModal&quot;</span> <span class="attr">tabindex</span>=<span class="string">&quot;-1&quot;</span> <span class="attr">role</span>=<span class="string">&quot;dialog&quot;</span> <span class="attr">aria-labelledby</span>=<span class="string">&quot;hintModalLabel&quot;</span> <span class="attr">aria-hidden</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line">					<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;modal-dialog modal-lg&quot;</span> <span class="attr">role</span>=<span class="string">&quot;document&quot;</span>&gt;</span></span><br><span class="line">						<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;modal-content&quot;</span>&gt;</span></span><br><span class="line">							<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;modal-header&quot;</span>&gt;</span></span><br><span class="line">								<span class="tag">&lt;<span class="name">h5</span> <span class="attr">class</span>=<span class="string">&quot;modal-title&quot;</span> <span class="attr">id</span>=<span class="string">&quot;hintModalLabel&quot;</span>&gt;</span>提示<span class="tag">&lt;/<span class="name">h5</span>&gt;</span></span><br><span class="line">							<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">							<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;modal-body&quot;</span> <span class="attr">id</span>=<span class="string">&quot;hintBody&quot;</span>&gt;</span></span><br><span class="line">								发布完毕!</span><br><span class="line">							<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">						<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">					<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">				</span><br><span class="line">				<span class="comment">&lt;!-- 帖子列表 --&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">ul</span> <span class="attr">class</span>=<span class="string">&quot;list-unstyled&quot;</span>&gt;</span></span><br><span class="line">					<span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">&quot;media pb-3 pt-3 mb-3 border-bottom&quot;</span> <span class="attr">th:each</span>=<span class="string">&quot;map:$&#123;discussPosts&#125;&quot;</span>&gt;</span></span><br><span class="line">						<span class="tag">&lt;<span class="name">a</span> <span class="attr">th:href</span>=<span class="string">&quot;@&#123;|/user/profile/$&#123;map.user.id&#125;|&#125;&quot;</span>&gt;</span></span><br><span class="line">							<span class="tag">&lt;<span class="name">img</span> <span class="attr">th:src</span>=<span class="string">&quot;$&#123;map.user.headerUrl&#125;&quot;</span> <span class="attr">class</span>=<span class="string">&quot;mr-4 rounded-circle&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;用户头像&quot;</span> <span class="attr">style</span>=<span class="string">&quot;width:50px;height:50px;&quot;</span>&gt;</span></span><br><span class="line">						<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">						<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;media-body&quot;</span>&gt;</span></span><br><span class="line">							<span class="tag">&lt;<span class="name">h6</span> <span class="attr">class</span>=<span class="string">&quot;mt-0 mb-3&quot;</span>&gt;</span></span><br><span class="line">								<span class="tag">&lt;<span class="name">a</span> <span class="attr">th:href</span>=<span class="string">&quot;@&#123;|/discuss/detail/$&#123;map.post.id&#125;|&#125;&quot;</span> <span class="attr">th:utext</span>=<span class="string">&quot;$&#123;map.post.title&#125;&quot;</span>&gt;</span>备战春招，面试刷题跟他复习，一个月全搞定！<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">								<span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;badge badge-secondary bg-primary&quot;</span> <span class="attr">th:if</span>=<span class="string">&quot;$&#123;map.post.type==1&#125;&quot;</span>&gt;</span>置顶<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">								<span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;badge badge-secondary bg-danger&quot;</span> <span class="attr">th:if</span>=<span class="string">&quot;$&#123;map.post.status==1&#125;&quot;</span>&gt;</span>精华<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">							<span class="tag">&lt;/<span class="name">h6</span>&gt;</span></span><br><span class="line">							<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;text-muted font-size-12&quot;</span>&gt;</span></span><br><span class="line">								<span class="tag">&lt;<span class="name">u</span> <span class="attr">class</span>=<span class="string">&quot;mr-3&quot;</span> <span class="attr">th:utext</span>=<span class="string">&quot;$&#123;map.user.username&#125;&quot;</span>&gt;</span>寒江雪<span class="tag">&lt;/<span class="name">u</span>&gt;</span> 发布于 <span class="tag">&lt;<span class="name">b</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;#dates.format(map.post.createTime,&#x27;yyyy-MM-dd HH:mm:ss&#x27;)&#125;&quot;</span>&gt;</span>2019-04-15 15:32:18<span class="tag">&lt;/<span class="name">b</span>&gt;</span></span><br><span class="line">								<span class="tag">&lt;<span class="name">ul</span> <span class="attr">class</span>=<span class="string">&quot;d-inline float-right&quot;</span>&gt;</span></span><br><span class="line">									<span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">&quot;d-inline ml-2&quot;</span>&gt;</span>赞 <span class="tag">&lt;<span class="name">span</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;map.likeCount&#125;&quot;</span>&gt;</span>11<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">									<span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">&quot;d-inline ml-2&quot;</span>&gt;</span>|<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">									<span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">&quot;d-inline ml-2&quot;</span>&gt;</span>回帖 <span class="tag">&lt;<span class="name">span</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;map.post.commentCount&#125;&quot;</span>&gt;</span>7<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">								<span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">							<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">						<span class="tag">&lt;/<span class="name">div</span>&gt;</span>						</span><br><span class="line">					<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">				<span class="comment">&lt;!-- 分页 --&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">nav</span> <span class="attr">class</span>=<span class="string">&quot;mt-5&quot;</span> <span class="attr">th:if</span>=<span class="string">&quot;$&#123;page.rows&gt;0&#125;&quot;</span> <span class="attr">th:fragment</span>=<span class="string">&quot;pagination&quot;</span>&gt;</span></span><br><span class="line">					<span class="tag">&lt;<span class="name">ul</span> <span class="attr">class</span>=<span class="string">&quot;pagination justify-content-center&quot;</span>&gt;</span></span><br><span class="line">						<span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">&quot;page-item&quot;</span>&gt;</span></span><br><span class="line">							<span class="tag">&lt;<span class="name">a</span> <span class="attr">class</span>=<span class="string">&quot;page-link&quot;</span> <span class="attr">th:href</span>=<span class="string">&quot;@&#123;$&#123;page.path&#125;(current=1)&#125;&quot;</span>&gt;</span>首页<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">						<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">						<span class="tag">&lt;<span class="name">li</span> <span class="attr">th:class</span>=<span class="string">&quot;|page-item $&#123;page.current==1?&#x27;disabled&#x27;:&#x27;&#x27;&#125;|&quot;</span>&gt;</span></span><br><span class="line">							<span class="tag">&lt;<span class="name">a</span> <span class="attr">class</span>=<span class="string">&quot;page-link&quot;</span> <span class="attr">th:href</span>=<span class="string">&quot;@&#123;$&#123;page.path&#125;(current=$&#123;page.current-1&#125;)&#125;&quot;</span>&gt;</span>上一页<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">						<span class="tag">&lt;<span class="name">li</span> <span class="attr">th:class</span>=<span class="string">&quot;|page-item $&#123;i==page.current?&#x27;active&#x27;:&#x27;&#x27;&#125;|&quot;</span> <span class="attr">th:each</span>=<span class="string">&quot;i:$&#123;#numbers.sequence(page.from,page.to)&#125;&quot;</span>&gt;</span></span><br><span class="line">							<span class="tag">&lt;<span class="name">a</span> <span class="attr">class</span>=<span class="string">&quot;page-link&quot;</span> <span class="attr">th:href</span>=<span class="string">&quot;@&#123;$&#123;page.path&#125;(current=$&#123;i&#125;)&#125;&quot;</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;i&#125;&quot;</span>&gt;</span>1<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">						<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">						<span class="tag">&lt;<span class="name">li</span> <span class="attr">th:class</span>=<span class="string">&quot;|page-item $&#123;page.current==page.total?&#x27;disabled&#x27;:&#x27;&#x27;&#125;|&quot;</span>&gt;</span></span><br><span class="line">							<span class="tag">&lt;<span class="name">a</span> <span class="attr">class</span>=<span class="string">&quot;page-link&quot;</span> <span class="attr">th:href</span>=<span class="string">&quot;@&#123;$&#123;page.path&#125;(current=$&#123;page.current+1&#125;)&#125;&quot;</span>&gt;</span>下一页<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">						<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">						<span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">&quot;page-item&quot;</span>&gt;</span></span><br><span class="line">							<span class="tag">&lt;<span class="name">a</span> <span class="attr">class</span>=<span class="string">&quot;page-link&quot;</span> <span class="attr">th:href</span>=<span class="string">&quot;@&#123;$&#123;page.path&#125;(current=$&#123;page.total&#125;)&#125;&quot;</span>&gt;</span>末页<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">						<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">					<span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;/<span class="name">nav</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">	<span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://code.jquery.com/jquery-3.3.1.min.js&quot;</span> <span class="attr">crossorigin</span>=<span class="string">&quot;anonymous&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.7/umd/popper.min.js&quot;</span> <span class="attr">crossorigin</span>=<span class="string">&quot;anonymous&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/js/bootstrap.min.js&quot;</span> <span class="attr">crossorigin</span>=<span class="string">&quot;anonymous&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">script</span> <span class="attr">th:src</span>=<span class="string">&quot;@&#123;/js/global.js&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">script</span> <span class="attr">th:src</span>=<span class="string">&quot;@&#123;js/index.js&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>效果图如下：</p>
<p><img src="/../images/82.PNG" alt="82"></p>
<h3 id="开发社区登录模块"><a href="#开发社区登录模块" class="headerlink" title="开发社区登录模块"></a>开发社区登录模块</h3><p>效果图如下：</p>
<p><img src="/../images/83.PNG" alt="83"></p>
<p><img src="/../images/84.PNG" alt="84"></p>
<h3 id="前缀树算法过滤敏感词"><a href="#前缀树算法过滤敏感词" class="headerlink" title="前缀树算法过滤敏感词"></a>前缀树算法过滤敏感词</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.tzd.community.util;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.commons.lang3.CharUtils;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.lang3.StringUtils;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.Logger;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.LoggerFactory;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.annotation.PostConstruct;</span><br><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> tianzedeng</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2022/4/8 - 14:59</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SensitiveFilter</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> LoggerFactory.getLogger(SensitiveFilter.class);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//替换符</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">REPLACEMENT</span> <span class="operator">=</span> <span class="string">&quot;***&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.初始化前缀树</span></span><br><span class="line">    <span class="comment">//根节点</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">TrieNode</span> <span class="variable">rootNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TrieNode</span>();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">try</span>(</span><br><span class="line">                <span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> <span class="built_in">this</span>.getClass().getClassLoader()</span><br><span class="line">                .getResourceAsStream(<span class="string">&quot;sensitive-words.txt&quot;</span>);</span><br><span class="line">                <span class="type">BufferedReader</span> <span class="variable">bufferedReader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(inputStream));</span><br><span class="line">        )&#123;</span><br><span class="line">                String keyword;</span><br><span class="line">                <span class="keyword">while</span> ((keyword = bufferedReader.readLine()) != <span class="literal">null</span>)&#123;</span><br><span class="line">                    <span class="comment">//添加到前缀树</span></span><br><span class="line">                    <span class="built_in">this</span>.addKeyword(keyword);</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">            logger.error(<span class="string">&quot;加载敏感词文件失败！&quot;</span> + e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将一个敏感词添加到前缀树</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">addKeyword</span><span class="params">(String keyword)</span>&#123;</span><br><span class="line">        <span class="type">TrieNode</span> <span class="variable">tempNode</span> <span class="operator">=</span> rootNode;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;keyword.length();i++)&#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> keyword.charAt(i);</span><br><span class="line">            <span class="type">TrieNode</span> <span class="variable">subNode</span> <span class="operator">=</span> tempNode.getSubNode(c);</span><br><span class="line">            <span class="keyword">if</span> (subNode==<span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="comment">//初始化子节点</span></span><br><span class="line">                subNode = <span class="keyword">new</span> <span class="title class_">TrieNode</span>();</span><br><span class="line">                tempNode.addSubNode(c,subNode);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//指向子节点，进入下一轮循环</span></span><br><span class="line">            tempNode = subNode;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//设置结束标识</span></span><br><span class="line">            <span class="keyword">if</span> (i == keyword.length()-<span class="number">1</span>)&#123;</span><br><span class="line">                tempNode.setKeywordEnd(<span class="literal">true</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 3.过滤敏感词</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> text 待过滤的文本</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 过滤后的文本</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">filter</span><span class="params">(String text)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(StringUtils.isBlank(text))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//指针1----指向根节点</span></span><br><span class="line">        <span class="type">TrieNode</span> <span class="variable">tempNode</span> <span class="operator">=</span> rootNode;</span><br><span class="line">        <span class="comment">//指针2---</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">begin</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//指针3</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">position</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//结果</span></span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">stringBuilder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (position &lt; text.length())&#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> text.charAt(position);</span><br><span class="line">            <span class="comment">//跳过符号</span></span><br><span class="line">            <span class="keyword">if</span> (isSymbol(c))&#123;</span><br><span class="line">                <span class="comment">//如果指针1处于根节点，将此符号计入结果，让指针2向下走一步</span></span><br><span class="line">                <span class="keyword">if</span> (tempNode == rootNode)&#123;</span><br><span class="line">                    stringBuilder.append(c);</span><br><span class="line">                    begin++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//无论符号在开头或中间，指针3都向下走一步</span></span><br><span class="line">                position++;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//检查下级节点</span></span><br><span class="line">            tempNode = tempNode.getSubNode(c);</span><br><span class="line">            <span class="keyword">if</span> (tempNode == <span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="comment">//以begin为开头的字符串不是敏感词</span></span><br><span class="line">                stringBuilder.append(text.charAt(begin));</span><br><span class="line">                <span class="comment">//进入下一个位置</span></span><br><span class="line">                position = ++begin;</span><br><span class="line">                <span class="comment">//重新指向根节点</span></span><br><span class="line">                tempNode = rootNode;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> (tempNode.isKeywordEnd())&#123;</span><br><span class="line">                <span class="comment">//发现敏感词，将begin到position的字符串替换掉</span></span><br><span class="line">                stringBuilder.append(REPLACEMENT);</span><br><span class="line">                <span class="comment">//进入下一个位置</span></span><br><span class="line">                begin = ++position;</span><br><span class="line">                <span class="comment">//重新指向根节点</span></span><br><span class="line">                tempNode = rootNode;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//检查下一个字符</span></span><br><span class="line">                position++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//将最后一批字符计入结果</span></span><br><span class="line">        stringBuilder.append(text.substring(begin));</span><br><span class="line">        <span class="keyword">return</span> stringBuilder.toString();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//判断是否为符号</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">isSymbol</span><span class="params">(Character c)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> !CharUtils.isAsciiAlphanumeric(c) &amp;&amp; (c&lt;<span class="number">0x2E80</span> || c&gt;<span class="number">0x9FFF</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//1.前缀树</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">TrieNode</span>&#123;</span><br><span class="line">        <span class="comment">//关键词结束的标识</span></span><br><span class="line">        <span class="keyword">private</span> <span class="type">boolean</span> <span class="variable">isKeywordEnd</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//子节点(key是下级节点字符，value是下级节点)</span></span><br><span class="line">        <span class="keyword">private</span> Map&lt;Character,TrieNode&gt; subNodes = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isKeywordEnd</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> isKeywordEnd;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setKeywordEnd</span><span class="params">(<span class="type">boolean</span> keywordEnd)</span> &#123;</span><br><span class="line">            isKeywordEnd = keywordEnd;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//添加子节点</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addSubNode</span><span class="params">(Character character,TrieNode node)</span>&#123;</span><br><span class="line">            subNodes.put(character,node);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//获取子节点</span></span><br><span class="line">        <span class="keyword">public</span> TrieNode <span class="title function_">getSubNode</span><span class="params">(Character character)</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> subNodes.get(character);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="记录日志"><a href="#记录日志" class="headerlink" title="记录日志"></a>记录日志</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">contextName</span>&gt;</span>community<span class="tag">&lt;/<span class="name">contextName</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;LOG_PATH&quot;</span> <span class="attr">value</span>=<span class="string">&quot;H:/project/data&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;APPDIR&quot;</span> <span class="attr">value</span>=<span class="string">&quot;community&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- error file --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">&quot;FILE_ERROR&quot;</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">file</span>&gt;</span>$&#123;LOG_PATH&#125;/$&#123;APPDIR&#125;/log_error.log<span class="tag">&lt;/<span class="name">file</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">rollingPolicy</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.core.rolling.TimeBasedRollingPolicy&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">fileNamePattern</span>&gt;</span>$&#123;LOG_PATH&#125;/$&#123;APPDIR&#125;/error/log-error-%d&#123;yyyy-MM-dd&#125;.%i.log<span class="tag">&lt;/<span class="name">fileNamePattern</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">timeBasedFileNamingAndTriggeringPolicy</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.core.rolling.SizeAndTimeBasedFNATP&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">maxFileSize</span>&gt;</span>5MB<span class="tag">&lt;/<span class="name">maxFileSize</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">timeBasedFileNamingAndTriggeringPolicy</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">maxHistory</span>&gt;</span>30<span class="tag">&lt;/<span class="name">maxHistory</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">rollingPolicy</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">append</span>&gt;</span>true<span class="tag">&lt;/<span class="name">append</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">encoder</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.classic.encoder.PatternLayoutEncoder&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">pattern</span>&gt;</span>%d %level [%thread] %logger&#123;10&#125; [%file:%line] %msg%n<span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">charset</span>&gt;</span>utf-8<span class="tag">&lt;/<span class="name">charset</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">encoder</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.classic.filter.LevelFilter&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">level</span>&gt;</span>error<span class="tag">&lt;/<span class="name">level</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">onMatch</span>&gt;</span>ACCEPT<span class="tag">&lt;/<span class="name">onMatch</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">onMismatch</span>&gt;</span>DENY<span class="tag">&lt;/<span class="name">onMismatch</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- warn file --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">&quot;FILE_WARN&quot;</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">file</span>&gt;</span>$&#123;LOG_PATH&#125;/$&#123;APPDIR&#125;/log_warn.log<span class="tag">&lt;/<span class="name">file</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">rollingPolicy</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.core.rolling.TimeBasedRollingPolicy&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">fileNamePattern</span>&gt;</span>$&#123;LOG_PATH&#125;/$&#123;APPDIR&#125;/warn/log-warn-%d&#123;yyyy-MM-dd&#125;.%i.log<span class="tag">&lt;/<span class="name">fileNamePattern</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">timeBasedFileNamingAndTriggeringPolicy</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.core.rolling.SizeAndTimeBasedFNATP&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">maxFileSize</span>&gt;</span>5MB<span class="tag">&lt;/<span class="name">maxFileSize</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">timeBasedFileNamingAndTriggeringPolicy</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">maxHistory</span>&gt;</span>30<span class="tag">&lt;/<span class="name">maxHistory</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">rollingPolicy</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">append</span>&gt;</span>true<span class="tag">&lt;/<span class="name">append</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">encoder</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.classic.encoder.PatternLayoutEncoder&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">pattern</span>&gt;</span>%d %level [%thread] %logger&#123;10&#125; [%file:%line] %msg%n<span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">charset</span>&gt;</span>utf-8<span class="tag">&lt;/<span class="name">charset</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">encoder</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.classic.filter.LevelFilter&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">level</span>&gt;</span>warn<span class="tag">&lt;/<span class="name">level</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">onMatch</span>&gt;</span>ACCEPT<span class="tag">&lt;/<span class="name">onMatch</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">onMismatch</span>&gt;</span>DENY<span class="tag">&lt;/<span class="name">onMismatch</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- info file --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">&quot;FILE_INFO&quot;</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">file</span>&gt;</span>$&#123;LOG_PATH&#125;/$&#123;APPDIR&#125;/log_info.log<span class="tag">&lt;/<span class="name">file</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">rollingPolicy</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.core.rolling.TimeBasedRollingPolicy&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">fileNamePattern</span>&gt;</span>$&#123;LOG_PATH&#125;/$&#123;APPDIR&#125;/info/log-info-%d&#123;yyyy-MM-dd&#125;.%i.log<span class="tag">&lt;/<span class="name">fileNamePattern</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">timeBasedFileNamingAndTriggeringPolicy</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.core.rolling.SizeAndTimeBasedFNATP&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">maxFileSize</span>&gt;</span>5MB<span class="tag">&lt;/<span class="name">maxFileSize</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">timeBasedFileNamingAndTriggeringPolicy</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">maxHistory</span>&gt;</span>30<span class="tag">&lt;/<span class="name">maxHistory</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">rollingPolicy</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">append</span>&gt;</span>true<span class="tag">&lt;/<span class="name">append</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">encoder</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.classic.encoder.PatternLayoutEncoder&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">pattern</span>&gt;</span>%d %level [%thread] %logger&#123;10&#125; [%file:%line] %msg%n<span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">charset</span>&gt;</span>utf-8<span class="tag">&lt;/<span class="name">charset</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">encoder</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.classic.filter.LevelFilter&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">level</span>&gt;</span>info<span class="tag">&lt;/<span class="name">level</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">onMatch</span>&gt;</span>ACCEPT<span class="tag">&lt;/<span class="name">onMatch</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">onMismatch</span>&gt;</span>DENY<span class="tag">&lt;/<span class="name">onMismatch</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- console --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">&quot;STDOUT&quot;</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.core.ConsoleAppender&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">encoder</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">pattern</span>&gt;</span>%d %level [%thread] %logger&#123;10&#125; [%file:%line] %msg%n<span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">charset</span>&gt;</span>utf-8<span class="tag">&lt;/<span class="name">charset</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">encoder</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.classic.filter.ThresholdFilter&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">level</span>&gt;</span>debug<span class="tag">&lt;/<span class="name">level</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">logger</span> <span class="attr">name</span>=<span class="string">&quot;com.tzd.community&quot;</span> <span class="attr">level</span>=<span class="string">&quot;debug&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">root</span> <span class="attr">level</span>=<span class="string">&quot;info&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">&quot;FILE_ERROR&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">&quot;FILE_WARN&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">&quot;FILE_INFO&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">&quot;STDOUT&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">root</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="Redis处理点赞、关注、热帖排行"><a href="#Redis处理点赞、关注、热帖排行" class="headerlink" title="Redis处理点赞、关注、热帖排行"></a>Redis处理点赞、关注、热帖排行</h3><p>效果图：</p>
<p><img src="/../images/85.PNG" alt="85"></p>
<p><img src="/../images/92.PNG" alt="92"></p>
<p><img src="/../images/91.PNG" alt="91"></p>
<h3 id="kafka处理系统通知"><a href="#kafka处理系统通知" class="headerlink" title="kafka处理系统通知"></a>kafka处理系统通知</h3><p>效果图：</p>
<p><img src="/../images/89.PNG" alt="89"></p>
<p><img src="/../images/90.PNG" alt="90"></p>
<h3 id="Elasticsearch实现分布式搜索功能"><a href="#Elasticsearch实现分布式搜索功能" class="headerlink" title="Elasticsearch实现分布式搜索功能"></a>Elasticsearch实现分布式搜索功能</h3><p>效果图：</p>
<p><img src="/../images/86.PNG" alt="86"></p>
<h3 id="Spring-Security实现权限控制"><a href="#Spring-Security实现权限控制" class="headerlink" title="Spring Security实现权限控制"></a>Spring Security实现权限控制</h3><p>效果图：</p>
<p><img src="/../images/87.PNG" alt="87"></p>
<p><img src="/../images/88.PNG" alt="88"></p>
]]></content>
      <categories>
        <category>项目实战</category>
      </categories>
      <tags>
        <tag>项目实战</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式</title>
    <url>/2022/03/03/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h3 id="JAVA常见的几种设计模式解读"><a href="#JAVA常见的几种设计模式解读" class="headerlink" title="JAVA常见的几种设计模式解读"></a>JAVA常见的几种设计模式解读</h3><p>设计模式（Design pattern）代表了最佳的实践，通常被有经验的面向对象的软件开发人员所采用。设计模式是软件开发人员在软件开发过程中面临的一般问题的解决方案。这些解决方案是众多软件开发人员经过相当长的一段时间的试验和错误总结出来的。</p>
<span id="more"></span>

<h4 id="单例模式（Singleton-Pattern）"><a href="#单例模式（Singleton-Pattern）" class="headerlink" title="单例模式（Singleton Pattern）"></a>单例模式（Singleton Pattern）</h4><ol>
<li><p>懒汉式，线程不安全</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span> <span class="params">()</span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="literal">null</span>)&#123;</span><br><span class="line">            instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当多个线程并行调用getInstance()的时候，就会创建多个实例。在多线程下不能工作。</p>
</li>
<li><p>懒汉式，线程安全</p>
<p>为了解决上述问题，将整个getInstance()方法设置为同步(synchronized).</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(singleton == <span class="literal">null</span>)&#123;</span><br><span class="line">        instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>虽然做到了线程安全，并且也解决了多实例问题，但是并不高效。因为在任何时候只能有一个线程调用getInstance()方法。但是同步操作只需要在第一次调用时才被需要，即第一次创建单例实例对象时。这就引出了双重检验锁。</p>
</li>
<li><p>双重检验锁</p>
<p>双重检验锁模式（double checked locking pattern），是一种使用同步块加锁的方法。程序员称其为双重检查锁，因为会有两次检查 <code>instance == null</code>，一次是在同步块外，一次是在同步块内。为什么在同步块内还要再检验一次？因为可能会有多个线程一起进入同步块外的 if，如果在同步块内不进行二次检验的话就会生成多个实例了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getSingleton</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(instance == <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">synchronized</span>(Singleton.class)&#123;</span><br><span class="line">            <span class="keyword">if</span>(instance == <span class="literal">null</span>)&#123;</span><br><span class="line">                instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码看起来很完美，很可惜，它是有问题。主要在于<code>instance = new Singleton()</code>这句，这并非是一个原子操作，事实上在 JVM 中这句话大概做了下面 3 件事情。</p>
<ul>
<li>给 instance 分配内存</li>
<li>调用 Singleton 的构造函数来初始化成员变量</li>
<li>将instance对象指向分配的内存空间（执行完这步 instance 就为非 null 了）</li>
</ul>
<p>但是在 JVM 的即时编译器中存在指令重排序的优化。也就是说上面的第二步和第三步的顺序是不能保证的，最终的执行顺序可能是 1-2-3 也可能是 1-3-2。如果是后者，则在 3 执行完毕、2 未执行之前，被线程二抢占了，这时 instance 已经是非 null 了（但却没有初始化），所以线程二会直接返回 instance，然后使用，然后顺理成章地报错。</p>
<p>我们只需要将 instance 变量声明成 volatile 就可以了.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton instance; <span class="comment">//声明成 volatile</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span> <span class="params">()</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getSingleton</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;                         </span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;       </span><br><span class="line">                    instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有些人认为使用 volatile 的原因是可见性，也就是可以保证线程在本地不会存有 instance 的副本，每次都是去主内存中读取。但其实是不对的。使用 volatile 的主要原因是其另一个特性：禁止指令重排序优化。也就是说，在 volatile 变量的赋值操作后面会有一个内存屏障（生成的汇编代码上），读操作不会被重排序到内存屏障之前。比如上面的例子，取操作必须在执行完 1-2-3 之后或者 1-3-2 之后，不存在执行到 1-3 然后取到值的情况。从「先行发生原则」的角度理解的话，就是对于一个 volatile 变量的写操作都先行发生于后面对这个变量的读操作（这里的“后面”是时间上的先后顺序）。</p>
<p>但是特别注意在 Java 5 以前的版本使用了 volatile 的双检锁还是有问题的。其原因是 Java 5 以前的 JMM （Java 内存模型）是存在缺陷的，即时将变量声明成 volatile 也不能完全避免重排序，主要是 volatile 变量前后的代码仍然存在重排序问题。这个 volatile 屏蔽重排序的问题在 Java 5 中才得以修复，所以在这之后才可以放心使用 volatile。</p>
</li>
<li><p>饿汉式</p>
<p>这种方法非常简单，因为单例的实例被声明成 static 和 final 变量了，在第一次加载类到内存中时就会初始化，所以创建实例本身是线程安全的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span>&#123;</span><br><span class="line">    <span class="comment">//类加载时就初始化</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Singleton</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种写法如果完美的话，就没必要在啰嗦那么多双检锁的问题了。缺点是它不是一种懒加载模式（lazy initialization），单例会在加载类后一开始就被初始化，即使客户端没有调用 getInstance()方法。饿汉式的创建方式在一些场景中将无法使用：譬如 Singleton 实例的创建是依赖参数或者配置文件的，在 getInstance() 之前必须调用某个方法设置参数给它，那样这种单例写法就无法使用了。</p>
</li>
<li><p>静态内部类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">SingletonHolder</span> &#123;  </span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Singleton</span> <span class="variable">INSTANCE</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton</span>();  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span> <span class="params">()</span>&#123;&#125;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;  </span><br><span class="line">        <span class="keyword">return</span> SingletonHolder.INSTANCE; </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种写法仍然使用JVM本身机制保证了线程安全问题；由于 SingletonHolder 是私有的，除了 getInstance() 之外没有办法访问它，因此它是懒汉式的；同时读取实例的时候不会进行同步，没有性能缺陷；也不依赖 JDK 版本。</p>
</li>
<li><p>枚举</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">EasySingleton</span>&#123;</span><br><span class="line">    INSTANCE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以通过EasySingleton.INSTANCE来访问实例，这比调用getInstance()方法简单多了。创建枚举默认就是线程安全的，所以不需要担心double checked locking，而且还能防止反序列化导致重新创建新的对象。</p>
</li>
</ol>
<h4 id="工厂模式（Factory-Pattern）"><a href="#工厂模式（Factory-Pattern）" class="headerlink" title="工厂模式（Factory Pattern）"></a>工厂模式（Factory Pattern）</h4><p>工厂顾名思义就是创建产品，根据产品是具体产品还是具体工厂可分为简单工厂模式和工厂方法模式，根据工厂的抽象程度可分为工厂方法模式和抽象工厂模式。该模式用于封装和管理对象的创建，是一种创建型模式。</p>
<ol>
<li><p>简单工厂模式</p>
<p>该模式对对象创建管理方式最为简单，因为其仅仅简单的对不同类对象的创建进行了一层薄薄的封装。该模式通过向工厂传递类型来指定要创建的对象，其UML类图如下：</p>
<p><img src="/../images/62.png" alt="62"></p>
<p>使用手机生产来讲解该模式：</p>
<p>Phone类：手机标准规范类（AbstractProduct）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Phone</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">make</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>MiPhone类：制造小米手机（Product1）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MiPhone</span> <span class="keyword">implements</span> <span class="title class_">Phone</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MiPhone</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.make();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">make</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">        System.out.println(<span class="string">&quot;make xiaomi phone!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>IPhone类：制造苹果手机（Product2）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IPhone</span> <span class="keyword">implements</span> <span class="title class_">Phone</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">IPhone</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.make();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">make</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">        System.out.println(<span class="string">&quot;make iphone!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>PhoneFactory类：手机工厂（Factory）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PhoneFactory</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> Phone <span class="title function_">makePhone</span><span class="params">(String phoneType)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(phoneType.equalsIgnoreCase(<span class="string">&quot;MiPhone&quot;</span>))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MiPhone</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(phoneType.equalsIgnoreCase(<span class="string">&quot;iPhone&quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">IPhone</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Demo类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] arg)</span> &#123;</span><br><span class="line">        <span class="type">PhoneFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PhoneFactory</span>();</span><br><span class="line">        <span class="type">Phone</span> <span class="variable">miPhone</span> <span class="operator">=</span> factory.makePhone(<span class="string">&quot;MiPhone&quot;</span>);            <span class="comment">// make xiaomi phone!</span></span><br><span class="line">        <span class="type">IPhone</span> <span class="variable">iPhone</span> <span class="operator">=</span> (IPhone)factory.makePhone(<span class="string">&quot;iPhone&quot;</span>);    <span class="comment">// make iphone!</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>工厂方法模式</p>
<p>和简单工厂模式中工厂负责生产所有产品相比，工厂方法模式将生成具体产品的任务分发给具体的产品工厂，其UML类图如下：</p>
<p><img src="/../images/63.png" alt="63"></p>
<p>也就是定义一个抽象工厂，其定义了产品的生产接口，但不负责具体的产品，将生产任务交给不同的派生类工厂。这样不用通过指定类型来创建对象了。</p>
<p>接下来继续使用生产手机的例子来讲解该模式。</p>
<p>其中和产品相关的Phone类、MiPhone类和IPhone类的定义不变。</p>
<p>AbstractFactory类：生产不同产品的工厂的抽象类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">AbstractFactory</span> &#123;</span><br><span class="line">    Phone <span class="title function_">makePhone</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>XiaoMiFactory类：生产小米手机的工厂（ConcreteFactory1）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">XiaoMiFactory</span> <span class="keyword">implements</span> <span class="title class_">AbstractFactory</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Phone <span class="title function_">makePhone</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MiPhone</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>AppleFactory类：生产苹果手机的工厂（ConcreteFactory2）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppleFactory</span> <span class="keyword">implements</span> <span class="title class_">AbstractFactory</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Phone <span class="title function_">makePhone</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">IPhone</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>演示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] arg)</span> &#123;</span><br><span class="line">        <span class="type">AbstractFactory</span> <span class="variable">miFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">XiaoMiFactory</span>();</span><br><span class="line">        <span class="type">AbstractFactory</span> <span class="variable">appleFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AppleFactory</span>();</span><br><span class="line">        miFactory.makePhone();            <span class="comment">// make xiaomi phone!</span></span><br><span class="line">        appleFactory.makePhone();        <span class="comment">// make iphone!</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>抽象工厂模式</p>
<p>上面两种模式不管工厂怎么拆分抽象，都只是针对一类产品<strong>Phone</strong>（AbstractProduct），如果要生成另一种产品PC，应该怎么表示呢？</p>
<p>最简单的方式是把2中介绍的工厂方法模式完全复制一份，不过这次生产的是PC。但同时也就意味着我们要完全复制和修改Phone生产管理的所有代码，显然这是一个笨办法，并不利于扩展和维护。</p>
<p>抽象工厂模式通过在AbstarctFactory中增加创建产品的接口，并在具体子工厂中实现新加产品的创建，当然前提是子工厂支持生产该产品。否则继承的这个接口可以什么也不干。</p>
<p>其UML类图如下：</p>
<p><img src="/../images/64.png" alt="64"></p>
<p>从上面类图结构中可以清楚的看到如何在工厂方法模式中通过增加新产品接口来实现产品的增加的。</p>
<p>接下来我们继续通过小米和苹果产品生产的例子来解释该模式。</p>
<p>为了弄清楚上面的结构，我们使用具体的产品和工厂来表示上面的UML类图，能更加清晰的看出模式是如何演变的：</p>
<p><img src="/../images/65.png" alt="65"></p>
</li>
</ol>
<p>PC类：定义PC产品的接口（AbstractPC）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">PC</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">make</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>MiPC类：定义小米电脑产品（MIPC）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MiPC</span> <span class="keyword">implements</span> <span class="title class_">PC</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MiPC</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.make();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">make</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">        System.out.println(<span class="string">&quot;make xiaomi PC!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>MAC类：定义苹果电脑产品（MAC）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MAC</span> <span class="keyword">implements</span> <span class="title class_">PC</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MAC</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.make();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">make</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">        System.out.println(<span class="string">&quot;make MAC!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面需要修改工厂相关的类的定义：</p>
<p>AbstractFactory类：增加PC产品制造接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">AbstractFactory</span> &#123;</span><br><span class="line">    Phone <span class="title function_">makePhone</span><span class="params">()</span>;</span><br><span class="line">    PC <span class="title function_">makePC</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>XiaoMiFactory类：增加小米PC的制造（ConcreteFactory1）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">XiaoMiFactory</span> <span class="keyword">implements</span> <span class="title class_">AbstractFactory</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Phone <span class="title function_">makePhone</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MiPhone</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> PC <span class="title function_">makePC</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MiPC</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>AppleFactory类：增加苹果PC的制造（ConcreteFactory2）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppleFactory</span> <span class="keyword">implements</span> <span class="title class_">AbstractFactory</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Phone <span class="title function_">makePhone</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">IPhone</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> PC <span class="title function_">makePC</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MAC</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>演示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] arg)</span> &#123;</span><br><span class="line">        <span class="type">AbstractFactory</span> <span class="variable">miFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">XiaoMiFactory</span>();</span><br><span class="line">        <span class="type">AbstractFactory</span> <span class="variable">appleFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AppleFactory</span>();</span><br><span class="line">        miFactory.makePhone();            <span class="comment">// make xiaomi phone!</span></span><br><span class="line">        miFactory.makePC();                <span class="comment">// make xiaomi PC!</span></span><br><span class="line">        appleFactory.makePhone();        <span class="comment">// make iphone!</span></span><br><span class="line">        appleFactory.makePC();            <span class="comment">// make MAC!</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="代理模式（Proxy-Pattern）"><a href="#代理模式（Proxy-Pattern）" class="headerlink" title="代理模式（Proxy Pattern）"></a>代理模式（Proxy Pattern）</h4><p>代理模式给某一个对象提供一个代理对象，并由代理对象控制对原对象的引用。通俗的来讲代理模式就是我们生活中常见的中介。代理对象在客户端和目标对象之间起到中介作用，代理模式属于结构性<a href="https://so.csdn.net/so/search?q=%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F&spm=1001.2101.3001.7020">设计模式</a>。使用代理模式主要有两个目的：一是保护目标对象，二是增强目标对象，下面是代理模式的结构类图：</p>
<p><img src="/../images/66.gif" alt="66"></p>
<ol>
<li><p>为什么要用代理模式？</p>
<ul>
<li>中介隔离作用：在某些情况下，一个客户类不想或者不能直接引用一个委托对象，而代理类对象可以在客户类和委托对象之间起到中介的作用，其特征是代理类和委托类实现相同的接口。</li>
<li>开闭原则，增加功能：代理类除了是客户类和委托类的中介之外，我们还可以通过给代理类增加额外的功能来扩展委托类的功能，这样做我们只需要修改代理类而不需要再修改委托类，符合代码设计的开闭原则。代理类主要负责为委托类预处理消息、过滤消息、把消息转发给委托类，以及事后对返回结果的处理等。代理类本身并不真正实现服务，而是同过调用委托类的相关方法，来提供特定的服务。真正的业务功能还是由委托类来实现，但是可以在业务功能执行的前后加入一些公共的服务。例如我们想给项目加入缓存、日志这些功能，我们就可以使用代理类来完成，而没必要打开已经封装好的委托类。</li>
</ul>
</li>
<li><p>有哪几种代理模式？</p>
<p>我们有多种不同的方式来实现代理。如果按照代理创建的时期来进行分类的话， 可以分为两种：静态代理、动态代理。静态代理是由程序员创建或特定工具自动生成源代码，在对其编译。在程序员运行之前，代理类.class文件就已经被创建了。动态代理是在程序运行时通过反射机制动态创建的。</p>
</li>
<li><p>静态代理</p>
<p>创建服务类接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">BuyHouse</span> &#123;</span><br><span class="line">     <span class="keyword">void</span> <span class="title function_">buyHosue</span><span class="params">()</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>实现服务接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BuyHouseImpl</span> <span class="keyword">implements</span> <span class="title class_">BuyHouse</span> &#123;</span><br><span class="line">    </span><br><span class="line">     <span class="meta">@Override</span></span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">buyHosue</span><span class="params">()</span> &#123;</span><br><span class="line">         System.out.println(<span class="string">&quot;我要买房&quot;</span>);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>创建代理类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BuyHouseProxy</span> <span class="keyword">implements</span> <span class="title class_">BuyHouse</span> &#123;</span><br><span class="line"> </span><br><span class="line">     <span class="keyword">private</span> BuyHouse buyHouse;</span><br><span class="line"> </span><br><span class="line">     <span class="keyword">public</span> <span class="title function_">BuyHouseProxy</span><span class="params">(<span class="keyword">final</span> BuyHouse buyHouse)</span> &#123;</span><br><span class="line">         <span class="built_in">this</span>.buyHouse = buyHouse;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="meta">@Override</span></span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">buyHosue</span><span class="params">()</span> &#123;</span><br><span class="line">         System.out.println(<span class="string">&quot;买房前准备&quot;</span>);</span><br><span class="line">         buyHouse.buyHosue();</span><br><span class="line">         System.out.println(<span class="string">&quot;买房后装修&quot;</span>);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>编写测试类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProxyTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">BuyHouse</span> <span class="variable">buyHouse</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BuyHouseImpl</span>();</span><br><span class="line">        buyHouse.buyHosue();</span><br><span class="line">        <span class="type">BuyHouseProxy</span> <span class="variable">buyHouseProxy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BuyHouseProxy</span>(buyHouse);</span><br><span class="line">        buyHouseProxy.buyHosue();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结：</p>
<p>​    优点：可以做到在符合开闭原则的情况下对目标对象进行功能扩展。</p>
<p>​    缺点：我们得为每一个服务都得创建代理类，工作量太大，不易管理。同时接口一旦发生改变，代理类也得相应修改。</p>
</li>
<li><p>动态代理</p>
<p>在动态代理中我们不再需要再手动的创建代理类，我们只需要编写一个动态处理器就可以了。真正的代理对象由JDK再运行时为我们动态的来创建。</p>
<p>编写动态处理器：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DynamicProxyHandler</span> <span class="keyword">implements</span> <span class="title class_">InvocationHandler</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Object object;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">DynamicProxyHandler</span><span class="params">(<span class="keyword">final</span> Object object)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.object = object;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;买房前准备&quot;</span>);</span><br><span class="line">        <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> method.invoke(object, args);</span><br><span class="line">        System.out.println(<span class="string">&quot;买房后装修&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编写测试类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DynamicProxyTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">BuyHouse</span> <span class="variable">buyHouse</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BuyHouseImpl</span>();</span><br><span class="line">        <span class="type">BuyHouse</span> <span class="variable">proxyBuyHouse</span> <span class="operator">=</span> (BuyHouse) Proxy.newProxyInstance(BuyHouse.class.getClassLoader(), <span class="keyword">new</span></span><br><span class="line">                <span class="title class_">Class</span>[]&#123;BuyHouse.class&#125;, <span class="keyword">new</span> <span class="title class_">DynamicProxyHandler</span>(buyHouse));</span><br><span class="line">        proxyBuyHouse.buyHosue();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 注意*Proxy.newProxyInstance()*方法接受三个参数：</p>
<ul>
<li>*ClassLoader loader:*指定当前目标对象使用的类加载器,获取加载器的方法是固定的。</li>
<li>*Class&lt;?&gt;[] interfaces:*指定目标对象实现的接口的类型,使用泛型方式确认类型。</li>
<li><em>InvocationHandler:</em><code>指定``动态处理器，</code>执行目标对象的方法时,会触发事件处理器的方法。</li>
</ul>
<p>总结：</p>
<p>虽然相对于静态代理，动态代理大大减少了我们的开发任务，同时减少了对业务接口的依赖，降低了耦合度。但是还是有一点点小小的遗憾之处，那就是它始终无法摆脱仅支持interface代理的桎梏，因为它的设计注定了这个遗憾。回想一下那些动态生成的代理类的继承关系图，它们已经注定有一个共同的父类叫Proxy。Java的继承机制注定了这些动态代理类们无法实现对class的动态代理，原因是多继承在Java中本质上就行不通。有很多条理由，人们可以否定对 class代理的必要性，但是同样有一些理由，相信支持class动态代理会更美好。接口和类的划分，本就不是很明显，只是到了Java中才变得如此的细化。如果只从方法的声明及是否被定义来考量，有一种两者的混合体，它的名字叫抽象类。实现对抽象类的动态代理，相信也有其内在的价值。此外，还有一些历史遗留的类，它们将因为没有实现任何接口而从此与动态代理永世无缘。如此种种，不得不说是一个小小的遗憾。但是，不完美并不等于不伟大，伟大是一种本质，Java动态代理就是佐例。</p>
</li>
<li><p>CGLIB代理</p>
<p>JDK实现动态代理需要实现类通过接口定义业务方法，对于没有接口的类，如何实现动态代理呢，这就需要CGLib了。CGLib采用了非常底层的字节码技术，其原理是通过字节码技术为一个类创建子类，并在子类中采用方法拦截的技术拦截所有父类方法的调用，顺势织入横切逻辑。但因为采用的是继承，所以不能对final修饰的类进行代理。JDK动态代理与CGLib动态代理均是实现Spring AOP的基础。</p>
<p>创建CGLIB代理类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CglibProxy</span> <span class="keyword">implements</span> <span class="title class_">MethodInterceptor</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Object target;</span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">getInstance</span><span class="params">(<span class="keyword">final</span> Object target)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.target = target;</span><br><span class="line">        <span class="type">Enhancer</span> <span class="variable">enhancer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Enhancer</span>();</span><br><span class="line">        enhancer.setSuperclass(<span class="built_in">this</span>.target.getClass());</span><br><span class="line">        enhancer.setCallback(<span class="built_in">this</span>);</span><br><span class="line">        <span class="keyword">return</span> enhancer.create();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">intercept</span><span class="params">(Object object, Method method, Object[] args, MethodProxy methodProxy)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;买房前准备&quot;</span>);</span><br><span class="line">        <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> methodProxy.invoke(object, args);</span><br><span class="line">        System.out.println(<span class="string">&quot;买房后装修&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建测试类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CglibProxyTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">BuyHouse</span> <span class="variable">buyHouse</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BuyHouseImpl</span>();</span><br><span class="line">        <span class="type">CglibProxy</span> <span class="variable">cglibProxy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CglibProxy</span>();</span><br><span class="line">        <span class="type">BuyHouseImpl</span> <span class="variable">buyHouseCglibProxy</span> <span class="operator">=</span> (BuyHouseImpl) cglibProxy.getInstance(buyHouse);</span><br><span class="line">        buyHouseCglibProxy.buyHosue();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结：</p>
<p>CGLIB创建的动态代理对象比JDK创建的动态代理对象的性能更高，但是CGLIB创建代理对象时所花费的时间却比JDK多得多。所以对于单例的对象，因为无需频繁创建对象，用CGLIB合适，反之使用JDK方式要更为合适一些。同时由于CGLib由于是采用动态创建子类的方法，对于final修饰的方法无法进行代理。</p>
</li>
</ol>
<h4 id="装饰者模式（Decorator-Pattern）"><a href="#装饰者模式（Decorator-Pattern）" class="headerlink" title="装饰者模式（Decorator Pattern）"></a>装饰者模式（Decorator Pattern）</h4><p>动态将职责附加到对象上，若要扩展功能，装饰者提供了比继承更具弹性的代替方案。 </p>
<p><strong>适用性</strong>：</p>
<p>当采用类继承的方式会造成类爆炸的情况。如本文的例子中，基本饮料（被装饰者）可能有茶、水、牛奶等等、可以添加的（装饰者）有糖、果肉、珍珠等。</p>
<p>如果通过<strong>继承</strong>的方式，为每一种类型的奶茶设计一种类会造成类爆炸，同时也不利于后期的扩展（如又添加一种基本饮料豆浆的情况），此时通过装饰者模式可以很好的解决问题。</p>
<p>装饰者模式本质是一种组合的思想（不同于继承的思想），多组合少继承。利用继承设计子类的行为，是在编译时静态决定的，而且所有的子类都会继承到相同的行为。然而，如果能够利用组合的做法扩展对象的行为，就可以在运行时动态地进行扩展。</p>
<p><strong>装饰者模式的主要组成部分</strong>：抽象被装饰者、具体被装饰者、抽象装饰者、具体装饰者。（当只有一个具体被装饰者、一个具体装饰者，其对应的抽象类可以省略）。</p>
<p><img src="/../images/66.png" alt="66"></p>
<p><strong>装饰者模式要点</strong>：</p>
<ol>
<li>多种具体被装饰者（主体类）抽象出一个抽象被装饰类，后面通过多态，动态传递具体对象。</li>
<li>抽象装饰类继承抽象被装饰者（保持接口）；要求传入被装饰者（使用父类应用、protected修饰）。</li>
<li>多种具体装饰者抽象出一个抽象装饰类。</li>
<li>具体装饰者中，可以添加新方法，可以重写方法；需要使用被装饰者方法的地方用传入的被装饰者引用。</li>
</ol>
<p><strong>被装饰抽象类-基本饮料</strong>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">作用：当具体的被装饰类有多种时，抽象提出该抽象类，用于后面实现多态。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">BaseDrink</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="type">int</span> <span class="title function_">calculate</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">display</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>具体的被装饰者类-water类：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">继承抽象的被装饰类，并实现其中的抽象方法。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Water</span> <span class="keyword">extends</span> <span class="title class_">BaseDrink</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">calculate</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">display</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;water&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>具体的被装饰者类-Tea类：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">继承抽象的被装饰者类，并实现其中的抽象方法</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Tea</span> <span class="keyword">extends</span> <span class="title class_">BaseDrink</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">calculate</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">5</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">display</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Tea&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>抽象装饰者类-Decorator：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">要点：1.抽象装饰者类中继承该抽象类以保持接口规范</span></span><br><span class="line"><span class="comment">	 2.包含该抽象类的引用以通过多态的方式对多种被装饰者类进行装饰</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Decorator</span> <span class="keyword">extends</span> <span class="title class_">BaseDrink</span>&#123;  <span class="comment">//继承，保持接口</span></span><br><span class="line">    <span class="keyword">protected</span> BaseDrink bd;  <span class="comment">//引用，多态</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Decorator</span><span class="params">(BaseDrink bd)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.bd = bd;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">calculate</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> bd.calculate();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">display</span><span class="params">()</span> &#123;</span><br><span class="line">        bd.display();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>装饰者类-果肉：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FleshDecorator</span> <span class="keyword">extends</span> <span class="title class_">Decorator</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">FleshDecorator</span><span class="params">(BaseDrink bd)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(bd);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">calculate</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.calculate() + <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">display</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.display();</span><br><span class="line">        System.out.println(<span class="string">&quot;+ flesh&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>装饰者类-糖：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SugarDecorator</span> <span class="keyword">extends</span> <span class="title class_">Decorator</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SugarDecorator</span><span class="params">(BaseDrink bd)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(bd);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">calculate</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.calculate()+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">display</span><span class="params">()</span> &#123;</span><br><span class="line">        bd.display();</span><br><span class="line">        System.out.println(<span class="string">&quot;+ sugar&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addMoreSugar</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;add more sugar&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试用例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestCase</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">BaseDrink</span> <span class="variable">water</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Water</span>();</span><br><span class="line">        <span class="type">SugarDecorator</span> <span class="variable">sugarWater</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SugarDecorator</span>(water);</span><br><span class="line">        sugarWater.addMoreSugar();</span><br><span class="line">        sugarWater.display();</span><br><span class="line">        System.out.println(sugarWater.calculate());</span><br><span class="line">        System.out.println(<span class="string">&quot;=========================&quot;</span>);</span><br><span class="line">        <span class="type">BaseDrink</span> <span class="variable">tea</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Tea</span>();</span><br><span class="line">        <span class="type">FleshDecorator</span> <span class="variable">fleshTea</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FleshDecorator</span>(tea);</span><br><span class="line">        fleshTea.display();</span><br><span class="line">        System.out.println(fleshTea.calculate());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="适配器模式（Adapter-Pattern）"><a href="#适配器模式（Adapter-Pattern）" class="headerlink" title="适配器模式（Adapter Pattern）"></a>适配器模式（Adapter Pattern）</h4><p>适配器模式定义：将一个类的接口，转化成客户期望的另一个接口，适配器让原本接口不兼容的类可以合作无间。</p>
<p><strong>适配器的例子</strong></p>
<p>适配器模式的对象：</p>
<ol>
<li>请求对象（手机）</li>
<li>适配器对象（带有两孔和三孔的插座）</li>
<li>需要适配的对象（三孔插座）</li>
<li>请求对象所需要的接口（插座要有两孔）</li>
</ol>
<p><strong>手机类：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Mobile</span> </span><br><span class="line">     &#123; </span><br><span class="line">         <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">Charge</span><span class="params">(ITwoHole twoHole)</span> </span><br><span class="line">         &#123; </span><br><span class="line">             twoHole.Connect(); </span><br><span class="line">             AddPower(); </span><br><span class="line">         &#125; </span><br><span class="line">         <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">AddPower</span><span class="params">()</span> </span><br><span class="line">         &#123; </span><br><span class="line">             Console.WriteLine(<span class="string">&quot;电量增加中。。。。&quot;</span>); </span><br><span class="line">         &#125; </span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure>

<p><strong>两孔插座接口：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ITwoHole</span> </span><br><span class="line">    &#123; </span><br><span class="line">        <span class="keyword">void</span> <span class="title function_">Connect</span><span class="params">()</span>; </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><strong>三孔插座：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreeHole</span> </span><br><span class="line">    &#123; </span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">Connect</span><span class="params">()</span> </span><br><span class="line">        &#123; </span><br><span class="line">            LeftConnect(); </span><br><span class="line">            RightConnect(); </span><br><span class="line">            ExtraConnect(); </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">LeftConnect</span><span class="params">()</span> </span><br><span class="line">        &#123; </span><br><span class="line">            Console.WriteLine(<span class="string">&quot;零线接通中。。。&quot;</span>); </span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">RightConnect</span><span class="params">()</span> </span><br><span class="line">        &#123; </span><br><span class="line">            Console.WriteLine(<span class="string">&quot;火线接通中。。。。。&quot;</span>); </span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">ExtraConnect</span><span class="params">()</span> </span><br><span class="line">        &#123; </span><br><span class="line">            Console.WriteLine(<span class="string">&quot;底线接通中。。。。&quot;</span>); </span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><strong>插座需要有两孔：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LineWithTwoHole</span> <span class="keyword">implements</span> <span class="title class_">ITwoHole</span> </span><br><span class="line">    &#123; </span><br><span class="line">       <span class="keyword">private</span> ThreeHole threeHole; </span><br><span class="line">       <span class="keyword">public</span> <span class="title function_">LineWithTwoHole</span><span class="params">(ThreeHole threeHole)</span> </span><br><span class="line">       &#123; </span><br><span class="line">           <span class="built_in">this</span>.threeHole = threeHole; </span><br><span class="line">       &#125; </span><br><span class="line">       <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">Connect</span><span class="params">()</span> </span><br><span class="line">       &#123; </span><br><span class="line">           threeHole.LeftConnect(); </span><br><span class="line">           threeHole.RightConnect(); </span><br><span class="line">       &#125; </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><strong>测试：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Program</span> &#123;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">Main</span><span class="params">(string[] args)</span>&#123; </span><br><span class="line">             <span class="type">Mobile</span> <span class="variable">mobile</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Mobile</span>(); </span><br><span class="line">             <span class="type">ThreeHole</span> <span class="variable">threeHole</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreeHole</span>(); </span><br><span class="line">             <span class="type">LineWithTwoHole</span> <span class="variable">lineWithTwoHole</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LineWithTwoHole</span>(threeHole); </span><br><span class="line">            mobile.Charge(lineWithTwoHole); </span><br><span class="line">             Console.ReadKey(); </span><br><span class="line">         &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>适配器模式类图</strong></p>
<p><img src="/../images/67.png" alt="67"></p>
<p>适配器模式的关系：请求对象引用需要适配的接口，适配器引用需要适配对象，适配器需要通过被适配对象来实现需要适配的接口。</p>
<h4 id="外观模式（Facade-Pattern）"><a href="#外观模式（Facade-Pattern）" class="headerlink" title="外观模式（Facade Pattern）"></a>外观模式（Facade Pattern）</h4><p>外观模式定义：外观模式提供了一个统一的接口，用来访问子系统中的一群接口。外观定义了一个高层接口，让子系统更容易使用。</p>
<p><strong>Computer类：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Computer</span> </span><br><span class="line">    &#123; </span><br><span class="line">       <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">Open</span><span class="params">()</span> </span><br><span class="line">       &#123; </span><br><span class="line">           Console.WriteLine(<span class="string">&quot;电脑开了&quot;</span>); </span><br><span class="line">       &#125; </span><br><span class="line">       <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">Close</span><span class="params">()</span> </span><br><span class="line">       &#123; </span><br><span class="line">           Console.WriteLine(<span class="string">&quot;电脑已经关闭了&quot;</span>); </span><br><span class="line">       &#125; </span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p><strong>Light类：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Light</span> </span><br><span class="line">   &#123; </span><br><span class="line">       <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">Open</span><span class="params">()</span> </span><br><span class="line">       &#123; </span><br><span class="line">           Console.WriteLine(<span class="string">&quot;灯开了&quot;</span>); </span><br><span class="line">       &#125; </span><br><span class="line">       <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">Close</span><span class="params">()</span> </span><br><span class="line">       &#123; </span><br><span class="line">           Console.WriteLine(<span class="string">&quot;灯关闭了&quot;</span>); </span><br><span class="line">       &#125; </span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p><strong>Print类：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Print</span> </span><br><span class="line">   &#123; </span><br><span class="line">       <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">Open</span><span class="params">()</span> </span><br><span class="line">       &#123; </span><br><span class="line">           Console.WriteLine(<span class="string">&quot;打印机打开了&quot;</span>); </span><br><span class="line">       &#125; </span><br><span class="line">       <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">Printing</span><span class="params">()</span> </span><br><span class="line">       &#123; </span><br><span class="line">           Console.WriteLine(<span class="string">&quot;打印完成&quot;</span>); </span><br><span class="line">       &#125; </span><br><span class="line">       <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">Close</span><span class="params">()</span> </span><br><span class="line">       &#123; </span><br><span class="line">           Console.WriteLine(<span class="string">&quot;打印机已关闭&quot;</span>); </span><br><span class="line">       &#125; </span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p><strong>Cinema类：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Cinema</span> </span><br><span class="line">  &#123; </span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">Open</span><span class="params">()</span> </span><br><span class="line">      &#123; </span><br><span class="line">          Console.WriteLine(<span class="string">&quot;照相机打开了&quot;</span>); </span><br><span class="line">      &#125; </span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">Close</span><span class="params">()</span> </span><br><span class="line">      &#123; </span><br><span class="line">          Console.WriteLine(<span class="string">&quot;照相机已关闭&quot;</span>); </span><br><span class="line">      &#125; </span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">TakePictures</span><span class="params">()</span> </span><br><span class="line">      &#123; </span><br><span class="line">          Console.WriteLine(<span class="string">&quot;已经拍完了&quot;</span>); </span><br><span class="line">      &#125; </span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p><strong>接口类：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ITakePicture</span> </span><br><span class="line">   &#123; </span><br><span class="line">        <span class="keyword">void</span> <span class="title function_">Open</span><span class="params">()</span>; </span><br><span class="line">        <span class="keyword">void</span> <span class="title function_">TakePictures</span><span class="params">()</span>; </span><br><span class="line">        <span class="keyword">void</span> <span class="title function_">Printing</span><span class="params">()</span>; </span><br><span class="line">        <span class="keyword">void</span> <span class="title function_">Close</span><span class="params">()</span>; </span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p><strong>接口实现类：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TakePicture</span> <span class="keyword">implements</span> <span class="title class_">ITakePicture</span> </span><br><span class="line">   &#123; </span><br><span class="line">       <span class="type">Computer</span> <span class="variable">computer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Computer</span>(); </span><br><span class="line">       <span class="type">Light</span> <span class="variable">light</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Light</span>(); </span><br><span class="line">       <span class="type">Print</span> <span class="variable">print</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Print</span>(); </span><br><span class="line">       <span class="type">Cinema</span> <span class="variable">cinema</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cinema</span>(); </span><br><span class="line">       <span class="keyword">public</span> <span class="title function_">TakePicture</span><span class="params">()</span> </span><br><span class="line">       &#123; </span><br><span class="line">          </span><br><span class="line">       &#125; </span><br><span class="line">       <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">Open</span><span class="params">()</span> </span><br><span class="line">       &#123; </span><br><span class="line">           light.Open(); </span><br><span class="line">           computer.Open(); </span><br><span class="line">           print.Open(); </span><br><span class="line">           cinema.Open(); </span><br><span class="line">       &#125;</span><br><span class="line"> </span><br><span class="line">       <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">TakePictures</span><span class="params">()</span> </span><br><span class="line">       &#123; </span><br><span class="line">           cinema.TakePictures(); </span><br><span class="line">       &#125;</span><br><span class="line"> </span><br><span class="line">       <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">Printing</span><span class="params">()</span> </span><br><span class="line">       &#123; </span><br><span class="line">           print.Printing(); </span><br><span class="line">       &#125;</span><br><span class="line"> </span><br><span class="line">       <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">Close</span><span class="params">()</span> </span><br><span class="line">       &#123; </span><br><span class="line">           light.Close(); </span><br><span class="line">           computer.Close(); </span><br><span class="line">           print.Close(); </span><br><span class="line">           cinema.Close(); </span><br><span class="line">       &#125; </span><br><span class="line">   &#125; </span><br></pre></td></tr></table></figure>

<p><strong>测试类：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Program</span> &#123; </span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">Main</span><span class="params">(string[] args)</span> &#123; </span><br><span class="line">          </span><br><span class="line">      <span class="type">ITakePicture</span> <span class="variable">takephoto</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TakePicture</span>(); </span><br><span class="line">      takephoto.Open(); </span><br><span class="line">      takephoto.TakePictures(); </span><br><span class="line">      takephoto.Printing(); </span><br><span class="line">      takephoto.Close(); </span><br><span class="line">      Console.ReadKey(); </span><br><span class="line">      &#125; </span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>可以看出外观模式的好处是：简化了设备的接口，同时降低了客户端和各个设备的耦合。例如，照相机的照相方法改成了TakePhoto（），那么也只需要在外观的实现方法中修改该设备的方法即可，不用去修改客户端代码。</p>
<h4 id="观察者模式（Observer-Pattern）"><a href="#观察者模式（Observer-Pattern）" class="headerlink" title="观察者模式（Observer Pattern）"></a>观察者模式（Observer Pattern）</h4>]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>JUC高并发编程-ConcurrentHashmap源码分析 - 多线程与高并发</title>
    <url>/2022/05/17/2022-05-17-JUC%E9%AB%98%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-ConcurrentHashmap%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<h1 id="ConcurrentHashmap源码分析"><a href="#ConcurrentHashmap源码分析" class="headerlink" title="ConcurrentHashmap源码分析"></a>ConcurrentHashmap源码分析</h1><span id="more"></span>

<h4 id="JDK7-HashMap并发死链"><a href="#JDK7-HashMap并发死链" class="headerlink" title="JDK7 HashMap并发死链"></a>JDK7 HashMap并发死链</h4><p>测试代码</p>
<p>注意要在JDK7下运行，否则扩容机制和hash的计算方式都变了</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">    <span class="comment">//测试java7中哪些数字的hash结果相等</span></span><br><span class="line">   	System.out.println(<span class="string">&quot;长度为16时，桶下标为1的key&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; <span class="number">64</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(hash(i)%<span class="number">16</span> == <span class="number">1</span>)&#123;</span><br><span class="line">            System.out.prinln(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">&quot;长度为32时，桶下标为1的key&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; <span class="number">64</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(hash(i)%<span class="number">32</span> == <span class="number">1</span>)&#123;</span><br><span class="line">            System.out.prinln(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//1,36,16,50当大小为16时，它们在一个桶内</span></span><br><span class="line">    <span class="keyword">final</span> HashMap&lt;Integer,String&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">//放12个元素</span></span><br><span class="line">    map.put(<span class="number">2</span>,<span class="literal">null</span>);</span><br><span class="line">    map.put(<span class="number">3</span>,<span class="literal">null</span>);</span><br><span class="line">    map.put(<span class="number">4</span>,<span class="literal">null</span>);</span><br><span class="line">    map.put(<span class="number">5</span>,<span class="literal">null</span>);</span><br><span class="line">    map.put(<span class="number">6</span>,<span class="literal">null</span>);</span><br><span class="line">    map.put(<span class="number">7</span>,<span class="literal">null</span>);</span><br><span class="line">    map.put(<span class="number">8</span>,<span class="literal">null</span>);</span><br><span class="line">    map.put(<span class="number">9</span>,<span class="literal">null</span>);</span><br><span class="line">    map.put(<span class="number">10</span>,<span class="literal">null</span>);</span><br><span class="line">    map.put(<span class="number">16</span> ,<span class="literal">null</span>);</span><br><span class="line">    map.put(<span class="number">16</span>,<span class="literal">null</span>);</span><br><span class="line">    map.put(<span class="number">35</span>,<span class="literal">null</span>);</span><br><span class="line">    map.put(<span class="number">1</span>,<span class="literal">null</span>);</span><br><span class="line">    </span><br><span class="line">    System.out.println(<span class="string">&quot;扩容前大小[main]:&quot;</span>+map.size());</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">        <span class="meta">@override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">            <span class="comment">//放第13个元素，发生扩容</span></span><br><span class="line">            map.put(<span class="number">50</span>,<span class="literal">null</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;扩容后大小[Thread-0]:&quot;</span>+map.size());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).start();</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">        <span class="meta">@override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">            <span class="comment">//放第13个元素，发生扩容</span></span><br><span class="line">            map.put(<span class="number">50</span>,<span class="literal">null</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;扩容后大小[Thread-1]:&quot;</span>+map.size());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).start();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">hash</span><span class="params">(Object k)</span>&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">h</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(<span class="number">0</span> != h &amp;&amp; k <span class="keyword">instanceof</span> String)&#123;</span><br><span class="line">        <span class="keyword">return</span> sun.misc.Hashing.stringHash32((String) k);</span><br><span class="line">    &#125;</span><br><span class="line">    h ^= k.hashCode();</span><br><span class="line">    h ^= (h &gt;&gt;&gt; <span class="number">20</span>) ^ (h &gt;&gt;&gt; <span class="number">12</span>);</span><br><span class="line">    <span class="keyword">return</span> h ^ (h &gt;&gt;&gt; <span class="number">7</span>) ^ (h &gt;&gt;&gt; <span class="number">4</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>小结</strong></p>
<ul>
<li>究其原因，是因为在多线程环境下使用了非线程安全的map集合</li>
<li>JDK8虽然将扩容算法做了调整，不再将元素加入链表头（而是保持与扩容前一样的顺序），但仍不意味着能够在多线程环境下能够安全扩容，还会出现其他问题（如扩容丢数据）</li>
</ul>
<h3 id="JDK8"><a href="#JDK8" class="headerlink" title="JDK8"></a>JDK8</h3><h4 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h4><p><img src="/../images/img94.png" alt="img94"></p>
<p>可以发现 Java8 的 ConcurrentHashMap 相对于 Java7 来说变化比较大，不再是之前的 <strong>Segment 数组 + HashEntry 数组 + 链表</strong>，而是 <strong>Node 数组 + 链表 &#x2F; 红黑树</strong>。当冲突链表达到一定长度时，链表会转换成红黑树。</p>
<h4 id="重要属性和内部类"><a href="#重要属性和内部类" class="headerlink" title="重要属性和内部类"></a>重要属性和内部类</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//默认为0</span></span><br><span class="line"><span class="comment">//当初始化时，为-1</span></span><br><span class="line"><span class="comment">//当扩容时，为-(1+扩容线程数)</span></span><br><span class="line"><span class="comment">//当初始化或扩容完成后，为下一次的扩容的阈值大小</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="type">int</span> sizeCtl;</span><br><span class="line"></span><br><span class="line"><span class="comment">//整个ConcurrentHashMap就是一个Node[]</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Node</span>&lt;K,V&gt; <span class="keyword">implements</span> <span class="title class_">Map</span>.Entry&lt;K,V&gt;&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//hash表</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">volatile</span> Node&lt;K,V&gt;[] table;</span><br><span class="line"></span><br><span class="line"><span class="comment">//扩容时的新hash表</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node&lt;K,V&gt;[] nextTable;</span><br><span class="line"></span><br><span class="line"><span class="comment">//扩容时如果某个bin迁移完成，用ForwardingNode作为旧table bin的头结点</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">ForwardingNode</span>&lt;K,V&gt; <span class="keyword">extends</span> <span class="title class_">Node</span>&lt;K,V&gt;&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//用在compute以及computeIfAbsent时，用来占位，计算完成后替换为普通Node</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">ReservationNode</span>&lt;K,V&gt; <span class="keyword">extends</span> <span class="title class_">Node</span>&lt;K,V&gt;&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//作为treebin的头结点，存储root和first</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> TreeBin&lt;K,V&gt; <span class="keyword">extends</span> <span class="title class_">Node</span>&lt;K,V&gt;&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//作为treebin的节点，存储parent，left，right</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">TreeNode</span>&lt;K,V&gt; <span class="keyword">extends</span> <span class="title class_">Node</span>&lt;K,V&gt;&#123;&#125;</span><br></pre></td></tr></table></figure>

<h4 id="重要方法"><a href="#重要方法" class="headerlink" title="重要方法"></a>重要方法</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//获取Node[]中第i个Node</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> &lt;K,V&gt; Node&lt;K,V&gt; <span class="title function_">tabAt</span><span class="params">(Node&lt;K,V&gt;[] tab,<span class="type">int</span> i)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//cas修改Node[]中第i个Node的值，c为旧值，v为新值</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> &lt;K,V&gt; <span class="type">boolean</span> <span class="title function_">casTabAt</span><span class="params">(Node&lt;K,V&gt;[] tab,<span class="type">int</span> i,Node&lt;K,V&gt; c,Node&lt;K,V&gt; v)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//直接修改Node[]中第i个Node的值，v为新值</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> &lt;K,V&gt; <span class="keyword">void</span> <span class="title function_">setTabAt</span><span class="params">(Node&lt;K,V&gt;[] tab,<span class="type">int</span> i,Node&lt;K,V&gt; v)</span>;</span><br></pre></td></tr></table></figure>

<h4 id="构造器分析"><a href="#构造器分析" class="headerlink" title="构造器分析"></a>构造器分析</h4><p>可以看到实现了懒惰初始化，在构造方法中仅仅计算了table的大小，以后在第一次使用时才会真正创建</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ConcurrentHashMap</span><span class="params">(<span class="type">int</span> initialCapacity,<span class="type">float</span> loadFactor,<span class="type">int</span> concurrencyLevel)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!(loadFactor &gt; <span class="number">0.0f</span>) || initialCapacity &lt; <span class="number">0</span> || concurrencyLevel &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>();</span><br><span class="line">    <span class="keyword">if</span>(initialCapacity &lt; concurrentLevel)</span><br><span class="line">        initialCapacity = concurrentLevel;</span><br><span class="line">    <span class="type">long</span> <span class="variable">size</span> <span class="operator">=</span> (<span class="type">long</span>)(<span class="number">1.0</span> + (<span class="type">long</span>)initialCapacity / loadFactor);</span><br><span class="line">    <span class="comment">//tableSizeFor仍然是保证计算的大小是2^n.</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">cap</span> <span class="operator">=</span> (size &gt;= (<span class="type">long</span>)MAXIUM_CAPACITY) ?</span><br><span class="line">        MAXIUM_CAPACITY : tableSizeFor((<span class="type">int</span>)size);</span><br><span class="line">    <span class="built_in">this</span>.sizeCtl = cap;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="get流程"><a href="#get流程" class="headerlink" title="get流程"></a>get流程</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">get</span><span class="params">(Object key)</span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab;</span><br><span class="line">    Node&lt;K,V&gt;[] e,p;</span><br><span class="line">    <span class="type">int</span> n,eh;</span><br><span class="line">    K ek;</span><br><span class="line">    <span class="comment">//spread方法能确保返回结果是正数</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">h</span> <span class="operator">=</span> spread(key.hashCode());</span><br><span class="line">    <span class="keyword">if</span>((tab = table) != <span class="literal">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">      (e = tabAt(tab,(n-<span class="number">1</span>) &amp; h)) != <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="comment">//如果头结点是已经要查找的key</span></span><br><span class="line">        <span class="keyword">if</span>((eh = e.hash) == h)&#123;</span><br><span class="line">            <span class="keyword">if</span>((ek = e.key) == key || (ek != <span class="literal">null</span> &amp;&amp; key.equals(ek)))</span><br><span class="line">                <span class="keyword">return</span> e.val;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//hash为负数表示该bin在扩容中或是treebin，这时调用find方法来查找</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(eh &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> (p = e.find(h,key)) != <span class="literal">null</span> ? p.val : <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">//正常遍历链表，用equals比较</span></span><br><span class="line">        <span class="keyword">while</span>((e = e.next) != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(e.hash == h &amp;&amp; </span><br><span class="line">              ((ek = e.key) == key || (ek != <span class="literal">null</span> &amp;&amp; key.equals(ek))))</span><br><span class="line">              <span class="keyword">return</span> e.val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结一下get过程：</p>
<ol>
<li>根据 hash 值计算位置。</li>
<li>查找到指定位置，如果头节点就是要找的，直接返回它的 value。</li>
<li>如果头节点 hash 值小于 0 ，说明正在扩容或者是红黑树，查找之。</li>
<li>如果是链表，遍历查找之。</li>
</ol>
<h4 id="put流程"><a href="#put流程" class="headerlink" title="put流程"></a>put流程</h4><p>以下数组简称（table），链表简称（bin）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">put</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> putVal(key, value, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Implementation for put and putIfAbsent */</span></span><br><span class="line"><span class="keyword">final</span> V <span class="title function_">putVal</span><span class="params">(K key, V value, <span class="type">boolean</span> onlyIfAbsent)</span> &#123;</span><br><span class="line">    <span class="comment">// key 和 value 不能为空</span></span><br><span class="line">    <span class="keyword">if</span> (key == <span class="literal">null</span> || value == <span class="literal">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">    <span class="type">int</span> <span class="variable">hash</span> <span class="operator">=</span> spread(key.hashCode());</span><br><span class="line">    <span class="type">int</span> <span class="variable">binCount</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (Node&lt;K,V&gt;[] tab = table;;) &#123;</span><br><span class="line">        <span class="comment">// f = 目标位置元素</span></span><br><span class="line">        Node&lt;K,V&gt; f; <span class="type">int</span> n, i, fh;<span class="comment">// fh 后面存放目标位置的元素 hash 值</span></span><br><span class="line">        <span class="keyword">if</span> (tab == <span class="literal">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">            <span class="comment">// 数组桶为空，初始化数组桶（自旋+CAS)</span></span><br><span class="line">            tab = initTable();</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((f = tabAt(tab, i = (n - <span class="number">1</span>) &amp; hash)) == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 桶内为空，CAS 放入，不加锁，成功了就直接 break 跳出</span></span><br><span class="line">            <span class="keyword">if</span> (casTabAt(tab, i, <span class="literal">null</span>,<span class="keyword">new</span> <span class="title class_">Node</span>&lt;K,V&gt;(hash, key, value, <span class="literal">null</span>)))</span><br><span class="line">                <span class="keyword">break</span>;  <span class="comment">// no lock when adding to empty bin</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//帮忙扩容</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((fh = f.hash) == MOVED)</span><br><span class="line">            tab = helpTransfer(tab, f);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">V</span> <span class="variable">oldVal</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">            <span class="comment">// 使用 synchronized 加锁加入节点</span></span><br><span class="line">            <span class="keyword">synchronized</span> (f) &#123;</span><br><span class="line">                <span class="keyword">if</span> (tabAt(tab, i) == f) &#123;</span><br><span class="line">                    <span class="comment">// 说明是链表</span></span><br><span class="line">                    <span class="keyword">if</span> (fh &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                        binCount = <span class="number">1</span>;</span><br><span class="line">                        <span class="comment">// 循环加入新的或者覆盖节点</span></span><br><span class="line">                        <span class="keyword">for</span> (Node&lt;K,V&gt; e = f;; ++binCount) &#123;</span><br><span class="line">                            K ek;</span><br><span class="line">                            <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                                ((ek = e.key) == key ||</span><br><span class="line">                                 (ek != <span class="literal">null</span> &amp;&amp; key.equals(ek)))) &#123;</span><br><span class="line">                                oldVal = e.val;</span><br><span class="line">                                <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">                                    e.val = value;</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                            Node&lt;K,V&gt; pred = e;</span><br><span class="line">                            <span class="keyword">if</span> ((e = e.next) == <span class="literal">null</span>) &#123;</span><br><span class="line">                                pred.next = <span class="keyword">new</span> <span class="title class_">Node</span>&lt;K,V&gt;(hash, key,</span><br><span class="line">                                                          value, <span class="literal">null</span>);</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (f <span class="keyword">instanceof</span> TreeBin) &#123;</span><br><span class="line">                        <span class="comment">// 红黑树</span></span><br><span class="line">                        Node&lt;K,V&gt; p;</span><br><span class="line">                        binCount = <span class="number">2</span>;</span><br><span class="line">                        <span class="keyword">if</span> ((p = ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key,</span><br><span class="line">                                                       value)) != <span class="literal">null</span>) &#123;</span><br><span class="line">                            oldVal = p.val;</span><br><span class="line">                            <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">                                p.val = value;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (binCount != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD)</span><br><span class="line">                    treeifyBin(tab, i);</span><br><span class="line">                <span class="keyword">if</span> (oldVal != <span class="literal">null</span>)</span><br><span class="line">                    <span class="keyword">return</span> oldVal;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    addCount(<span class="number">1L</span>, binCount);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结：</p>
<ol>
<li>根据 key 计算出 hashcode 。</li>
<li>判断是否需要进行初始化。</li>
<li>即为当前 key 定位出的 Node，如果为空表示当前位置可以写入数据，利用 CAS 尝试写入，失败则自旋保证成功。</li>
<li>如果当前位置的 <code>hashcode == MOVED == -1</code>,则需要进行扩容。</li>
<li>如果都不满足，则利用 synchronized 锁写入数据。</li>
<li>如果数量大于 <code>TREEIFY_THRESHOLD</code> 则要执行树化方法，在treeifyBin中会首先判断当前数组长度≥64时才会将链表转换为红黑树。</li>
</ol>
<h4 id="初始化initTable"><a href="#初始化initTable" class="headerlink" title="初始化initTable"></a>初始化initTable</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Initializes table, using the size recorded in sizeCtl.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Node&lt;K,V&gt;[] initTable() &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; <span class="type">int</span> sc;</span><br><span class="line">    <span class="keyword">while</span> ((tab = table) == <span class="literal">null</span> || tab.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//如果 sizeCtl &lt; 0 ,说明另外的线程执行CAS 成功，正在进行初始化。</span></span><br><span class="line">        <span class="keyword">if</span> ((sc = sizeCtl) &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="comment">// 让出 CPU 使用权</span></span><br><span class="line">            Thread.yield(); <span class="comment">// lost initialization race; just spin</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapInt(<span class="built_in">this</span>, SIZECTL, sc, -<span class="number">1</span>)) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> ((tab = table) == <span class="literal">null</span> || tab.length == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> (sc &gt; <span class="number">0</span>) ? sc : DEFAULT_CAPACITY;</span><br><span class="line">                    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">                    Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])<span class="keyword">new</span> <span class="title class_">Node</span>&lt;?,?&gt;[n];</span><br><span class="line">                    table = tab = nt;</span><br><span class="line">                    sc = n - (n &gt;&gt;&gt; <span class="number">2</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                sizeCtl = sc;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从源码中可以发现 ConcurrentHashMap 的初始化是通过<strong>自旋和 CAS</strong> 操作完成的。里面需要注意的是变量 <code>sizeCtl</code> ，它的值决定着当前的初始化状态。</p>
<ol>
<li>-1 说明正在初始化</li>
<li>-N 说明有N-1个线程正在进行扩容</li>
<li>表示 table 初始化大小，如果 table 没有初始化</li>
<li>表示 table 容量，如果 table已经初始化。</li>
</ol>
<h4 id="addCount流程"><a href="#addCount流程" class="headerlink" title="addCount流程"></a>addCount流程</h4><p>具体代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">addCount(<span class="number">1L</span>, binCount);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">null</span>;</span><br></pre></td></tr></table></figure>

<p>当插入结束的时候，会调用该方法，并传入一个 1 和 binCount 参数。从方法名字上，该方法应该是对哈希表的元素进行计数的。</p>
<p>一起来看看 addCount 是如何操作的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 从 putVal 传入的参数是 1， binCount，binCount 默认是0，只有 hash 冲突了才会大于 1.且他的大小是链表的长度（如果不是红黑数结构的话）。</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">addCount</span><span class="params">(<span class="type">long</span> x, <span class="type">int</span> check)</span> &#123;</span><br><span class="line">    CounterCell[] as; <span class="type">long</span> b, s;</span><br><span class="line">    <span class="comment">// 如果计数盒子不是空 或者</span></span><br><span class="line">    <span class="comment">// 如果修改 baseCount 失败</span></span><br><span class="line">    <span class="keyword">if</span> ((as = counterCells) != <span class="literal">null</span> ||</span><br><span class="line">        !U.compareAndSwapLong(<span class="built_in">this</span>, BASECOUNT, b = baseCount, s = b + x)) &#123;</span><br><span class="line">        CounterCell a; <span class="type">long</span> v; <span class="type">int</span> m;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">uncontended</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">// 如果计数盒子是空（尚未出现并发）</span></span><br><span class="line">        <span class="comment">// 如果随机取余一个数组位置为空 或者</span></span><br><span class="line">        <span class="comment">// 修改这个槽位的变量失败（出现并发了）</span></span><br><span class="line">        <span class="comment">// 执行 fullAddCount 方法。并结束</span></span><br><span class="line">        <span class="keyword">if</span> (as == <span class="literal">null</span> || (m = as.length - <span class="number">1</span>) &lt; <span class="number">0</span> ||</span><br><span class="line">            (a = as[ThreadLocalRandom.getProbe() &amp; m]) == <span class="literal">null</span> ||</span><br><span class="line">            !(uncontended =</span><br><span class="line">              U.compareAndSwapLong(a, CELLVALUE, v = a.value, v + x))) &#123;</span><br><span class="line">            fullAddCount(x, uncontended);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (check &lt;= <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        s = sumCount();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果需要检查,检查是否需要扩容，在 putVal 方法调用时，默认就是要检查的。</span></span><br><span class="line">    <span class="keyword">if</span> (check &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        Node&lt;K,V&gt;[] tab, nt; <span class="type">int</span> n, sc;</span><br><span class="line">        <span class="comment">// 如果map.size() 大于 sizeCtl（达到扩容阈值需要扩容） 且</span></span><br><span class="line">        <span class="comment">// table 不是空；且 table 的长度小于 1 &lt;&lt; 30。（可以扩容）</span></span><br><span class="line">        <span class="keyword">while</span> (s &gt;= (<span class="type">long</span>)(sc = sizeCtl) &amp;&amp; (tab = table) != <span class="literal">null</span> &amp;&amp;</span><br><span class="line">               (n = tab.length) &lt; MAXIMUM_CAPACITY) &#123;</span><br><span class="line">            <span class="comment">// 根据 length 得到一个标识</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">rs</span> <span class="operator">=</span> resizeStamp(n);</span><br><span class="line">            <span class="comment">// 如果正在扩容</span></span><br><span class="line">            <span class="keyword">if</span> (sc &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 如果 sc 的低 16 位不等于 标识符（校验异常 sizeCtl 变化了）</span></span><br><span class="line">                <span class="comment">// 如果 sc == 标识符 + 1 （扩容结束了，不再有线程进行扩容）（默认第一个线程设置 sc ==rs 左移 16 位 + 2，当第一个线程结束扩容了，就会将 sc 减一。这个时候，sc 就等于 rs + 1）</span></span><br><span class="line">                <span class="comment">// 如果 sc == 标识符 + 65535（帮助线程数已经达到最大）</span></span><br><span class="line">                <span class="comment">// 如果 nextTable == null（结束扩容了）</span></span><br><span class="line">                <span class="comment">// 如果 transferIndex &lt;= 0 (转移状态变化了)</span></span><br><span class="line">                <span class="comment">// 结束循环 </span></span><br><span class="line">                <span class="keyword">if</span> ((sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs || sc == rs + <span class="number">1</span> ||</span><br><span class="line">                    sc == rs + MAX_RESIZERS || (nt = nextTable) == <span class="literal">null</span> ||</span><br><span class="line">                    transferIndex &lt;= <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="comment">// 如果可以帮助扩容，那么将 sc 加 1. 表示多了一个线程在帮助扩容</span></span><br><span class="line">                <span class="keyword">if</span> (U.compareAndSwapInt(<span class="built_in">this</span>, SIZECTL, sc, sc + <span class="number">1</span>))</span><br><span class="line">                    <span class="comment">// 扩容</span></span><br><span class="line">                    transfer(tab, nt);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果不在扩容，将 sc 更新：标识符左移 16 位 然后 + 2. 也就是变成一个负数。高 16 位是标识符，低 16 位初始是 2.</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapInt(<span class="built_in">this</span>, SIZECTL, sc,</span><br><span class="line">                                         (rs &lt;&lt; RESIZE_STAMP_SHIFT) + <span class="number">2</span>))</span><br><span class="line">                <span class="comment">// 更新 sizeCtl 为负数后，开始扩容。</span></span><br><span class="line">                transfer(tab, <span class="literal">null</span>);</span><br><span class="line">            s = sumCount();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>总结一下该方法的逻辑：</strong></p>
<p>x 参数表示的此次需要对表中元素的个数加几。check 参数表示是否需要进行扩容检查，大于等于0 需要进行检查，而我们的 putVal 方法的 binCount 参数最小也是 0 ，因此，每次添加元素都会进行检查。（除非是覆盖操作）</p>
<ol>
<li>判断计数盒子属性是否是空，如果是空，就尝试修改 baseCount 变量，对该变量进行加 X。</li>
<li>如果计数盒子不是空，或者修改 baseCount 变量失败了，则放弃对 baseCount 进行操作。</li>
<li>如果计数盒子是 null 或者计数盒子的 length 是 0，或者随机取一个位置取于数组长度是 null，那么就对刚刚的元素进行 CAS 赋值。</li>
<li>如果赋值失败，或者满足上面的条件，则调用 fullAddCount 方法重新死循环插入。</li>
<li>这里如果操作 baseCount 失败了（或者计数盒子不是 Null），且对计数盒子赋值成功，那么就检查 check 变量，如果该变量小于等于 1. 直接结束。否则，计算一下 count 变量。</li>
<li>如果 check 大于等于 0 ，说明需要对是否扩容进行检查。</li>
<li>如果 map 的 size 大于 sizeCtl（扩容阈值），且 table 的长度小于 1 &lt;&lt; 30，那么就进行扩容。</li>
<li>根据 length 得到一个标识符，然后，判断 sizeCtl 状态，如果小于 0 ，说明要么在初始化，要么在扩容。</li>
<li>如果正在扩容，那么就校验一下数据是否变化了（具体可以看上面代码的注释）。如果检验数据不通过，break。</li>
<li>如果校验数据通过了，那么将 sizeCtl 加一，表示多了一个线程帮助扩容。然后进行扩容。</li>
<li>如果没有在扩容，但是需要扩容。那么就将 sizeCtl 更新，赋值为标识符左移 16 位 —— 一个负数。然后加 2。 表示，已经有一个线程开始扩容了。然后进行扩容。然后再次更新 count，看看是否还需要扩容。</li>
</ol>
<p><strong>总结下来看，addCount 方法做了 2 件事情：</strong></p>
<ol>
<li>对 table 的长度加一。无论是通过修改 baseCount，还是通过使用 CounterCell。当 CounterCell 被初始化了，就优先使用他，不再使用 baseCount。</li>
<li>检查是否需要扩容，或者是否正在扩容。如果需要扩容，就调用扩容方法，如果正在扩容，就帮助其扩容。</li>
</ol>
<p><strong>有几个要点注意：</strong></p>
<ol>
<li>第一次调用扩容方法前，sizeCtl 的低 16 位是加 2 的，不是加一。所以 sc &#x3D;&#x3D; rs + 1 的判断是表示是否完成任务了。因为完成扩容后，sizeCtl &#x3D;&#x3D; rs + 1。</li>
<li>扩容线程最大数量是 65535，是由于低 16 位的位数限制。</li>
<li>这里也是可以帮助扩容的，类似 helpTransfer 方法。</li>
</ol>
<h4 id="size计算流程"><a href="#size计算流程" class="headerlink" title="size计算流程"></a>size计算流程</h4><p>size计算实际发生在put，remove改变集合元素的操作之中</p>
<ul>
<li>没有竞争发生，向baseCount累加计数</li>
<li>有竞争发生，新建counterCells，向其中的一个cell累加计数<ul>
<li>counterCells初始有两个cell</li>
<li>如果计数竞争比较激烈，会创建新的cell来累加计数</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">   <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span> &#123;</span><br><span class="line">       <span class="type">long</span> <span class="variable">n</span> <span class="operator">=</span> sumCount();</span><br><span class="line">       <span class="keyword">return</span> ((n &lt; <span class="number">0L</span>) ? <span class="number">0</span> :</span><br><span class="line">               (n &gt; (<span class="type">long</span>)Integer.MAX_VALUE) ? Integer.MAX_VALUE : (<span class="type">int</span>)n);</span><br><span class="line">   &#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">long</span> <span class="title function_">sumCount</span><span class="params">()</span> &#123;</span><br><span class="line">       CounterCell[] as = counterCells; CounterCell a;</span><br><span class="line">       <span class="type">long</span> <span class="variable">sum</span> <span class="operator">=</span> baseCount;</span><br><span class="line">       <span class="keyword">if</span> (as != <span class="literal">null</span>) &#123;</span><br><span class="line">           <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; as.length; ++i) &#123;</span><br><span class="line">               <span class="keyword">if</span> ((a = as[i]) != <span class="literal">null</span>)</span><br><span class="line">                   sum += a.value;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> sum;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h4 id="transfer流程"><a href="#transfer流程" class="headerlink" title="transfer流程"></a>transfer流程</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">transfer</span><span class="params">(Node&lt;K,V&gt;[] tab, Node&lt;K,V&gt;[] nextTab)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> tab.length, stride;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">//将 (n&gt;&gt;&gt;3相当于 n/8) 然后除以 CPU核心数。如果得到的结果小于 16，那么就使用 16</span></span><br><span class="line"> </span><br><span class="line">        <span class="comment">// 这里的目的是让每个 CPU 处理的桶一样多，避免出现转移任务不均匀的现象，如果桶较少的话，默认一个 CPU（一个线程）处理 16 个桶，也就是长度为16的时候，扩容的时候只会有一个线程来扩容</span></span><br><span class="line">        <span class="keyword">if</span> ((stride = (NCPU &gt; <span class="number">1</span>) ? (n &gt;&gt;&gt; <span class="number">3</span>) / NCPU : n) &lt; MIN_TRANSFER_STRIDE)</span><br><span class="line">            stride = MIN_TRANSFER_STRIDE; <span class="comment">// subdivide range</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//nextTab未初始化，nextTab是用来扩容的node数组</span></span><br><span class="line">        <span class="keyword">if</span> (nextTab == <span class="literal">null</span>) &#123;            <span class="comment">// initiating</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line"> </span><br><span class="line">                <span class="comment">//新建一个n&lt;&lt;1原始table大小的nextTab,也就是32</span></span><br><span class="line">                <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">                Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])<span class="keyword">new</span> <span class="title class_">Node</span>&lt;?,?&gt;[n &lt;&lt; <span class="number">1</span>];</span><br><span class="line"> </span><br><span class="line">                <span class="comment">//赋值给nextTab</span></span><br><span class="line">                nextTab = nt;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable ex) &#123;      <span class="comment">// try to cope with OOME</span></span><br><span class="line"> </span><br><span class="line">                <span class="comment">//扩容失败，sizeCtl使用int的最大值</span></span><br><span class="line">                sizeCtl = Integer.MAX_VALUE;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"> </span><br><span class="line">            <span class="comment">//更新成员变量</span></span><br><span class="line">            nextTable = nextTab;</span><br><span class="line"> </span><br><span class="line">            <span class="comment">//更新转移下标，表示转移时的下标</span></span><br><span class="line">            transferIndex = n;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">//新的tab的长度</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">nextn</span> <span class="operator">=</span> nextTab.length;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// 创建一个 fwd 节点，表示一个正在被迁移的Node，并且它的hash值为-1(MOVED)，也就是前面我们在讲putval方法的时候，会有一个判断MOVED的逻辑。它的作用是用来占位，表示原数组中位置i处的节点完成迁移以后，就会在i位置设置一个fwd来告诉其他线程这个位置已经处理过了，具体后续还会在讲</span></span><br><span class="line">        ForwardingNode&lt;K,V&gt; fwd = <span class="keyword">new</span> <span class="title class_">ForwardingNode</span>&lt;K,V&gt;(nextTab);</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// 首次推进为 true，如果等于 true，说明需要再次推进一个下标（i--），反之，如果是 false，那么就不能推进下标，需要将当前的下标处理完毕才能继续推进</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">advance</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">//判断是否已经扩容完成，完成就return，退出循环</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">finishing</span> <span class="operator">=</span> <span class="literal">false</span>; <span class="comment">// to ensure sweep before committing nextTab</span></span><br><span class="line"> </span><br><span class="line">        <span class="comment">//通过for自循环处理每个槽位中的链表元素，默认advace为真，通过CAS设置transferIndex属性值，并初始化i和bound值，i指当前处理的槽位序号，bound指需要处理的槽位边界，先处理槽位15的节点；</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, bound = <span class="number">0</span>;;) &#123;</span><br><span class="line"> </span><br><span class="line">            <span class="comment">// 这个循环使用CAS不断尝试为当前线程分配任务</span></span><br><span class="line"> </span><br><span class="line">            <span class="comment">// 直到分配成功或任务队列已经被全部分配完毕</span></span><br><span class="line"> </span><br><span class="line">            <span class="comment">// 如果当前线程已经被分配过bucket区域</span></span><br><span class="line"> </span><br><span class="line">            <span class="comment">// 那么会通过--i指向下一个待处理bucket然后退出该循环</span></span><br><span class="line">            Node&lt;K,V&gt; f; <span class="type">int</span> fh;</span><br><span class="line">            <span class="keyword">while</span> (advance) &#123;</span><br><span class="line">                <span class="type">int</span> nextIndex, nextBound;</span><br><span class="line"> </span><br><span class="line">                <span class="comment">//--i表示下一个待处理的bucket，如果它&gt;=bound,表示当前线程已经分配过bucket区域</span></span><br><span class="line">                <span class="keyword">if</span> (--i &gt;= bound || finishing)</span><br><span class="line">                    advance = <span class="literal">false</span>;</span><br><span class="line"> </span><br><span class="line">                <span class="comment">//表示所有bucket已经被分配完毕 给nextIndex赋予初始值 = 16</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> ((nextIndex = transferIndex) &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    i = -<span class="number">1</span>;</span><br><span class="line">                    advance = <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//通过cas来修改TRANSFERINDEX,为当前线程分配任务，处理的节点区间为(nextBound,nextIndex)-&gt;(0,15)</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapInt</span><br><span class="line">                         (<span class="built_in">this</span>, TRANSFERINDEX, nextIndex,</span><br><span class="line">                          nextBound = (nextIndex &gt; stride ?</span><br><span class="line">                                       nextIndex - stride : <span class="number">0</span>))) &#123;</span><br><span class="line"> </span><br><span class="line">                    <span class="comment">//0</span></span><br><span class="line">                    bound = nextBound;</span><br><span class="line"> </span><br><span class="line">                    <span class="comment">//15</span></span><br><span class="line">                    i = nextIndex - <span class="number">1</span>;</span><br><span class="line">                    advance = <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"> </span><br><span class="line">            <span class="comment">//i&lt;0说明已经遍历完旧的数组，也就是当前线程已经处理完所有负责的bucket</span></span><br><span class="line">            <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt;= n || i + n &gt;= nextn) &#123;</span><br><span class="line">                <span class="type">int</span> sc;</span><br><span class="line"> </span><br><span class="line">                <span class="comment">//如果完成了扩容</span></span><br><span class="line">                <span class="keyword">if</span> (finishing) &#123;</span><br><span class="line"> </span><br><span class="line">                    <span class="comment">//删除成员变量</span></span><br><span class="line">                    nextTable = <span class="literal">null</span>;</span><br><span class="line"> </span><br><span class="line">                    <span class="comment">//更新table数组</span></span><br><span class="line">                    table = nextTab;</span><br><span class="line"> </span><br><span class="line">                    <span class="comment">//更新阈值(32*0.75=24)</span></span><br><span class="line">                    sizeCtl = (n &lt;&lt; <span class="number">1</span>) - (n &gt;&gt;&gt; <span class="number">1</span>);</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line"> </span><br><span class="line">                <span class="comment">// sizeCtl 在迁移前会设置为 (rs &lt;&lt; RESIZE_STAMP_SHIFT) + 2 (详细介绍点击这里)</span></span><br><span class="line"> </span><br><span class="line">                <span class="comment">// 然后，每增加一个线程参与迁移就会将 sizeCtl 加 1，</span></span><br><span class="line"> </span><br><span class="line">                <span class="comment">// 这里使用 CAS 操作对 sizeCtl 的低16位进行减 1，代表做完了属于自己的任务</span></span><br><span class="line">                <span class="keyword">if</span> (U.compareAndSwapInt(<span class="built_in">this</span>, SIZECTL, sc = sizeCtl, sc - <span class="number">1</span>)) &#123;</span><br><span class="line"> </span><br><span class="line">                    <span class="comment">//第一个扩容的线程，执行transfer方法之前，会设置 sizeCtl = (resizeStamp(n) &lt;&lt; RESIZE_STAMP_SHIFT) + 2)</span></span><br><span class="line"> </span><br><span class="line">                    <span class="comment">//后续帮其扩容的线程，执行transfer方法之前，会设置 sizeCtl = sizeCtl+1</span></span><br><span class="line"> </span><br><span class="line">                    <span class="comment">//每一个退出transfer的方法的线程，退出之前，会设置 sizeCtl = sizeCtl-1</span></span><br><span class="line"> </span><br><span class="line">                    <span class="comment">//那么最后一个线程退出时：必然有</span></span><br><span class="line">                    <span class="comment">//sc == (resizeStamp(n) &lt;&lt; RESIZE_STAMP_SHIFT) + 2)，即 (sc - 2) == resizeStamp(n) &lt;&lt; RESIZE_STAMP_SHIFT</span></span><br><span class="line"> </span><br><span class="line">                    <span class="comment">// 如果 sc - 2 不等于标识符左移 16 位。如果他们相等了，说明没有线程在帮助他们扩容了。也就是说，扩容结束了。</span></span><br><span class="line">                    <span class="keyword">if</span> ((sc - <span class="number">2</span>) != resizeStamp(n) &lt;&lt; RESIZE_STAMP_SHIFT)</span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line"> </span><br><span class="line">                    <span class="comment">// 如果相等，扩容结束了，更新 finising 变量</span></span><br><span class="line">                    finishing = advance = <span class="literal">true</span>;</span><br><span class="line"> </span><br><span class="line">                    <span class="comment">// 再次循环检查一下整张表</span></span><br><span class="line">                    i = n; <span class="comment">// recheck before commit</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"> </span><br><span class="line">            <span class="comment">// 如果位置 i 处是空的，没有任何节点，那么放入刚刚初始化的 ForwardingNode ”空节点“</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((f = tabAt(tab, i)) == <span class="literal">null</span>)</span><br><span class="line">                advance = casTabAt(tab, i, <span class="literal">null</span>, fwd);</span><br><span class="line"> </span><br><span class="line">            <span class="comment">//表示该位置已经完成了迁移，也就是如果线程A已经处理过这个节点，那么线程B处理这个节点时，hash值一定为MOVED</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((fh = f.hash) == MOVED)</span><br><span class="line">                advance = <span class="literal">true</span>; <span class="comment">// already processed</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (f) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (tabAt(tab, i) == f) &#123;</span><br><span class="line">                        Node&lt;K,V&gt; ln, hn;</span><br><span class="line">                        <span class="keyword">if</span> (fh &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                            <span class="type">int</span> <span class="variable">runBit</span> <span class="operator">=</span> fh &amp; n;</span><br><span class="line">                            Node&lt;K,V&gt; lastRun = f;</span><br><span class="line">                            <span class="keyword">for</span> (Node&lt;K,V&gt; p = f.next; p != <span class="literal">null</span>; p = p.next) &#123;</span><br><span class="line">                                <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> p.hash &amp; n;</span><br><span class="line">                                <span class="keyword">if</span> (b != runBit) &#123;</span><br><span class="line">                                    runBit = b;</span><br><span class="line">                                    lastRun = p;</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="keyword">if</span> (runBit == <span class="number">0</span>) &#123;</span><br><span class="line">                                ln = lastRun;</span><br><span class="line">                                hn = <span class="literal">null</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="keyword">else</span> &#123;</span><br><span class="line">                                hn = lastRun;</span><br><span class="line">                                ln = <span class="literal">null</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="keyword">for</span> (Node&lt;K,V&gt; p = f; p != lastRun; p = p.next) &#123;</span><br><span class="line">                                <span class="type">int</span> <span class="variable">ph</span> <span class="operator">=</span> p.hash; <span class="type">K</span> <span class="variable">pk</span> <span class="operator">=</span> p.key; <span class="type">V</span> <span class="variable">pv</span> <span class="operator">=</span> p.val;</span><br><span class="line">                                <span class="keyword">if</span> ((ph &amp; n) == <span class="number">0</span>)</span><br><span class="line">                                    ln = <span class="keyword">new</span> <span class="title class_">Node</span>&lt;K,V&gt;(ph, pk, pv, ln);</span><br><span class="line">                                <span class="type">else</span></span><br><span class="line">                                    <span class="variable">hn</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>&lt;K,V&gt;(ph, pk, pv, hn);</span><br><span class="line">                            &#125;</span><br><span class="line">                            setTabAt(nextTab, i, ln);</span><br><span class="line">                            setTabAt(nextTab, i + n, hn);</span><br><span class="line">                            setTabAt(tab, i, fwd);</span><br><span class="line">                            advance = <span class="literal">true</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span> <span class="keyword">if</span> (f <span class="keyword">instanceof</span> TreeBin) &#123;</span><br><span class="line">                            TreeBin&lt;K,V&gt; t = (TreeBin&lt;K,V&gt;)f;</span><br><span class="line">                            TreeNode&lt;K,V&gt; lo = <span class="literal">null</span>, loTail = <span class="literal">null</span>;</span><br><span class="line">                            TreeNode&lt;K,V&gt; hi = <span class="literal">null</span>, hiTail = <span class="literal">null</span>;</span><br><span class="line">                            <span class="type">int</span> <span class="variable">lc</span> <span class="operator">=</span> <span class="number">0</span>, hc = <span class="number">0</span>;</span><br><span class="line">                            <span class="keyword">for</span> (Node&lt;K,V&gt; e = t.first; e != <span class="literal">null</span>; e = e.next) &#123;</span><br><span class="line">                                <span class="type">int</span> <span class="variable">h</span> <span class="operator">=</span> e.hash;</span><br><span class="line">                                TreeNode&lt;K,V&gt; p = <span class="keyword">new</span> <span class="title class_">TreeNode</span>&lt;K,V&gt;</span><br><span class="line">                                    (h, e.key, e.val, <span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line">                                <span class="keyword">if</span> ((h &amp; n) == <span class="number">0</span>) &#123;</span><br><span class="line">                                    <span class="keyword">if</span> ((p.prev = loTail) == <span class="literal">null</span>)</span><br><span class="line">                                        lo = p;</span><br><span class="line">                                    <span class="keyword">else</span></span><br><span class="line">                                        loTail.next = p;</span><br><span class="line">                                    loTail = p;</span><br><span class="line">                                    ++lc;</span><br><span class="line">                                &#125;</span><br><span class="line">                                <span class="keyword">else</span> &#123;</span><br><span class="line">                                    <span class="keyword">if</span> ((p.prev = hiTail) == <span class="literal">null</span>)</span><br><span class="line">                                        hi = p;</span><br><span class="line">                                    <span class="keyword">else</span></span><br><span class="line">                                        hiTail.next = p;</span><br><span class="line">                                    hiTail = p;</span><br><span class="line">                                    ++hc;</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                            ln = (lc &lt;= UNTREEIFY_THRESHOLD) ? untreeify(lo) :</span><br><span class="line">                                (hc != <span class="number">0</span>) ? <span class="keyword">new</span> <span class="title class_">TreeBin</span>&lt;K,V&gt;(lo) : t;</span><br><span class="line">                            hn = (hc &lt;= UNTREEIFY_THRESHOLD) ? untreeify(hi) :</span><br><span class="line">                                (lc != <span class="number">0</span>) ? <span class="keyword">new</span> <span class="title class_">TreeBin</span>&lt;K,V&gt;(hi) : t;</span><br><span class="line">                            setTabAt(nextTab, i, ln);</span><br><span class="line">                            setTabAt(nextTab, i + n, hn);</span><br><span class="line">                            setTabAt(tab, i, fwd);</span><br><span class="line">                            advance = <span class="literal">true</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="JDK7"><a href="#JDK7" class="headerlink" title="JDK7"></a>JDK7</h3><p>它维护了一个segment数组，每个segment对应一把锁</p>
<ul>
<li>优点：如果多个线程访问不同的segment，实际是没有冲突的，这与jdk8中类似</li>
<li>缺点：Segment数组默认大小为16，这个容量初始化指定后就不能改变了，并不是懒惰初始化。</li>
</ul>
<h4 id="存储结构-1"><a href="#存储结构-1" class="headerlink" title="存储结构"></a>存储结构</h4><p><img src="/../images/img95.png" alt="img95"></p>
<p>Java 7 中 <code>ConcurrentHashMap</code> 的存储结构如上图，<code>ConcurrnetHashMap</code> 由很多个 <code>Segment</code> 组合，而每一个 <code>Segment</code> 是一个类似于 HashMap 的结构，所以每一个 <code>HashMap</code> 的内部可以进行扩容。但是 <code>Segment</code> 的个数一旦<strong>初始化就不能改变</strong>，默认 <code>Segment</code> 的个数是 16 个，你也可以认为 <code>ConcurrentHashMap</code> 默认支持最多 16 个线程并发。</p>
<h4 id="构造器分析-1"><a href="#构造器分析-1" class="headerlink" title="构造器分析"></a>构造器分析</h4><p>通过 ConcurrentHashMap 的无参构造探寻 ConcurrentHashMap 的初始化流程。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Creates a new, empty map with a default initial capacity (16),</span></span><br><span class="line"><span class="comment"> * load factor (0.75) and concurrencyLevel (16).</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ConcurrentHashMap</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>(DEFAULT_INITIAL_CAPACITY, DEFAULT_LOAD_FACTOR, DEFAULT_CONCURRENCY_LEVEL);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>无参构造中调用了有参构造，传入了三个参数的默认值，他们的值是。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 默认初始化容量</span><br><span class="line"> */</span><br><span class="line">static final int DEFAULT_INITIAL_CAPACITY = 16;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 默认负载因子</span><br><span class="line"> */</span><br><span class="line">static final float DEFAULT_LOAD_FACTOR = 0.75f;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 默认并发级别</span><br><span class="line"> */</span><br><span class="line">static final int DEFAULT_CONCURRENCY_LEVEL = 16;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>接着看下这个有参构造函数的内部实现逻辑。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ConcurrentHashMap</span><span class="params">(<span class="type">int</span> initialCapacity,<span class="type">float</span> loadFactor, <span class="type">int</span> concurrencyLevel)</span> &#123;</span><br><span class="line">    <span class="comment">// 参数校验</span></span><br><span class="line">    <span class="keyword">if</span> (!(loadFactor &gt; <span class="number">0</span>) || initialCapacity &lt; <span class="number">0</span> || concurrencyLevel &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>();</span><br><span class="line">    <span class="comment">// 校验并发级别大小，大于 1&lt;&lt;16，重置为 65536</span></span><br><span class="line">    <span class="keyword">if</span> (concurrencyLevel &gt; MAX_SEGMENTS)</span><br><span class="line">        concurrencyLevel = MAX_SEGMENTS;</span><br><span class="line">    <span class="comment">// Find power-of-two sizes best matching arguments</span></span><br><span class="line">    <span class="comment">// 2的多少次方</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">sshift</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">ssize</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 这个循环可以找到 concurrencyLevel 之上最近的 2的次方值</span></span><br><span class="line">    <span class="keyword">while</span> (ssize &lt; concurrencyLevel) &#123;</span><br><span class="line">        ++sshift;</span><br><span class="line">        ssize &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 记录段偏移量</span></span><br><span class="line">    <span class="built_in">this</span>.segmentShift = <span class="number">32</span> - sshift;</span><br><span class="line">    <span class="comment">// 记录段掩码</span></span><br><span class="line">    <span class="built_in">this</span>.segmentMask = ssize - <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 设置容量</span></span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">        initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">    <span class="comment">// c = 容量 / ssize ，默认 16 / 16 = 1，这里是计算每个 Segment 中的类似于 HashMap 的容量</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> initialCapacity / ssize;</span><br><span class="line">    <span class="keyword">if</span> (c * ssize &lt; initialCapacity)</span><br><span class="line">        ++c;</span><br><span class="line">    <span class="type">int</span> <span class="variable">cap</span> <span class="operator">=</span> MIN_SEGMENT_TABLE_CAPACITY;</span><br><span class="line">    <span class="comment">//Segment 中的类似于 HashMap 的容量至少是2或者2的倍数</span></span><br><span class="line">    <span class="keyword">while</span> (cap &lt; c)</span><br><span class="line">        cap &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// create segments and segments[0]</span></span><br><span class="line">    <span class="comment">// 创建 Segment 数组，设置 segments[0]</span></span><br><span class="line">    Segment&lt;K,V&gt; s0 = <span class="keyword">new</span> <span class="title class_">Segment</span>&lt;K,V&gt;(loadFactor, (<span class="type">int</span>)(cap * loadFactor),</span><br><span class="line">                         (HashEntry&lt;K,V&gt;[])<span class="keyword">new</span> <span class="title class_">HashEntry</span>[cap]);</span><br><span class="line">    Segment&lt;K,V&gt;[] ss = (Segment&lt;K,V&gt;[])<span class="keyword">new</span> <span class="title class_">Segment</span>[ssize];</span><br><span class="line">    UNSAFE.putOrderedObject(ss, SBASE, s0); <span class="comment">// ordered write of segments[0]</span></span><br><span class="line">    <span class="built_in">this</span>.segments = ss;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结一下在 Java 7 中 ConcurrnetHashMap 的初始化逻辑。</p>
<ol>
<li>必要参数校验。</li>
<li>校验并发级别 concurrencyLevel 大小，如果大于最大值，重置为最大值。无参构造<strong>默认值是 16.</strong></li>
<li>寻找并发级别 concurrencyLevel 之上最近的 <strong>2 的幂次方</strong>值，作为初始化容量大小，<strong>默认是 16</strong>。</li>
<li>记录 segmentShift 偏移量，这个值为【容量 &#x3D; 2 的N次方】中的 N，在后面 Put 时计算位置时会用到。<strong>默认是 32 - sshift &#x3D; 28</strong>.</li>
<li>记录 segmentMask，默认是 ssize - 1 &#x3D; 16 -1 &#x3D; 15.</li>
<li><em>*初始化 segments[0]**，**默认大小为 2</em><em>，<strong>负载因子 0.75</strong>，**扩容阀值是 2</em>0.75&#x3D;1.5**，插入第二个值时才会进行扩容。</li>
</ol>
<h4 id="put流程-1"><a href="#put流程-1" class="headerlink" title="put流程"></a>put流程</h4><p>接着上面的初始化参数继续查看 put 方法源码。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Maps the specified key to the specified value in this table.</span></span><br><span class="line"><span class="comment"> * Neither the key nor the value can be null.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt; The value can be retrieved by calling the &lt;tt&gt;get&lt;/tt&gt; method</span></span><br><span class="line"><span class="comment"> * with a key that is equal to the original key.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key key with which the specified value is to be associated</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> value value to be associated with the specified key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the previous value associated with &lt;tt&gt;key&lt;/tt&gt;, or</span></span><br><span class="line"><span class="comment"> *         &lt;tt&gt;null&lt;/tt&gt; if there was no mapping for &lt;tt&gt;key&lt;/tt&gt;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> NullPointerException if the specified key or value is null</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> V <span class="title function_">put</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">    Segment&lt;K,V&gt; s;</span><br><span class="line">    <span class="keyword">if</span> (value == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">    <span class="type">int</span> <span class="variable">hash</span> <span class="operator">=</span> hash(key);</span><br><span class="line">    <span class="comment">// hash 值无符号右移 28位（初始化时获得），然后与 segmentMask=15 做与运算</span></span><br><span class="line">    <span class="comment">// 其实也就是把高4位与segmentMask（1111）做与运算</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> (hash &gt;&gt;&gt; segmentShift) &amp; segmentMask;</span><br><span class="line">    <span class="keyword">if</span> ((s = (Segment&lt;K,V&gt;)UNSAFE.getObject          <span class="comment">// nonvolatile; recheck</span></span><br><span class="line">         (segments, (j &lt;&lt; SSHIFT) + SBASE)) == <span class="literal">null</span>) <span class="comment">//  in ensureSegment</span></span><br><span class="line">        <span class="comment">// 如果查找到的 Segment 为空，初始化</span></span><br><span class="line">        s = ensureSegment(j);</span><br><span class="line">    <span class="keyword">return</span> s.put(key, hash, value, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns the segment for the given index, creating it and</span></span><br><span class="line"><span class="comment"> * recording in segment table (via CAS) if not already present.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> k the index</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the segment</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line"><span class="keyword">private</span> Segment&lt;K,V&gt; <span class="title function_">ensureSegment</span><span class="params">(<span class="type">int</span> k)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> Segment&lt;K,V&gt;[] ss = <span class="built_in">this</span>.segments;</span><br><span class="line">    <span class="type">long</span> <span class="variable">u</span> <span class="operator">=</span> (k &lt;&lt; SSHIFT) + SBASE; <span class="comment">// raw offset</span></span><br><span class="line">    Segment&lt;K,V&gt; seg;</span><br><span class="line">    <span class="comment">// 判断 u 位置的 Segment 是否为null</span></span><br><span class="line">    <span class="keyword">if</span> ((seg = (Segment&lt;K,V&gt;)UNSAFE.getObjectVolatile(ss, u)) == <span class="literal">null</span>) &#123;</span><br><span class="line">        Segment&lt;K,V&gt; proto = ss[<span class="number">0</span>]; <span class="comment">// use segment 0 as prototype</span></span><br><span class="line">        <span class="comment">// 获取0号 segment 里的 HashEntry&lt;K,V&gt; 初始化长度</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">cap</span> <span class="operator">=</span> proto.table.length;</span><br><span class="line">        <span class="comment">// 获取0号 segment 里的 hash 表里的扩容负载因子，所有的 segment 的 loadFactor 是相同的</span></span><br><span class="line">        <span class="type">float</span> <span class="variable">lf</span> <span class="operator">=</span> proto.loadFactor;</span><br><span class="line">        <span class="comment">// 计算扩容阀值</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">threshold</span> <span class="operator">=</span> (<span class="type">int</span>)(cap * lf);</span><br><span class="line">        <span class="comment">// 创建一个 cap 容量的 HashEntry 数组</span></span><br><span class="line">        HashEntry&lt;K,V&gt;[] tab = (HashEntry&lt;K,V&gt;[])<span class="keyword">new</span> <span class="title class_">HashEntry</span>[cap];</span><br><span class="line">        <span class="keyword">if</span> ((seg = (Segment&lt;K,V&gt;)UNSAFE.getObjectVolatile(ss, u)) == <span class="literal">null</span>) &#123; <span class="comment">// recheck</span></span><br><span class="line">            <span class="comment">// 再次检查 u 位置的 Segment 是否为null，因为这时可能有其他线程进行了操作</span></span><br><span class="line">            Segment&lt;K,V&gt; s = <span class="keyword">new</span> <span class="title class_">Segment</span>&lt;K,V&gt;(lf, threshold, tab);</span><br><span class="line">            <span class="comment">// 自旋检查 u 位置的 Segment 是否为null</span></span><br><span class="line">            <span class="keyword">while</span> ((seg = (Segment&lt;K,V&gt;)UNSAFE.getObjectVolatile(ss, u))</span><br><span class="line">                   == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 使用CAS 赋值，只会成功一次</span></span><br><span class="line">                <span class="keyword">if</span> (UNSAFE.compareAndSwapObject(ss, u, <span class="literal">null</span>, seg = s))</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> seg;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的源码分析了 ConcurrentHashMap 在 put 一个数据时的处理流程，下面梳理下具体流程。</p>
<ol>
<li><p>计算要 put 的 key 的位置，获取指定位置的 Segment。</p>
</li>
<li><p>如果指定位置的 Segment 为空，则初始化这个 Segment。</p>
<p><strong>初始化 Segment 流程：</strong></p>
<ol>
<li>检查计算得到的位置的 Segment 是否为null.</li>
<li>为 null 继续初始化，使用 Segment[0] 的容量和负载因子创建一个 HashEntry 数组。</li>
<li>再次检查计算得到的指定位置的 Segment 是否为null.</li>
<li>使用创建的 HashEntry 数组初始化这个 Segment.</li>
<li>自旋判断计算得到的指定位置的 Segment 是否为null，使用 CAS 在这个位置赋值为 Segment.</li>
</ol>
</li>
<li><p>Segment.put 插入 key,value 值</p>
</li>
</ol>
<p>上面探究了获取 Segment 段和初始化 Segment 段的操作。最后一行的 Segment 的 put 方法还没有查看，继续分析。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> V <span class="title function_">put</span><span class="params">(K key, <span class="type">int</span> hash, V value, <span class="type">boolean</span> onlyIfAbsent)</span> &#123;</span><br><span class="line">    <span class="comment">// 获取 ReentrantLock 独占锁，获取不到，scanAndLockForPut 获取。</span></span><br><span class="line">    HashEntry&lt;K,V&gt; node = tryLock() ? <span class="literal">null</span> : scanAndLockForPut(key, hash, value);</span><br><span class="line">    V oldValue;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        HashEntry&lt;K,V&gt;[] tab = table;</span><br><span class="line">        <span class="comment">// 计算要put的数据位置</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> (tab.length - <span class="number">1</span>) &amp; hash;</span><br><span class="line">        <span class="comment">// CAS 获取 index 坐标的值</span></span><br><span class="line">        HashEntry&lt;K,V&gt; first = entryAt(tab, index);</span><br><span class="line">        <span class="keyword">for</span> (HashEntry&lt;K,V&gt; e = first;;) &#123;</span><br><span class="line">            <span class="keyword">if</span> (e != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 检查是否 key 已经存在，如果存在，则遍历链表寻找位置，找到后替换 value</span></span><br><span class="line">                K k;</span><br><span class="line">                <span class="keyword">if</span> ((k = e.key) == key ||</span><br><span class="line">                    (e.hash == hash &amp;&amp; key.equals(k))) &#123;</span><br><span class="line">                    oldValue = e.value;</span><br><span class="line">                    <span class="keyword">if</span> (!onlyIfAbsent) &#123;</span><br><span class="line">                        e.value = value;</span><br><span class="line">                        ++modCount;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                e = e.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// first 有值没说明 index 位置已经有值了，有冲突，链表头插法。</span></span><br><span class="line">                <span class="keyword">if</span> (node != <span class="literal">null</span>)</span><br><span class="line">                    node.setNext(first);</span><br><span class="line">                <span class="type">else</span></span><br><span class="line">                    <span class="variable">node</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashEntry</span>&lt;K,V&gt;(hash, key, value, first);</span><br><span class="line">                <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> count + <span class="number">1</span>;</span><br><span class="line">                <span class="comment">// 容量大于扩容阀值，小于最大容量，进行扩容</span></span><br><span class="line">                <span class="keyword">if</span> (c &gt; threshold &amp;&amp; tab.length &lt; MAXIMUM_CAPACITY)</span><br><span class="line">                    rehash(node);</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    <span class="comment">// index 位置赋值 node，node 可能是一个元素，也可能是一个链表的表头</span></span><br><span class="line">                    setEntryAt(tab, index, node);</span><br><span class="line">                ++modCount;</span><br><span class="line">                count = c;</span><br><span class="line">                oldValue = <span class="literal">null</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> oldValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于 Segment 继承了 ReentrantLock，所以 Segment 内部可以很方便的获取锁，put 流程就用到了这个功能。</p>
<ol>
<li><p>tryLock() 获取锁，获取不到使用 <strong>scanAndLockForPut</strong> 方法继续获取。</p>
</li>
<li><p>计算 put 的数据要放入的 index 位置，然后获取这个位置上的 HashEntry 。</p>
</li>
<li><p>遍历 put 新元素，为什么要遍历？因为这里获取的 HashEntry 可能是一个空元素，也可能是链表已存在，所以要区别对待。</p>
<p>如果这个位置上的 <strong>HashEntry 不存在</strong>：</p>
<ol>
<li>如果当前容量大于扩容阀值，小于最大容量，<strong>进行扩容</strong>。</li>
<li>直接头插法插入。</li>
</ol>
<p>如果这个位置上的 <strong>HashEntry 存在</strong>：</p>
<ol>
<li>判断链表当前元素 Key 和 hash 值是否和要 put 的 key 和 hash 值一致。一致则替换值</li>
<li>不一致，获取链表下一个节点，直到发现相同进行值替换，或者链表表里完毕没有相同的。<ol>
<li>如果当前容量大于扩容阀值，小于最大容量，<strong>进行扩容</strong>。</li>
<li>直接链表头插法插入。</li>
</ol>
</li>
</ol>
</li>
<li><p>如果要插入的位置之前已经存在，替换后返回旧值，否则返回 null.</p>
</li>
</ol>
<p>这里面的第一步中的 scanAndLockForPut 操作这里没有介绍，这个方法做的操作就是不断的自旋 <code>tryLock()</code> 获取锁。当自旋次数大于指定次数时，使用 <code>lock()</code> 阻塞获取锁。在自旋时顺表获取下 hash 位置的 HashEntry。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> HashEntry&lt;K,V&gt; <span class="title function_">scanAndLockForPut</span><span class="params">(K key, <span class="type">int</span> hash, V value)</span> &#123;</span><br><span class="line">    HashEntry&lt;K,V&gt; first = entryForHash(<span class="built_in">this</span>, hash);</span><br><span class="line">    HashEntry&lt;K,V&gt; e = first;</span><br><span class="line">    HashEntry&lt;K,V&gt; node = <span class="literal">null</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">retries</span> <span class="operator">=</span> -<span class="number">1</span>; <span class="comment">// negative while locating node</span></span><br><span class="line">    <span class="comment">// 自旋获取锁</span></span><br><span class="line">    <span class="keyword">while</span> (!tryLock()) &#123;</span><br><span class="line">        HashEntry&lt;K,V&gt; f; <span class="comment">// to recheck first below</span></span><br><span class="line">        <span class="keyword">if</span> (retries &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (e == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (node == <span class="literal">null</span>) <span class="comment">// speculatively create node</span></span><br><span class="line">                    node = <span class="keyword">new</span> <span class="title class_">HashEntry</span>&lt;K,V&gt;(hash, key, value, <span class="literal">null</span>);</span><br><span class="line">                retries = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (key.equals(e.key))</span><br><span class="line">                retries = <span class="number">0</span>;</span><br><span class="line">            <span class="type">else</span></span><br><span class="line">                <span class="variable">e</span> <span class="operator">=</span> e.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (++retries &gt; MAX_SCAN_RETRIES) &#123;</span><br><span class="line">            <span class="comment">// 自旋达到指定次数后，阻塞等到只到获取到锁</span></span><br><span class="line">            lock();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((retries &amp; <span class="number">1</span>) == <span class="number">0</span> &amp;&amp;</span><br><span class="line">                 (f = entryForHash(<span class="built_in">this</span>, hash)) != first) &#123;</span><br><span class="line">            e = first = f; <span class="comment">// re-traverse if entry changed</span></span><br><span class="line">            retries = -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="扩容rehash"><a href="#扩容rehash" class="headerlink" title="扩容rehash"></a>扩容rehash</h4><p>ConcurrentHashMap 的扩容只会扩容到原来的两倍。老数组里的数据移动到新的数组时，位置要么不变，要么变为 index+ oldSize，参数里的 node 会在扩容之后使用链表<strong>头插法</strong>插入到指定位置。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">rehash</span><span class="params">(HashEntry&lt;K,V&gt; node)</span> &#123;</span><br><span class="line">    HashEntry&lt;K,V&gt;[] oldTable = table;</span><br><span class="line">    <span class="comment">// 老容量</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">oldCapacity</span> <span class="operator">=</span> oldTable.length;</span><br><span class="line">    <span class="comment">// 新容量，扩大两倍</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">newCapacity</span> <span class="operator">=</span> oldCapacity &lt;&lt; <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 新的扩容阀值 </span></span><br><span class="line">    threshold = (<span class="type">int</span>)(newCapacity * loadFactor);</span><br><span class="line">    <span class="comment">// 创建新的数组</span></span><br><span class="line">    HashEntry&lt;K,V&gt;[] newTable = (HashEntry&lt;K,V&gt;[]) <span class="keyword">new</span> <span class="title class_">HashEntry</span>[newCapacity];</span><br><span class="line">    <span class="comment">// 新的掩码，默认2扩容后是4，-1是3，二进制就是11。</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">sizeMask</span> <span class="operator">=</span> newCapacity - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; oldCapacity ; i++) &#123;</span><br><span class="line">        <span class="comment">// 遍历老数组</span></span><br><span class="line">        HashEntry&lt;K,V&gt; e = oldTable[i];</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="literal">null</span>) &#123;</span><br><span class="line">            HashEntry&lt;K,V&gt; next = e.next;</span><br><span class="line">            <span class="comment">// 计算新的位置，新的位置只可能是不便或者是老的位置+老的容量。</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">idx</span> <span class="operator">=</span> e.hash &amp; sizeMask;</span><br><span class="line">            <span class="keyword">if</span> (next == <span class="literal">null</span>)   <span class="comment">//  Single node on list</span></span><br><span class="line">                <span class="comment">// 如果当前位置还不是链表，只是一个元素，直接赋值</span></span><br><span class="line">                newTable[idx] = e;</span><br><span class="line">            <span class="keyword">else</span> &#123; <span class="comment">// Reuse consecutive sequence at same slot</span></span><br><span class="line">                <span class="comment">// 如果是链表了</span></span><br><span class="line">                HashEntry&lt;K,V&gt; lastRun = e;</span><br><span class="line">                <span class="type">int</span> <span class="variable">lastIdx</span> <span class="operator">=</span> idx;</span><br><span class="line">                <span class="comment">// 新的位置只可能是不便或者是老的位置+老的容量。</span></span><br><span class="line">                <span class="comment">// 遍历结束后，lastRun 后面的元素位置都是相同的</span></span><br><span class="line">                <span class="keyword">for</span> (HashEntry&lt;K,V&gt; last = next; last != <span class="literal">null</span>; last = last.next) &#123;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> last.hash &amp; sizeMask;</span><br><span class="line">                    <span class="keyword">if</span> (k != lastIdx) &#123;</span><br><span class="line">                        lastIdx = k;</span><br><span class="line">                        lastRun = last;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// ，lastRun 后面的元素位置都是相同的，直接作为链表赋值到新位置。</span></span><br><span class="line">                newTable[lastIdx] = lastRun;</span><br><span class="line">                <span class="comment">// Clone remaining nodes</span></span><br><span class="line">                <span class="keyword">for</span> (HashEntry&lt;K,V&gt; p = e; p != lastRun; p = p.next) &#123;</span><br><span class="line">                    <span class="comment">// 遍历剩余元素，头插法到指定 k 位置。</span></span><br><span class="line">                    <span class="type">V</span> <span class="variable">v</span> <span class="operator">=</span> p.value;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">h</span> <span class="operator">=</span> p.hash;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> h &amp; sizeMask;</span><br><span class="line">                    HashEntry&lt;K,V&gt; n = newTable[k];</span><br><span class="line">                    newTable[k] = <span class="keyword">new</span> <span class="title class_">HashEntry</span>&lt;K,V&gt;(h, p.key, v, n);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 头插法插入新的节点</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">nodeIndex</span> <span class="operator">=</span> node.hash &amp; sizeMask; <span class="comment">// add the new node</span></span><br><span class="line">    node.setNext(newTable[nodeIndex]);</span><br><span class="line">    newTable[nodeIndex] = node;</span><br><span class="line">    table = newTable;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有些同学可能会对最后的两个 for 循环有疑惑，这里第一个 for 是为了寻找这样一个节点，这个节点后面的所有 next 节点的新位置都是相同的。然后把这个作为一个链表赋值到新位置。第二个 for 循环是为了把剩余的元素通过头插法插入到指定位置链表。这样实现的原因可能是基于概率统计，有深入研究的同学可以发表下意见。</p>
<h4 id="get流程-1"><a href="#get流程-1" class="headerlink" title="get流程"></a>get流程</h4><p>到这里就很简单了，get 方法只需要两步即可。</p>
<ol>
<li>计算得到 key 的存放位置。</li>
<li>遍历指定位置查找相同 key 的 value 值。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">get</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">    Segment&lt;K,V&gt; s; <span class="comment">// manually integrate access methods to reduce overhead</span></span><br><span class="line">    HashEntry&lt;K,V&gt;[] tab;</span><br><span class="line">    <span class="type">int</span> <span class="variable">h</span> <span class="operator">=</span> hash(key);</span><br><span class="line">    <span class="type">long</span> <span class="variable">u</span> <span class="operator">=</span> (((h &gt;&gt;&gt; segmentShift) &amp; segmentMask) &lt;&lt; SSHIFT) + SBASE;</span><br><span class="line">    <span class="comment">// 计算得到 key 的存放位置</span></span><br><span class="line">    <span class="keyword">if</span> ((s = (Segment&lt;K,V&gt;)UNSAFE.getObjectVolatile(segments, u)) != <span class="literal">null</span> &amp;&amp;</span><br><span class="line">        (tab = s.table) != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (HashEntry&lt;K,V&gt; e = (HashEntry&lt;K,V&gt;) UNSAFE.getObjectVolatile</span><br><span class="line">                 (tab, ((<span class="type">long</span>)(((tab.length - <span class="number">1</span>) &amp; h)) &lt;&lt; TSHIFT) + TBASE);</span><br><span class="line">             e != <span class="literal">null</span>; e = e.next) &#123;</span><br><span class="line">            <span class="comment">// 如果是链表，遍历查找到相同 key 的 value。</span></span><br><span class="line">            K k;</span><br><span class="line">            <span class="keyword">if</span> ((k = e.key) == key || (e.hash == h &amp;&amp; key.equals(k)))</span><br><span class="line">                <span class="keyword">return</span> e.value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="size计算流程-1"><a href="#size计算流程-1" class="headerlink" title="size计算流程"></a>size计算流程</h4><ul>
<li>计算元素个数前，先不加锁计算两次，如果前后两次结果一样，认为个数返回正确</li>
<li>如果不一样，进行重试，重试次数超过3，将所有segment锁住，重新计算个数返回</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="comment">// Try a few times to get accurate count. On failure due to</span></span><br><span class="line">	<span class="comment">// continuous async changes in table, resort to locking.</span></span><br><span class="line">	<span class="keyword">final</span> Segment&lt;K,V&gt;[] segments = <span class="built_in">this</span>.segments;</span><br><span class="line">	<span class="type">int</span> size;</span><br><span class="line">	<span class="type">boolean</span> overflow; <span class="comment">// true if size overflows 32 bits</span></span><br><span class="line">	<span class="type">long</span> sum;         <span class="comment">// sum of modCounts</span></span><br><span class="line">	<span class="type">long</span> <span class="variable">last</span> <span class="operator">=</span> <span class="number">0L</span>;   <span class="comment">// previous sum</span></span><br><span class="line">	<span class="type">int</span> <span class="variable">retries</span> <span class="operator">=</span> -<span class="number">1</span>; <span class="comment">// first iteration isn&#x27;t retry</span></span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		<span class="keyword">for</span> (;;) &#123;</span><br><span class="line">			<span class="comment">//判断retries是否等于RETRIES_BEFORE_LOCK(值为2)</span></span><br><span class="line">			<span class="comment">//也就是默认有两次的机会，是不加锁来求size的</span></span><br><span class="line">			<span class="keyword">if</span> (retries++ == RETRIES_BEFORE_LOCK) &#123;</span><br><span class="line">				<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; segments.length; ++j)</span><br><span class="line">					ensureSegment(j).lock(); <span class="comment">// force creation</span></span><br><span class="line">			&#125;</span><br><span class="line">			sum = <span class="number">0L</span>;</span><br><span class="line">			size = <span class="number">0</span>;</span><br><span class="line">			overflow = <span class="literal">false</span>;</span><br><span class="line">			<span class="comment">//遍历Segments[]数组获取里面的每一个segment，然后对modCount进行求和</span></span><br><span class="line">			<span class="comment">//这个for嵌套在for(;;)中，默认会执行两次，如果两次值相同，就返回</span></span><br><span class="line">			<span class="comment">//如果两次值不同，就进入到上面的if中，进行加锁。之后在进行求和</span></span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; segments.length; ++j) &#123;</span><br><span class="line">				Segment&lt;K,V&gt; seg = segmentAt(segments, j);</span><br><span class="line">				<span class="keyword">if</span> (seg != <span class="literal">null</span>) &#123;</span><br><span class="line">					sum += seg.modCount;</span><br><span class="line">					<span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> seg.count;</span><br><span class="line">					<span class="keyword">if</span> (c &lt; <span class="number">0</span> || (size += c) &lt; <span class="number">0</span>)</span><br><span class="line">						overflow = <span class="literal">true</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (sum == last)</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			last = sum;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">finally</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (retries &gt; RETRIES_BEFORE_LOCK) &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; segments.length; ++j)</span><br><span class="line">				segmentAt(segments, j).unlock();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> overflow ? Integer.MAX_VALUE : size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>Java7 中 ConcurrentHashMap 使用的分段锁，也就是每一个 Segment 上同时只有一个线程可以操作，每一个 Segment 都是一个类似 HashMap 数组的结构，它可以扩容，它的冲突会转化为链表。但是 Segment 的个数一但初始化就不能改变。</p>
<p>Java8 中的 ConcurrentHashMap 使用的 Synchronized 锁加 CAS 的机制。结构也由 Java7 中的 <strong>Segment 数组 + HashEntry 数组 + 链表</strong> 进化成了 <strong>Node 数组 + 链表 &#x2F; 红黑树</strong>，Node 是类似于一个 HashEntry 的结构。它的冲突再达到一定大小时会转化成红黑树，在冲突小于一定数量时又退回链表。</p>
<p>有些同学可能对 Synchronized 的性能存在疑问，其实 Synchronized 锁自从引入锁升级策略后，性能不再是问题，有兴趣的同学可以自己了解下 Synchronized 的<strong>锁升级</strong>。</p>
]]></content>
      <categories>
        <category>多线程与高并发</category>
      </categories>
  </entry>
  <entry>
    <title>JUC高并发编程-线程池</title>
    <url>/2022/05/17/2022-05-17-JUC%E9%AB%98%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-%E7%BA%BF%E7%A8%8B%E6%B1%A0/</url>
    <content><![CDATA[<h1 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h1><h4 id="线程池介绍"><a href="#线程池介绍" class="headerlink" title="线程池介绍"></a>线程池介绍</h4><p>池化技术现在已经屡见不鲜了，线程池、数据库连接池、Http 连接池等等都是对这个思想的应用。池化技术的思想主要是为了减少每次获取资源的消耗，提高对资源的利用率。</p>
<p>线程池提供了一种限制和管理资源（包括执行一个任务）的方式。 每个线程池还维护一些基本统计信息，例如已完成任务的数量。</p>
<p>使用线程池的好处：</p>
<ul>
<li>降低资源消耗：通过重复利用已创建的线程降低线程创建和销毁造成的消耗。</li>
<li>提高响应速度：当任务到达时，任务可以不需要等到线程创建就能立即执行。</li>
<li>提高线程的可管理性：线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。</li>
</ul>
<h4 id="自定义线程池"><a href="#自定义线程池" class="headerlink" title="自定义线程池"></a>自定义线程池</h4><p><img src="/../images/img93.PNG" alt="img93"></p>
<p>步骤1：自定义拒绝策略接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span><span class="comment">//拒绝策略</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">RejectPolicy</span>&lt;T&gt;&#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">reject</span><span class="params">(BlockingQueue&lt;T&gt; queue,T task)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上图就是一个线程池的实现，先初始化线程池、阻塞队列大小，然后开几个线程通过线程池对象调用方法执行任务，如果任务过多，会添加到阻塞队列中，线程执行完任务再从阻塞队列中取值继续执行。当执行的线程数大于线程池和阻塞队列的大小，我们可以定义拒绝策略，类似 jdk 线程池那样。代码实现如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestThreadPool</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ThreadPool</span> <span class="variable">threadPool</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPool</span>(<span class="number">1</span>,<span class="number">1000</span>,TimeUnit.SECONDS,<span class="number">4</span>,(queue,task)-&gt;&#123;</span><br><span class="line">            <span class="comment">// 1. 死等</span></span><br><span class="line">           queue.put(task);</span><br><span class="line">            <span class="comment">// 2) 带超时等待</span></span><br><span class="line">           <span class="comment">//queue.offer(task, 1500, TimeUnit.MILLISECONDS);</span></span><br><span class="line">            <span class="comment">// 3) 让调用者放弃任务执行</span></span><br><span class="line">           <span class="comment">//log.debug(&quot;放弃&#123;&#125;&quot;, task);</span></span><br><span class="line">            <span class="comment">// 4) 让调用者抛出异常</span></span><br><span class="line">            <span class="comment">//throw new RuntimeException(&quot;任务执行失败 &quot; + task);</span></span><br><span class="line">            <span class="comment">// 5) 让调用者自己执行任务</span></span><br><span class="line">            <span class="comment">//task.run();</span></span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i;</span><br><span class="line">            threadPool.execute(()-&gt;&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                log.debug(<span class="string">&quot;&#123;&#125;&quot;</span>, j);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//拒绝策略</span></span><br><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">RejectPolicy</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">reject</span><span class="params">(BlockingQueue&lt;T&gt; queue, T task)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ThreadPool</span>&#123;</span><br><span class="line">    <span class="comment">//任务队列</span></span><br><span class="line">    <span class="keyword">private</span> BlockingQueue&lt;Runnable&gt; taskQueue;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//线程集合</span></span><br><span class="line">    <span class="keyword">private</span> HashSet&lt;Worker&gt; workers = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//核心线程数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> coreSize;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取任务时的超时时间</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> timeout;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> TimeUnit timeUnit;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//拒绝策略</span></span><br><span class="line">    <span class="keyword">private</span> RejectPolicy&lt;Runnable&gt; rejectPolicy;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ThreadPool</span><span class="params">(<span class="type">int</span> coreSize, <span class="type">long</span> timeout, TimeUnit timeUnit, <span class="type">int</span> queueCapcity,RejectPolicy&lt;Runnable&gt; rejectPolicy)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.coreSize = coreSize;</span><br><span class="line">        <span class="built_in">this</span>.timeout = timeout;</span><br><span class="line">        <span class="built_in">this</span>.timeUnit = timeUnit;</span><br><span class="line">        <span class="built_in">this</span>.taskQueue = <span class="keyword">new</span> <span class="title class_">BlockingQueue</span>&lt;&gt;(queueCapcity);</span><br><span class="line">        <span class="built_in">this</span>.rejectPolicy = rejectPolicy;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//执行任务</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">(Runnable task)</span> &#123;</span><br><span class="line">        <span class="comment">// 当任务数没有超过 coreSize 时，直接交给 worker 对象执行</span></span><br><span class="line">        <span class="comment">// 如果任务数超过 coreSize 时，加入任务队列暂存</span></span><br><span class="line">        <span class="keyword">synchronized</span> (workers) &#123;</span><br><span class="line">            <span class="keyword">if</span> (workers.size() &lt; coreSize) &#123;</span><br><span class="line">                <span class="type">Worker</span> <span class="variable">worker</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Worker</span>(task);</span><br><span class="line">                log.debug(<span class="string">&quot;新增 worker&#123;&#125;, &#123;&#125;&quot;</span>, worker, task);</span><br><span class="line">                workers.add(worker);</span><br><span class="line">                worker.start();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 1) 死等</span></span><br><span class="line">                <span class="comment">// 2) 带超时等待</span></span><br><span class="line">                <span class="comment">// 3) 让调用者放弃任务执行</span></span><br><span class="line">                <span class="comment">// 4) 让调用者抛出异常</span></span><br><span class="line">                <span class="comment">// 5) 让调用者自己执行任务</span></span><br><span class="line">                <span class="comment">//taskQueue.put(task);</span></span><br><span class="line">                taskQueue.tryPut(rejectPolicy, task);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Worker</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> Runnable task;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Worker</span><span class="params">(Runnable task)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.task = task;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="comment">//执行任务</span></span><br><span class="line">            <span class="comment">// 1) 当 task 不为空，执行任务</span></span><br><span class="line">            <span class="comment">// 2) 当 task 执行完毕，再接着从任务队列获取任务并执行</span></span><br><span class="line">            <span class="comment">//while(task != null || (task = taskQueue.take()) != null)</span></span><br><span class="line">            <span class="keyword">while</span> (task != <span class="literal">null</span> || (task = taskQueue.poll(timeout, timeUnit)) != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    log.debug(<span class="string">&quot;正在执行...&#123;&#125;&quot;</span>, task);</span><br><span class="line">                    task.run();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    task = <span class="literal">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">synchronized</span> (workers) &#123;</span><br><span class="line">                log.debug(<span class="string">&quot;worker 被移除&#123;&#125;&quot;</span>, <span class="built_in">this</span>);</span><br><span class="line">                workers.remove(<span class="built_in">this</span>);</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BlockingQueue</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="comment">//1.任务队列</span></span><br><span class="line">    <span class="keyword">private</span> Deque&lt;T&gt; queue = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;T&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.锁</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.生产者条件变量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">Condition</span> <span class="variable">fullWait</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//4.消费者条件变量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">Condition</span> <span class="variable">emptyWait</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//5.容量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> capcity;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">BlockingQueue</span><span class="params">(<span class="type">int</span> capcity)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.capcity = capcity;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//带超时的阻塞获取</span></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">poll</span><span class="params">(<span class="type">long</span> timeout, TimeUnit unit)</span> &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 将 timeout 统一转换为 纳秒</span></span><br><span class="line">            <span class="type">long</span> <span class="variable">nanos</span> <span class="operator">=</span> unit.toNanos(timeout);</span><br><span class="line">            <span class="keyword">while</span> (queue.isEmpty()) &#123;</span><br><span class="line">                <span class="comment">// 返回值是剩余时间</span></span><br><span class="line">                <span class="keyword">if</span> (nanos &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    nanos=emptyWait.awaitNanos(nanos);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">T</span> <span class="variable">t</span> <span class="operator">=</span> queue.removeFirst();</span><br><span class="line">            fullWait.signal();</span><br><span class="line">            <span class="keyword">return</span> t;</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//阻塞获取</span></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">take</span><span class="params">()</span> &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (queue.isEmpty()) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    emptyWait.wait();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">T</span> <span class="variable">t</span> <span class="operator">=</span> queue.removeFirst();</span><br><span class="line">            fullWait.signal();</span><br><span class="line">            <span class="keyword">return</span> t;</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//阻塞添加</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(T task)</span> &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (queue.size() == capcity) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    fullWait.wait();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            log.debug(<span class="string">&quot;加入任务队列 &#123;&#125;&quot;</span>, task);</span><br><span class="line">            queue.addLast(task);</span><br><span class="line">            emptyWait.signal();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//带超时的阻塞添加</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">offer</span><span class="params">(T task, <span class="type">long</span> timeout, TimeUnit timeUnit)</span> &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">long</span> <span class="variable">nanos</span> <span class="operator">=</span> timeUnit.toNanos(timeout);</span><br><span class="line">            <span class="keyword">while</span> (queue.size() == capcity) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    nanos = fullWait.awaitNanos(nanos);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            log.debug(<span class="string">&quot;加入任务队列 &#123;&#125;&quot;</span>, task);</span><br><span class="line">            queue.addLast(task);</span><br><span class="line">            emptyWait.signal();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span> &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> queue.size();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">tryPut</span><span class="params">(RejectPolicy&lt;T&gt; rejectPolicy,T task)</span> &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (queue.size() == capcity) &#123;</span><br><span class="line">                rejectPolicy.reject(<span class="built_in">this</span>, task);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                log.debug(<span class="string">&quot;加入任务队列 &#123;&#125;&quot;</span>, task);</span><br><span class="line">                queue.addLast(task);</span><br><span class="line">                emptyWait.signal();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="ThreadPoolExecutor"><a href="#ThreadPoolExecutor" class="headerlink" title="ThreadPoolExecutor"></a>ThreadPoolExecutor</h4><h5 id="线程池状态"><a href="#线程池状态" class="headerlink" title="线程池状态"></a>线程池状态</h5><p>ThreadPoolExecutor 使用 int 的高 3 位来表示线程池状态，低 29 位表示线程数量，ThreadPoolExecutor 类中的线程状态变量如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Integer.SIZE 值为 32 </span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">COUNT_BITS</span> <span class="operator">=</span> Integer.SIZE - <span class="number">3</span>;</span><br><span class="line"> <span class="comment">// runState is stored in the high-order bits</span></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">RUNNING</span>    <span class="operator">=</span> -<span class="number">1</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">SHUTDOWN</span>   <span class="operator">=</span>  <span class="number">0</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">STOP</span>       <span class="operator">=</span>  <span class="number">1</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">TIDYING</span>    <span class="operator">=</span>  <span class="number">2</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">TERMINATED</span> <span class="operator">=</span>  <span class="number">3</span> &lt;&lt; COUNT_BITS;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th align="center">状态名称</th>
<th align="center">高3位的值</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">RUNNING</td>
<td align="center">111</td>
<td align="center">接收新任务，同时处理任务队列中的任务</td>
</tr>
<tr>
<td align="center">SHUTDOWN</td>
<td align="center">000</td>
<td align="center">不接受新任务，但是处理任务队列中的任务</td>
</tr>
<tr>
<td align="center">STOP</td>
<td align="center">001</td>
<td align="center">中断正在执行的任务，同时抛弃阻塞队列中的任务</td>
</tr>
<tr>
<td align="center">TIDYING</td>
<td align="center">010</td>
<td align="center">任务执行完毕，活动线程为0时，即将进入终结阶段</td>
</tr>
<tr>
<td align="center">TERMINATED</td>
<td align="center">011</td>
<td align="center">终结状态</td>
</tr>
</tbody></table>
<p>线程池状态和线程池中线程的数量由一个原子整型ctl来共同表示。使用一个数来表示两个值的主要原因是：可以通过一次CAS同时更改两个属性的值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 原子整数，前 3 位保存了线程池的状态，剩余位保存的是线程数量</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">AtomicInteger</span> <span class="variable">ctl</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(ctlOf(RUNNING, <span class="number">0</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 并不是所有平台的 int 都是 32 位。</span></span><br><span class="line"><span class="comment">// 去掉前三位保存线程状态的位数，剩下的用于保存线程数量</span></span><br><span class="line"><span class="comment">// 高3位为0，剩余位数全为1</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">COUNT_BITS</span> <span class="operator">=</span> Integer.SIZE - <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2^COUNT_BITS次方，表示可以保存的最大线程数</span></span><br><span class="line"><span class="comment">// CAPACITY 的高3位为 0</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">CAPACITY</span>   <span class="operator">=</span> (<span class="number">1</span> &lt;&lt; COUNT_BITS) - <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p>获取线程池状态、线程数量以及合并两个值的操作：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">/ Packing and unpacking ctl</span><br><span class="line"><span class="comment">// 获取运行状态</span></span><br><span class="line"><span class="comment">// 该操作会让除高3位以外的数全部变为0</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">runStateOf</span><span class="params">(<span class="type">int</span> c)</span>     &#123; <span class="keyword">return</span> c &amp; ~CAPACITY; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取运行线程数</span></span><br><span class="line"><span class="comment">// 该操作会让高3位为0</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">workerCountOf</span><span class="params">(<span class="type">int</span> c)</span>  &#123; <span class="keyword">return</span> c &amp; CAPACITY; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算ctl新值</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">ctlOf</span><span class="params">(<span class="type">int</span> rs, <span class="type">int</span> wc)</span> &#123; <span class="keyword">return</span> rs | wc; &#125;</span><br></pre></td></tr></table></figure>

<p>线程池的属性：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 工作线程，内部封装了Thread</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Worker</span></span><br><span class="line">        <span class="keyword">extends</span> <span class="title class_">AbstractQueuedSynchronizer</span></span><br><span class="line">        <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 阻塞队列，用于存放来不及被核心线程执行的任务</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> BlockingQueue&lt;Runnable&gt; workQueue;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 锁</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">mainLock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用于存放核心线程的容器，只有当持有锁时才能够获取其中的元素（核心线程）</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> HashSet&lt;Worker&gt; workers = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;Worker&gt;();</span><br></pre></td></tr></table></figure>

<h5 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h5><p>看一下 ThreadPoolExecutor 类参数最多、最全的有参构造方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ThreadPoolExecutor</span><span class="params">(<span class="type">int</span> corePoolSize,</span></span><br><span class="line"><span class="params">                          <span class="type">int</span> maximumPoolSize,</span></span><br><span class="line"><span class="params">                          <span class="type">long</span> keepAliveTime,</span></span><br><span class="line"><span class="params">                          TimeUnit unit,</span></span><br><span class="line"><span class="params">                          BlockingQueue&lt;Runnable&gt; workQueue,</span></span><br><span class="line"><span class="params">                          ThreadFactory threadFactory,</span></span><br><span class="line"><span class="params">                          RejectedExecutionHandler handler)</span></span><br></pre></td></tr></table></figure>

<p>构造参数解释：</p>
<ul>
<li>corePoolSize：核心线程数</li>
<li>maximumPoolSize：最大线程数<ul>
<li>maximumPoolSize - corePoolSize &#x3D; 救急线程数</li>
</ul>
</li>
<li>keepAliveTime：救急线程空闲时的最大生存时间</li>
<li>unit：时间单位</li>
<li>workQueue：阻塞队列（存放任务）<ul>
<li>有界阻塞队列：ArrayBlockingQueue</li>
<li>无界阻塞队列：LinkedBlockingQueue</li>
<li>最多只有一个同步元素的队列：SynchronousQueue</li>
</ul>
</li>
<li>PriorityBlockingQueue：优先队列</li>
<li>threadFactory：线程工厂（给线程取名字）</li>
<li>handler：拒绝策略</li>
</ul>
<p>工作方式：</p>
<ol>
<li><p>线程池中刚开始没有线程，当一个任务提交给线程池后，线程池会创建一个新线程来执行任务。</p>
</li>
<li><p>当线程数达到 corePoolSize 没有线程空闲时，这时再加入任务，新加的任务会被加入 workQueue 队列排 队，直到有空闲的线程。</p>
</li>
<li><p>如果队列选择了有界队列，那么任务超过了队列大小时，会创建 maximumPoolSize - corePoolSize 数目的线程来救急。</p>
</li>
<li><p>如果线程数达到 maximumPoolSize 仍然有新任务，这时会执行拒绝策略。拒绝策略 jdk 提供了下面的前4 种实现，其它的著名框架也提供了实现：</p>
<ol>
<li><p>ThreadPoolExecutor.AbortPolicy：让调用者抛出RejectedExecutionException 异常，这是默认策略。</p>
</li>
<li><p>ThreadPoolExecutor.CallerRunsPolicy：让调用者运行任务。</p>
</li>
<li><p>ThreadPoolExecutor.DiscardPolicy：放弃本次任务。</p>
</li>
<li><p>ThreadPoolExecutor.DiscardOldestPolicy：放弃队列中最早的任务，本任务取而代之。</p>
</li>
<li><p>Dubbo 的实现：在抛出 RejectedExecutionException 异常之前会记录日志，并 dump 线程栈信息，方便定位问题。</p>
</li>
<li><p>Netty 的实现：创建一个新线程来执行任务。</p>
</li>
<li><p>ActiveMQ 的实现：带超时等待（60s）尝试放入队列，类似之前自定义的拒绝策略。</p>
</li>
<li><p>PinPoint 的实现，它使用了一个拒绝策略链，会逐一尝试策略链中每种拒绝策略。</p>
</li>
</ol>
</li>
<li><p>当高峰过去后，超过 corePoolSize 的救急线程如果一段时间没有任务做，需要结束节省资源，这个时间由 keepAliveTime 和 unit 来控制。</p>
</li>
</ol>
<p>jdk 线程池的拒绝策略结构图如下：</p>
<p>据这个构造方法，JDK Executors 类中提供了众多工厂方法来创建各种用途的线程池。</p>
<h5 id="newFixedThreadPool"><a href="#newFixedThreadPool" class="headerlink" title="newFixedThreadPool"></a>newFixedThreadPool</h5><p>newFixedThreadPool 创建的是固定大小的线程池。实现代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建大小为 2 的固定线程池, 自定义线程名称</span></span><br><span class="line"> <span class="type">ExecutorService</span> <span class="variable">executorService</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">2</span>, <span class="keyword">new</span> <span class="title class_">ThreadFactory</span>() &#123;</span><br><span class="line">     <span class="keyword">private</span> <span class="type">AtomicInteger</span> <span class="variable">atomicInteger</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="number">1</span>);</span><br><span class="line">     <span class="meta">@Override</span></span><br><span class="line">     <span class="keyword">public</span> Thread <span class="title function_">newThread</span><span class="params">(Runnable r)</span> &#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(r, <span class="string">&quot;my_thread_&quot;</span> + atomicInteger.getAndIncrement());</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;);</span><br><span class="line"> <span class="comment">// 开 3 个线程, 线程池大小为 2 , 第三个线程执行时, 如果前两个线程任务没执行完, 会加入任务队列.</span></span><br><span class="line"> executorService.execute(() -&gt; &#123;</span><br><span class="line">     log.info(<span class="string">&quot;1&quot;</span>);</span><br><span class="line"> &#125;);</span><br><span class="line"> executorService.execute(() -&gt; &#123;</span><br><span class="line">     log.info(<span class="string">&quot;2&quot;</span>);</span><br><span class="line"> &#125;);</span><br><span class="line"> executorService.execute(() -&gt; &#123;</span><br><span class="line">     log.info(<span class="string">&quot;3&quot;</span>);</span><br><span class="line"> &#125;);</span><br></pre></td></tr></table></figure>

<p>Executors 类 使用 newFixedThreadPool 创建线程的源码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newFixedThreadPool</span><span class="params">(<span class="type">int</span> nThreads)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(nThreads, nThreads,</span><br><span class="line">                                      <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                      <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;Runnable&gt;());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ThreadPoolExecutor</span><span class="params">(<span class="type">int</span> corePoolSize,</span></span><br><span class="line"><span class="params">                              <span class="type">int</span> maximumPoolSize,</span></span><br><span class="line"><span class="params">                              <span class="type">long</span> keepAliveTime,</span></span><br><span class="line"><span class="params">                              TimeUnit unit,</span></span><br><span class="line"><span class="params">                              BlockingQueue&lt;Runnable&gt; workQueue)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,</span><br><span class="line">             Executors.defaultThreadFactory(), defaultHandler);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>通过源码可以看到 new ThreadPoolExecutor(xxx) 方法其实是是调用了之前的完整参数的构造方法，创建的是固定的线程数，使用了默认的线程工厂和拒绝策略。</p>
<p>特点：</p>
<ul>
<li>核心线程数 &#x3D; 最大线程数（没有救急线程被创建），因此也无需超时时间。</li>
<li>阻塞队列是无界的（LinkedBlockingQueue），可以放任意数量的任务。</li>
<li>适用于任务量已知，相对耗时的任务。</li>
</ul>
<h5 id="newCachedThreadPool"><a href="#newCachedThreadPool" class="headerlink" title="newCachedThreadPool"></a>newCachedThreadPool</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ExecutorService</span> <span class="variable">executorService</span> <span class="operator">=</span> Executors.newCachedThreadPool();</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newCachedThreadPool</span><span class="params">()</span> &#123;</span><br><span class="line">	 <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">0</span>, Integer.MAX_VALUE,</span><br><span class="line">	 <span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">	 <span class="keyword">new</span> <span class="title class_">SynchronousQueue</span>&lt;Runnable&gt;());</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>特点：</p>
<ul>
<li><p>核心线程数是 0，最大线程数是 Integer.MAX_VALUE，救急线程的空闲生存时间是 60s，意味着全部都是救急线程（60s 后没有任务就回收），救急线程可以无限创建。</p>
</li>
<li><p>队列采用了 SynchronousQueue 实现特点是它没有容量，没有线程来取任务是放不进去的（一手交钱、一手交 货）SynchronousQueue。</p>
</li>
<li><p>整个线程池表现为线程数会根据任务量不断增长，没有上限，当任务执行完毕，空闲1分钟后释放线程。</p>
</li>
<li><p>适合任务数比较密集，但每个任务执行时间较短的情况。</p>
</li>
</ul>
<p>示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">SynchronousQueue&lt;Integer&gt; integers = <span class="keyword">new</span> <span class="title class_">SynchronousQueue</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                log.debug(<span class="string">&quot;putting &#123;&#125; &quot;</span>, <span class="number">1</span>);</span><br><span class="line">                integers.put(<span class="number">1</span>);</span><br><span class="line">                log.debug(<span class="string">&quot;&#123;&#125; putted...&quot;</span>, <span class="number">1</span>);</span><br><span class="line">                log.debug(<span class="string">&quot;putting...&#123;&#125; &quot;</span>, <span class="number">2</span>);</span><br><span class="line">                integers.put(<span class="number">2</span>);</span><br><span class="line">                log.debug(<span class="string">&quot;&#123;&#125; putted...&quot;</span>, <span class="number">2</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;,<span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                log.debug(<span class="string">&quot;taking &#123;&#125;&quot;</span>,<span class="number">1</span>);</span><br><span class="line">                integers.take();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;t2&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                log.debug(<span class="string">&quot;taking &#123;&#125;&quot;</span>,<span class="number">2</span>);</span><br><span class="line">                integers.take();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;t3&quot;</span>).start();</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">20</span>:<span class="number">17</span>:<span class="number">15.364</span> [t1] DEBUG com.heu.test.TestPool2 - putting <span class="number">1</span> </span><br><span class="line"><span class="number">20</span>:<span class="number">17</span>:<span class="number">16.372</span> [t2] DEBUG com.heu.test.TestPool2 - taking <span class="number">1</span></span><br><span class="line"><span class="number">20</span>:<span class="number">17</span>:<span class="number">16.373</span> [t1] DEBUG com.heu.test.TestPool2 - <span class="number">1</span> putted...</span><br><span class="line"><span class="number">20</span>:<span class="number">17</span>:<span class="number">16.373</span> [t1] DEBUG com.heu.test.TestPool2 - putting..<span class="number">.2</span> </span><br><span class="line"><span class="number">20</span>:<span class="number">17</span>:<span class="number">17.373</span> [t3] DEBUG com.heu.test.TestPool2 - taking <span class="number">2</span></span><br><span class="line"><span class="number">20</span>:<span class="number">17</span>:<span class="number">17.374</span> [t1] DEBUG com.heu.test.TestPool2 - <span class="number">2</span> putted...</span><br></pre></td></tr></table></figure>

<h5 id="newSingleThreadExecutor"><a href="#newSingleThreadExecutor" class="headerlink" title="newSingleThreadExecutor"></a>newSingleThreadExecutor</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newSingleThreadExecutor</span><span class="params">()</span> &#123;</span><br><span class="line"> <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">FinalizableDelegatedExecutorService</span></span><br><span class="line"> (<span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">1</span>, <span class="number">1</span>,<span class="number">0L</span>, TimeUnit.MILLISECONDS,<span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;Runnable&gt;()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用场景：</p>
<ul>
<li><p>希望多个任务排队执行。线程数固定为 1，任务数多于 1 时，会放入无界队列排队。任务执行完毕，这唯一的线程也不会被释放。</p>
</li>
<li><p>newSingleThreadExecutor 和 newFixedThreadPool 区别：</p>
<ul>
<li><p>自己创建一个单线程串行执行任务，如果任务执行失败而终止，那么没有任何补救措施，而newSingleThreadExecutor 线程池还会新建一个线程，保证池的正常工作。</p>
</li>
<li><p>newSingleThreadExecutor() 线程个数始终为 1，不能修改。FinalizableDelegatedExecutorService 应用的是装饰器模式，只对外暴露了 ExecutorService 接口，不能调用 ThreadPoolExecutor 中特有的方法。</p>
</li>
<li><p>Executors.newFixedThreadPool(1) 初始时为1，以后还可以修改。它对外暴露的是 ThreadPoolExecutor 对象，可以强转后调用 setCorePoolSize 等方法进行修改。</p>
</li>
</ul>
</li>
</ul>
<p>Executors 返回线程池对象的弊端如下：</p>
<ul>
<li><p>FixedThreadPool 和 SingleThreadExecutor：允许请求的队列长度为 Integer.MAX_VALUE，可能堆积大量的请求，从而导致 OOM。</p>
</li>
<li><p>CachedThreadPool 和 ScheduledThreadPool：允许创建的线程数量为 Integer.MAX_VALUE ，可能会创建大量线程，从而导致 OOM。</p>
</li>
<li><p>其实就是使用有界队列，控制线程创建数量。</p>
</li>
<li><p>此外，除了避免 OOM 的原因之外，不推荐使用 Executors提供的线程池的原因还有：</p>
<ul>
<li><p>实际使用中需要根据自己机器的性能、业务场景来手动配置线程池的参数比如核心线程数、使用的任务队列、饱和策略等等。</p>
</li>
<li><p>我们应该显示地给线程池命名，这样有助于我们定位问题。</p>
</li>
</ul>
</li>
</ul>
<h5 id="提交任务"><a href="#提交任务" class="headerlink" title="提交任务"></a>提交任务</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 执行任务</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">execute</span><span class="params">(Runnable command)</span>;</span><br><span class="line"><span class="comment">// 提交任务 task，用返回值 Future 获得任务执行结果，Future的原理就是利用之前讲到的保护性暂停模式来接受返回结果的，主线程可以执行 FutureTask.get()方法来等待任务执行完成。</span></span><br><span class="line">&lt;T&gt; Future&lt;T&gt; <span class="title function_">submit</span><span class="params">(Callable&lt;T&gt; task)</span>;</span><br><span class="line"><span class="comment">// 提交 tasks 中所有任务</span></span><br><span class="line">&lt;T&gt; List&lt;Future&lt;T&gt;&gt; <span class="title function_">invokeAll</span><span class="params">(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks)</span></span><br><span class="line"> <span class="keyword">throws</span> InterruptedException;</span><br><span class="line"><span class="comment">// 提交 tasks 中所有任务，带超时时间</span></span><br><span class="line">&lt;T&gt; List&lt;Future&lt;T&gt;&gt; <span class="title function_">invokeAll</span><span class="params">(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks,</span></span><br><span class="line"><span class="params"> <span class="type">long</span> timeout, TimeUnit unit)</span></span><br><span class="line"> <span class="keyword">throws</span> InterruptedException;</span><br><span class="line"><span class="comment">// 提交 tasks 中所有任务，哪个任务先成功执行完毕，返回此任务执行结果，其它任务取消</span></span><br><span class="line">&lt;T&gt; T <span class="title function_">invokeAny</span><span class="params">(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks)</span></span><br><span class="line"> <span class="keyword">throws</span> InterruptedException, ExecutionException;</span><br><span class="line"><span class="comment">// 提交 tasks 中所有任务，哪个任务先成功执行完毕，返回此任务执行结果，其它任务取消，带超时时间</span></span><br><span class="line">&lt;T&gt; T <span class="title function_">invokeAny</span><span class="params">(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks,</span></span><br><span class="line"><span class="params"> <span class="type">long</span> timeout, TimeUnit unit)</span></span><br><span class="line"> <span class="keyword">throws</span> InterruptedException, ExecutionException, TimeoutException;</span><br></pre></td></tr></table></figure>

<h5 id="关闭线程池"><a href="#关闭线程池" class="headerlink" title="关闭线程池"></a>关闭线程池</h5><p>shutdown：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	  线程池状态变为 SHUTDOWN</span></span><br><span class="line"><span class="comment">	- 不会接收新任务</span></span><br><span class="line"><span class="comment">	- 但已提交任务会执行完，包括等待队列里面的</span></span><br><span class="line"><span class="comment">	- 此方法不会阻塞调用线程的执行</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">shutdown</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">mainLock</span> <span class="operator">=</span> <span class="built_in">this</span>.mainLock;</span><br><span class="line">        mainLock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            checkShutdownAccess();</span><br><span class="line">            <span class="comment">// 修改线程池状态</span></span><br><span class="line">            advanceRunState(SHUTDOWN);</span><br><span class="line">            <span class="comment">// 仅会打断空闲线程</span></span><br><span class="line">            interruptIdleWorkers();</span><br><span class="line">            onShutdown(); <span class="comment">// 扩展点 ScheduledThreadPoolExecutor</span></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            mainLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 尝试终结(没有运行的线程可以立刻终结)</span></span><br><span class="line">        tryTerminate();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>shutdownNow：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">线程池状态变为 STOP</span></span><br><span class="line"><span class="comment">- 不会接收新任务</span></span><br><span class="line"><span class="comment">- 会将队列中的任务返回</span></span><br><span class="line"><span class="comment">- 并用 interrupt 的方式中断正在执行的任务</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">   <span class="keyword">public</span> List&lt;Runnable&gt; <span class="title function_">shutdownNow</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">       List&lt;Runnable&gt; tasks;</span><br><span class="line">       <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">mainLock</span> <span class="operator">=</span> <span class="built_in">this</span>.mainLock;</span><br><span class="line">       mainLock.lock();</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           checkShutdownAccess();</span><br><span class="line">           <span class="comment">// 修改线程池状态</span></span><br><span class="line">           advanceRunState(STOP);</span><br><span class="line">           <span class="comment">// 打断所有线程</span></span><br><span class="line">           interruptWorkers();</span><br><span class="line">           <span class="comment">// 获取队列中剩余任务</span></span><br><span class="line">           tasks = drainQueue();</span><br><span class="line">       &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">           mainLock.unlock();</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">// 尝试终结</span></span><br><span class="line">       tryTerminate();</span><br><span class="line">       <span class="keyword">return</span> tasks;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>其它方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 不在 RUNNING 状态的线程池，此方法就返回 true</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">isShutdown</span><span class="params">()</span>;</span><br><span class="line"><span class="comment">// 线程池状态是否是 TERMINATED</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">isTerminated</span><span class="params">()</span>;</span><br><span class="line"><span class="comment">// 调用 shutdown 后，由于调用使线程结束线程的方法是异步的并不会等待所有任务运行结束就返回，因此如果它想在线程池 TERMINATED 后做些其它事情，可以利用此方法等待</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">awaitTermination</span><span class="params">(<span class="type">long</span> timeout, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException;</span><br></pre></td></tr></table></figure>

<h5 id="任务调度线程池"><a href="#任务调度线程池" class="headerlink" title="任务调度线程池"></a>任务调度线程池</h5><p>在任务调度线程池功能加入之前，可以使用 java.util.Timer 来实现定时功能，Timer 的优点在于简单易用，但由于所有任务都是由同一个线程来调度，因此所有任务都是串行执行的，同一时间只能有一个任务在执行，前一个任务的延迟或异常都将会影响到之后的任务。</p>
<p>示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Timer</span> <span class="variable">timer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Timer</span>();</span><br><span class="line">        <span class="type">TimerTask</span> <span class="variable">task1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TimerTask</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                log.debug(<span class="string">&quot;task 1&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="type">TimerTask</span> <span class="variable">task2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TimerTask</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                log.debug(<span class="string">&quot;task 2&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用 timer 添加两个任务，希望它们都在 1s 后执行</span></span><br><span class="line">        <span class="comment">// 但由于 timer 内只有一个线程来顺序执行队列中的任务，因此『任务1』的延时，影响了『任务2』的执行</span></span><br><span class="line">        timer.schedule(task1,<span class="number">1000</span>);</span><br><span class="line">        timer.schedule(task2,<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">20</span>:<span class="number">40</span>:<span class="number">59.276</span> [Timer-<span class="number">0</span>] DEBUG com.heu.test.TestTimer - task <span class="number">1</span></span><br><span class="line"><span class="number">20</span>:<span class="number">41</span>:<span class="number">01.296</span> [Timer-<span class="number">0</span>] DEBUG com.heu.test.TestTimer - task <span class="number">2</span></span><br></pre></td></tr></table></figure>

<p>使用 ScheduledExecutorService 改写：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ScheduledExecutorService</span> <span class="variable">executorService</span> <span class="operator">=</span> Executors.newScheduledThreadPool(<span class="number">2</span>);</span><br><span class="line">        executorService.schedule(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;任务1，执行时间：&quot;</span> + <span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="number">1000</span>, TimeUnit.MILLISECONDS);</span><br><span class="line"></span><br><span class="line">        executorService.schedule(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;任务2，执行时间：&quot;</span> + <span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">        &#125;,<span class="number">1000</span>, TimeUnit.MILLISECONDS);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">任务<span class="number">1</span>，执行时间：Mon Jun <span class="number">14</span> <span class="number">20</span>:<span class="number">46</span>:<span class="number">29</span> CST <span class="number">2021</span></span><br><span class="line">任务<span class="number">2</span>，执行时间：Mon Jun <span class="number">14</span> <span class="number">20</span>:<span class="number">46</span>:<span class="number">29</span> CST <span class="number">2021</span></span><br></pre></td></tr></table></figure>

<p>整个线程池表现为：线程数固定，任务数多于线程数时，会放入无界队列排队。任务执行完毕，这些线程也不会被释放，用来执行延迟或反复执行的任务。</p>
<p>scheduleAtFixedRate 例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ScheduledExecutorService</span> <span class="variable">pool</span> <span class="operator">=</span> Executors.newScheduledThreadPool(<span class="number">1</span>);</span><br><span class="line">log.debug(<span class="string">&quot;start...&quot;</span>);</span><br><span class="line">pool.scheduleAtFixedRate(() -&gt; &#123;</span><br><span class="line"> 	log.debug(<span class="string">&quot;running...&quot;</span>);</span><br><span class="line">    sleep(<span class="number">2</span>);</span><br><span class="line">&#125;, <span class="number">1</span>, <span class="number">1</span>, TimeUnit.SECONDS);</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">21</span>:<span class="number">44</span>:<span class="number">30.311</span> TestTimer [main] - start... </span><br><span class="line"><span class="number">21</span>:<span class="number">44</span>:<span class="number">31.360</span> TestTimer [pool-<span class="number">1</span>-thread-<span class="number">1</span>] - running... </span><br><span class="line"><span class="number">21</span>:<span class="number">44</span>:<span class="number">33.361</span> TestTimer [pool-<span class="number">1</span>-thread-<span class="number">1</span>] - running... </span><br><span class="line"><span class="number">21</span>:<span class="number">44</span>:<span class="number">35.362</span> TestTimer [pool-<span class="number">1</span>-thread-<span class="number">1</span>] - running... </span><br><span class="line"><span class="number">21</span>:<span class="number">44</span>:<span class="number">37.362</span> TestTimer [pool-<span class="number">1</span>-thread-<span class="number">1</span>] - running...</span><br></pre></td></tr></table></figure>

<p>输出分析：一开始，延时 1s，接下来，由于任务执行时间 &gt; 间隔时间，间隔被『撑』到了 2s。</p>
<p>scheduleWithFixedDelay 例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ScheduledExecutorService</span> <span class="variable">pool</span> <span class="operator">=</span> Executors.newScheduledThreadPool(<span class="number">1</span>);</span><br><span class="line">log.debug(<span class="string">&quot;start...&quot;</span>);</span><br><span class="line">pool.scheduleWithFixedDelay(()-&gt; &#123;</span><br><span class="line"> 	log.debug(<span class="string">&quot;running...&quot;</span>);</span><br><span class="line"> 	sleep(<span class="number">2</span>);</span><br><span class="line">&#125;, <span class="number">1</span>, <span class="number">1</span>, TimeUnit.SECONDS);</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">21</span>:<span class="number">40</span>:<span class="number">55.078</span> TestTimer [main] - start... </span><br><span class="line"><span class="number">21</span>:<span class="number">40</span>:<span class="number">56.140</span> TestTimer [pool-<span class="number">1</span>-thread-<span class="number">1</span>] - running... </span><br><span class="line"><span class="number">21</span>:<span class="number">40</span>:<span class="number">59.143</span> TestTimer [pool-<span class="number">1</span>-thread-<span class="number">1</span>] - running... </span><br><span class="line"><span class="number">21</span>:<span class="number">41</span>:<span class="number">02.145</span> TestTimer [pool-<span class="number">1</span>-thread-<span class="number">1</span>] - running... </span><br><span class="line"><span class="number">21</span>:<span class="number">41</span>:<span class="number">05.147</span> TestTimer [pool-<span class="number">1</span>-thread-<span class="number">1</span>] - running...</span><br></pre></td></tr></table></figure>

<p>输出分析：一开始，延时 1s，scheduleWithFixedDelay 的间隔是 上一个任务结束 &lt;-&gt; 延时 &lt;-&gt; 下一个任务开始 所以间隔都是 3s。</p>
<h5 id="正确处理执行任务异常"><a href="#正确处理执行任务异常" class="headerlink" title="正确处理执行任务异常"></a>正确处理执行任务异常</h5><p>方法1：主动捉异常：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ExecutorService</span> <span class="variable">pool</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">1</span>);</span><br><span class="line">	pool.submit(() -&gt; &#123;</span><br><span class="line">		 <span class="keyword">try</span> &#123;</span><br><span class="line">			 log.debug(<span class="string">&quot;task1&quot;</span>);</span><br><span class="line">			 <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span> / <span class="number">0</span>;</span><br><span class="line">		 &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">		 	log.error(<span class="string">&quot;error:&quot;</span>, e);</span><br><span class="line">		 &#125;</span><br><span class="line">	&#125;);</span><br></pre></td></tr></table></figure>

<p>方法2：使用 Future，错误信息都被封装进submit方法的返回方法中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ExecutorService</span> <span class="variable">pool</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">1</span>);</span><br><span class="line">	Future&lt;Boolean&gt; f = pool.submit(() -&gt; &#123;</span><br><span class="line">		 log.debug(<span class="string">&quot;task1&quot;</span>);</span><br><span class="line">		 <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span> / <span class="number">0</span>;</span><br><span class="line">		 <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	&#125;);</span><br><span class="line">	log.debug(<span class="string">&quot;result:&#123;&#125;&quot;</span>, f.get());</span><br></pre></td></tr></table></figure>

<h4 id="Tomcat-线程池"><a href="#Tomcat-线程池" class="headerlink" title="Tomcat 线程池"></a>Tomcat 线程池</h4><ul>
<li><p>LimitLatch 用来限流，可以控制最大连接个数，类似 J.U.C 中的 Semaphore 后面再讲。</p>
</li>
<li><p>Acceptor 只负责【接收新的 socket 连接】。</p>
</li>
<li><p>Poller 只负责监听 socket channel 是否有【可读的 I&#x2F;O 事件】。</p>
</li>
<li><p>一旦可读，封装一个任务对象（socketProcessor），提交给 Executor 线程池处理。</p>
</li>
<li><p>Executor 线程池中的工作线程最终负责【处理请求】。</p>
</li>
</ul>
<p>Tomcat 线程池扩展了 ThreadPoolExecutor，行为稍有不同，如果总线程数达到 maximumPoolSize，这时不会立刻抛 RejectedExecutionException 异常，而是再次尝试将任务放入队列，如果还失败，才抛出 RejectedExecutionException 异常。</p>
<p>tomcat部分源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">(Runnable command, <span class="type">long</span> timeout, TimeUnit unit)</span> &#123;</span><br><span class="line">        submittedCount.incrementAndGet();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="built_in">super</span>.execute(command);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RejectedExecutionException rx) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">super</span>.getQueue() <span class="keyword">instanceof</span> TaskQueue) &#123;</span><br><span class="line">                <span class="keyword">final</span> <span class="type">TaskQueue</span> <span class="variable">queue</span> <span class="operator">=</span> (TaskQueue)<span class="built_in">super</span>.getQueue();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 使任务从新进入阻塞队列</span></span><br><span class="line">                    <span class="keyword">if</span> (!queue.force(command, timeout, unit)) &#123;</span><br><span class="line">                        submittedCount.decrementAndGet();</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RejectedExecutionException</span>(<span class="string">&quot;Queue capacity is full.&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException x) &#123;</span><br><span class="line">                    submittedCount.decrementAndGet();</span><br><span class="line">                    Thread.interrupted();</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RejectedExecutionException</span>(x);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                submittedCount.decrementAndGet();</span><br><span class="line">                <span class="keyword">throw</span> rx;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">force</span><span class="params">(Runnable o, <span class="type">long</span> timeout, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">if</span> ( parent.isShutdown() )</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RejectedExecutionException</span>(</span><br><span class="line">                    <span class="string">&quot;Executor not running, can&#x27;t force a command into the queue&quot;</span></span><br><span class="line">            );</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.offer(o,timeout,unit); <span class="comment">//forces the item onto the queue, to be used if the task</span></span><br><span class="line">        is rejected</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>Connector 配置如下：</p>
<p>Executor 线程池配置如下：</p>
<p>可以看到该线程池实现的是一个无界的队列，所以说是不是执行任务的线程数大于了核心线程数，都会添加到阻塞队列中，那么救急线程是不是就不会用到呢，其实不是，分析如下图：</p>
<p>如图所示，当添加新的任务时，如果提交的任务大于核心线程数小于最大线程数就创建救急线程，否则就加入任务队列中。</p>
<h4 id="异步模式之工作线程"><a href="#异步模式之工作线程" class="headerlink" title="异步模式之工作线程"></a>异步模式之工作线程</h4><p><strong>定义：</strong></p>
<p>让有限的工作线程（Worker Thread）来轮流异步处理无限多的任务。也可以将其归类为分工模式，它的典型实现就是线程池，也体现了经典设计模式中的享元模式。</p>
<p><strong>例如：</strong></p>
<p>海底捞的服务员（线程），轮流处理每位客人的点餐（任务），如果为每位客人都配一名专属的服务员，那 么成本就太高了（对比另一种多线程设计模式：Thread-Per-Message） 注意，不同任务类型应该使用不同的线程池，这样能够避免饥饿，并能提升效率 例如，如果一个餐馆的工人既要招呼客人（任务类型A），又要到后厨做菜（任务类型B）显然效率不咋地，分成 服务员（线程池A）与厨师（线程池B）更为合理，当然你能想到更细致的分工。</p>
<p><strong>饥饿：</strong></p>
<p>固定大小线程池会有饥饿现象，解决方法可以增加线程池的大小，不过不是根本解决方案，还是前面提到的，不同的任务类型，采用不同的线程池。实现代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 异步模式之工作线程</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Slf4j(topic = &quot;c.Code_07_StarvationTest&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Code_07_StarvationTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(Arrays.asList(<span class="string">&quot;宫保鸡丁&quot;</span>, <span class="string">&quot;青椒肉丝&quot;</span>, <span class="string">&quot;千张肉丝&quot;</span>));</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">Random</span> <span class="variable">random</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">cooking</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> list.get(random.nextInt(list.size()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 演示饥饿现象</span></span><br><span class="line">		<span class="comment">//  ExecutorService executorService = Executors.newFixedThreadPool(2);</span></span><br><span class="line">		<span class="comment">//  test1(executorService);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 解决</span></span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">cookPool</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">1</span>);</span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">waiterPool</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        waiterPool.execute(() -&gt; &#123;</span><br><span class="line">            log.info(<span class="string">&quot;处理点餐&quot;</span>);</span><br><span class="line">            Future&lt;String&gt; f = cookPool.submit(() -&gt; &#123;</span><br><span class="line">                log.info(<span class="string">&quot;做菜&quot;</span>);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> cooking();</span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                log.info(<span class="string">&quot;上菜 &#123;&#125; &quot;</span>, f.get());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        waiterPool.execute(() -&gt; &#123;</span><br><span class="line">            log.info(<span class="string">&quot;处理点餐&quot;</span>);</span><br><span class="line">            Future&lt;String&gt; f2 = cookPool.submit(() -&gt; &#123;</span><br><span class="line">                log.info(<span class="string">&quot;做菜&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> cooking();</span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                log.info(<span class="string">&quot;上菜 &#123;&#125; &quot;</span>, f2.get());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">( ExecutorService executorService)</span> &#123;</span><br><span class="line">        executorService.execute(() -&gt; &#123;</span><br><span class="line">            log.info(<span class="string">&quot;处理点餐&quot;</span>);</span><br><span class="line">            Future&lt;String&gt; f = executorService.submit(() -&gt; &#123;</span><br><span class="line">                log.info(<span class="string">&quot;做菜&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> cooking();</span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                log.info(<span class="string">&quot;上菜 &#123;&#125; &quot;</span>, f.get());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        executorService.execute(() -&gt; &#123;</span><br><span class="line">            log.info(<span class="string">&quot;处理点餐&quot;</span>);</span><br><span class="line">            Future&lt;String&gt; f2 = executorService.submit(() -&gt; &#123;</span><br><span class="line">                log.info(<span class="string">&quot;做菜&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> cooking();</span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                log.info(<span class="string">&quot;上菜 &#123;&#125; &quot;</span>, f2.get());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>创建多大的线程池合适?</strong></p>
<p>过小会导致程序不能充分地利用系统资源、容易导致饥饿，过大会导致更多的线程上下文切换，占用更多内存。</p>
<ol>
<li><p>CPU 密集型运算 通常采用 cpu 核数 + 1 能够实现最优的 CPU 利用率，+1 是保证当线程由于页缺失故障（操作系统）或其它原因导致暂停时，额外的这个线程就能顶上去，保证 CPU 时钟周期不被浪费。</p>
</li>
<li><p>I&#x2F;O 密集型运算 CPU 不总是处于繁忙状态，例如，当你执行业务计算时，这时候会使用 CPU 资源，但当你执行 I&#x2F;O 操作时、远程 RPC 调用时，包括进行数据库操作时，这时候 CPU 就闲下来了，你可以利用多线程提高它的利用率。</p>
</li>
<li><p>经验公式如下：</p>
<ul>
<li><p>线程数 &#x3D; 核数 * 期望 CPU 利用率 * 总时间(CPU计算时间+等待时间) &#x2F; CPU 计算时间。</p>
</li>
<li><p>例如 4 核 CPU 计算时间是 50% ，其它等待时间是 50%，期望 cpu 被 100% 利用，套用公式 4 * 100% * 100% &#x2F; 50% &#x3D; 8。</p>
</li>
<li><p>例如 4 核 CPU 计算时间是 10% ，其它等待时间是 90%，期望 cpu 被 100% 利用，套用公式 4 * 100% * 100% &#x2F; 10% &#x3D; 40。</p>
</li>
</ul>
</li>
</ol>
<h4 id="应用之定时任务"><a href="#应用之定时任务" class="headerlink" title="应用之定时任务"></a>应用之定时任务</h4><p>使用 newScheduledThreadPool 中的 scheduleAtFixedRate 这个方法可以执行定时任务。代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 获取当前时间</span></span><br><span class="line">        <span class="type">LocalDateTime</span> <span class="variable">now</span> <span class="operator">=</span> LocalDateTime.now();</span><br><span class="line">        System.out.println(now);</span><br><span class="line">        <span class="comment">// 获取每周四晚时间</span></span><br><span class="line">        <span class="type">LocalDateTime</span> <span class="variable">time</span> <span class="operator">=</span> now.withHour(<span class="number">18</span>).withMinute(<span class="number">0</span>).withSecond(<span class="number">0</span>).withNano(<span class="number">0</span>).with(DayOfWeek.THURSDAY);</span><br><span class="line">        <span class="keyword">if</span>(now.compareTo(time) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            time = time.plusWeeks(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">long</span> <span class="variable">initalDelay</span> <span class="operator">=</span> Duration.between(now, time).toMillis();</span><br><span class="line">        <span class="comment">// 一周的时间</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">period</span> <span class="operator">=</span> <span class="number">1000</span> * <span class="number">60</span> * <span class="number">60</span> * <span class="number">24</span> * <span class="number">7</span>;</span><br><span class="line">        <span class="comment">// initalDelay 表示当前时间与周四的时间差, period 一周的间隔时间。</span></span><br><span class="line">        <span class="type">ScheduledExecutorService</span> <span class="variable">executorService</span> <span class="operator">=</span> Executors.newScheduledThreadPool(<span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 创建一个定时任务, 每周四 18:00:00 执行。</span></span><br><span class="line">        executorService.scheduleAtFixedRate(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;running&quot;</span>);</span><br><span class="line">        &#125;, initalDelay, period, TimeUnit.MILLISECONDS);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>多线程与高并发</category>
      </categories>
      <tags>
        <tag>多线程与高并发</tag>
      </tags>
  </entry>
  <entry>
    <title>java集合-ArrayList源码解析 - ArrayList源码解析</title>
    <url>/2022/05/19/2022-05-19-java%E9%9B%86%E5%90%88-ArrayList%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</url>
    <content><![CDATA[<h1 id="ArrayList源码解析"><a href="#ArrayList源码解析" class="headerlink" title="ArrayList源码解析"></a>ArrayList源码解析</h1><span id="more"></span>

<h4 id="ArrayList简介"><a href="#ArrayList简介" class="headerlink" title="ArrayList简介"></a>ArrayList简介</h4><p><code>ArrayList</code> 的底层是数组队列，相当于动态数组。与 Java 中的数组相比，它的容量能动态增长。在添加大量元素前，应用程序可以使用<code>ensureCapacity</code>操作来增加 <code>ArrayList</code> 实例的容量。这可以减少递增式再分配的数量。</p>
<p><code>ArrayList</code>继承于 <strong>AbstractList</strong> ，实现了 <strong>List</strong>, <strong>RandomAccess</strong>, <strong>Cloneable</strong>, <strong>java.io.Serializable</strong> 这些接口。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayList</span>&lt;E&gt; <span class="keyword">extends</span> <span class="title class_">AbstractList</span>&lt;E&gt;</span><br><span class="line">        <span class="keyword">implements</span> <span class="title class_">List</span>&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable&#123;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>RandomAccess</code> 是一个标志接口，表明实现这个这个接口的 List 集合是支持<strong>快速随机访问</strong>的。在 <code>ArrayList</code> 中，我们即可以通过元素的序号快速获取元素对象，这就是快速随机访问。</li>
<li><code>ArrayList</code> 实现了 <strong>Cloneable 接口</strong> ，即覆盖了函数<code>clone()</code>，能被克隆。</li>
<li><code>ArrayList</code> 实现了 <code>java.io.Serializable</code>接口，这意味着<code>ArrayList</code>支持序列化，能通过序列化去传输。</li>
</ul>
<h5 id="ArrayList和Vector的区别"><a href="#ArrayList和Vector的区别" class="headerlink" title="ArrayList和Vector的区别"></a>ArrayList和Vector的区别</h5><ol>
<li><code>ArrayList</code> 是 <code>List</code> 的主要实现类，底层使用 <code>Object[ ]</code>存储，适用于频繁的查找工作，线程不安全 ；</li>
<li><code>Vector</code> 是 <code>List</code> 的古老实现类，底层使用 <code>Object[ ]</code>存储，线程安全的。</li>
</ol>
<h5 id="ArrayList和LinkedList的区别"><a href="#ArrayList和LinkedList的区别" class="headerlink" title="ArrayList和LinkedList的区别"></a>ArrayList和LinkedList的区别</h5><ol>
<li><strong>是否保证线程安全：</strong> <code>ArrayList</code> 和 <code>LinkedList</code> 都是不同步的，也就是不保证线程安全；</li>
<li><strong>底层数据结构：</strong> <code>Arraylist</code> 底层使用的是 <strong>Object 数组</strong>；<code>LinkedList</code> 底层使用的是 <strong>双向链表</strong> 数据结构（JDK1.6 之前为循环链表，JDK1.7 取消了循环。注意双向链表和双向循环链表的区别，下面有介绍到！）</li>
<li><strong>插入和删除是否受元素位置的影响：</strong> ① <strong>ArrayList 采用数组存储，所以插入和删除元素的时间复杂度受元素位置的影响。</strong> 比如：执行<code>add(E e)</code>方法的时候， <code>ArrayList</code> 会默认在将指定的元素追加到此列表的末尾，这种情况时间复杂度就是 O(1)。但是如果要在指定位置 i 插入和删除元素的话（<code>add(int index, E element)</code>）时间复杂度就为 O(n-i)。因为在进行上述操作的时候集合中第 i 和第 i 个元素之后的(n-i)个元素都要执行向后位&#x2F;向前移一位的操作。 ② <strong>LinkedList 采用链表存储，所以对于add(E e)方法的插入，删除元素时间复杂度不受元素位置的影响，近似 O(1)，如果是要在指定位置i插入和删除元素的话（(add(int index, E element)） 时间复杂度近似为o(n))因为需要先移动到指定位置再插入。</strong></li>
<li><strong>是否支持快速随机访问：</strong> <code>LinkedList</code> 不支持高效的随机元素访问，而 <code>ArrayList</code> 支持。快速随机访问就是通过元素的序号快速获取元素对象(对应于<code>get(int index)</code>方法)。</li>
<li><strong>内存空间占用：</strong> <code>ArrayList</code> 的空 间浪费主要体现在在 list 列表的结尾会预留一定的容量空间，而 <code>LinkedList</code> 的空间花费则体现在它的每一个元素都需要消耗比 <code>ArrayList</code> 更多的空间（因为要存放直接后继和直接前驱以及数据）。</li>
</ol>
<h4 id="ArrayList核心源码解读"><a href="#ArrayList核心源码解读" class="headerlink" title="ArrayList核心源码解读"></a>ArrayList核心源码解读</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> java.util;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.function.Consumer;</span><br><span class="line"><span class="keyword">import</span> java.util.function.Predicate;</span><br><span class="line"><span class="keyword">import</span> java.util.function.UnaryOperator;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayList</span>&lt;E&gt; <span class="keyword">extends</span> <span class="title class_">AbstractList</span>&lt;E&gt;</span><br><span class="line">        <span class="keyword">implements</span> <span class="title class_">List</span>&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">8683452581122892189L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 默认初始容量大小</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">DEFAULT_CAPACITY</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 空数组（用于空实例）。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">     <span class="comment">//用于默认大小空实例的共享空数组实例。</span></span><br><span class="line">      <span class="comment">//我们把它从EMPTY_ELEMENTDATA数组中区分出来，以知道在添加第一个元素时容量需要增加多少。</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 保存ArrayList数据的数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">transient</span> Object[] elementData; <span class="comment">// non-private to simplify nested class access</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * ArrayList 所包含的元素个数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 带初始容量参数的构造函数（用户可以在创建ArrayList对象时自己指定集合的初始大小）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ArrayList</span><span class="params">(<span class="type">int</span> initialCapacity)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (initialCapacity &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//如果传入的参数大于0，创建initialCapacity大小的数组</span></span><br><span class="line">            <span class="built_in">this</span>.elementData = <span class="keyword">new</span> <span class="title class_">Object</span>[initialCapacity];</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (initialCapacity == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//如果传入的参数等于0，创建空数组</span></span><br><span class="line">            <span class="built_in">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//其他情况，抛出异常</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Illegal Capacity: &quot;</span>+</span><br><span class="line">                                               initialCapacity);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *默认无参构造函数</span></span><br><span class="line"><span class="comment">     *DEFAULTCAPACITY_EMPTY_ELEMENTDATA 为0.初始化为10，也就是说初始其实是空数组 当添加第一个元素的时候数组容量才变成10</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ArrayList</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造一个包含指定集合的元素的列表，按照它们由集合的迭代器返回的顺序。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ArrayList</span><span class="params">(Collection&lt;? extends E&gt; c)</span> &#123;</span><br><span class="line">        <span class="comment">//将指定集合转换为数组</span></span><br><span class="line">        elementData = c.toArray();</span><br><span class="line">        <span class="comment">//如果elementData数组的长度不为0</span></span><br><span class="line">        <span class="keyword">if</span> ((size = elementData.length) != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果elementData不是Object类型数据（c.toArray可能返回的不是Object类型的数组所以加上下面的语句用于判断）</span></span><br><span class="line">            <span class="keyword">if</span> (elementData.getClass() != Object[].class)</span><br><span class="line">                <span class="comment">//将原来不是Object类型的elementData数组的内容，赋值给新的Object类型的elementData数组</span></span><br><span class="line">                elementData = Arrays.copyOf(elementData, size, Object[].class);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 其他情况，用空数组代替</span></span><br><span class="line">            <span class="built_in">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 修改这个ArrayList实例的容量是列表的当前大小。 应用程序可以使用此操作来最小化ArrayList实例的存储。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">trimToSize</span><span class="params">()</span> &#123;</span><br><span class="line">        modCount++;</span><br><span class="line">        <span class="keyword">if</span> (size &lt; elementData.length) &#123;</span><br><span class="line">            elementData = (size == <span class="number">0</span>)</span><br><span class="line">              ? EMPTY_ELEMENTDATA</span><br><span class="line">              : Arrays.copyOf(elementData, size);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//下面是ArrayList的扩容机制</span></span><br><span class="line"><span class="comment">//ArrayList的扩容机制提高了性能，如果每次只扩充一个，</span></span><br><span class="line"><span class="comment">//那么频繁的插入会导致频繁的拷贝，降低性能，而ArrayList的扩容机制避免了这种情况。</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 如有必要，增加此ArrayList实例的容量，以确保它至少能容纳元素的数量</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>   minCapacity   所需的最小容量</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">ensureCapacity</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">        <span class="comment">//如果是true，minExpand的值为0，如果是false,minExpand的值为10</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">minExpand</span> <span class="operator">=</span> (elementData != DEFAULTCAPACITY_EMPTY_ELEMENTDATA)</span><br><span class="line">            <span class="comment">// any size if not default element table</span></span><br><span class="line">            ? <span class="number">0</span></span><br><span class="line">            <span class="comment">// larger than default for default empty table. It&#x27;s already</span></span><br><span class="line">            <span class="comment">// supposed to be at default size.</span></span><br><span class="line">            : DEFAULT_CAPACITY;</span><br><span class="line">        <span class="comment">//如果最小容量大于已有的最大容量</span></span><br><span class="line">        <span class="keyword">if</span> (minCapacity &gt; minExpand) &#123;</span><br><span class="line">            ensureExplicitCapacity(minCapacity);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="comment">//1.得到最小扩容量</span></span><br><span class="line">   <span class="comment">//2.通过最小容量扩容</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">ensureCapacityInternal</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</span><br><span class="line">              <span class="comment">// 获取“默认的容量”和“传入参数”两者之间的最大值</span></span><br><span class="line">            minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ensureExplicitCapacity(minCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">//判断是否需要扩容</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">ensureExplicitCapacity</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">        modCount++;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// overflow-conscious code</span></span><br><span class="line">        <span class="keyword">if</span> (minCapacity - elementData.length &gt; <span class="number">0</span>)</span><br><span class="line">            <span class="comment">//调用grow方法进行扩容，调用此方法代表已经开始扩容了</span></span><br><span class="line">            grow(minCapacity);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 要分配的最大数组大小</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAX_ARRAY_SIZE</span> <span class="operator">=</span> Integer.MAX_VALUE - <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * ArrayList扩容的核心方法。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">grow</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">        <span class="comment">// oldCapacity为旧容量，newCapacity为新容量</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">oldCapacity</span> <span class="operator">=</span> elementData.length;</span><br><span class="line">        <span class="comment">//将oldCapacity 右移一位，其效果相当于oldCapacity /2，</span></span><br><span class="line">        <span class="comment">//我们知道位运算的速度远远快于整除运算，整句运算式的结果就是将新容量更新为旧容量的1.5倍，</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">newCapacity</span> <span class="operator">=</span> oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);</span><br><span class="line">        <span class="comment">//然后检查新容量是否大于最小需要容量，若还是小于最小需要容量，那么就把最小需要容量当作数组的新容量，</span></span><br><span class="line">        <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">            newCapacity = minCapacity;</span><br><span class="line">        <span class="comment">//再检查新容量是否超出了ArrayList所定义的最大容量，</span></span><br><span class="line">        <span class="comment">//若超出了，则调用hugeCapacity()来比较minCapacity和 MAX_ARRAY_SIZE，</span></span><br><span class="line">        <span class="comment">//如果minCapacity大于MAX_ARRAY_SIZE，则新容量则为Interger.MAX_VALUE，否则，新容量大小则为 MAX_ARRAY_SIZE。</span></span><br><span class="line">        <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">            newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">        <span class="comment">// minCapacity is usually close to size, so this is a win:</span></span><br><span class="line">        elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//比较minCapacity和 MAX_ARRAY_SIZE</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">hugeCapacity</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (minCapacity &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">OutOfMemoryError</span>();</span><br><span class="line">        <span class="keyword">return</span> (minCapacity &gt; MAX_ARRAY_SIZE) ?</span><br><span class="line">            Integer.MAX_VALUE :</span><br><span class="line">            MAX_ARRAY_SIZE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *返回此列表中的元素数。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 如果此列表不包含元素，则返回 true 。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//注意=和==的区别</span></span><br><span class="line">        <span class="type">return</span> <span class="variable">size</span> <span class="operator">=</span>= <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 如果此列表包含指定的元素，则返回true 。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">contains</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">        <span class="comment">//indexOf()方法：返回此列表中指定元素的首次出现的索引，如果此列表不包含此元素，则为-1</span></span><br><span class="line">        <span class="keyword">return</span> indexOf(o) &gt;= <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *返回此列表中指定元素的首次出现的索引，如果此列表不包含此元素，则为-1</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">indexOf</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">                <span class="keyword">if</span> (elementData[i]==<span class="literal">null</span>)</span><br><span class="line">                    <span class="keyword">return</span> i;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">                <span class="comment">//equals()方法比较</span></span><br><span class="line">                <span class="keyword">if</span> (o.equals(elementData[i]))</span><br><span class="line">                    <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回此列表中指定元素的最后一次出现的索引，如果此列表不包含元素，则返回-1。.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">lastIndexOf</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> size-<span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">                <span class="keyword">if</span> (elementData[i]==<span class="literal">null</span>)</span><br><span class="line">                    <span class="keyword">return</span> i;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> size-<span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">                <span class="keyword">if</span> (o.equals(elementData[i]))</span><br><span class="line">                    <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回此ArrayList实例的浅拷贝。 （元素本身不被复制。）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">clone</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ArrayList&lt;?&gt; v = (ArrayList&lt;?&gt;) <span class="built_in">super</span>.clone();</span><br><span class="line">            <span class="comment">//Arrays.copyOf功能是实现数组的复制，返回复制后的数组。参数是被复制的数组和复制的长度</span></span><br><span class="line">            v.elementData = Arrays.copyOf(elementData, size);</span><br><span class="line">            v.modCount = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">return</span> v;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">            <span class="comment">// 这不应该发生，因为我们是可以克隆的</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InternalError</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *以正确的顺序（从第一个到最后一个元素）返回一个包含此列表中所有元素的数组。</span></span><br><span class="line"><span class="comment">     *返回的数组将是“安全的”，因为该列表不保留对它的引用。 （换句话说，这个方法必须分配一个新的数组）。</span></span><br><span class="line"><span class="comment">     *因此，调用者可以自由地修改返回的数组。 此方法充当基于阵列和基于集合的API之间的桥梁。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Object[] toArray() &#123;</span><br><span class="line">        <span class="keyword">return</span> Arrays.copyOf(elementData, size);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 以正确的顺序返回一个包含此列表中所有元素的数组（从第一个到最后一个元素）;</span></span><br><span class="line"><span class="comment">     *返回的数组的运行时类型是指定数组的运行时类型。 如果列表适合指定的数组，则返回其中。</span></span><br><span class="line"><span class="comment">     *否则，将为指定数组的运行时类型和此列表的大小分配一个新数组。</span></span><br><span class="line"><span class="comment">     *如果列表适用于指定的数组，其余空间（即数组的列表数量多于此元素），则紧跟在集合结束后的数组中的元素设置为null 。</span></span><br><span class="line"><span class="comment">     *（这仅在调用者知道列表不包含任何空元素的情况下才能确定列表的长度。）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; T[] toArray(T[] a) &#123;</span><br><span class="line">        <span class="keyword">if</span> (a.length &lt; size)</span><br><span class="line">            <span class="comment">// 新建一个运行时类型的数组，但是ArrayList数组的内容</span></span><br><span class="line">            <span class="keyword">return</span> (T[]) Arrays.copyOf(elementData, size, a.getClass());</span><br><span class="line">            <span class="comment">//调用System提供的arraycopy()方法实现数组之间的复制</span></span><br><span class="line">        System.arraycopy(elementData, <span class="number">0</span>, a, <span class="number">0</span>, size);</span><br><span class="line">        <span class="keyword">if</span> (a.length &gt; size)</span><br><span class="line">            a[size] = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Positional Access Operations</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">    E <span class="title function_">elementData</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (E) elementData[index];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回此列表中指定位置的元素。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> E <span class="title function_">get</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        rangeCheck(index);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> elementData(index);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用指定的元素替换此列表中指定位置的元素。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> E <span class="title function_">set</span><span class="params">(<span class="type">int</span> index, E element)</span> &#123;</span><br><span class="line">        <span class="comment">//对index进行界限检查</span></span><br><span class="line">        rangeCheck(index);</span><br><span class="line"></span><br><span class="line">        <span class="type">E</span> <span class="variable">oldValue</span> <span class="operator">=</span> elementData(index);</span><br><span class="line">        elementData[index] = element;</span><br><span class="line">        <span class="comment">//返回原来在这个位置的元素</span></span><br><span class="line">        <span class="keyword">return</span> oldValue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将指定的元素追加到此列表的末尾。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">        ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">        <span class="comment">//这里看到ArrayList添加元素的实质就相当于为数组赋值</span></span><br><span class="line">        elementData[size++] = e;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 在此列表中的指定位置插入指定的元素。</span></span><br><span class="line"><span class="comment">     *先调用 rangeCheckForAdd 对index进行界限检查；然后调用 ensureCapacityInternal 方法保证capacity足够大；</span></span><br><span class="line"><span class="comment">     *再将从index开始之后的所有成员后移一个位置；将element插入index位置；最后size加1。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> index, E element)</span> &#123;</span><br><span class="line">        rangeCheckForAdd(index);</span><br><span class="line"></span><br><span class="line">        ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">        <span class="comment">//arraycopy()这个实现数组之间复制的方法一定要看一下，下面就用到了arraycopy()方法实现数组自己复制自己</span></span><br><span class="line">        System.arraycopy(elementData, index, elementData, index + <span class="number">1</span>,</span><br><span class="line">                         size - index);</span><br><span class="line">        elementData[index] = element;</span><br><span class="line">        size++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 删除该列表中指定位置的元素。 将任何后续元素移动到左侧（从其索引中减去一个元素）。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> E <span class="title function_">remove</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        rangeCheck(index);</span><br><span class="line"></span><br><span class="line">        modCount++;</span><br><span class="line">        <span class="type">E</span> <span class="variable">oldValue</span> <span class="operator">=</span> elementData(index);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">numMoved</span> <span class="operator">=</span> size - index - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</span><br><span class="line">            System.arraycopy(elementData, index+<span class="number">1</span>, elementData, index,</span><br><span class="line">                             numMoved);</span><br><span class="line">        elementData[--size] = <span class="literal">null</span>; <span class="comment">// clear to let GC do its work</span></span><br><span class="line">      <span class="comment">//从列表中删除的元素</span></span><br><span class="line">        <span class="keyword">return</span> oldValue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 从列表中删除指定元素的第一个出现（如果存在）。 如果列表不包含该元素，则它不会更改。</span></span><br><span class="line"><span class="comment">     *返回true，如果此列表包含指定的元素</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">remove</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>; index &lt; size; index++)</span><br><span class="line">                <span class="keyword">if</span> (elementData[index] == <span class="literal">null</span>) &#123;</span><br><span class="line">                    fastRemove(index);</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>; index &lt; size; index++)</span><br><span class="line">                <span class="keyword">if</span> (o.equals(elementData[index])) &#123;</span><br><span class="line">                    fastRemove(index);</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Private remove method that skips bounds checking and does not</span></span><br><span class="line"><span class="comment">     * return the value removed.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">fastRemove</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        modCount++;</span><br><span class="line">        <span class="type">int</span> <span class="variable">numMoved</span> <span class="operator">=</span> size - index - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</span><br><span class="line">            System.arraycopy(elementData, index+<span class="number">1</span>, elementData, index,</span><br><span class="line">                             numMoved);</span><br><span class="line">        elementData[--size] = <span class="literal">null</span>; <span class="comment">// clear to let GC do its work</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 从列表中删除所有元素。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">clear</span><span class="params">()</span> &#123;</span><br><span class="line">        modCount++;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 把数组中所有的元素的值设为null</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">            elementData[i] = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        size = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 按指定集合的Iterator返回的顺序将指定集合中的所有元素追加到此列表的末尾。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">addAll</span><span class="params">(Collection&lt;? extends E&gt; c)</span> &#123;</span><br><span class="line">        Object[] a = c.toArray();</span><br><span class="line">        <span class="type">int</span> <span class="variable">numNew</span> <span class="operator">=</span> a.length;</span><br><span class="line">        ensureCapacityInternal(size + numNew);  <span class="comment">// Increments modCount</span></span><br><span class="line">        System.arraycopy(a, <span class="number">0</span>, elementData, size, numNew);</span><br><span class="line">        size += numNew;</span><br><span class="line">        <span class="keyword">return</span> numNew != <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将指定集合中的所有元素插入到此列表中，从指定的位置开始。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">addAll</span><span class="params">(<span class="type">int</span> index, Collection&lt;? extends E&gt; c)</span> &#123;</span><br><span class="line">        rangeCheckForAdd(index);</span><br><span class="line"></span><br><span class="line">        Object[] a = c.toArray();</span><br><span class="line">        <span class="type">int</span> <span class="variable">numNew</span> <span class="operator">=</span> a.length;</span><br><span class="line">        ensureCapacityInternal(size + numNew);  <span class="comment">// Increments modCount</span></span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">numMoved</span> <span class="operator">=</span> size - index;</span><br><span class="line">        <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</span><br><span class="line">            System.arraycopy(elementData, index, elementData, index + numNew,</span><br><span class="line">                             numMoved);</span><br><span class="line"></span><br><span class="line">        System.arraycopy(a, <span class="number">0</span>, elementData, index, numNew);</span><br><span class="line">        size += numNew;</span><br><span class="line">        <span class="keyword">return</span> numNew != <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 从此列表中删除所有索引为fromIndex （含）和toIndex之间的元素。</span></span><br><span class="line"><span class="comment">     *将任何后续元素移动到左侧（减少其索引）。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">removeRange</span><span class="params">(<span class="type">int</span> fromIndex, <span class="type">int</span> toIndex)</span> &#123;</span><br><span class="line">        modCount++;</span><br><span class="line">        <span class="type">int</span> <span class="variable">numMoved</span> <span class="operator">=</span> size - toIndex;</span><br><span class="line">        System.arraycopy(elementData, toIndex, elementData, fromIndex,</span><br><span class="line">                         numMoved);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// clear to let GC do its work</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">newSize</span> <span class="operator">=</span> size - (toIndex-fromIndex);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> newSize; i &lt; size; i++) &#123;</span><br><span class="line">            elementData[i] = <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        size = newSize;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 检查给定的索引是否在范围内。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">rangeCheck</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (index &gt;= size)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IndexOutOfBoundsException</span>(outOfBoundsMsg(index));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * add和addAll使用的rangeCheck的一个版本</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">rangeCheckForAdd</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (index &gt; size || index &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IndexOutOfBoundsException</span>(outOfBoundsMsg(index));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回IndexOutOfBoundsException细节信息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String <span class="title function_">outOfBoundsMsg</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Index: &quot;</span>+index+<span class="string">&quot;, Size: &quot;</span>+size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 从此列表中删除指定集合中包含的所有元素。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">removeAll</span><span class="params">(Collection&lt;?&gt; c)</span> &#123;</span><br><span class="line">        Objects.requireNonNull(c);</span><br><span class="line">        <span class="comment">//如果此列表被修改则返回true</span></span><br><span class="line">        <span class="keyword">return</span> batchRemove(c, <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 仅保留此列表中包含在指定集合中的元素。</span></span><br><span class="line"><span class="comment">     *换句话说，从此列表中删除其中不包含在指定集合中的所有元素。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">retainAll</span><span class="params">(Collection&lt;?&gt; c)</span> &#123;</span><br><span class="line">        Objects.requireNonNull(c);</span><br><span class="line">        <span class="keyword">return</span> batchRemove(c, <span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 从列表中的指定位置开始，返回列表中的元素（按正确顺序）的列表迭代器。</span></span><br><span class="line"><span class="comment">     *指定的索引表示初始调用将返回的第一个元素为next 。 初始调用previous将返回指定索引减1的元素。</span></span><br><span class="line"><span class="comment">     *返回的列表迭代器是fail-fast 。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> ListIterator&lt;E&gt; <span class="title function_">listIterator</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt; size)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IndexOutOfBoundsException</span>(<span class="string">&quot;Index: &quot;</span>+index);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ListItr</span>(index);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *返回列表中的列表迭代器（按适当的顺序）。</span></span><br><span class="line"><span class="comment">     *返回的列表迭代器是fail-fast 。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> ListIterator&lt;E&gt; <span class="title function_">listIterator</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ListItr</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *以正确的顺序返回该列表中的元素的迭代器。</span></span><br><span class="line"><span class="comment">     *返回的迭代器是fail-fast 。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Iterator&lt;E&gt; <span class="title function_">iterator</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Itr</span>();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h4 id="ArryList扩容机制分析"><a href="#ArryList扩容机制分析" class="headerlink" title="ArryList扩容机制分析"></a>ArryList扩容机制分析</h4><h5 id="ArrayList的构造函数"><a href="#ArrayList的构造函数" class="headerlink" title="ArrayList的构造函数"></a>ArrayList的构造函数</h5><p><strong>（JDK8）ArrayList 有三种方式来初始化，构造方法源码如下：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 默认初始容量大小</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">DEFAULT_CAPACITY</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  *默认构造函数，使用初始容量10构造一个空列表(无参数构造)</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="keyword">public</span> <span class="title function_">ArrayList</span><span class="params">()</span> &#123;</span><br><span class="line">     <span class="built_in">this</span>.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 带初始容量参数的构造函数。（用户自己指定容量）</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="keyword">public</span> <span class="title function_">ArrayList</span><span class="params">(<span class="type">int</span> initialCapacity)</span> &#123;</span><br><span class="line">     <span class="keyword">if</span> (initialCapacity &gt; <span class="number">0</span>) &#123;<span class="comment">//初始容量大于0</span></span><br><span class="line">         <span class="comment">//创建initialCapacity大小的数组</span></span><br><span class="line">         <span class="built_in">this</span>.elementData = <span class="keyword">new</span> <span class="title class_">Object</span>[initialCapacity];</span><br><span class="line">     &#125; <span class="keyword">else</span> <span class="keyword">if</span> (initialCapacity == <span class="number">0</span>) &#123;<span class="comment">//初始容量等于0</span></span><br><span class="line">         <span class="comment">//创建空数组</span></span><br><span class="line">         <span class="built_in">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;<span class="comment">//初始容量小于0，抛出异常</span></span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Illegal Capacity: &quot;</span>+</span><br><span class="line">                                            initialCapacity);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *构造包含指定collection元素的列表，这些元素利用该集合的迭代器按顺序返回</span></span><br><span class="line"><span class="comment"> *如果指定的集合为null，throws NullPointerException。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">ArrayList</span><span class="params">(Collection&lt;? extends E&gt; c)</span> &#123;</span><br><span class="line">     elementData = c.toArray();</span><br><span class="line">     <span class="keyword">if</span> ((size = elementData.length) != <span class="number">0</span>) &#123;</span><br><span class="line">         <span class="comment">// c.toArray might (incorrectly) not return Object[] (see 6260652)</span></span><br><span class="line">         <span class="keyword">if</span> (elementData.getClass() != Object[].class)</span><br><span class="line">             elementData = Arrays.copyOf(elementData, size, Object[].class);</span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="comment">// replace with empty array.</span></span><br><span class="line">         <span class="built_in">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p><strong>以无参数构造方法创建 ArrayList 时，实际上初始化赋值的是一个空数组。当真正对数组进行添加元素操作时，才真正分配容量。即向数组中添加第一个元素时，数组容量扩为 10</strong>。</p>
<p>补充：JDK6 new 无参构造的 <code>ArrayList</code> 对象时，直接创建了长度是 10 的 <code>Object[]</code> 数组 elementData 。</p>
<h5 id="ArrayList的扩容机制"><a href="#ArrayList的扩容机制" class="headerlink" title="ArrayList的扩容机制"></a>ArrayList的扩容机制</h5><p>这里以无参构造函数创建的 ArrayList 为例分析</p>
<h6 id="add方法"><a href="#add方法" class="headerlink" title="add方法"></a>add方法</h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 将指定的元素追加到此列表的末尾。</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line"><span class="comment">//添加元素之前，先调用ensureCapacityInternal方法</span></span><br><span class="line">     ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">     <span class="comment">//这里看到ArrayList添加元素的实质就相当于为数组赋值</span></span><br><span class="line">     elementData[size++] = e;</span><br><span class="line">     <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意</strong> ：JDK11 移除了 <code>ensureCapacityInternal()</code> 和 <code>ensureExplicitCapacity()</code> 方法。</p>
<h6 id="ensureCapacityInternal-方法"><a href="#ensureCapacityInternal-方法" class="headerlink" title="ensureCapacityInternal()方法"></a>ensureCapacityInternal()方法</h6><p>（JDK7）可以看到 <code>add</code> 方法 首先调用了<code>ensureCapacityInternal(size + 1)</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//得到最小扩容量</span></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">ensureCapacityInternal</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">     <span class="keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</span><br><span class="line">           <span class="comment">// 获取默认的容量和传入参数的较大值</span></span><br><span class="line">         minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     ensureExplicitCapacity(minCapacity);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p><strong>当 要 add 进第 1 个元素时，minCapacity 为 1，在 Math.max()方法比较后，minCapacity 为 10。</strong></p>
<p>此处和后续 JDK8 代码格式化略有不同，核心代码基本一样。</p>
<h6 id="ensureExplicitCapacity-方法"><a href="#ensureExplicitCapacity-方法" class="headerlink" title="ensureExplicitCapacity()方法"></a>ensureExplicitCapacity()方法</h6><p>如果调用 <code>ensureCapacityInternal()</code> 方法就一定会进入（执行）这个方法，下面我们来研究一下这个方法的源码！</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//判断是否需要扩容</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">ensureExplicitCapacity</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">      modCount++;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// overflow-conscious code</span></span><br><span class="line">      <span class="keyword">if</span> (minCapacity - elementData.length &gt; <span class="number">0</span>)</span><br><span class="line">          <span class="comment">//调用grow方法进行扩容，调用此方法代表已经开始扩容了</span></span><br><span class="line">          grow(minCapacity);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>我们来仔细分析一下：</p>
<ul>
<li>当我们要 add 进第 1 个元素到 ArrayList 时，elementData.length 为 0 （因为还是一个空的 list），因为执行了 <code>ensureCapacityInternal()</code> 方法 ，所以 minCapacity 此时为 10。此时，<code>minCapacity - elementData.length &gt; 0</code>成立，所以会进入 <code>grow(minCapacity)</code> 方法。</li>
<li>当 add 第 2 个元素时，minCapacity 为 2，此时 e lementData.length(容量)在添加第一个元素后扩容成 10 了。此时，<code>minCapacity - elementData.length &gt; 0</code> 不成立，所以不会进入 （执行）<code>grow(minCapacity)</code> 方法。</li>
<li>添加第 3、4···到第 10 个元素时，依然不会执行 grow 方法，数组容量都为 10。</li>
</ul>
<p>直到添加第 11 个元素，minCapacity(为 11)比 elementData.length（为 10）要大。进入 grow 方法进行扩容。</p>
<h6 id="grow-方法"><a href="#grow-方法" class="headerlink" title="grow()方法"></a>grow()方法</h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 要分配的最大数组大小</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAX_ARRAY_SIZE</span> <span class="operator">=</span> Integer.MAX_VALUE - <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ArrayList扩容的核心方法。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">grow</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">    <span class="comment">// oldCapacity为旧容量，newCapacity为新容量</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">oldCapacity</span> <span class="operator">=</span> elementData.length;</span><br><span class="line">    <span class="comment">//将oldCapacity 右移一位，其效果相当于oldCapacity /2，</span></span><br><span class="line">    <span class="comment">//我们知道位运算的速度远远快于整除运算，整句运算式的结果就是将新容量更新为旧容量的1.5倍，</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">newCapacity</span> <span class="operator">=</span> oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    <span class="comment">//然后检查新容量是否大于最小需要容量，若还是小于最小需要容量，那么就把最小需要容量当作数组的新容量，</span></span><br><span class="line">    <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = minCapacity;</span><br><span class="line">   <span class="comment">// 如果新容量大于 MAX_ARRAY_SIZE,进入(执行) `hugeCapacity()` 方法来比较 minCapacity 和 MAX_ARRAY_SIZE，</span></span><br><span class="line">   <span class="comment">//如果minCapacity大于最大容量，则新容量则为`Integer.MAX_VALUE`，否则，新容量大小则为 MAX_ARRAY_SIZE 即为 `Integer.MAX_VALUE - 8`。</span></span><br><span class="line">    <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">    <span class="comment">// minCapacity is usually close to size, so this is a win:</span></span><br><span class="line">    elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>int newCapacity &#x3D; oldCapacity + (oldCapacity &gt;&gt; 1),所以 ArrayList 每次扩容之后容量都会变为原来的 1.5 倍左右（oldCapacity 为偶数就是 1.5 倍，否则是 1.5 倍左右）！</strong> 奇偶不同，比如 ：10+10&#x2F;2 &#x3D; 15, 33+33&#x2F;2&#x3D;49。如果是奇数的话会丢掉小数。</p>
<p>“&gt;&gt;”（移位运算符）：&gt;&gt;1 右移一位相当于除 2，右移 n 位相当于除以 2 的 n 次方。这里 oldCapacity 明显右移了 1 位所以相当于 oldCapacity &#x2F;2。对于大数据的 2 进制运算,位移运算符比那些普通运算符的运算要快很多,因为程序仅仅移动一下而已,不去计算,这样提高了效率,节省了资源。</p>
<p><strong>我们再来通过例子探究一下grow() 方法 ：</strong></p>
<ul>
<li>当 add 第 1 个元素时，oldCapacity 为 0，经比较后第一个 if 判断成立，newCapacity &#x3D; minCapacity(为 10)。但是第二个 if 判断不会成立，即 newCapacity 不比 MAX_ARRAY_SIZE 大，则不会进入 <code>hugeCapacity</code> 方法。数组容量为 10，add 方法中 return true,size 增为 1。</li>
<li>当 add 第 11 个元素进入 grow 方法时，newCapacity 为 15，比 minCapacity（为 11）大，第一个 if 判断不成立。新容量没有大于数组最大 size，不会进入 hugeCapacity 方法。数组容量扩为 15，add 方法中 return true,size 增为 11。</li>
<li>以此类推······</li>
</ul>
<p><strong>这里补充一点比较重要，但是容易被忽视掉的知识点：</strong></p>
<ul>
<li>java 中的 <code>length</code>属性是针对数组说的,比如说你声明了一个数组,想知道这个数组的长度则用到了 length 这个属性.</li>
<li>java 中的 <code>length()</code> 方法是针对字符串说的,如果想看这个字符串的长度则用到 <code>length()</code> 这个方法.</li>
<li>java 中的 <code>size()</code> 方法是针对泛型集合说的,如果想看这个泛型有多少个元素,就调用此方法来查看!</li>
</ul>
<h6 id="hugeCapacity-方法"><a href="#hugeCapacity-方法" class="headerlink" title="hugeCapacity()方法"></a>hugeCapacity()方法</h6><p>从上面 <code>grow()</code> 方法源码我们知道： 如果新容量大于 MAX_ARRAY_SIZE,进入(执行) <code>hugeCapacity()</code> 方法来比较 minCapacity 和 MAX_ARRAY_SIZE，如果 minCapacity 大于最大容量，则新容量则为<code>Integer.MAX_VALUE</code>，否则，新容量大小则为 MAX_ARRAY_SIZE 即为 <code>Integer.MAX_VALUE - 8</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">hugeCapacity</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (minCapacity &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">OutOfMemoryError</span>();</span><br><span class="line">    <span class="comment">//对minCapacity和MAX_ARRAY_SIZE进行比较</span></span><br><span class="line">    <span class="comment">//若minCapacity大，将Integer.MAX_VALUE作为新数组的大小</span></span><br><span class="line">    <span class="comment">//若MAX_ARRAY_SIZE大，将MAX_ARRAY_SIZE作为新数组的大小</span></span><br><span class="line">    <span class="comment">//MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8;</span></span><br><span class="line">    <span class="keyword">return</span> (minCapacity &gt; MAX_ARRAY_SIZE) ?</span><br><span class="line">        Integer.MAX_VALUE :</span><br><span class="line">        MAX_ARRAY_SIZE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="System-arraycopy-和Arrays-copyOf-方法"><a href="#System-arraycopy-和Arrays-copyOf-方法" class="headerlink" title="System.arraycopy()和Arrays.copyOf()方法"></a>System.arraycopy()和Arrays.copyOf()方法</h5><h6 id="System-arraycopy-方法"><a href="#System-arraycopy-方法" class="headerlink" title="System.arraycopy()方法"></a>System.arraycopy()方法</h6><p>源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 我们发现 arraycopy 是一个 native 方法,接下来我们解释一下各个参数的具体意义</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*   复制数组</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> src 源数组</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> srcPos 源数组中的起始位置</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> dest 目标数组</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> destPos 目标数组中的起始位置</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> length 要复制的数组元素的数量</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">arraycopy</span><span class="params">(Object src,  <span class="type">int</span>  srcPos,</span></span><br><span class="line"><span class="params">                                    Object dest, <span class="type">int</span> destPos,</span></span><br><span class="line"><span class="params">                                    <span class="type">int</span> length)</span>;</span><br></pre></td></tr></table></figure>

<p>场景：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 在此列表中的指定位置插入指定的元素。</span></span><br><span class="line"><span class="comment"> *先调用 rangeCheckForAdd 对index进行界限检查；然后调用 ensureCapacityInternal 方法保证capacity足够大；</span></span><br><span class="line"><span class="comment"> *再将从index开始之后的所有成员后移一个位置；将element插入index位置；最后size加1。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> index, E element)</span> &#123;</span><br><span class="line">    rangeCheckForAdd(index);</span><br><span class="line"></span><br><span class="line">    ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">    <span class="comment">//arraycopy()方法实现数组自己复制自己</span></span><br><span class="line">    <span class="comment">//elementData:源数组;index:源数组中的起始位置;elementData：目标数组；index + 1：目标数组中的起始位置； size - index：要复制的数组元素的数量；</span></span><br><span class="line">    System.arraycopy(elementData, index, elementData, index + <span class="number">1</span>, size - index);</span><br><span class="line">    elementData[index] = element;</span><br><span class="line">    size++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们写一个简单的方法测试以下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArraycopyTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">        <span class="type">int</span>[] a = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">10</span>];</span><br><span class="line">        a[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        a[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        a[<span class="number">2</span>] = <span class="number">2</span>;</span><br><span class="line">        a[<span class="number">3</span>] = <span class="number">3</span>;</span><br><span class="line">        System.arraycopy(a, <span class="number">2</span>, a, <span class="number">3</span>, <span class="number">3</span>);</span><br><span class="line">        a[<span class="number">2</span>]=<span class="number">99</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; a.length; i++) &#123;</span><br><span class="line">            System.out.print(a[i] + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0 1 99 2 3 0 0 0 0 0</span><br></pre></td></tr></table></figure>

<h6 id="Arrays-copyOf-方法"><a href="#Arrays-copyOf-方法" class="headerlink" title="Arrays.copyOf()方法"></a>Arrays.copyOf()方法</h6><p>源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] copyOf(<span class="type">int</span>[] original, <span class="type">int</span> newLength) &#123;</span><br><span class="line">    <span class="comment">// 申请一个新的数组</span></span><br><span class="line">    <span class="type">int</span>[] copy = <span class="keyword">new</span> <span class="title class_">int</span>[newLength];</span><br><span class="line"><span class="comment">// 调用System.arraycopy,将源数组中的数据进行拷贝,并返回新的数组</span></span><br><span class="line">    System.arraycopy(original, <span class="number">0</span>, copy, <span class="number">0</span>,</span><br><span class="line">                     Math.min(original.length, newLength));</span><br><span class="line">    <span class="keyword">return</span> copy;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>场景：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  以正确的顺序返回一个包含此列表中所有元素的数组（从第一个到最后一个元素）; 返回的数组的运行时类型是指定数组的运行时类型。</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="keyword">public</span> Object[] toArray() &#123;</span><br><span class="line"> <span class="comment">//elementData：要复制的数组；size：要复制的长度</span></span><br><span class="line">     <span class="keyword">return</span> Arrays.copyOf(elementData, size);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>个人觉得使用 <code>Arrays.copyOf()</code>方法主要是为了给原有数组扩容，测试代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayscopyOfTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] a = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">3</span>];</span><br><span class="line">        a[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        a[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        a[<span class="number">2</span>] = <span class="number">2</span>;</span><br><span class="line">        <span class="type">int</span>[] b = Arrays.copyOf(a, <span class="number">10</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;b.length&quot;</span>+b.length);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">10</span><br></pre></td></tr></table></figure>

<h6 id="两者联系和区别"><a href="#两者联系和区别" class="headerlink" title="两者联系和区别"></a>两者联系和区别</h6><p><strong>联系：</strong></p>
<p>看两者源代码可以发现 <code>copyOf()</code>内部实际调用了 <code>System.arraycopy()</code> 方法</p>
<p><strong>区别：</strong></p>
<p><code>arraycopy()</code> 需要目标数组，将原数组拷贝到你自己定义的数组里或者原数组，而且可以选择拷贝的起点和长度以及放入新数组中的位置 <code>copyOf()</code> 是系统自动在内部新建一个数组，并返回该数组。</p>
<h5 id="ensureCapacity-方法"><a href="#ensureCapacity-方法" class="headerlink" title="ensureCapacity()方法"></a>ensureCapacity()方法</h5><p>ArrayList 源码中有一个 <code>ensureCapacity</code> 方法不知道大家注意到没有，这个方法 ArrayList 内部没有被调用过，所以很显然是提供给用户调用的，那么这个方法有什么作用呢？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">如有必要，增加此 ArrayList 实例的容量，以确保它至少可以容纳由minimum capacity参数指定的元素数。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>   minCapacity   所需的最小容量</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">ensureCapacity</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">minExpand</span> <span class="operator">=</span> (elementData != DEFAULTCAPACITY_EMPTY_ELEMENTDATA)</span><br><span class="line">        <span class="comment">// any size if not default element table</span></span><br><span class="line">        ? <span class="number">0</span></span><br><span class="line">        <span class="comment">// larger than default for default empty table. It&#x27;s already</span></span><br><span class="line">        <span class="comment">// supposed to be at default size.</span></span><br><span class="line">        : DEFAULT_CAPACITY;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (minCapacity &gt; minExpand) &#123;</span><br><span class="line">        ensureExplicitCapacity(minCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>最好在 add 大量元素之前用 ensureCapacity 方法，以减少增量重新分配的次数</strong></p>
<p>我们通过下面的代码实际测试以下这个方法的效果：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EnsureCapacityTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        ArrayList&lt;Object&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Object&gt;();</span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">N</span> <span class="operator">=</span> <span class="number">10000000</span>;</span><br><span class="line">        <span class="type">long</span> <span class="variable">startTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">            list.add(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">long</span> <span class="variable">endTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;使用ensureCapacity方法前：&quot;</span>+(endTime - startTime));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">使用ensureCapacity方法前：2158</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EnsureCapacityTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        ArrayList&lt;Object&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Object&gt;();</span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">N</span> <span class="operator">=</span> <span class="number">10000000</span>;</span><br><span class="line">        list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Object&gt;();</span><br><span class="line">        <span class="type">long</span> <span class="variable">startTime1</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        list.ensureCapacity(N);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">            list.add(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">long</span> <span class="variable">endTime1</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;使用ensureCapacity方法后：&quot;</span>+(endTime1 - startTime1));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">使用ensureCapacity方法后：1773</span><br></pre></td></tr></table></figure>

<p>通过运行结果，我们可以看出向 ArrayList 添加大量元素之前最好先使用<code>ensureCapacity</code> 方法，以减少增量重新分配的次数。</p>
]]></content>
      <categories>
        <category>集合</category>
      </categories>
  </entry>
  <entry>
    <title>java基础知识 - java</title>
    <url>/2022/05/24/2022-05-24-java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
    <content><![CDATA[<h1 id="java基础知识"><a href="#java基础知识" class="headerlink" title="java基础知识"></a>java基础知识</h1><span id="more"></span>

<h3 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h3><h4 id="三大特性"><a href="#三大特性" class="headerlink" title="三大特性"></a>三大特性</h4><h5 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h5><p>利用抽象数据类型将数据和基于数据的操作封装在一起，使其构成一个不可分割的独立实体。数据被保护在抽象数据类型的内部，尽可能地隐藏内部的细节，只保留一些对外接口使之与外部发生联系。用户无需知道对象内部的细节，但可以通过对象对外提供的接口来访问该对象。</p>
<p>优点:</p>
<ul>
<li>减少耦合: 可以独立地开发、测试、优化、使用、理解和修改</li>
<li>减轻维护的负担: 可以更容易被程序员理解，并且在调试的时候可以不影响其他模块</li>
<li>有效地调节性能: 可以通过剖析确定哪些模块影响了系统的性能</li>
<li>提高软件的可重用性</li>
<li>降低了构建大型系统的风险: 即使整个系统不可用，但是这些独立的模块却有可能是可用的</li>
</ul>
<p>以下 Person 类封装 name、gender、age 等属性，外界只能通过 get() 方法获取一个 Person 对象的 name 属性和 gender 属性，而无法获取 age 属性，但是 age 属性可以供 work() 方法使用。</p>
<p>注意到 gender 属性使用 int 数据类型进行存储，封装使得用户注意不到这种实现细节。并且在需要修改 gender 属性使用的数据类型时，也可以在不影响客户端代码的情况下进行。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> gender;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getGender</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">return</span> <span class="variable">gender</span> <span class="operator">=</span>= <span class="number">0</span> ? <span class="string">&quot;man&quot;</span> : <span class="string">&quot;woman&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">work</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">18</span> &lt;= age &amp;&amp; age &lt;= <span class="number">50</span>) &#123;</span><br><span class="line">            System.out.println(name + <span class="string">&quot; is working very hard!&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(name + <span class="string">&quot; can&#x27;t work any more!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h5><p>继承实现了  <strong>IS-A</strong>  关系，例如 Cat 和 Animal 就是一种 IS-A 关系，因此 Cat 可以继承自 Animal，从而获得 Animal 非 private 的属性和方法。</p>
<p>继承应该遵循里氏替换原则，子类对象必须能够替换掉所有父类对象。</p>
<p>Cat 可以当做 Animal 来使用，也就是说可以使用 Animal 引用 Cat 对象。父类引用指向子类对象称为  <strong>向上转型</strong> </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Animal</span> <span class="variable">animal</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cat</span>();</span><br></pre></td></tr></table></figure>

<h5 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h5><p>多态分为编译时多态和运行时多态:</p>
<ul>
<li>编译时多态主要指方法的重载</li>
<li>运行时多态指程序中定义的对象引用所指向的具体类型在运行期间才确定</li>
</ul>
<p>运行时多态有三个条件：</p>
<ul>
<li>继承</li>
<li>覆盖（重写）</li>
<li>向上转型</li>
</ul>
<p>下面的代码中，乐器类(Instrument)有两个子类: Wind 和 Percussion，它们都覆盖了父类的 play() 方法，并且在 main() 方法中使用父类 Instrument 来引用 Wind 和 Percussion 对象。在 Instrument 引用调用 play() 方法时，会执行实际引用对象所在类的 play() 方法，而不是 Instrument 类的方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Instrument</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">play</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Instrument is playing...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Wind</span> <span class="keyword">extends</span> <span class="title class_">Instrument</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">play</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Wind is playing...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Percussion</span> <span class="keyword">extends</span> <span class="title class_">Instrument</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">play</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Percussion is playing...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Music</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        List&lt;Instrument&gt; instruments = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        instruments.add(<span class="keyword">new</span> <span class="title class_">Wind</span>());</span><br><span class="line">        instruments.add(<span class="keyword">new</span> <span class="title class_">Percussion</span>());</span><br><span class="line">        <span class="keyword">for</span>(Instrument instrument : instruments) &#123;</span><br><span class="line">            instrument.play();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h4><h5 id="泛化关系（Generalization）"><a href="#泛化关系（Generalization）" class="headerlink" title="泛化关系（Generalization）"></a>泛化关系（Generalization）</h5><p>用来描述继承关系，在 Java 中使用 extends 关键字。</p>
<p><img src="/../images/note27.png" alt="note27"></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">@startuml</span><br><span class="line"></span><br><span class="line">title Generalization</span><br><span class="line"></span><br><span class="line">class Vehical</span><br><span class="line">class Car</span><br><span class="line">class Truck</span><br><span class="line"></span><br><span class="line">Vehical &lt;|-- Car</span><br><span class="line">Vehical &lt;|-- Truck</span><br><span class="line"></span><br><span class="line">@enduml</span><br></pre></td></tr></table></figure>

<h5 id="实现关系-Realization"><a href="#实现关系-Realization" class="headerlink" title="实现关系 (Realization)"></a>实现关系 (Realization)</h5><p>用来实现一个接口，在 Java 中使用 implement 关键字。</p>
<p><img src="/../images/note28.png" alt="note28"></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">@startuml</span><br><span class="line"></span><br><span class="line">title Realization</span><br><span class="line"></span><br><span class="line">interface MoveBehavior</span><br><span class="line">class Fly</span><br><span class="line">class Run</span><br><span class="line"></span><br><span class="line">MoveBehavior &lt;|.. Fly</span><br><span class="line">MoveBehavior &lt;|.. Run</span><br><span class="line"></span><br><span class="line">@enduml</span><br></pre></td></tr></table></figure>

<h5 id="聚合关系-Aggregation"><a href="#聚合关系-Aggregation" class="headerlink" title="聚合关系 (Aggregation)"></a>聚合关系 (Aggregation)</h5><p>表示整体由部分组成，但是整体和部分不是强依赖的，整体不存在了部分还是会存在。</p>
<p><img src="/../images/note29.png" alt="note29"></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">@startuml</span><br><span class="line"></span><br><span class="line">title Aggregation</span><br><span class="line"></span><br><span class="line">class Computer</span><br><span class="line">class Keyboard</span><br><span class="line">class Mouse</span><br><span class="line">class Screen</span><br><span class="line"></span><br><span class="line">Computer o-- Keyboard</span><br><span class="line">Computer o-- Mouse</span><br><span class="line">Computer o-- Screen</span><br><span class="line"></span><br><span class="line">@enduml</span><br></pre></td></tr></table></figure>

<h5 id="组合关系-Composition"><a href="#组合关系-Composition" class="headerlink" title="组合关系 (Composition)"></a>组合关系 (Composition)</h5><p>和聚合不同，组合中整体和部分是强依赖的，整体不存在了部分也不存在了。比如公司和部门，公司没了部门就不存在了。但是公司和员工就属于聚合关系了，因为公司没了员工还在。</p>
<p><img src="/../images/note30.png" alt="note30"></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">@startuml</span><br><span class="line"></span><br><span class="line">title Composition</span><br><span class="line"></span><br><span class="line">class Company</span><br><span class="line">class DepartmentA</span><br><span class="line">class DepartmentB</span><br><span class="line"></span><br><span class="line">Company *-- DepartmentA</span><br><span class="line">Company *-- DepartmentB</span><br><span class="line"></span><br><span class="line">@enduml</span><br></pre></td></tr></table></figure>

<h5 id="关联关系-Association"><a href="#关联关系-Association" class="headerlink" title="关联关系 (Association)"></a>关联关系 (Association)</h5><p>表示不同类对象之间有关联，这是一种静态关系，与运行过程的状态无关，在最开始就可以确定。因此也可以用 1 对 1、多对 1、多对多这种关联关系来表示。比如学生和学校就是一种关联关系，一个学校可以有很多学生，但是一个学生只属于一个学校，因此这是一种多对一的关系，在运行开始之前就可以确定。</p>
<p><img src="/../images/note31.png" alt="note31"></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">@startuml</span><br><span class="line"></span><br><span class="line">title Association</span><br><span class="line"></span><br><span class="line">class School</span><br><span class="line">class Student</span><br><span class="line"></span><br><span class="line">School <span class="string">&quot;1&quot;</span> - <span class="string">&quot;n&quot;</span> Student</span><br><span class="line"></span><br><span class="line">@enduml</span><br></pre></td></tr></table></figure>

<h5 id="依赖关系-Dependency"><a href="#依赖关系-Dependency" class="headerlink" title="依赖关系 (Dependency)"></a>依赖关系 (Dependency)</h5><p>和关联关系不同的是，依赖关系是在运行过程中起作用的。A 类和 B 类是依赖关系主要有三种形式:</p>
<ul>
<li>A 类是 B 类中的(某中方法的)局部变量；</li>
<li>A 类是 B 类方法当中的一个参数；</li>
<li>A 类向 B 类发送消息，从而影响 B 类发生变化；</li>
</ul>
<p><img src="/../images/note32.png" alt="note32"></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">@startuml</span><br><span class="line"></span><br><span class="line">title Dependency</span><br><span class="line"></span><br><span class="line">class Vehicle &#123;</span><br><span class="line">    move(MoveBehavior)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface MoveBehavior &#123;</span><br><span class="line">    move()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">note <span class="string">&quot;MoveBehavior.move()&quot;</span> as N</span><br><span class="line"></span><br><span class="line">Vehicle ..&gt; MoveBehavior</span><br><span class="line"></span><br><span class="line">Vehicle .. N</span><br><span class="line"></span><br><span class="line">@enduml</span><br></pre></td></tr></table></figure>

<h3 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h3><h4 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h4><h5 id="包装类型"><a href="#包装类型" class="headerlink" title="包装类型"></a>包装类型</h5><p>八个基本类型：</p>
<ul>
<li>boolean&#x2F;1</li>
<li>byte&#x2F;8</li>
<li>char&#x2F;16</li>
<li>short&#x2F;16</li>
<li>int&#x2F;32</li>
<li>float&#x2F;32</li>
<li>long&#x2F;64</li>
<li>double&#x2F;64</li>
</ul>
<p>基本类型都有对应的包装类型，基本类型与其对应的包装类型之间的赋值使用自动装箱与拆箱完成。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">2</span>;     <span class="comment">// 装箱</span></span><br><span class="line"><span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> x;         <span class="comment">// 拆箱</span></span><br></pre></td></tr></table></figure>

<h5 id="缓存池"><a href="#缓存池" class="headerlink" title="缓存池"></a>缓存池</h5><p>new Integer(123) 与 Integer.valueOf(123) 的区别在于:</p>
<ul>
<li>new Integer(123) 每次都会新建一个对象</li>
<li>Integer.valueOf(123) 会使用缓存池中的对象，多次调用会取得同一个对象的引用。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">x</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">123</span>);</span><br><span class="line"><span class="type">Integer</span> <span class="variable">y</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">123</span>);</span><br><span class="line">System.out.println(x == y);    <span class="comment">// false</span></span><br><span class="line"><span class="type">Integer</span> <span class="variable">z</span> <span class="operator">=</span> Integer.valueOf(<span class="number">123</span>);</span><br><span class="line"><span class="type">Integer</span> <span class="variable">k</span> <span class="operator">=</span> Integer.valueOf(<span class="number">123</span>);</span><br><span class="line">System.out.println(z == k);   <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>valueOf() 方法的实现比较简单，就是先判断值是否在缓存池中，如果在的话就直接返回缓存池的内容。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title function_">valueOf</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)</span><br><span class="line">        <span class="keyword">return</span> IntegerCache.cache[i + (-IntegerCache.low)];</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 Java 8 中，Integer 缓存池的大小默认为 -128~127。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">low</span> <span class="operator">=</span> -<span class="number">128</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> high;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> Integer cache[];</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    <span class="comment">// high value may be configured by property</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">h</span> <span class="operator">=</span> <span class="number">127</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">integerCacheHighPropValue</span> <span class="operator">=</span></span><br><span class="line">        sun.misc.VM.getSavedProperty(<span class="string">&quot;java.lang.Integer.IntegerCache.high&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (integerCacheHighPropValue != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> parseInt(integerCacheHighPropValue);</span><br><span class="line">            i = Math.max(i, <span class="number">127</span>);</span><br><span class="line">            <span class="comment">// Maximum array size is Integer.MAX_VALUE</span></span><br><span class="line">            h = Math.min(i, Integer.MAX_VALUE - (-low) -<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span>( NumberFormatException nfe) &#123;</span><br><span class="line">            <span class="comment">// If the property cannot be parsed into an int, ignore it.</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    high = h;</span><br><span class="line"></span><br><span class="line">    cache = <span class="keyword">new</span> <span class="title class_">Integer</span>[(high - low) + <span class="number">1</span>];</span><br><span class="line">    <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> low;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>; k &lt; cache.length; k++)</span><br><span class="line">        cache[k] = <span class="keyword">new</span> <span class="title class_">Integer</span>(j++);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// range [-128, 127] must be interned (JLS7 5.1.7)</span></span><br><span class="line">    <span class="keyword">assert</span> IntegerCache.high &gt;= <span class="number">127</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译器会<strong>在缓冲池范围内的基本类型</strong>自动装箱过程调用 valueOf() 方法，因此多个 Integer 实例使用自动装箱来创建并且值相同，那么就会引用相同的对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">m</span> <span class="operator">=</span> <span class="number">123</span>;</span><br><span class="line"><span class="type">Integer</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">123</span>;</span><br><span class="line">System.out.println(m == n); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>基本类型对应的缓冲池如下：</p>
<ul>
<li>boolean values true and false</li>
<li>all byte values</li>
<li>short values between -128 and 127</li>
<li>int values between -128 and 127</li>
<li>char in the range \u0000 to \u007F</li>
</ul>
<p>在使用这些基本类型对应的包装类型时，就可以直接使用缓冲池中的对象。</p>
<p>如果在缓冲池之外：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">m</span> <span class="operator">=</span> <span class="number">323</span>;</span><br><span class="line"><span class="type">Integer</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">323</span>;</span><br><span class="line">System.out.println(m == n); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<h4 id="String"><a href="#String" class="headerlink" title="String"></a>String</h4><h5 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h5><p>String 被声明为 final，因此它不可被继承。</p>
<p>内部使用 char 数组存储数据，该数组被声明为 final，这意味着 value 数组初始化之后就不能再引用其它数组。并且 String 内部没有改变 value 数组的方法，因此可以保证 String 不可变。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">String</span></span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">java</span>.io.Serializable, Comparable&lt;String&gt;, CharSequence &#123;</span><br><span class="line">    <span class="comment">/** The value is used for character storage. */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">char</span> value[];</span><br></pre></td></tr></table></figure>

<h5 id="不可变的好处"><a href="#不可变的好处" class="headerlink" title="不可变的好处"></a>不可变的好处</h5><ol>
<li><strong>可以缓存 hash 值</strong></li>
</ol>
<p>   因为 String 的 hash 值经常被使用，例如 String 用做 HashMap 的 key。不可变的特性可以使得 hash 值也不可变，因此只需要进行一次计算。</p>
<ol start="2">
<li><strong>String Pool 的需要</strong></li>
</ol>
<p>   如果一个 String 对象已经被创建过了，那么就会从 String Pool 中取得引用。只有 String 是不可变的，才可能使用 String Pool。</p>
<p>   <img src="/../images/note.jpg" alt="note"></p>
<ol start="3">
<li><p><strong>安全性</strong></p>
<p>String 经常作为参数，String 不可变性可以保证参数不可变。例如在作为网络连接参数的情况下如果 String 是可变的，那么在网络连接过程中，String 被改变，改变 String 对象的那一方以为现在连接的是其它主机，而实际情况却不一定是。</p>
</li>
<li><p><strong>线程安全</strong></p>
<p>String 不可变性天生具备线程安全，可以在多个线程中安全地使用。</p>
</li>
</ol>
<h5 id="String-StringBuffer-and-StringBuilder"><a href="#String-StringBuffer-and-StringBuilder" class="headerlink" title="String, StringBuffer and StringBuilder"></a>String, StringBuffer and StringBuilder</h5><ol>
<li>可变性<ul>
<li>String 不可变</li>
<li>StringBuffer 和 StringBuilder 可变</li>
</ul>
</li>
<li>线程安全<ul>
<li>String 不可变，因此是线程安全的</li>
<li>StringBuilder 不是线程安全的</li>
<li>StringBuffer 是线程安全的，内部使用 synchronized 进行同步</li>
</ul>
</li>
</ol>
<h5 id="String-intern"><a href="#String-intern" class="headerlink" title="String.intern()"></a>String.intern()</h5><p>使用 String.intern() 可以保证相同内容的字符串变量引用同一的内存对象。</p>
<p>下面示例中，s1 和 s2 采用 new String() 的方式新建了两个不同对象，而 s3 是通过 s1.intern() 方法取得一个对象引用。intern() 首先把 s1 引用的对象放到 String Pool(字符串常量池)中，然后返回这个对象引用。因此 s3 和 s1 引用的是同一个字符串常量池的对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;aaa&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;aaa&quot;</span>);</span><br><span class="line">System.out.println(s1 == s2);           <span class="comment">// false</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> s1.intern();</span><br><span class="line">System.out.println(s1.intern() == s3);  <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>如果是采用 “bbb” 这种使用双引号的形式创建字符串实例，会自动地将新建的对象放入 String Pool 中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s4</span> <span class="operator">=</span> <span class="string">&quot;bbb&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">s5</span> <span class="operator">=</span> <span class="string">&quot;bbb&quot;</span>;</span><br><span class="line">System.out.println(s4 == s5);  <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>在 Java 7 之前，字符串常量池被放在运行时常量池中，它属于永久代。而在 Java 7，字符串常量池被移到 Native Method 中。这是因为永久代的空间有限，在大量使用字符串的场景下会导致 OutOfMemoryError 错误。</p>
<h4 id="运算"><a href="#运算" class="headerlink" title="运算"></a>运算</h4><h5 id="参数传递"><a href="#参数传递" class="headerlink" title="参数传递"></a>参数传递</h5><p>Java 的参数是以值传递的形式传入方法中，而不是引用传递。</p>
<p>以下代码中 Dog dog 的 dog 是一个指针，存储的是对象的地址。在将一个参数传入一个方法时，本质上是将对象的地址以值的方式传递到形参中。因此在方法中改变指针引用的对象，那么这两个指针此时指向的是完全不同的对象，一方改变其所指向对象的内容对另一方没有影响。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Dog</span> &#123;</span><br><span class="line">    String name;</span><br><span class="line"></span><br><span class="line">    Dog(String name) &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    String <span class="title function_">getObjectAddress</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PassByValueExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Dog</span> <span class="variable">dog</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>(<span class="string">&quot;A&quot;</span>);</span><br><span class="line">        System.out.println(dog.getObjectAddress()); <span class="comment">// Dog@4554617c</span></span><br><span class="line">        func(dog);</span><br><span class="line">        System.out.println(dog.getObjectAddress()); <span class="comment">// Dog@4554617c</span></span><br><span class="line">        System.out.println(dog.getName());          <span class="comment">// A</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">func</span><span class="params">(Dog dog)</span> &#123;</span><br><span class="line">        System.out.println(dog.getObjectAddress()); <span class="comment">// Dog@4554617c</span></span><br><span class="line">        dog = <span class="keyword">new</span> <span class="title class_">Dog</span>(<span class="string">&quot;B&quot;</span>);</span><br><span class="line">        System.out.println(dog.getObjectAddress()); <span class="comment">// Dog@74a14482</span></span><br><span class="line">        System.out.println(dog.getName());          <span class="comment">// B</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是如果在方法中改变对象的字段值会改变原对象该字段值，因为改变的是同一个地址指向的内容。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">PassByValueExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Dog</span> <span class="variable">dog</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>(<span class="string">&quot;A&quot;</span>);</span><br><span class="line">        func(dog);</span><br><span class="line">        System.out.println(dog.getName());          <span class="comment">// B</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">func</span><span class="params">(Dog dog)</span> &#123;</span><br><span class="line">        dog.setName(<span class="string">&quot;B&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="float与double"><a href="#float与double" class="headerlink" title="float与double"></a>float与double</h5><p>1.1 字面量属于 double 类型，不能直接将 1.1 直接赋值给 float 变量，因为这是向下转型。Java 不能隐式执行向下转型，因为这会使得精度降低。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// float f = 1.1;</span></span><br></pre></td></tr></table></figure>

<p>1.1f 字面量才是 float 类型。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">float</span> <span class="variable">f</span> <span class="operator">=</span> <span class="number">1.1f</span>;</span><br></pre></td></tr></table></figure>

<h5 id="隐式类型转换"><a href="#隐式类型转换" class="headerlink" title="隐式类型转换"></a>隐式类型转换</h5><p>因为字面量 1 是 int 类型，它比 short 类型精度要高，因此不能隐式地将 int 类型下转型为 short 类型。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">short</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="comment">// s1 = s1 + 1;</span></span><br></pre></td></tr></table></figure>

<p>但是使用 +&#x3D; 运算符可以执行隐式类型转换。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">s1 += <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p>上面的语句相当于将 s1 + 1 的计算结果进行了向下转型:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">s1 = (<span class="type">short</span>) (s1 + <span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<h5 id="switch"><a href="#switch" class="headerlink" title="switch"></a>switch</h5><p>从 Java 7 开始，可以在 switch 条件判断语句中使用 String 对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;a&quot;</span>;</span><br><span class="line"><span class="keyword">switch</span> (s) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;a&quot;</span>:</span><br><span class="line">        System.out.println(<span class="string">&quot;aaa&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;b&quot;</span>:</span><br><span class="line">        System.out.println(<span class="string">&quot;bbb&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>switch 不支持 long，是因为 switch 的设计初衷是对那些只有少数的几个值进行等值判断，如果值过于复杂，那么还是用 if 比较合适。</p>
<h4 id="继承-1"><a href="#继承-1" class="headerlink" title="继承"></a>继承</h4><h5 id="访问权限"><a href="#访问权限" class="headerlink" title="访问权限"></a>访问权限</h5><p>Java 中有三个访问权限修饰符: private、protected 以及 public，如果不加访问修饰符，表示包级可见。</p>
<p>可以对类或类中的成员(字段以及方法)加上访问修饰符。</p>
<ul>
<li>类可见表示其它类可以用这个类创建实例对象。</li>
<li>成员可见表示其它类可以用这个类的实例对象访问到该成员；</li>
</ul>
<p>protected 用于修饰成员，表示在继承体系中成员对于子类可见，但是这个访问修饰符对于类没有意义。</p>
<p>设计良好的模块会隐藏所有的实现细节，把它的 API 与它的实现清晰地隔离开来。模块之间只通过它们的 API 进行通信，一个模块不需要知道其他模块的内部工作情况，这个概念被称为信息隐藏或封装。因此访问权限应当尽可能地使每个类或者成员不被外界访问。</p>
<p>如果子类的方法重写了父类的方法，那么子类中该方法的访问级别不允许低于父类的访问级别。这是为了确保可以使用父类实例的地方都可以使用子类实例，也就是确保满足里氏替换原则。</p>
<p>字段决不能是公有的，因为这么做的话就失去了对这个字段修改行为的控制，客户端可以对其随意修改。例如下面的例子中，AccessExample 拥有 id 共有字段，如果在某个时刻，我们想要使用 int 去存储 id 字段，那么就需要去修改所有的客户端代码。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AccessExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String id;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以使用公有的 getter 和 setter 方法来替换公有字段，这样的话就可以控制对字段的修改行为。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AccessExample</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> id;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getId</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> id + <span class="string">&quot;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setId</span><span class="params">(String id)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.id = Integer.valueOf(id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是也有例外，如果是包级私有的类或者私有的嵌套类，那么直接暴露成员不会有特别大的影响。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AccessWithInnerClassExample</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">InnerClass</span> &#123;</span><br><span class="line">        <span class="type">int</span> x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> InnerClass innerClass;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">AccessWithInnerClassExample</span><span class="params">()</span> &#123;</span><br><span class="line">        innerClass = <span class="keyword">new</span> <span class="title class_">InnerClass</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getValue</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> innerClass.x;  <span class="comment">// 直接访问</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="抽象类和接口"><a href="#抽象类和接口" class="headerlink" title="抽象类和接口"></a>抽象类和接口</h5><ol>
<li>抽象类</li>
</ol>
<p>   抽象类和抽象方法都使用 abstract 关键字进行声明。抽象类一般会包含抽象方法，抽象方法一定位于抽象类中。</p>
<p>   抽象类和普通类最大的区别是，抽象类不能被实例化，需要继承抽象类才能实例化其子类。</p>
   <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractClassExample</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="type">int</span> x;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> y;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">func1</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">func2</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;func2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

   <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AbstractExtendClassExample</span> <span class="keyword">extends</span> <span class="title class_">AbstractClassExample</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">func1</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;func1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

   <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// AbstractClassExample ac1 = new AbstractClassExample(); // &#x27;AbstractClassExample&#x27; is abstract; cannot be instantiated</span></span><br><span class="line"><span class="type">AbstractClassExample</span> <span class="variable">ac2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AbstractExtendClassExample</span>();</span><br><span class="line">ac2.func1();</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><p>接口</p>
<p>接口是抽象类的延伸，在 Java 8 之前，它可以看成是一个完全抽象的类，也就是说它不能有任何的方法实现。</p>
<p>从 Java 8 开始，接口也可以拥有默认的方法实现，这是因为不支持默认方法的接口的维护成本太高了。在 Java 8 之前，如果一个接口想要添加新的方法，那么要修改所有实现了该接口的类。</p>
<p>接口的成员(字段 + 方法)默认都是 public 的，并且不允许定义为 private 或者 protected。</p>
<p>接口的字段默认都是 static 和 final 的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">InterfaceExample</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">func1</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">func2</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;func2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">123</span>;</span><br><span class="line">    <span class="comment">// int y;               // Variable &#x27;y&#x27; might not have been initialized</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="variable">z</span> <span class="operator">=</span> <span class="number">0</span>;       <span class="comment">// Modifier &#x27;public&#x27; is redundant for interface fields</span></span><br><span class="line">    <span class="comment">// private int k = 0;   // Modifier &#x27;private&#x27; not allowed here</span></span><br><span class="line">    <span class="comment">// protected int l = 0; // Modifier &#x27;protected&#x27; not allowed here</span></span><br><span class="line">    <span class="comment">// private void fun3(); // Modifier &#x27;private&#x27; not allowed here</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InterfaceImplementExample</span> <span class="keyword">implements</span> <span class="title class_">InterfaceExample</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">func1</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;func1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// InterfaceExample ie1 = new InterfaceExample(); // &#x27;InterfaceExample&#x27; is abstract; cannot be instantiated</span></span><br><span class="line"><span class="type">InterfaceExample</span> <span class="variable">ie2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InterfaceImplementExample</span>();</span><br><span class="line">ie2.func1();</span><br><span class="line">System.out.println(InterfaceExample.x);</span><br></pre></td></tr></table></figure>
</li>
<li><p>比较</p>
<ul>
<li>从设计层面上看，抽象类提供了一种 IS-A 关系，那么就必须满足里式替换原则，即子类对象必须能够替换掉所有父类对象。而接口更像是一种 LIKE-A 关系，它只是提供一种方法实现契约，并不要求接口和实现接口的类具有 IS-A 关系。</li>
<li>从使用上来看，一个类可以实现多个接口，但是不能继承多个抽象类。</li>
<li>接口的字段只能是 static 和 final 类型的，而抽象类的字段没有这种限制。</li>
<li>接口的成员只能是 public 的，而抽象类的成员可以有多种访问权限。</li>
</ul>
</li>
<li><p>使用选择</p>
<p>使用接口:</p>
<ul>
<li>需要让不相关的类都实现一个方法，例如不相关的类都可以实现 Compareable 接口中的 compareTo() 方法；</li>
<li>需要使用多重继承。</li>
</ul>
<p>使用抽象类：</p>
<ul>
<li>需要在几个相关的类中共享代码</li>
<li>需要能控制继承来的成员的访问权限，而不是都为 public。</li>
<li>需要继承非静态和非常量字段。</li>
</ul>
<p>在很多情况下，接口优先于抽象类，因为接口没有抽象类严格的类层次结构要求，可以灵活地为一个类添加行为。并且从 Java 8 开始，接口也可以有默认的方法实现，使得修改接口的成本也变的很低。</p>
</li>
</ol>
<h5 id="super"><a href="#super" class="headerlink" title="super"></a>super</h5><ul>
<li>访问父类的构造函数: 可以使用 super() 函数访问父类的构造函数，从而委托父类完成一些初始化的工作。</li>
<li>访问父类的成员: 如果子类重写了父类的中某个方法的实现，可以通过使用 super 关键字来引用父类的方法实现。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SuperExample</span> &#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="type">int</span> x;</span><br><span class="line">    <span class="keyword">protected</span> <span class="type">int</span> y;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SuperExample</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.x = x;</span><br><span class="line">        <span class="built_in">this</span>.y = y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">func</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;SuperExample.func()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SuperExtendExample</span> <span class="keyword">extends</span> <span class="title class_">SuperExample</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> z;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SuperExtendExample</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> z)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(x, y);</span><br><span class="line">        <span class="built_in">this</span>.z = z;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">func</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.func();</span><br><span class="line">        System.out.println(<span class="string">&quot;SuperExtendExample.func()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">SuperExample</span> <span class="variable">e</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SuperExtendExample</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">e.func();</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">SuperExample.func()</span><br><span class="line">SuperExtendExample.func()</span><br></pre></td></tr></table></figure>

<h5 id="重写和重载"><a href="#重写和重载" class="headerlink" title="重写和重载"></a>重写和重载</h5><ol>
<li><p>重写（override）</p>
<p>存在于继承体系中，指子类实现了一个与父类在方法声明上完全相同的一个方法。</p>
<p>为了满足里式替换原则，重写有以下两个限制:</p>
<ul>
<li>子类方法的访问权限必须大于等于父类方法；</li>
<li>子类方法的返回类型必须是父类方法返回类型或为其子类型。</li>
</ul>
<p>使用 @Override 注解，可以让编译器帮忙检查是否满足上面的两个限制条件。</p>
</li>
<li><p>重载（overload）</p>
<p>存在于同一个类中，指一个方法与已经存在的方法名称上相同，但是参数类型、个数、顺序至少有一个不同。</p>
<p>应该注意的是，返回值不同，其它都相同不算是重载。</p>
</li>
</ol>
<h4 id="Object通用方法"><a href="#Object通用方法" class="headerlink" title="Object通用方法"></a>Object通用方法</h4><h5 id="概览-1"><a href="#概览-1" class="headerlink" title="概览"></a>概览</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> Class&lt;?&gt; getClass()</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object obj)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">native</span> Object <span class="title function_">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">notify</span><span class="params">()</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">notifyAll</span><span class="params">()</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">wait</span><span class="params">(<span class="type">long</span> timeout)</span> <span class="keyword">throws</span> InterruptedException</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">wait</span><span class="params">(<span class="type">long</span> timeout, <span class="type">int</span> nanos)</span> <span class="keyword">throws</span> InterruptedException</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">wait</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable &#123;&#125;</span><br></pre></td></tr></table></figure>

<h5 id="equals"><a href="#equals" class="headerlink" title="equals()"></a>equals()</h5><ol>
<li>等价关系</li>
</ol>
<p>自反性</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">x.equals(x); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>对称性</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">x.equals(y) == y.equals(x); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>传递性</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (x.equals(y) &amp;&amp; y.equals(z))</span><br><span class="line">    x.equals(z); <span class="comment">// true;</span></span><br></pre></td></tr></table></figure>

<p>一致性</p>
<p>多次调用 equals() 方法结果不变</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">x.equals(y) == x.equals(y); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>与null的比较</p>
<p>对任何不是 null 的对象 x 调用 x.equals(null) 结果都为 false</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">x.equals(<span class="literal">null</span>); <span class="comment">// false;</span></span><br></pre></td></tr></table></figure>

<p>2.equals()与&#x3D;&#x3D;</p>
<ul>
<li>对于基本类型，&#x3D;&#x3D; 判断两个值是否相等，基本类型没有 equals() 方法。</li>
<li>对于引用类型，&#x3D;&#x3D; 判断两个变量是否引用同一个对象，而 equals() 判断引用的对象是否等价。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">x</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">1</span>);</span><br><span class="line"><span class="type">Integer</span> <span class="variable">y</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">1</span>);</span><br><span class="line">System.out.println(x.equals(y)); <span class="comment">// true</span></span><br><span class="line">System.out.println(x == y);      <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<p>3.实现</p>
<ul>
<li>检查是否为同一个对象的引用，如果是直接返回 true；</li>
<li>检查是否是同一个类型，如果不是，直接返回 false；</li>
<li>将 Object 对象进行转型；</li>
<li>判断每个关键域是否相等。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EqualExample</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> x;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> y;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> z;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">EqualExample</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> z)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.x = x;</span><br><span class="line">        <span class="built_in">this</span>.y = y;</span><br><span class="line">        <span class="built_in">this</span>.z = z;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span> == o) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="literal">null</span> || getClass() != o.getClass()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">EqualExample</span> <span class="variable">that</span> <span class="operator">=</span> (EqualExample) o;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (x != that.x) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (y != that.y) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="type">return</span> <span class="variable">z</span> <span class="operator">=</span>= that.z;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="hashCode"><a href="#hashCode" class="headerlink" title="hashCode()"></a>hashCode()</h5><p>hashCode() 返回散列值，而 equals() 是用来判断两个对象是否等价。等价的两个对象散列值一定相同，但是散列值相同的两个对象不一定等价。</p>
<p>在覆盖 equals() 方法时应当总是覆盖 hashCode() 方法，保证等价的两个对象散列值也相等。</p>
<p>下面的代码中，新建了两个等价的对象，并将它们添加到 HashSet 中。我们希望将这两个对象当成一样的，只在集合中添加一个对象，但是因为 EqualExample 没有实现 hasCode() 方法，因此这两个对象的散列值是不同的，最终导致集合添加了两个等价的对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">EqualExample</span> <span class="variable">e1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">EqualExample</span>(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line"><span class="type">EqualExample</span> <span class="variable">e2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">EqualExample</span>(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">System.out.println(e1.equals(e2)); <span class="comment">// true</span></span><br><span class="line">HashSet&lt;EqualExample&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">set.add(e1);</span><br><span class="line">set.add(e2);</span><br><span class="line">System.out.println(set.size());   <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>

<p>理想的散列函数应当具有均匀性，即不相等的对象应当均匀分布到所有可能的散列值上。这就要求了散列函数要把所有域的值都考虑进来，可以将每个域都当成 R 进制的某一位，然后组成一个 R 进制的整数。R 一般取 31，因为它是一个奇素数，如果是偶数的话，当出现乘法溢出，信息就会丢失，因为与 2 相乘相当于向左移一位。</p>
<p>一个数与 31 相乘可以转换成移位和减法: <code>31*x == (x&lt;&lt;5)-x</code>，编译器会自动进行这个优化。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">17</span>;</span><br><span class="line">    result = <span class="number">31</span> * result + x;</span><br><span class="line">    result = <span class="number">31</span> * result + y;</span><br><span class="line">    result = <span class="number">31</span> * result + z;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="toString-NaN"><a href="#toString-NaN" class="headerlink" title="toString()"></a>toString()</h5><p>默认返回 ToStringExample@4554617c 这种形式，其中 @ 后面的数值为散列码的无符号十六进制表示。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ToStringExample</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> number;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ToStringExample</span><span class="params">(<span class="type">int</span> number)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.number = number;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ToStringExample</span> <span class="variable">example</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ToStringExample</span>(<span class="number">123</span>);</span><br><span class="line">System.out.println(example.toString());</span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">ToStringExample@4554617c</span><br></pre></td></tr></table></figure>

<h5 id="clone"><a href="#clone" class="headerlink" title="clone()"></a>clone()</h5><p>1.cloneable</p>
<p>clone() 是 Object 的 protected 方法，它不是 public，一个类不显式去重写 clone()，其它类就不能直接去调用该类实例的 clone() 方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CloneExample</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> a;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">CloneExample</span> <span class="variable">e1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CloneExample</span>();</span><br><span class="line"><span class="comment">// CloneExample e2 = e1.clone(); // &#x27;clone()&#x27; has protected access in &#x27;java.lang.Object&#x27;</span></span><br></pre></td></tr></table></figure>

<p>重写 clone() 得到以下实现:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CloneExample</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> a;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> b;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> CloneExample <span class="title function_">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException &#123;</span><br><span class="line">        <span class="keyword">return</span> (CloneExample)<span class="built_in">super</span>.clone();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">CloneExample</span> <span class="variable">e1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CloneExample</span>();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="type">CloneExample</span> <span class="variable">e2</span> <span class="operator">=</span> e1.clone();</span><br><span class="line">&#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">java.lang.CloneNotSupportedException: CloneExample</span><br></pre></td></tr></table></figure>

<p>以上抛出了 CloneNotSupportedException，这是因为 CloneExample 没有实现 Cloneable 接口。</p>
<p>应该注意的是，clone() 方法并不是 Cloneable 接口的方法，而是 Object 的一个 protected 方法。Cloneable 接口只是规定，如果一个类没有实现 Cloneable 接口又调用了 clone() 方法，就会抛出 CloneNotSupportedException。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CloneExample</span> <span class="keyword">implements</span> <span class="title class_">Cloneable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> a;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> b;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Object <span class="title function_">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.clone();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2.浅拷贝</p>
<p>拷贝对象和原始对象的引用类型引用同一个对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ShallowCloneExample</span> <span class="keyword">implements</span> <span class="title class_">Cloneable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] arr;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ShallowCloneExample</span><span class="params">()</span> &#123;</span><br><span class="line">        arr = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">10</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            arr[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(<span class="type">int</span> index, <span class="type">int</span> value)</span> &#123;</span><br><span class="line">        arr[index] = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">get</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> arr[index];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> ShallowCloneExample <span class="title function_">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException &#123;</span><br><span class="line">        <span class="keyword">return</span> (ShallowCloneExample) <span class="built_in">super</span>.clone();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ShallowCloneExample</span> <span class="variable">e1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ShallowCloneExample</span>();</span><br><span class="line"><span class="type">ShallowCloneExample</span> <span class="variable">e2</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    e2 = e1.clone();</span><br><span class="line">&#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">e1.set(<span class="number">2</span>, <span class="number">222</span>);</span><br><span class="line">System.out.println(e2.get(<span class="number">2</span>)); <span class="comment">// 222</span></span><br></pre></td></tr></table></figure>

<p>3.深拷贝</p>
<p>拷贝对象和原始对象的引用类型引用不同对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DeepCloneExample</span> <span class="keyword">implements</span> <span class="title class_">Cloneable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] arr;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">DeepCloneExample</span><span class="params">()</span> &#123;</span><br><span class="line">        arr = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">10</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            arr[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(<span class="type">int</span> index, <span class="type">int</span> value)</span> &#123;</span><br><span class="line">        arr[index] = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">get</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> arr[index];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> DeepCloneExample <span class="title function_">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException &#123;</span><br><span class="line">        <span class="type">DeepCloneExample</span> <span class="variable">result</span> <span class="operator">=</span> (DeepCloneExample) <span class="built_in">super</span>.clone();</span><br><span class="line">        result.arr = <span class="keyword">new</span> <span class="title class_">int</span>[arr.length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            result.arr[i] = arr[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">DeepCloneExample</span> <span class="variable">e1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DeepCloneExample</span>();</span><br><span class="line"><span class="type">DeepCloneExample</span> <span class="variable">e2</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    e2 = e1.clone();</span><br><span class="line">&#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">e1.set(<span class="number">2</span>, <span class="number">222</span>);</span><br><span class="line">System.out.println(e2.get(<span class="number">2</span>)); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>

<p>4.clone()的替代方案</p>
<p>使用 clone() 方法来拷贝一个对象即复杂又有风险，它会抛出异常，并且还需要类型转换。Effective Java 书上讲到，最好不要去使用 clone()，可以使用拷贝构造函数或者拷贝工厂来拷贝一个对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CloneConstructorExample</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] arr;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CloneConstructorExample</span><span class="params">()</span> &#123;</span><br><span class="line">        arr = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">10</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            arr[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CloneConstructorExample</span><span class="params">(CloneConstructorExample original)</span> &#123;</span><br><span class="line">        arr = <span class="keyword">new</span> <span class="title class_">int</span>[original.arr.length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; original.arr.length; i++) &#123;</span><br><span class="line">            arr[i] = original.arr[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(<span class="type">int</span> index, <span class="type">int</span> value)</span> &#123;</span><br><span class="line">        arr[index] = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">get</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> arr[index];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">CloneConstructorExample</span> <span class="variable">e1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CloneConstructorExample</span>();</span><br><span class="line"><span class="type">CloneConstructorExample</span> <span class="variable">e2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CloneConstructorExample</span>(e1);</span><br><span class="line">e1.set(<span class="number">2</span>, <span class="number">222</span>);</span><br><span class="line">System.out.println(e2.get(<span class="number">2</span>)); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>

<h4 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h4><h5 id="final"><a href="#final" class="headerlink" title="final"></a>final</h5><p>1.数据</p>
<p>声明数据为常量，可以是编译时常量，也可以是在运行时被初始化后不能被改变的常量。</p>
<ul>
<li>对于基本类型，final 使数值不变；</li>
<li>对于引用类型，final 使引用不变，也就不能引用其它对象，但是被引用的对象本身是可以修改的。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="comment">// x = 2;  // cannot assign value to final variable &#x27;x&#x27;</span></span><br><span class="line"><span class="keyword">final</span> <span class="type">A</span> <span class="variable">y</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">A</span>();</span><br><span class="line">y.a = <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p>2.方法</p>
<p>声明方法不能被子类重写。</p>
<p>private 方法隐式地被指定为 final，如果在子类中定义的方法和基类中的一个 private 方法签名相同，此时子类的方法不是重写基类方法，而是在子类中定义了一个新的方法。</p>
<p>3.类</p>
<p>声明类不允许被继承。</p>
<h5 id="static"><a href="#static" class="headerlink" title="static"></a>static</h5><p>1.静态变量</p>
<ul>
<li>静态变量: 又称为类变量，也就是说这个变量属于类的，类所有的实例都共享静态变量，可以直接通过类名来访问它；静态变量在内存中只存在一份。</li>
<li>实例变量: 每创建一个实例就会产生一个实例变量，它与该实例同生共死。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> x;         <span class="comment">// 实例变量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> y;  <span class="comment">// 静态变量</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// int x = A.x;  // Non-static field &#x27;x&#x27; cannot be referenced from a static context</span></span><br><span class="line">        <span class="type">A</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">A</span>();</span><br><span class="line">        <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> a.x;</span><br><span class="line">        <span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> A.y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2.静态方法</p>
<p>静态方法在类加载的时候就存在了，它不依赖于任何实例。所以静态方法必须有实现，也就是说它不能是抽象方法(abstract)。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">func1</span><span class="params">()</span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// public abstract static void func2();  // Illegal combination of modifiers: &#x27;abstract&#x27; and &#x27;static&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>只能访问所属类的静态字段和静态方法，方法中不能有 this 和 super 关键字。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> x;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> y;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">func1</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> x;</span><br><span class="line">        <span class="comment">// int b = y;  // Non-static field &#x27;y&#x27; cannot be referenced from a static context</span></span><br><span class="line">        <span class="comment">// int b = this.y;     // &#x27;A.this&#x27; cannot be referenced from a static context</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3.静态语句块</p>
<p>静态语句块在类初始化时运行一次。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;123&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">A</span> <span class="variable">a1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">A</span>();</span><br><span class="line">        <span class="type">A</span> <span class="variable">a2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">A</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">123</span><br></pre></td></tr></table></figure>

<p>4.静态内部类</p>
<p>非静态内部类依赖于外部类的实例，而静态内部类不需要。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OuterClass</span> &#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">InnerClass</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">StaticInnerClass</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// InnerClass innerClass = new InnerClass(); // &#x27;OuterClass.this&#x27; cannot be referenced from a static context</span></span><br><span class="line">        <span class="type">OuterClass</span> <span class="variable">outerClass</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OuterClass</span>();</span><br><span class="line">        <span class="type">InnerClass</span> <span class="variable">innerClass</span> <span class="operator">=</span> outerClass.<span class="keyword">new</span> <span class="title class_">InnerClass</span>();</span><br><span class="line">        <span class="type">StaticInnerClass</span> <span class="variable">staticInnerClass</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StaticInnerClass</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>静态内部类不能访问外部类的非静态的变量和方法。</p>
<p>5.静态导包</p>
<p>在使用静态变量和方法时不用再指明 ClassName，从而简化代码，但可读性大大降低。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> com.xxx.ClassName.*</span><br></pre></td></tr></table></figure>

<p>6.初始化顺序</p>
<p>静态变量和静态语句块优先于实例变量和普通语句块，静态变量和静态语句块的初始化顺序取决于它们在代码中的顺序。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">staticField</span> <span class="operator">=</span> <span class="string">&quot;静态变量&quot;</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;静态语句块&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">String</span> <span class="variable">field</span> <span class="operator">=</span> <span class="string">&quot;实例变量&quot;</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;普通语句块&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后才是构造函数的初始化。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">InitialOrderTest</span><span class="params">()</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;构造函数&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>存在继承的情况下，初始化顺序为:</p>
<ul>
<li>父类(静态变量、静态语句块)</li>
<li>子类(静态变量、静态语句块)</li>
<li>父类(实例变量、普通语句块)</li>
<li>父类(构造函数)</li>
<li>子类(实例变量、普通语句块)</li>
<li>子类(构造函数)</li>
</ul>
]]></content>
      <categories>
        <category>java</category>
      </categories>
  </entry>
  <entry>
    <title>ThreadLocal源码解析 - ThreadLocal</title>
    <url>/2022/05/24/2022-05-24-ThreadLocal%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</url>
    <content><![CDATA[<h1 id="ThreadLocal源码解析"><a href="#ThreadLocal源码解析" class="headerlink" title="ThreadLocal源码解析"></a>ThreadLocal源码解析</h1><span id="more"></span>

<p><img src="/.io//Blog\source\images\v.png" alt="v"></p>
<h4 id="ThreadLocal代码演示"><a href="#ThreadLocal代码演示" class="headerlink" title="ThreadLocal代码演示"></a>ThreadLocal代码演示</h4><p>我们先看下<code>ThreadLocal</code>使用示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadLocalTest</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt; messages = Lists.newArrayList();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;ThreadLocalTest&gt; holder = ThreadLocal.withInitial(ThreadLocalTest::<span class="keyword">new</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(String message)</span> &#123;</span><br><span class="line">        holder.get().messages.add(message);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title function_">clear</span><span class="params">()</span> &#123;</span><br><span class="line">        List&lt;String&gt; messages = holder.get().messages;</span><br><span class="line">        holder.remove();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;size: &quot;</span> + holder.get().messages.size());</span><br><span class="line">        <span class="keyword">return</span> messages;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        ThreadLocalTest.add(<span class="string">&quot;tzd&quot;</span>);</span><br><span class="line">        System.out.println(holder.get().messages);</span><br><span class="line">        ThreadLocalTest.clear();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>打印结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[tzd]</span><br><span class="line">size: 0</span><br></pre></td></tr></table></figure>

<p><code>ThreadLocal</code>对象可以提供线程局部变量，每个线程<code>Thread</code>拥有一份自己的<strong>副本变量</strong>，多个线程互不干扰。</p>
<h4 id="ThreadLocal的数据结构"><a href="#ThreadLocal的数据结构" class="headerlink" title="ThreadLocal的数据结构"></a>ThreadLocal的数据结构</h4><p><img src="/../images/w.png" alt="w"></p>
<p><code>Thread</code>类有一个类型为<code>ThreadLocal.ThreadLocalMap</code>的实例变量<code>threadLocals</code>，也就是说每个线程有一个自己的<code>ThreadLocalMap</code>。</p>
<p><code>ThreadLocalMap</code>有自己的独立实现，可以简单地将它的<code>key</code>视作<code>ThreadLocal</code>，<code>value</code>为代码中放入的值（实际上<code>key</code>并不是<code>ThreadLocal</code>本身，而是它的一个<strong>弱引用</strong>）。</p>
<p>每个线程在往<code>ThreadLocal</code>里放值的时候，都会往自己的<code>ThreadLocalMap</code>里存，读也是以<code>ThreadLocal</code>作为引用，在自己的<code>map</code>里找对应的<code>key</code>，从而实现了<strong>线程隔离</strong>。</p>
<p><code>ThreadLocalMap</code>有点类似<code>HashMap</code>的结构，只是<code>HashMap</code>是由<strong>数组+链表</strong>实现的，而<code>ThreadLocalMap</code>中并没有<strong>链表</strong>结构。</p>
<p>我们还要注意<code>Entry</code>， 它的<code>key</code>是<code>ThreadLocal&lt;?&gt; k</code> ，继承自<code>WeakReference</code>， 也就是我们常说的弱引用类型。</p>
<h4 id="GC之后key是否为null？"><a href="#GC之后key是否为null？" class="headerlink" title="GC之后key是否为null？"></a>GC之后key是否为null？</h4><p><code>ThreadLocal</code> 的<code>key</code>是弱引用，那么在<code>ThreadLocal.get()</code>的时候，发生<code>GC</code>之后，<code>key</code>是否是<code>null</code>？</p>
<p>为了搞清楚这个问题，我们需要搞清楚<code>Java</code>的<strong>四种引用类型</strong>：</p>
<ul>
<li><strong>强引用</strong>：我们常常 new 出来的对象就是强引用类型，只要强引用存在，垃圾回收器将永远不会回收被引用的对象，哪怕内存不足的时候</li>
<li><strong>软引用</strong>：使用 SoftReference 修饰的对象被称为软引用，软引用指向的对象在内存要溢出的时候被回收</li>
<li><strong>弱引用</strong>：使用 WeakReference 修饰的对象被称为弱引用，只要发生垃圾回收，若这个对象只被弱引用指向，那么就会被回收</li>
<li><strong>虚引用</strong>：虚引用是最弱的引用，在 Java 中使用 PhantomReference 进行定义。虚引用中唯一的作用就是用队列接收对象即将死亡的通知</li>
</ul>
<p>接着再来看下代码，我们使用反射的方式来看看<code>GC</code>后<code>ThreadLocal</code>中的数据情况：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadLocalDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> NoSuchFieldException, IllegalAccessException, InterruptedException &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;test(<span class="string">&quot;abc&quot;</span>,<span class="literal">false</span>));</span><br><span class="line">        t.start();</span><br><span class="line">        t.join();</span><br><span class="line">        System.out.println(<span class="string">&quot;--gc后--&quot;</span>);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; test(<span class="string">&quot;def&quot;</span>, <span class="literal">true</span>));</span><br><span class="line">        t2.start();</span><br><span class="line">        t2.join();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">(String s,<span class="type">boolean</span> isGC)</span>  &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;&gt;().set(s);</span><br><span class="line">            <span class="keyword">if</span> (isGC) &#123;</span><br><span class="line">                System.gc();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">            Class&lt;? <span class="keyword">extends</span> <span class="title class_">Thread</span>&gt; clz = t.getClass();</span><br><span class="line">            <span class="type">Field</span> <span class="variable">field</span> <span class="operator">=</span> clz.getDeclaredField(<span class="string">&quot;threadLocals&quot;</span>);</span><br><span class="line">            field.setAccessible(<span class="literal">true</span>);</span><br><span class="line">            <span class="type">Object</span> <span class="variable">ThreadLocalMap</span> <span class="operator">=</span> field.get(t);</span><br><span class="line">            Class&lt;?&gt; tlmClass = ThreadLocalMap.getClass();</span><br><span class="line">            <span class="type">Field</span> <span class="variable">tableField</span> <span class="operator">=</span> tlmClass.getDeclaredField(<span class="string">&quot;table&quot;</span>);</span><br><span class="line">            tableField.setAccessible(<span class="literal">true</span>);</span><br><span class="line">            Object[] arr = (Object[]) tableField.get(ThreadLocalMap);</span><br><span class="line">            <span class="keyword">for</span> (Object o : arr) &#123;</span><br><span class="line">                <span class="keyword">if</span> (o != <span class="literal">null</span>) &#123;</span><br><span class="line">                    Class&lt;?&gt; entryClass = o.getClass();</span><br><span class="line">                    <span class="type">Field</span> <span class="variable">valueField</span> <span class="operator">=</span> entryClass.getDeclaredField(<span class="string">&quot;value&quot;</span>);</span><br><span class="line">                    <span class="type">Field</span> <span class="variable">referenceField</span> <span class="operator">=</span> entryClass.getSuperclass().getSuperclass().getDeclaredField(<span class="string">&quot;referent&quot;</span>);</span><br><span class="line">                    valueField.setAccessible(<span class="literal">true</span>);</span><br><span class="line">                    referenceField.setAccessible(<span class="literal">true</span>);</span><br><span class="line">                    System.out.println(String.format(<span class="string">&quot;弱引用key:%s,值:%s&quot;</span>, referenceField.get(o), valueField.get(o)));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>打印结果如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">弱引用key:java.lang.ThreadLocal@433619b6,值:abc</span><br><span class="line">弱引用key:java.lang.ThreadLocal@418a15e3,值:java.lang.ref.SoftReference<span class="meta">@bf97a12</span></span><br><span class="line">--gc后--</span><br><span class="line">弱引用key:<span class="literal">null</span>,值:def</span><br></pre></td></tr></table></figure>

<p><img src="/../images/x.png" alt="x"></p>
<p>如图所示，因为这里创建的<code>ThreadLocal</code>并没有指向任何值，也就是没有任何引用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;&gt;().set(s);</span><br></pre></td></tr></table></figure>

<p>所以这里在<code>GC</code>之后，<code>key</code>就会被回收，我们看到上面<code>debug</code>中的<code>referent=null</code>, 如果<strong>改动一下代码：</strong></p>
<p><img src="/../images/y.png" alt="y"></p>
<p>这个问题刚开始看，如果没有过多思考，<strong>弱引用</strong>，还有<strong>垃圾回收</strong>，那么肯定会觉得是<code>null</code>。</p>
<p>其实是不对的，因为题目说的是在做 <code>ThreadLocal.get()</code> 操作，证明其实还是有<strong>强引用</strong>存在的，所以 <code>key</code> 并不为 <code>null</code>，如下图所示，<code>ThreadLocal</code>的<strong>强引用</strong>仍然是存在的。</p>
<p><img src="/../images/z.png" alt="z"></p>
<p>如果我们的<strong>强引用</strong>不存在的话，那么 <code>key</code> 就会被回收，也就是会出现我们 <code>value</code> 没被回收，<code>key</code> 被回收，导致 <code>value</code> 永远存在，出现内存泄漏。</p>
<h4 id="ThreadLocal-set-方法源码详解"><a href="#ThreadLocal-set-方法源码详解" class="headerlink" title="ThreadLocal.set()方法源码详解"></a>ThreadLocal.set()方法源码详解</h4><p><img src="/../images/A.png" alt="A"></p>
<p><code>ThreadLocal</code>中的<code>set</code>方法原理如上图所示，很简单，主要是判断<code>ThreadLocalMap</code>是否存在，然后使用<code>ThreadLocal</code>中的<code>set</code>方法进行数据处理。</p>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(T value)</span> &#123;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">    <span class="type">ThreadLocalMap</span> <span class="variable">map</span> <span class="operator">=</span> getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="literal">null</span>)</span><br><span class="line">        map.set(<span class="built_in">this</span>, value);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        createMap(t, value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">createMap</span><span class="params">(Thread t, T firstValue)</span> &#123;</span><br><span class="line">    t.threadLocals = <span class="keyword">new</span> <span class="title class_">ThreadLocalMap</span>(<span class="built_in">this</span>, firstValue);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>主要的核心逻辑还是在<code>ThreadLocalMap</code>中的，一步步往下看，后面还有更详细的剖析。</p>
<h4 id="ThreadLocalMap-Hash算法"><a href="#ThreadLocalMap-Hash算法" class="headerlink" title="ThreadLocalMap Hash算法"></a>ThreadLocalMap Hash算法</h4><p>既然是<code>Map</code>结构，那么<code>ThreadLocalMap</code>当然也要实现自己的<code>hash</code>算法来解决散列表数组冲突问题。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> key.threadLocalHashCode &amp; (len-<span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<p><code>ThreadLocalMap</code>中<code>hash</code>算法很简单，这里<code>i</code>就是当前 key 在散列表中对应的数组下标位置。</p>
<p>这里最关键的就是<code>threadLocalHashCode</code>值的计算，<code>ThreadLocal</code>中有一个属性为<code>HASH_INCREMENT = 0x61c88647</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadLocal</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">threadLocalHashCode</span> <span class="operator">=</span> nextHashCode();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">AtomicInteger</span> <span class="variable">nextHashCode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">HASH_INCREMENT</span> <span class="operator">=</span> <span class="number">0x61c88647</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">nextHashCode</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> nextHashCode.getAndAdd(HASH_INCREMENT);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">ThreadLocalMap</span> &#123;</span><br><span class="line">        ThreadLocalMap(ThreadLocal&lt;?&gt; firstKey, Object firstValue) &#123;</span><br><span class="line">            table = <span class="keyword">new</span> <span class="title class_">Entry</span>[INITIAL_CAPACITY];</span><br><span class="line">            <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> firstKey.threadLocalHashCode &amp; (INITIAL_CAPACITY - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">            table[i] = <span class="keyword">new</span> <span class="title class_">Entry</span>(firstKey, firstValue);</span><br><span class="line">            size = <span class="number">1</span>;</span><br><span class="line">            setThreshold(INITIAL_CAPACITY);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>每当创建一个<code>ThreadLocal</code>对象，这个<code>ThreadLocal.nextHashCode</code> 这个值就会增长 <code>0x61c88647</code> 。</p>
<p>这个值很特殊，它是<strong>斐波那契数</strong> 也叫 <strong>黄金分割数</strong>。<code>hash</code>增量为 这个数字，带来的好处就是 <code>hash</code> <strong>分布非常均匀</strong>。</p>
<p>我们自己可以尝试下：</p>
<p><img src="/../images/code.png" alt="code"></p>
<h4 id="ThreadLocalMap-Hash冲突"><a href="#ThreadLocalMap-Hash冲突" class="headerlink" title="ThreadLocalMap Hash冲突"></a>ThreadLocalMap Hash冲突</h4><p><strong>注明：</strong> 下面所有示例图中，<strong>绿色块</strong><code>Entry</code>代表<strong>正常数据</strong>，<strong>灰色块</strong>代表<code>Entry</code>的<code>key</code>值为<code>null</code>，<strong>已被垃圾回收</strong>。<strong>白色块</strong>表示<code>Entry</code>为<code>null</code>。</p>
<p>虽然<code>ThreadLocalMap</code>中使用了<strong>黄金分割数</strong>来作为<code>hash</code>计算因子，大大减少了<code>Hash</code>冲突的概率，但是仍然会存在冲突。</p>
<p><code>HashMap</code>中解决冲突的方法是在数组上构造一个<strong>链表</strong>结构，冲突的数据挂载到链表上，如果链表长度超过一定数量则会转化成<strong>红黑树</strong>。</p>
<p>而 <code>ThreadLocalMap</code> 中并没有链表结构，所以这里不能使用 <code>HashMap</code> 解决冲突的方式了。</p>
<p><img src="/../images/note.png" alt="note"></p>
<p>如上图所示，如果我们插入一个<code>value=27</code>的数据，通过 <code>hash</code> 计算后应该落入槽位 4 中，而槽位 4 已经有了 <code>Entry</code> 数据。</p>
<p>此时就会线性向后查找，一直找到 <code>Entry</code> 为 <code>null</code> 的槽位才会停止查找，将当前元素放入此槽位中。当然迭代过程中还有其他的情况，比如遇到了 <code>Entry</code> 不为 <code>null</code> 且 <code>key</code> 值相等的情况，还有 <code>Entry</code> 中的 <code>key</code> 值为 <code>null</code> 的情况等等都会有不同的处理，后面会一一详细讲解。</p>
<p>这里还画了一个<code>Entry</code>中的<code>key</code>为<code>null</code>的数据（<strong>Entry&#x3D;2 的灰色块数据</strong>），因为<code>key</code>值是<strong>弱引用</strong>类型，所以会有这种数据存在。在<code>set</code>过程中，如果遇到了<code>key</code>过期的<code>Entry</code>数据，实际上是会进行一轮<strong>探测式清理</strong>操作的，具体操作方式后面会讲到。</p>
<h4 id="ThreadLocalMap-set-详解"><a href="#ThreadLocalMap-set-详解" class="headerlink" title="ThreadLocalMap.set()详解"></a>ThreadLocalMap.set()详解</h4><h5 id="ThreadLocalMap-set-原理图解"><a href="#ThreadLocalMap-set-原理图解" class="headerlink" title="ThreadLocalMap.set()原理图解"></a>ThreadLocalMap.set()原理图解</h5><p>看完了<code>ThreadLocal</code> <strong>hash 算法</strong>后，我们再来看<code>set</code>是如何实现的。</p>
<p>往<code>ThreadLocalMap</code>中<code>set</code>数据（<strong>新增</strong>或者<strong>更新</strong>数据）分为好几种情况，针对不同的情况我们画图来说明。</p>
<p><strong>第一种情况：</strong> 通过<code>hash</code>计算后的槽位对应的<code>Entry</code>数据为空：</p>
<p><img src="/../images/note0.png" alt="note0"></p>
<p>这里直接将数据放到该槽位即可。</p>
<p><strong>第二种情况：</strong> 槽位数据不为空，<code>key</code>值与当前<code>ThreadLocal</code>通过<code>hash</code>计算获取的<code>key</code>值一致：</p>
<p><img src="/../images/note1.png" alt="note1"></p>
<p>这里直接更新该槽位的数据。</p>
<p><strong>第三种情况：</strong> 槽位数据不为空，往后遍历过程中，在找到<code>Entry</code>为<code>null</code>的槽位之前，没有遇到<code>key</code>过期的<code>Entry</code>：</p>
<p><img src="/../images/note2.png" alt="note2"></p>
<p>遍历散列数组，线性往后查找，如果找到<code>Entry</code>为<code>null</code>的槽位，则将数据放入该槽位中，或者往后遍历过程中，遇到了<strong>key 值相等</strong>的数据，直接更新即可。</p>
<p><strong>第四种情况：</strong> 槽位数据不为空，往后遍历过程中，在找到<code>Entry</code>为<code>null</code>的槽位之前，遇到<code>key</code>过期的<code>Entry</code>，如下图，往后遍历过程中，遇到了<code>index=7</code>的槽位数据<code>Entry</code>的<code>key=null</code>：</p>
<p><img src="/../images/note3.png" alt="note3"></p>
<p>散列数组下标为 7 位置对应的<code>Entry</code>数据<code>key</code>为<code>null</code>，表明此数据<code>key</code>值已经被垃圾回收掉了，此时就会执行<code>replaceStaleEntry()</code>方法，该方法含义是<strong>替换过期数据的逻辑</strong>，以<strong>index&#x3D;7</strong>位起点开始遍历，进行探测式数据清理工作。</p>
<p>初始化探测式清理过期数据扫描的开始位置：<code>slotToExpunge = staleSlot = 7</code></p>
<p>以当前<code>staleSlot</code>开始 向前迭代查找，找其他过期的数据，然后更新过期数据起始扫描下标<code>slotToExpunge</code>。<code>for</code>循环迭代，直到碰到<code>Entry</code>为<code>null</code>结束。</p>
<p>如果找到了过期的数据，继续向前迭代，直到遇到<code>Entry=null</code>的槽位才停止迭代，如下图所示，<strong>slotToExpunge 被更新为 0</strong>：</p>
<p><img src="/../images/note4.png" alt="note4"></p>
<p>以当前节点(<code>index=7</code>)向前迭代，检测是否有过期的<code>Entry</code>数据，如果有则更新<code>slotToExpunge</code>值。碰到<code>null</code>则结束探测。以上图为例<code>slotToExpunge</code>被更新为 0。</p>
<p>上面向前迭代的操作是为了更新探测清理过期数据的起始下标<code>slotToExpunge</code>的值，这个值在后面会讲解，它是用来判断当前过期槽位<code>staleSlot</code>之前是否还有过期元素。</p>
<p>接着开始以<code>staleSlot</code>位置(<code>index=7</code>)向后迭代，<strong>如果找到了相同 key 值的 Entry 数据：</strong></p>
<p><img src="/../images/note5.png" alt="note5"></p>
<p>从当前节点<code>staleSlot</code>向后查找<code>key</code>值相等的<code>Entry</code>元素，找到后更新<code>Entry</code>的值并交换<code>staleSlot</code>元素的位置(<code>staleSlot</code>位置为过期元素)，更新<code>Entry</code>数据，然后开始进行过期<code>Entry</code>的清理工作，如下图所示：</p>
<p><img src="/../images/view.png" alt="view"></p>
<p>向后遍历过程中，如果没有找到相同 key 值的 Entry 数据：</p>
<p><img src="/../images/note6.png" alt="note6"></p>
<p>从当前节点<code>staleSlot</code>向后查找<code>key</code>值相等的<code>Entry</code>元素，直到<code>Entry</code>为<code>null</code>则停止寻找。通过上图可知，此时<code>table</code>中没有<code>key</code>值相同的<code>Entry</code>。</p>
<p>创建新的<code>Entry</code>，替换<code>table[stableSlot]</code>位置：</p>
<p><img src="/../images/note7.png" alt="note7"></p>
<p>替换完成后也是进行过期元素清理工作，清理工作主要是有两个方法：<code>expungeStaleEntry()</code>和<code>cleanSomeSlots()</code>，具体细节后面会讲到，请继续往后看。</p>
<h5 id="ThreadLocalMap-set-源码详解"><a href="#ThreadLocalMap-set-源码详解" class="headerlink" title="ThreadLocalMap.set()源码详解"></a>ThreadLocalMap.set()源码详解</h5><p>上面已经用图的方式解析了<code>set()</code>实现的原理，其实已经很清晰了，我们接着再看下源码：</p>
<p><code>java.lang.ThreadLocal</code>.<code>ThreadLocalMap.set()</code>:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(ThreadLocal&lt;?&gt; key, Object value)</span> &#123;</span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> tab.length;</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> key.threadLocalHashCode &amp; (len-<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">Entry</span> <span class="variable">e</span> <span class="operator">=</span> tab[i];</span><br><span class="line">         e != <span class="literal">null</span>;</span><br><span class="line">         e = tab[i = nextIndex(i, len)]) &#123;</span><br><span class="line">        ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (k == key) &#123;</span><br><span class="line">            e.value = value;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (k == <span class="literal">null</span>) &#123;</span><br><span class="line">            replaceStaleEntry(key, value, i);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    tab[i] = <span class="keyword">new</span> <span class="title class_">Entry</span>(key, value);</span><br><span class="line">    <span class="type">int</span> <span class="variable">sz</span> <span class="operator">=</span> ++size;</span><br><span class="line">    <span class="keyword">if</span> (!cleanSomeSlots(i, sz) &amp;&amp; sz &gt;= threshold)</span><br><span class="line">        rehash();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里会通过<code>key</code>来计算在散列表中的对应位置，然后以当前<code>key</code>对应的桶的位置向后查找，找到可以使用的桶。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Entry[] tab = table;</span><br><span class="line"><span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> tab.length;</span><br><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> key.threadLocalHashCode &amp; (len-<span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<p>什么情况下桶才是可以使用的呢？</p>
<ol>
<li><code>k = key</code> 说明是替换操作，可以使用</li>
<li>碰到一个过期的桶，执行替换逻辑，占用过期桶</li>
<li>查找过程中，碰到桶中<code>Entry=null</code>的情况，直接使用</li>
</ol>
<p>接着就是执行<code>for</code>循环遍历，向后查找，我们先看下<code>nextIndex()</code>、<code>prevIndex()</code>方法实现：</p>
<p><img src="/../images/note8.png" alt="note8"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">nextIndex</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> len)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> ((i + <span class="number">1</span> &lt; len) ? i + <span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">prevIndex</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> len)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> ((i - <span class="number">1</span> &gt;= <span class="number">0</span>) ? i - <span class="number">1</span> : len - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接着看剩下<code>for</code>循环中的逻辑：</p>
<ol>
<li>遍历当前<code>key</code>值对应的桶中<code>Entry</code>数据为空，这说明散列数组这里没有数据冲突，跳出<code>for</code>循环，直接<code>set</code>数据到对应的桶中</li>
<li>如果<code>key</code>值对应的桶中<code>Entry</code>数据不为空<br>2.1 如果<code>k = key</code>，说明当前<code>set</code>操作是一个替换操作，做替换逻辑，直接返回<br>2.2 如果<code>key = null</code>，说明当前桶位置的<code>Entry</code>是过期数据，执行<code>replaceStaleEntry()</code>方法(核心方法)，然后返回</li>
<li><code>for</code>循环执行完毕，继续往下执行说明向后迭代的过程中遇到了<code>entry</code>为<code>null</code>的情况<br>3.1 在<code>Entry</code>为<code>null</code>的桶中创建一个新的<code>Entry</code>对象<br>3.2 执行<code>++size</code>操作</li>
<li>调用<code>cleanSomeSlots()</code>做一次启发式清理工作，清理散列数组中<code>Entry</code>的<code>key</code>过期的数据<br>4.1 如果清理工作完成后，未清理到任何数据，且<code>size</code>超过了阈值(数组长度的 2&#x2F;3)，进行<code>rehash()</code>操作<br>4.2 <code>rehash()</code>中会先进行一轮探测式清理，清理过期<code>key</code>，清理完成后如果<strong>size &gt;&#x3D; threshold - threshold &#x2F; 4</strong>，就会执行真正的扩容逻辑(扩容逻辑往后看)</li>
</ol>
<p>接着重点看下<code>replaceStaleEntry()</code>方法，<code>replaceStaleEntry()</code>方法提供替换过期数据的功能，我们可以对应上面<strong>第四种情况</strong>的原理图来再回顾下，具体代码如下：</p>
<p><code>java.lang.ThreadLocal.ThreadLocalMap.replaceStaleEntry()</code>:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">replaceStaleEntry</span><span class="params">(ThreadLocal&lt;?&gt; key, Object value,</span></span><br><span class="line"><span class="params">                                       <span class="type">int</span> staleSlot)</span> &#123;</span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> tab.length;</span><br><span class="line">    Entry e;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">slotToExpunge</span> <span class="operator">=</span> staleSlot;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> prevIndex(staleSlot, len);</span><br><span class="line">         (e = tab[i]) != <span class="literal">null</span>;</span><br><span class="line">         i = prevIndex(i, len))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (e.get() == <span class="literal">null</span>)</span><br><span class="line">            slotToExpunge = i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> nextIndex(staleSlot, len);</span><br><span class="line">         (e = tab[i]) != <span class="literal">null</span>;</span><br><span class="line">         i = nextIndex(i, len)) &#123;</span><br><span class="line"></span><br><span class="line">        ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (k == key) &#123;</span><br><span class="line">            e.value = value;</span><br><span class="line"></span><br><span class="line">            tab[i] = tab[staleSlot];</span><br><span class="line">            tab[staleSlot] = e;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (slotToExpunge == staleSlot)</span><br><span class="line">                slotToExpunge = i;</span><br><span class="line">            cleanSomeSlots(expungeStaleEntry(slotToExpunge), len);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (k == <span class="literal">null</span> &amp;&amp; slotToExpunge == staleSlot)</span><br><span class="line">            slotToExpunge = i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    tab[staleSlot].value = <span class="literal">null</span>;</span><br><span class="line">    tab[staleSlot] = <span class="keyword">new</span> <span class="title class_">Entry</span>(key, value);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (slotToExpunge != staleSlot)</span><br><span class="line">        cleanSomeSlots(expungeStaleEntry(slotToExpunge), len);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>slotToExpunge</code>表示开始探测式清理过期数据的开始下标，默认从当前的<code>staleSlot</code>开始。以当前的<code>staleSlot</code>开始，向前迭代查找，找到没有过期的数据，<code>for</code>循环一直碰到<code>Entry</code>为<code>null</code>才会结束。如果向前找到了过期数据，更新探测清理过期数据的开始下标为 i，即<code>slotToExpunge=i</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> prevIndex(staleSlot, len);</span><br><span class="line">     (e = tab[i]) != <span class="literal">null</span>;</span><br><span class="line">     i = prevIndex(i, len))&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (e.get() == <span class="literal">null</span>)&#123;</span><br><span class="line">        slotToExpunge = i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接着开始从<code>staleSlot</code>向后查找，也是碰到<code>Entry</code>为<code>null</code>的桶结束。 如果迭代过程中，<strong>碰到 k &#x3D;&#x3D; key</strong>，这说明这里是替换逻辑，替换新数据并且交换当前<code>staleSlot</code>位置。如果<code>slotToExpunge == staleSlot</code>，这说明<code>replaceStaleEntry()</code>一开始向前查找过期数据时并未找到过期的<code>Entry</code>数据，接着向后查找过程中也未发现过期数据，修改开始探测式清理过期数据的下标为当前循环的 index，即<code>slotToExpunge = i</code>。最后调用<code>cleanSomeSlots(expungeStaleEntry(slotToExpunge), len);</code>进行启发式过期数据清理。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (k == key) &#123;</span><br><span class="line">    e.value = value;</span><br><span class="line"></span><br><span class="line">    tab[i] = tab[staleSlot];</span><br><span class="line">    tab[staleSlot] = e;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (slotToExpunge == staleSlot)</span><br><span class="line">        slotToExpunge = i;</span><br><span class="line"></span><br><span class="line">    cleanSomeSlots(expungeStaleEntry(slotToExpunge), len);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>cleanSomeSlots()</code>和<code>expungeStaleEntry()</code>方法后面都会细讲，这两个是和清理相关的方法，一个是过期<code>key</code>相关<code>Entry</code>的启发式清理(<code>Heuristically scan</code>)，另一个是过期<code>key</code>相关<code>Entry</code>的探测式清理。</p>
<p><strong>如果 k !&#x3D; key</strong>则会接着往下走，<code>k == null</code>说明当前遍历的<code>Entry</code>是一个过期数据，<code>slotToExpunge == staleSlot</code>说明，一开始的向前查找数据并未找到过期的<code>Entry</code>。如果条件成立，则更新<code>slotToExpunge</code> 为当前位置，这个前提是前驱节点扫描时未发现过期数据。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (k == <span class="literal">null</span> &amp;&amp; slotToExpunge == staleSlot)</span><br><span class="line">    slotToExpunge = i;</span><br></pre></td></tr></table></figure>

<p>往后迭代的过程中如果没有找到<code>k == key</code>的数据，且碰到<code>Entry</code>为<code>null</code>的数据，则结束当前的迭代操作。此时说明这里是一个添加的逻辑，将新的数据添加到<code>table[staleSlot]</code> 对应的<code>slot</code>中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">tab[staleSlot].value = <span class="literal">null</span>;</span><br><span class="line">tab[staleSlot] = <span class="keyword">new</span> <span class="title class_">Entry</span>(key, value);</span><br></pre></td></tr></table></figure>

<p>最后判断除了<code>staleSlot</code>以外，还发现了其他过期的<code>slot</code>数据，就要开启清理数据的逻辑：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (slotToExpunge != staleSlot)</span><br><span class="line">    cleanSomeSlots(expungeStaleEntry(slotToExpunge), len);</span><br></pre></td></tr></table></figure>

<h4 id="ThreadLocalMap过期key的探测式清理流程"><a href="#ThreadLocalMap过期key的探测式清理流程" class="headerlink" title="ThreadLocalMap过期key的探测式清理流程"></a>ThreadLocalMap过期key的探测式清理流程</h4><p>上面我们有提及<code>ThreadLocalMap</code>的两种过期<code>key</code>数据清理方式：<strong>探测式清理</strong>和<strong>启发式清理</strong>。</p>
<p>我们先讲下探测式清理，也就是<code>expungeStaleEntry</code>方法，遍历散列数组，从开始位置向后探测清理过期数据，将过期数据的<code>Entry</code>设置为<code>null</code>，沿途中碰到未过期的数据则将此数据<code>rehash</code>后重新在<code>table</code>数组中定位，如果定位的位置已经有了数据，则会将未过期的数据放到最靠近此位置的<code>Entry=null</code>的桶中，使<code>rehash</code>后的<code>Entry</code>数据距离正确的桶的位置更近一些。操作逻辑如下：</p>
<p><img src="/../images/note9.png" alt="note9"></p>
<p>如上图，<code>set(27)</code> 经过 hash 计算后应该落到<code>index=4</code>的桶中，由于<code>index=4</code>桶已经有了数据，所以往后迭代最终数据放入到<code>index=7</code>的桶中，放入后一段时间后<code>index=5</code>中的<code>Entry</code>数据<code>key</code>变为了<code>null</code></p>
<p><img src="/../images/note10.png" alt="note10"></p>
<p>如果再有其他数据<code>set</code>到<code>map</code>中，就会触发<strong>探测式清理</strong>操作。</p>
<p>如上图，执行<strong>探测式清理</strong>后，<code>index=5</code>的数据被清理掉，继续往后迭代，到<code>index=7</code>的元素时，经过<code>rehash</code>后发现该元素正确的<code>index=4</code>，而此位置已经有了数据，往后查找离<code>index=4</code>最近的<code>Entry=null</code>的节点(刚被探测式清理掉的数据：<code>index=5</code>)，找到后移动<code>index= 7</code>的数据到<code>index=5</code>中，此时桶的位置离正确的位置<code>index=4</code>更近了。</p>
<p>经过一轮探测式清理后，<code>key</code>过期的数据会被清理掉，没过期的数据经过<code>rehash</code>重定位后所处的桶位置理论上更接近<code>i= key.hashCode &amp; (tab.len - 1)</code>的位置。这种优化会提高整个散列表查询性能。</p>
<p>接着看下<code>expungeStaleEntry()</code>具体流程，我们还是以先原理图后源码讲解的方式来一步步梳理：</p>
<p><img src="/../images/note11.png" alt="note11"></p>
<p>我们假设<code>expungeStaleEntry(3)</code> 来调用此方法，如上图所示，我们可以看到<code>ThreadLocalMap</code>中<code>table</code>的数据情况，接着执行清理操作：</p>
<p><img src="/../images/note12.png" alt="note12"></p>
<p>第一步是清空当前<code>staleSlot</code>位置的数据，<code>index=3</code>位置的<code>Entry</code>变成了<code>null</code>。然后接着往后探测：</p>
<p><img src="/../images/noe13.png" alt="noe"></p>
<p>执行完第二步后，index&#x3D;4 的元素挪到 index&#x3D;3 的槽位中。</p>
<p>继续往后迭代检查，碰到正常数据，计算该数据位置是否偏移，如果被偏移，则重新计算<code>slot</code>位置，目的是让正常数据尽可能存放在正确位置或离正确位置更近的位置</p>
<p><img src="/../images/note13.png" alt="note13"></p>
<p>在往后迭代的过程中碰到空的槽位，终止探测，这样一轮探测式清理工作就完成了，接着我们继续看看具体<strong>实现源代码</strong>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">expungeStaleEntry</span><span class="params">(<span class="type">int</span> staleSlot)</span> &#123;</span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> tab.length;</span><br><span class="line"></span><br><span class="line">    tab[staleSlot].value = <span class="literal">null</span>;</span><br><span class="line">    tab[staleSlot] = <span class="literal">null</span>;</span><br><span class="line">    size--;</span><br><span class="line"></span><br><span class="line">    Entry e;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = nextIndex(staleSlot, len);</span><br><span class="line">         (e = tab[i]) != <span class="literal">null</span>;</span><br><span class="line">         i = nextIndex(i, len)) &#123;</span><br><span class="line">        ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line">        <span class="keyword">if</span> (k == <span class="literal">null</span>) &#123;</span><br><span class="line">            e.value = <span class="literal">null</span>;</span><br><span class="line">            tab[i] = <span class="literal">null</span>;</span><br><span class="line">            size--;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">h</span> <span class="operator">=</span> k.threadLocalHashCode &amp; (len - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (h != i) &#123;</span><br><span class="line">                tab[i] = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">while</span> (tab[h] != <span class="literal">null</span>)</span><br><span class="line">                    h = nextIndex(h, len);</span><br><span class="line">                tab[h] = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里我们还是以<code>staleSlot=3</code> 来做示例说明，首先是将<code>tab[staleSlot]</code>槽位的数据清空，然后设置<code>size--</code> 接着以<code>staleSlot</code>位置往后迭代，如果遇到<code>k==null</code>的过期数据，也是清空该槽位数据，然后<code>size--</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (k == <span class="literal">null</span>) &#123;</span><br><span class="line">    e.value = <span class="literal">null</span>;</span><br><span class="line">    tab[i] = <span class="literal">null</span>;</span><br><span class="line">    size--;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果<code>key</code>没有过期，重新计算当前<code>key</code>的下标位置是不是当前槽位下标位置，如果不是，那么说明产生了<code>hash</code>冲突，此时以新计算出来正确的槽位位置往后迭代，找到最近一个可以存放<code>entry</code>的位置。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">h</span> <span class="operator">=</span> k.threadLocalHashCode &amp; (len - <span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span> (h != i) &#123;</span><br><span class="line">    tab[i] = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (tab[h] != <span class="literal">null</span>)</span><br><span class="line">        h = nextIndex(h, len);</span><br><span class="line"></span><br><span class="line">    tab[h] = e;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里是处理正常的产生<code>Hash</code>冲突的数据，经过迭代后，有过<code>Hash</code>冲突数据的<code>Entry</code>位置会更靠近正确位置，这样的话，查询的时候 效率才会更高。</p>
<h4 id="ThreadLocalMap扩容机制"><a href="#ThreadLocalMap扩容机制" class="headerlink" title="ThreadLocalMap扩容机制"></a>ThreadLocalMap扩容机制</h4><p>在<code>ThreadLocalMap.set()</code>方法的最后，如果执行完启发式清理工作后，未清理到任何数据，且当前散列数组中<code>Entry</code>的数量已经达到了列表的扩容阈值<code>(len*2/3)</code>，就开始执行<code>rehash()</code>逻辑：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (!cleanSomeSlots(i, sz) &amp;&amp; sz &gt;= threshold)</span><br><span class="line">    rehash();</span><br></pre></td></tr></table></figure>

<p>接着看下<code>rehash()</code>具体实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">rehash</span><span class="params">()</span> &#123;</span><br><span class="line">    expungeStaleEntries();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (size &gt;= threshold - threshold / <span class="number">4</span>)</span><br><span class="line">        resize();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">expungeStaleEntries</span><span class="params">()</span> &#123;</span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> tab.length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; len; j++) &#123;</span><br><span class="line">        <span class="type">Entry</span> <span class="variable">e</span> <span class="operator">=</span> tab[j];</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="literal">null</span> &amp;&amp; e.get() == <span class="literal">null</span>)</span><br><span class="line">            expungeStaleEntry(j);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里首先是会进行探测式清理工作，从<code>table</code>的起始位置往后清理，上面有分析清理的详细流程。清理完成之后，<code>table</code>中可能有一些<code>key</code>为<code>null</code>的<code>Entry</code>数据被清理掉，所以此时通过判断<code>size &gt;= threshold - threshold / 4</code> 也就是<code>size &gt;= threshold * 3/4</code> 来决定是否扩容。</p>
<p>我们还记得上面进行<code>rehash()</code>的阈值是<code>size &gt;= threshold</code>，所以当面试官套路我们<code>ThreadLocalMap</code>扩容机制的时候 我们一定要说清楚这两个步骤：</p>
<p><img src="/../images/note14.png" alt="note14"></p>
<p>接着看看具体的<code>resize()</code>方法，为了方便演示，我们以<code>oldTab.len=8</code>来举例：</p>
<p><img src="/../images/note15.png" alt="note15"></p>
<p>扩容后的<code>tab</code>的大小为<code>oldLen * 2</code>，然后遍历老的散列表，重新计算<code>hash</code>位置，然后放到新的<code>tab</code>数组中，如果出现<code>hash</code>冲突则往后寻找最近的<code>entry</code>为<code>null</code>的槽位，遍历完成之后，<code>oldTab</code>中所有的<code>entry</code>数据都已经放入到新的<code>tab</code>中了。重新计算<code>tab</code>下次扩容的<strong>阈值</strong>，具体代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">resize</span><span class="params">()</span> &#123;</span><br><span class="line">    Entry[] oldTab = table;</span><br><span class="line">    <span class="type">int</span> <span class="variable">oldLen</span> <span class="operator">=</span> oldTab.length;</span><br><span class="line">    <span class="type">int</span> <span class="variable">newLen</span> <span class="operator">=</span> oldLen * <span class="number">2</span>;</span><br><span class="line">    Entry[] newTab = <span class="keyword">new</span> <span class="title class_">Entry</span>[newLen];</span><br><span class="line">    <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; oldLen; ++j) &#123;</span><br><span class="line">        <span class="type">Entry</span> <span class="variable">e</span> <span class="operator">=</span> oldTab[j];</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="literal">null</span>) &#123;</span><br><span class="line">            ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line">            <span class="keyword">if</span> (k == <span class="literal">null</span>) &#123;</span><br><span class="line">                e.value = <span class="literal">null</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">h</span> <span class="operator">=</span> k.threadLocalHashCode &amp; (newLen - <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">while</span> (newTab[h] != <span class="literal">null</span>)</span><br><span class="line">                    h = nextIndex(h, newLen);</span><br><span class="line">                newTab[h] = e;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    setThreshold(newLen);</span><br><span class="line">    size = count;</span><br><span class="line">    table = newTab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="ThreadLocalMap-get-详解"><a href="#ThreadLocalMap-get-详解" class="headerlink" title="ThreadLocalMap.get()详解"></a>ThreadLocalMap.get()详解</h4><p>上面已经看完了<code>set()</code>方法的源码，其中包括<code>set</code>数据、清理数据、优化数据桶的位置等操作，接着看看<code>get()</code>操作的原理。</p>
<h5 id="ThreadLocalMap-get-图解"><a href="#ThreadLocalMap-get-图解" class="headerlink" title="ThreadLocalMap.get()图解"></a>ThreadLocalMap.get()图解</h5><p><strong>第一种情况：</strong> 通过查找<code>key</code>值计算出散列表中<code>slot</code>位置，然后该<code>slot</code>位置中的<code>Entry.key</code>和查找的<code>key</code>一致，则直接返回：</p>
<p><img src="/../images/note16.png" alt="note16"></p>
<p><strong>第二种情况：</strong> <code>slot</code>位置中的<code>Entry.key</code>和要查找的<code>key</code>不一致：</p>
<p><img src="/../images/note17.png" alt="note17"></p>
<p>我们以<code>get(ThreadLocal1)</code>为例，通过<code>hash</code>计算后，正确的<code>slot</code>位置应该是 4，而<code>index=4</code>的槽位已经有了数据，且<code>key</code>值不等于<code>ThreadLocal1</code>，所以需要继续往后迭代查找。</p>
<p>迭代到<code>index=5</code>的数据时，此时<code>Entry.key=null</code>，触发一次探测式数据回收操作，执行<code>expungeStaleEntry()</code>方法，执行完后，<code>index 5,8</code>的数据都会被回收，而<code>index 6,7</code>的数据都会前移，此时继续往后迭代，到<code>index = 6</code>的时候即找到了<code>key</code>值相等的<code>Entry</code>数据，如下图所示：</p>
<p><img src="/../images/note18.png" alt="note18"></p>
<h5 id="ThreadLocalMap-get-源码详解"><a href="#ThreadLocalMap-get-源码详解" class="headerlink" title="ThreadLocalMap.get()源码详解"></a>ThreadLocalMap.get()源码详解</h5><p><code>java.lang.ThreadLocal.ThreadLocalMap.getEntry()</code>:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> Entry <span class="title function_">getEntry</span><span class="params">(ThreadLocal&lt;?&gt; key)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> key.threadLocalHashCode &amp; (table.length - <span class="number">1</span>);</span><br><span class="line">    <span class="type">Entry</span> <span class="variable">e</span> <span class="operator">=</span> table[i];</span><br><span class="line">    <span class="keyword">if</span> (e != <span class="literal">null</span> &amp;&amp; e.get() == key)</span><br><span class="line">        <span class="keyword">return</span> e;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> getEntryAfterMiss(key, i, e);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Entry <span class="title function_">getEntryAfterMiss</span><span class="params">(ThreadLocal&lt;?&gt; key, <span class="type">int</span> i, Entry e)</span> &#123;</span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> tab.length;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (e != <span class="literal">null</span>) &#123;</span><br><span class="line">        ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line">        <span class="keyword">if</span> (k == key)</span><br><span class="line">            <span class="keyword">return</span> e;</span><br><span class="line">        <span class="keyword">if</span> (k == <span class="literal">null</span>)</span><br><span class="line">            expungeStaleEntry(i);</span><br><span class="line">        <span class="type">else</span></span><br><span class="line">            <span class="variable">i</span> <span class="operator">=</span> nextIndex(i, len);</span><br><span class="line">        e = tab[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="ThreadLocalMap过期key的启发式清理流程"><a href="#ThreadLocalMap过期key的启发式清理流程" class="headerlink" title="ThreadLocalMap过期key的启发式清理流程"></a>ThreadLocalMap过期key的启发式清理流程</h4><p>上面多次提及到<code>ThreadLocalMap</code>过期key的两种清理方式：<em>*探测式清理(expungeStaleEntry())**、**启发式清理(cleanSomeSlots())</em>*</p>
<p>探测式清理是以当前<code>Entry</code> 往后清理，遇到值为<code>null</code>则结束清理，属于<strong>线性探测清理</strong>。</p>
<p>而启发式清理被作者定义为：<strong>Heuristically scan some cells looking for stale entries</strong>.</p>
<p><img src="/../images/note19.png" alt="note19"></p>
<p>具体代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">cleanSomeSlots</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">removed</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> tab.length;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        i = nextIndex(i, len);</span><br><span class="line">        <span class="type">Entry</span> <span class="variable">e</span> <span class="operator">=</span> tab[i];</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="literal">null</span> &amp;&amp; e.get() == <span class="literal">null</span>) &#123;</span><br><span class="line">            n = len;</span><br><span class="line">            removed = <span class="literal">true</span>;</span><br><span class="line">            i = expungeStaleEntry(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span> ( (n &gt;&gt;&gt;= <span class="number">1</span>) != <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> removed;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="InheritableThreadLocal"><a href="#InheritableThreadLocal" class="headerlink" title="InheritableThreadLocal"></a>InheritableThreadLocal</h4><p>我们使用<code>ThreadLocal</code>的时候，在异步场景下是无法给子线程共享父线程中创建的线程副本数据的。</p>
<p>为了解决这个问题，JDK 中还有一个<code>InheritableThreadLocal</code>类，我们来看一个例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InheritableThreadLocalDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        ThreadLocal&lt;String&gt; ThreadLocal = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;&gt;();</span><br><span class="line">        ThreadLocal&lt;String&gt; inheritableThreadLocal = <span class="keyword">new</span> <span class="title class_">InheritableThreadLocal</span>&lt;&gt;();</span><br><span class="line">        ThreadLocal.set(<span class="string">&quot;父类数据:threadLocal&quot;</span>);</span><br><span class="line">        inheritableThreadLocal.set(<span class="string">&quot;父类数据:inheritableThreadLocal&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;子线程获取父类ThreadLocal数据：&quot;</span> + ThreadLocal.get());</span><br><span class="line">                System.out.println(<span class="string">&quot;子线程获取父类inheritableThreadLocal数据：&quot;</span> + inheritableThreadLocal.get());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>打印结果：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">子线程获取父类ThreadLocal数据：<span class="literal">null</span></span><br><span class="line">子线程获取父类inheritableThreadLocal数据：父类数据:inheritableThreadLocal</span><br></pre></td></tr></table></figure>

<p>实现原理是子线程是通过在父线程中通过调用<code>new Thread()</code>方法来创建子线程，<code>Thread#init</code>方法在<code>Thread</code>的构造方法中被调用。在<code>init</code>方法中拷贝父线程数据到子线程中：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">(ThreadGroup g, Runnable target, String name,</span></span><br><span class="line"><span class="params">                      <span class="type">long</span> stackSize, AccessControlContext acc,</span></span><br><span class="line"><span class="params">                      <span class="type">boolean</span> inheritThreadLocals)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (name == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>(<span class="string">&quot;name cannot be null&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (inheritThreadLocals &amp;&amp; parent.inheritableThreadLocals != <span class="literal">null</span>)</span><br><span class="line">        <span class="built_in">this</span>.inheritableThreadLocals =</span><br><span class="line">            ThreadLocal.createInheritedMap(parent.inheritableThreadLocals);</span><br><span class="line">    <span class="built_in">this</span>.stackSize = stackSize;</span><br><span class="line">    tid = nextThreadID();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但<code>InheritableThreadLocal</code>仍然有缺陷，一般我们做异步化处理都是使用的线程池，而<code>InheritableThreadLocal</code>是在<code>new Thread</code>中的<code>init()</code>方法给赋值的，而线程池是线程复用的逻辑，所以这里会存在问题。</p>
<h4 id="ThreadLocal项目中使用实战"><a href="#ThreadLocal项目中使用实战" class="headerlink" title="ThreadLocal项目中使用实战"></a>ThreadLocal项目中使用实战</h4><h5 id="Thread使用场景"><a href="#Thread使用场景" class="headerlink" title="Thread使用场景"></a>Thread使用场景</h5><p>我们现在项目中日志记录用的是<code>ELK+Logstash</code>，最后在<code>Kibana</code>中进行展示和检索。</p>
<p>现在都是分布式系统统一对外提供服务，项目间调用的关系可以通过 <code>traceId</code> 来关联，但是不同项目之间如何传递 <code>traceId</code> 呢？</p>
<p>这里我们使用 <code>org.slf4j.MDC</code> 来实现此功能，内部就是通过 <code>ThreadLocal</code> 来实现的，具体实现如下：</p>
<p>当前端发送请求到<strong>服务 A</strong>时，<strong>服务 A</strong>会生成一个类似<code>UUID</code>的<code>traceId</code>字符串，将此字符串放入当前线程的<code>ThreadLocal</code>中，在调用<strong>服务 B</strong>的时候，将<code>traceId</code>写入到请求的<code>Header</code>中，<strong>服务 B</strong>在接收请求时会先判断请求的<code>Header</code>中是否有<code>traceId</code>，如果存在则写入自己线程的<code>ThreadLocal</code>中。</p>
<p><img src="/../images/note20.png" alt="note20"></p>
<p>图中的<code>requestId</code>即为我们各个系统链路关联的<code>traceId</code>，系统间互相调用，通过这个<code>requestId</code>即可找到对应链路，这里还有会有一些其他场景：</p>
<p><img src="/../images/note21.png" alt="note21"></p>
<p>针对于这些场景，我们都可以有相应的解决方案，如下所示</p>
<h5 id="Feign远程调用解决方案"><a href="#Feign远程调用解决方案" class="headerlink" title="Feign远程调用解决方案"></a>Feign远程调用解决方案</h5><p><strong>服务发送请求：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FeignInvokeInterceptor</span> <span class="keyword">implements</span> <span class="title class_">RequestInterceptor</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">apply</span><span class="params">(RequestTemplate template)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">requestId</span> <span class="operator">=</span> MDC.get(<span class="string">&quot;requestId&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (StringUtils.isNotBlank(requestId)) &#123;</span><br><span class="line">            template.header(<span class="string">&quot;requestId&quot;</span>, requestId);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>服务接收请求：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LogInterceptor</span> <span class="keyword">extends</span> <span class="title class_">HandlerInterceptorAdapter</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterCompletion</span><span class="params">(HttpServletRequest arg0, HttpServletResponse arg1, Object arg2, Exception arg3)</span> &#123;</span><br><span class="line">        MDC.remove(<span class="string">&quot;requestId&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postHandle</span><span class="params">(HttpServletRequest arg0, HttpServletResponse arg1, Object arg2, ModelAndView arg3)</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">requestId</span> <span class="operator">=</span> request.getHeader(BaseConstant.REQUEST_ID_KEY);</span><br><span class="line">        <span class="keyword">if</span> (StringUtils.isBlank(requestId)) &#123;</span><br><span class="line">            requestId = UUID.randomUUID().toString().replace(<span class="string">&quot;-&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        MDC.put(<span class="string">&quot;requestId&quot;</span>, requestId);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="线程池异步调用，requestId传递"><a href="#线程池异步调用，requestId传递" class="headerlink" title="线程池异步调用，requestId传递"></a>线程池异步调用，requestId传递</h5><p>因为<code>MDC</code>是基于<code>ThreadLocal</code>去实现的，异步过程中，子线程并没有办法获取到父线程<code>ThreadLocal</code>存储的数据，所以这里可以自定义线程池执行器，修改其中的<code>run()</code>方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyThreadPoolTaskExecutor</span> <span class="keyword">extends</span> <span class="title class_">ThreadPoolTaskExecutor</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">(Runnable runnable)</span> &#123;</span><br><span class="line">        Map&lt;String, String&gt; context = MDC.getCopyOfContextMap();</span><br><span class="line">        <span class="built_in">super</span>.execute(() -&gt; run(runnable, context));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">(Runnable runnable, Map&lt;String, String&gt; context)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (context != <span class="literal">null</span>) &#123;</span><br><span class="line">            MDC.setContextMap(context);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            runnable.run();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            MDC.remove();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="使用MQ发送消息给第三方系统"><a href="#使用MQ发送消息给第三方系统" class="headerlink" title="使用MQ发送消息给第三方系统"></a>使用MQ发送消息给第三方系统</h5><p>在 MQ 发送的消息体中自定义属性<code>requestId</code>，接收方消费消息后，自己解析<code>requestId</code>使用即可。                                            </p>
]]></content>
      <categories>
        <category>ThreadLocal</category>
      </categories>
  </entry>
  <entry>
    <title>计算机网络 - 计算机网络</title>
    <url>/2022/05/24/2022-05-24-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/</url>
    <content><![CDATA[<h1 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h1><span id="more"></span>

<h4 id="TCP-x2F-IP模型"><a href="#TCP-x2F-IP模型" class="headerlink" title="TCP&#x2F;IP模型"></a>TCP&#x2F;IP模型</h4><p>TCP&#x2F;IP协议模型（Transmission Control Protocol&#x2F;Internet Protocol），包含了一系列构成互联网基础的网络协议，是Internet的核心协议。</p>
<p>OSI分层 （7层）：物理层、数据链路层、网络层、传输层、会话层、表示层、应用层。（物链网输会示用）</p>
<p>TCP&#x2F;IP分层（4层）：网络接口层、 网际层、运输层、 应用层。（接网输用）</p>
<p>五层协议 （5层）：物理层、数据链路层、网络层、运输层、 应用层。（物链网输用）</p>
<p><img src="/../images/note26.png" alt="note26"></p>
<p>每一层的作用如下：</p>
<ul>
<li>物理层：通过媒介传输比特,确定机械及电气规范（比特Bit）</li>
<li>数据链路层：将比特组装成帧和点到点的传递（帧Frame）</li>
<li>网络层：负责数据包从源到宿的传递和网际互连（包PackeT）</li>
<li>传输层：提供端到端的可靠报文传递和错误恢复（段Segment）</li>
<li>会话层：建立、管理和终止会话（会话协议数据单元SPDU）</li>
<li>表示层：对数据进行翻译、加密和压缩（表示协议数据单元PPDU）</li>
<li>应用层：允许访问OSI环境的手段（应用协议数据单元APDU）</li>
</ul>
<p>基于TCP&#x2F;IP的参考模型将协议分成四个层次，它们分别是链路层、网络层、传输层和应用层。下图表示TCP&#x2F;IP模型与OSI模型各层的对照关系。</p>
<p><img src="/../images/1.jpg" alt="1"></p>
<p>TCP&#x2F;IP协议族按照层次由上到下，层层包装。最上面的是应用层，这里面有http，ftp,等等我们熟悉的协议。而第二层则是传输层，著名的TCP和UDP协议就在这个层次。第三层是网络层，IP协议就在这里，它负责对数据加上IP地址和其他的数据以确定传输的目标。第四层是数据链路层，这个层次为待传送的数据加入一个以太网协议头，并进行CRC编码，为最后的数据传输做准备。</p>
<p><img src="/../images/2.jpg" alt="2"></p>
<p>上图清楚地表示了TCP&#x2F;IP协议中每个层的作用，而TCP&#x2F;IP协议通信的过程其实就对应着数据入栈与出栈的过程。入栈的过程，数据发送方每层不断地封装首部与尾部，添加一些传输的信息，确保能传输到目的地。出栈的过程，数据接收方每层不断地拆除首部与尾部，得到最终传输的数据。</p>
<p><img src="/../images/note22.png" alt="note22"></p>
<h4 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h4><p>物理层负责0、1比特流与物理设备电压高低、光的闪灭之间的互换。 数据链路层负责将0、1序列划分为数据帧从一个节点传输到临近的另一个节点,这些节点是通过MAC来唯一标识的(MAC,物理地址，一个主机会有一个MAC地址)。</p>
<p><img src="/../images/note23.png" alt="note23"></p>
<ul>
<li>封装成帧: 把网络层数据报加头和尾，封装成帧,帧头中包括源MAC地址和目的MAC地址。</li>
<li>透明传输:零比特填充、转义字符。</li>
<li>可靠传输: 在出错率很低的链路上很少用，但是无线链路WLAN会保证可靠传输。</li>
<li>差错检测(CRC):接收者检测错误,如果发现差错，丢弃该帧。</li>
</ul>
<h4 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h4><h5 id="IP协议"><a href="#IP协议" class="headerlink" title="IP协议"></a>IP协议</h5><p>IP协议是TCP&#x2F;IP协议的核心，所有的TCP，UDP，IMCP，IGMP的数据都以IP数据格式传输。要注意的是，IP不是可靠的协议，这是说，IP协议没有提供一种数据未传达以后的处理机制，这被认为是上层协议：TCP或UDP要做的事情。</p>
<p><strong>IP地址</strong></p>
<p>在数据链路层中我们一般通过MAC地址来识别不同的节点，而在IP层我们也要有一个类似的地址标识，这就是IP地址。</p>
<p>32位IP地址分为网络位和地址位，这样做可以减少路由器中路由表记录的数目，有了网络地址，就可以限定拥有相同网络地址的终端都在同一个范围内，那么路由表只需要维护一条这个网络地址的方向，就可以找到相应的这些终端了。</p>
<ul>
<li>A类IP地址: 0.0.0.0~127.255.255.255  </li>
<li>B类IP地址:128.0.0.0~191.255.255.255</li>
<li>C类IP地址:192.0.0.0~239.255.255.255</li>
</ul>
<p><strong>IP协议头</strong></p>
<p><img src="/../images/3.jpg" alt="3"></p>
<p>这里只介绍:八位的TTL字段。这个字段规定该数据包在穿过多少个路由之后才会被抛弃。某个IP数据包每穿过一个路由器，该数据包的TTL数值就会减少1，当该数据包的TTL成为零，它就会被自动抛弃。<br>这个字段的最大值也就是255，也就是说一个协议包也就在路由器里面穿行255次就会被抛弃了，根据系统的不同，这个数字也不一样，一般是32或者是64。</p>
<h5 id="ARP及RARP协议"><a href="#ARP及RARP协议" class="headerlink" title="ARP及RARP协议"></a>ARP及RARP协议</h5><p>ARP 是根据IP地址获取MAC地址的一种协议。</p>
<p>ARP（地址解析）协议是一种解析协议，本来主机是完全不知道这个IP对应的是哪个主机的哪个接口，当主机要发送一个IP包的时候，会首先查一下自己的ARP高速缓存（就是一个IP-MAC地址对应表缓存）。</p>
<p>如果查询的IP－MAC值对不存在，那么主机就向网络发送一个ARP协议广播包，这个广播包里面就有待查询的IP地址，而直接收到这份广播的包的所有主机都会查询自己的IP地址，如果收到广播包的某一个主机发现自己符合条件，那么就准备好一个包含自己的MAC地址的ARP包传送给发送ARP广播的主机。</p>
<p>而广播主机拿到ARP包后会更新自己的ARP缓存（就是存放IP-MAC对应表的地方）。发送广播的主机就会用新的ARP缓存数据准备好数据链路层的的数据包发送工作。</p>
<p>RARP协议的工作与此相反，不做赘述。</p>
<h5 id="ICMP协议"><a href="#ICMP协议" class="headerlink" title="ICMP协议"></a>ICMP协议</h5><p>IP协议并不是一个可靠的协议，它不保证数据被送达，那么，自然的，保证数据送达的工作应该由其他的模块来完成。其中一个重要的模块就是ICMP(网络控制报文)协议。ICMP不是高层协议，而是IP层的协议。</p>
<p>当传送IP数据包发生错误。比如主机不可达，路由不可达等等，ICMP协议将会把错误信息封包，然后传送回给主机。给主机一个处理错误的机会，这 也就是为什么说建立在IP层以上的协议是可能做到安全的原因。</p>
<h5 id="ping"><a href="#ping" class="headerlink" title="ping"></a>ping</h5><p>ping可以说是ICMP的最著名的应用，是TCP&#x2F;IP协议的一部分。利用“ping”命令可以检查网络是否连通，可以很好地帮助我们分析和判定网络故障。</p>
<p>例如：当我们某一个网站上不去的时候。通常会ping一下这个网站。ping会回显出一些有用的信息。一般的信息如下:</p>
<p><img src="/../images/4.jpg" alt="4"></p>
<p>ping这个单词源自声纳定位，而这个程序的作用也确实如此，它利用ICMP协议包来侦测另一个主机是否可达。原理是用类型码为0的ICMP发请 求，受到请求的主机则用类型码为8的ICMP回应。</p>
<p>ping程序来计算间隔时间，并计算有多少个包被送达。用户就可以判断网络大致的情况。我们可以看到， ping给出来了传送的时间和TTL的数据。</p>
<h5 id="TraceRoute"><a href="#TraceRoute" class="headerlink" title="TraceRoute"></a>TraceRoute</h5><p>Traceroute是用来侦测主机到目的主机之间所经路由情况的重要工具，也是最便利的工具。</p>
<p>Traceroute的原理是非常非常的有意思，它收到到目的主机的IP后，首先给目的主机发送一个TTL&#x3D;1的UDP数据包，而经过的第一个路由器收到这个数据包以后，就自动把TTL减1，而TTL变为0以后，路由器就把这个包给抛弃了，并同时产生 一个主机不可达的ICMP数据报给主机。主机收到这个数据报以后再发一个TTL&#x3D;2的UDP数据报给目的主机，然后刺激第二个路由器给主机发ICMP数据 报。如此往复直到到达目的主机。这样，traceroute就拿到了所有的路由器IP。</p>
<p><img src="/../images/5.jpg" alt="5"></p>
<h4 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h4><h5 id="TCP-x2F-UP"><a href="#TCP-x2F-UP" class="headerlink" title="TCP&#x2F;UP"></a>TCP&#x2F;UP</h5><p>TCP&#x2F;UDP都是是传输层协议，但是两者具有不同的特性，同时也具有不同的应用场景，下面以图表的形式对比分析。</p>
<table>
<thead>
<tr>
<th align="center"></th>
<th align="center">TCP</th>
<th align="center">UDP</th>
</tr>
</thead>
<tbody><tr>
<td align="center">可靠性</td>
<td align="center">可靠</td>
<td align="center">不可靠</td>
</tr>
<tr>
<td align="center">连接性</td>
<td align="center">面向连接</td>
<td align="center">无连接</td>
</tr>
<tr>
<td align="center">报文</td>
<td align="center">面向字节流</td>
<td align="center">面向报文</td>
</tr>
<tr>
<td align="center">效率</td>
<td align="center">传输效率低</td>
<td align="center">传输效率高</td>
</tr>
<tr>
<td align="center">双工性</td>
<td align="center">全双工</td>
<td align="center">一对一、一对多、多对一、多对多</td>
</tr>
<tr>
<td align="center">流量控制</td>
<td align="center">滑动窗口</td>
<td align="center">无</td>
</tr>
<tr>
<td align="center">拥塞控制</td>
<td align="center">慢开始、拥塞避免、快重传、快恢复</td>
<td align="center">无</td>
</tr>
<tr>
<td align="center">传输速度</td>
<td align="center">慢</td>
<td align="center">块</td>
</tr>
<tr>
<td align="center">应用场景</td>
<td align="center">对效率要求低，对准确性要求高或者要求有连接的场景</td>
<td align="center">对效率要求高，对准确性要求低</td>
</tr>
</tbody></table>
<p><strong>面向报文</strong><br>面向报文的传输方式是应用层交给UDP多长的报文，UDP就照样发送，即一次发送一个报文。因此，应用程序必须选择合适大小的报文。若报文太长，则IP层需要分片，降低效率。若太短，会是IP太小。</p>
<p><strong>面向字节流</strong><br>面向字节流的话，虽然应用程序和TCP的交互是一次一个数据块（大小不等），但TCP把应用程序看成是一连串的无结构的字节流。TCP有一个缓冲，当应用程序传送的数据块太长，TCP就可以把它划分短一些再传送。</p>
<p>关于拥塞控制，流量控制，是TCP的重点，后面讲解。</p>
<p>TCP和UDP协议的一些应用</p>
<p><img src="/../images/6.jpg" alt="6"></p>
<p><strong>什么时候应该使用TCP？</strong></p>
<p>当对网络通讯质量有要求的时候，比如：整个数据要准确无误的传递给对方，这往往用于一些要求可靠的应用，比如HTTP、HTTPS、FTP等传输文件的协议，POP、SMTP等邮件传输的协议。</p>
<p><strong>什么时候应该使用UDP？</strong></p>
<p>当对网络通讯质量要求不高的时候，要求网络通讯速度能尽量的快，这时就可以使用UDP。</p>
<h5 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h5><p>DNS（Domain Name System，域名系统），因特网上作为域名和IP地址相互映射的一个分布式数据库，能够使用户更方便的访问互联网，而不用去记住能够被机器直接读取的IP数串。通过主机名，最终得到该主机名对应的IP地址的过程叫做域名解析（或主机名解析）。DNS协议运行在UDP协议之上，使用端口号53。</p>
<h5 id="TCP连接的建立与终止"><a href="#TCP连接的建立与终止" class="headerlink" title="TCP连接的建立与终止"></a>TCP连接的建立与终止</h5><h6 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h6><p>TCP是面向连接的，无论哪一方向另一方发送数据之前，都必须先在双方之间建立一条连接。在TCP&#x2F;IP协议中，TCP协议提供可靠的连接服务，连接是通过三次握手进行初始化的。三次握手的目的是同步连接双方的序列号和确认号并交换 TCP窗口大小信息。</p>
<p><img src="/../images/note24.png" alt="note24"></p>
<p>第一次握手： 建立连接。客户端发送连接请求报文段，将SYN位置为1，Sequence Number为x；然后，客户端进入SYN_SEND状态，等待服务器的确认；</p>
<p>第二次握手： 服务器收到SYN报文段。服务器收到客户端的SYN报文段，需要对这个SYN报文段进行确认，设置Acknowledgment Number为x+1(Sequence Number+1)；同时，自己自己还要发送SYN请求信息，将SYN位置为1，Sequence Number为y；服务器端将上述所有信息放到一个报文段（即SYN+ACK报文段）中，一并发送给客户端，此时服务器进入SYN_RECV状态；</p>
<p>第三次握手： 客户端收到服务器的SYN+ACK报文段。然后将Acknowledgment Number设置为y+1，向服务器发送ACK报文段，这个报文段发送完毕以后，客户端和服务器端都进入ESTABLISHED状态，完成TCP三次握手。</p>
<p><strong>为什么要三次握手？</strong></p>
<p>为了防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误。</p>
<p>具体例子：“已失效的连接请求报文段”的产生在这样一种情况下：client发出的第一个连接请求报文段并没有丢失，而是在某个网络结点长时间的滞留了，以致延误到连接释放以后的某个时间才到达server。本来这是一个早已失效的报文段。但server收到此失效的连接请求报文段后，就误认为是client再次发出的一个新的连接请求。于是就向client发出确认报文段，同意建立连接。假设不采用“三次握手”，那么只要server发出确认，新的连接就建立了。由于现在client并没有发出建立连接的请求，因此不会理睬server的确认，也不会向server发送数据。但server却以为新的运输连接已经建立，并一直等待client发来数据。这样，server的很多资源就白白浪费掉了。采用“三次握手”的办法可以防止上述现象发生。例如刚才那种情况，client不会向server的确认发出确认。server由于收不到确认，就知道client并没有要求建立连接。”</p>
<h6 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h6><p>当客户端和服务器通过三次握手建立了TCP连接以后，当数据传送完毕，肯定是要断开TCP连接的啊。那对于TCP的断开连接，这里就有了神秘的“四次分手”。</p>
<p><img src="/../images/7.jpg" alt="7"></p>
<p>第一次分手： 主机1（可以使客户端，也可以是服务器端），设置Sequence Number，向主机2发送一个FIN报文段；此时，主机1进入FIN_WAIT_1状态；这表示主机1没有数据要发送给主机2了；<br>第二次分手： 主机2收到了主机1发送的FIN报文段，向主机1回一个ACK报文段，Acknowledgment Number为Sequence Number加1；主机1进入FIN_WAIT_2状态；主机2告诉主机1，我“同意”你的关闭请求；</p>
<p>第三次分手： 主机2向主机1发送FIN报文段，请求关闭连接，同时主机2进入LAST_ACK状态；</p>
<p>第四次分手： 主机1收到主机2发送的FIN报文段，向主机2发送ACK报文段，然后主机1进入TIME_WAIT状态；主机2收到主机1的ACK报文段以后，就关闭连接；此时，主机1等待2MSL后依然没有收到回复，则证明Server端已正常关闭，那好，主机1也可以关闭连接了。</p>
<p><strong>为什么要四次分手？</strong></p>
<p>TCP协议是一种面向连接的、可靠的、基于字节流的运输层通信协议。TCP是全双工模式，这就意味着，当主机1发出FIN报文段时，只是表示主机1已经没有数据要发送了，主机1告诉主机2，它的数据已经全部发送完毕了；但是，这个时候主机1还是可以接受来自主机2的数据；当主机2返回ACK报文段时，表示它已经知道主机1没有数据发送了，但是主机2还是可以发送数据到主机1的；当主机2也发送了FIN报文段时，这个时候就表示主机2也没有数据要发送了，就会告诉主机1，我也没有数据要发送了，之后彼此就会愉快的中断这次TCP连接。</p>
<p><strong>为什么要等待2MSL？</strong></p>
<p>MSL：报文段最大生存时间，它是任何报文段被丢弃前在网络内的最长时间。<br>原因有二：</p>
<ul>
<li>保证TCP协议的全双工连接能够可靠关闭</li>
<li>保证这次连接的重复数据段从网络中消失</li>
</ul>
<p>第一点：如果主机1直接CLOSED了，那么由于IP协议的不可靠性或者是其它网络原因，导致主机2没有收到主机1最后回复的ACK。那么主机2就会在超时之后继续发送FIN，此时由于主机1已经CLOSED了，就找不到与重发的FIN对应的连接。所以，主机1不是直接进入CLOSED，而是要保持TIME_WAIT，当再次收到FIN的时候，能够保证对方收到ACK，最后正确的关闭连接。</p>
<p>第二点：如果主机1直接CLOSED，然后又再向主机2发起一个新连接，我们不能保证这个新连接与刚关闭的连接的端口号是不同的。也就是说有可能新连接和老连接的端口号是相同的。一般来说不会发生什么问题，但是还是有特殊情况出现：假设新连接和已经关闭的老连接端口号是一样的，如果前一次连接的某些数据仍然滞留在网络中，这些延迟数据在建立新连接之后才到达主机2，由于新连接和老连接的端口号是一样的，TCP协议就认为那个延迟的数据是属于新连接的，这样就和真正的新连接的数据包发生混淆了。所以TCP连接还要在TIME_WAIT状态等待2倍MSL，这样可以保证本次连接的所有数据都从网络中消失。</p>
<h5 id="TCP流量控制"><a href="#TCP流量控制" class="headerlink" title="TCP流量控制"></a>TCP流量控制</h5><p>如果发送方把数据发送得过快，接收方可能会来不及接收，这就会造成数据的丢失。所谓流量控制就是让发送方的发送速率不要太快，要让接收方来得及接收。</p>
<p>利用滑动窗口机制可以很方便地在TCP连接上实现对发送方的流量控制。</p>
<p>设A向B发送数据。在连接建立时，B告诉了A：“我的接收窗口是 rwnd &#x3D; 400 ”(这里的 rwnd 表示 receiver window) 。因此，发送方的发送窗口不能超过接收方给出的接收窗口的数值。请注意，TCP的窗口单位是字节，不是报文段。假设每一个报文段为100字节长，而数据报文段序号的初始值设为1。大写ACK表示首部中的确认位ACK，小写ack表示确认字段的值ack。</p>
<p><img src="/../images/8.jpg" alt="8"></p>
<p>从图中可以看出，B进行了三次流量控制。第一次把窗口减少到 rwnd &#x3D; 300 ，第二次又减到了 rwnd &#x3D; 100 ，最后减到 rwnd &#x3D; 0 ，即不允许发送方再发送数据了。这种使发送方暂停发送的状态将持续到主机B重新发出一个新的窗口值为止。B向A发送的三个报文段都设置了 ACK &#x3D; 1 ，只有在ACK&#x3D;1时确认号字段才有意义。</p>
<p>TCP为每一个连接设有一个持续计时器(persistence timer)。只要TCP连接的一方收到对方的零窗口通知，就启动持续计时器。若持续计时器设置的时间到期，就发送一个零窗口控测报文段（携1字节的数据），那么收到这个报文段的一方就重新设置持续计时器。</p>
<h5 id="TCP拥塞控制"><a href="#TCP拥塞控制" class="headerlink" title="TCP拥塞控制"></a>TCP拥塞控制</h5><h6 id="慢开始和拥塞避免"><a href="#慢开始和拥塞避免" class="headerlink" title="慢开始和拥塞避免"></a>慢开始和拥塞避免</h6><p>发送方维持一个拥塞窗口 cwnd ( congestion window )的状态变量。拥塞窗口的大小取决于网络的拥塞程度，并且动态地在变化。发送方让自己的发送窗口等于拥塞窗口。</p>
<p>发送方控制拥塞窗口的原则是：只要网络没有出现拥塞，拥塞窗口就再增大一些，以便把更多的分组发送出去。但只要网络出现拥塞，拥塞窗口就减小一些，以减少注入到网络中的分组数。</p>
<p><strong>慢开始算法：</strong><br>当主机开始发送数据时，如果立即所大量数据字节注入到网络，那么就有可能引起网络拥塞，因为现在并不清楚网络的负荷情况。<br>因此，较好的方法是 先探测一下，即由小到大逐渐增大发送窗口，也就是说，由小到大逐渐增大拥塞窗口数值。</p>
<p>通常在刚刚开始发送报文段时，先把拥塞窗口 cwnd 设置为一个最大报文段MSS的数值。而在每收到一个对新的报文段的确认后，把拥塞窗口增加至多一个MSS的数值。用这样的方法逐步增大发送方的拥塞窗口 cwnd ，可以使分组注入到网络的速率更加合理。</p>
<p><img src="/../images/9.jpg" alt="9"></p>
<p>每经过一个传输轮次，拥塞窗口 cwnd 就加倍。一个传输轮次所经历的时间其实就是往返时间RTT。不过“传输轮次”更加强调：把拥塞窗口cwnd所允许发送的报文段都连续发送出去，并收到了对已发送的最后一个字节的确认。<br>另，慢开始的“慢”并不是指cwnd的增长速率慢，而是指在TCP开始发送报文段时先设置cwnd&#x3D;1，使得发送方在开始时只发送一个报文段（目的是试探一下网络的拥塞情况），然后再逐渐增大cwnd。</p>
<p>为了防止拥塞窗口cwnd增长过大引起网络拥塞，还需要设置一个慢开始门限ssthresh状态变量。慢开始门限ssthresh的用法如下：</p>
<ul>
<li>当 cwnd &lt; ssthresh 时，使用上述的慢开始算法。</li>
<li>当 cwnd &gt; ssthresh 时，停止使用慢开始算法而改用拥塞避免算法。</li>
<li>当 cwnd &#x3D; ssthresh 时，既可使用慢开始算法，也可使用拥塞控制避免算法。</li>
</ul>
<p><strong>拥塞避免</strong><br>让拥塞窗口cwnd缓慢地增大，即每经过一个往返时间RTT就把发送方的拥塞窗口cwnd加1，而不是加倍。这样拥塞窗口cwnd按线性规律缓慢增长，比慢开始算法的拥塞窗口增长速率缓慢得多。</p>
<p><img src="/../images/10.jpg" alt="10"></p>
<p>无论在慢开始阶段还是在拥塞避免阶段，只要发送方判断网络出现拥塞（其根据就是没有收到确认），就要把慢开始门限ssthresh设置为出现拥塞时的发送 方窗口值的一半（但不能小于2）。然后把拥塞窗口cwnd重新设置为1，执行慢开始算法。</p>
<p>这样做的目的就是要迅速减少主机发送到网络中的分组数，使得发生 拥塞的路由器有足够时间把队列中积压的分组处理完毕。</p>
<p>如下图，用具体数值说明了上述拥塞控制的过程。现在发送窗口的大小和拥塞窗口一样大。</p>
<p><img src="/../images/11.jpg" alt="11"></p>
<h6 id="快重传和快恢复"><a href="#快重传和快恢复" class="headerlink" title="快重传和快恢复"></a>快重传和快恢复</h6><p><strong>快重传</strong><br>快重传算法首先要求接收方每收到一个失序的报文段后就立即发出重复确认（为的是使发送方及早知道有报文段没有到达对方）而不要等到自己发送数据时才进行捎带确认。</p>
<p><img src="/../images/12.jpg" alt="12"></p>
<p>接收方收到了M1和M2后都分别发出了确认。现在假定接收方没有收到M3但接着收到了M4。</p>
<p>显然，接收方不能确认M4，因为M4是收到的失序报文段。根据 可靠传输原理，接收方可以什么都不做，也可以在适当时机发送一次对M2的确认。</p>
<p>但按照快重传算法的规定，接收方应及时发送对M2的重复确认，这样做可以让 发送方及早知道报文段M3没有到达接收方。发送方接着发送了M5和M6。接收方收到这两个报文后，也还要再次发出对M2的重复确认。这样，发送方共收到了 接收方的四个对M2的确认，其中后三个都是重复确认。</p>
<p>快重传算法还规定，发送方只要一连收到三个重复确认就应当立即重传对方尚未收到的报文段M3，而不必 继续等待M3设置的重传计时器到期。</p>
<p>由于发送方尽早重传未被确认的报文段，因此采用快重传后可以使整个网络吞吐量提高约20%。</p>
<p><strong>快恢复</strong><br>与快重传配合使用的还有快恢复算法，其过程有以下两个要点：</p>
<ul>
<li>当发送方连续收到三个重复确认，就执行“乘法减小”算法，把慢开始门限ssthresh减半。</li>
<li>与慢开始不同之处是现在不执行慢开始算法（即拥塞窗口cwnd现在不设置为1），而是把cwnd值设置为 慢开始门限ssthresh减半后的数值，然后开始执行拥塞避免算法（“加法增大”），使拥塞窗口缓慢地线性增大。</li>
</ul>
<p><img src="/../images/note25.png" alt="note25"></p>
<h4 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h4><h5 id="HTTP和HTTPS有什么区别？"><a href="#HTTP和HTTPS有什么区别？" class="headerlink" title="HTTP和HTTPS有什么区别？"></a>HTTP和HTTPS有什么区别？</h5><ol>
<li><p>端口不同：HTTP使用的是80端口，HTTPS使用443端口；</p>
</li>
<li><p>HTTP（超文本传输协议）信息是明文传输，HTTPS运行在SSL(Secure Socket Layer)之上，添加了加密和认证机制，更加安全；</p>
</li>
<li><p>HTTPS由于加密解密会带来更大的CPU和内存开销；</p>
</li>
<li><p>HTTPS通信需要证书，一般需要向证书颁发机构（CA）购买。</p>
</li>
</ol>
<h6 id="HTTP-协议包括哪些请求？"><a href="#HTTP-协议包括哪些请求？" class="headerlink" title="HTTP 协议包括哪些请求？"></a>HTTP 协议包括哪些请求？</h6><ul>
<li><p>GET：向特定的资源发出请求。</p>
</li>
<li><p>POST：向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST请求可能会导致新的资源的创建和&#x2F;或已有资源的修改。</p>
</li>
<li><p>OPTIONS：返回服务器针对特定资源所支持的HTTP请求方法。也可以利用向Web服务器发送’*’的请求来测试服务器的功能性。</p>
</li>
<li><p>HEAD：向服务器索要与GET请求相一致的响应，只不过响应体将不会被返回。这一方法可以在不必传输整个响应内容的情况下，就可以获取包含在响应消息头中的元信息。</p>
</li>
<li><p>PUT：向指定资源位置上传其最新内容。</p>
</li>
<li><p>DELETE：请求服务器删除Request-URI所标识的资源。</p>
</li>
<li><p>TRACE：回显服务器收到的请求，主要用于测试或诊断。</p>
</li>
<li><p>CONNECT：HTTP&#x2F;1.1协议中预留给能够将连接改为管道方式的代理服务器。</p>
</li>
</ul>
<h6 id="HTTP1-0和HTTP1-1的区别"><a href="#HTTP1-0和HTTP1-1的区别" class="headerlink" title="HTTP1.0和HTTP1.1的区别"></a>HTTP1.0和HTTP1.1的区别</h6><ol>
<li><p>长连接： HTTP1.1支持长连接和请求的流水线处理，在一个TCP连接上可以传送多个HTTP请求和响应，减少了建立和关闭连接的消耗和延迟，在HTTP1.1中默认开启长连接keep-alive，一定程度上弥补了HTTP1.0每次请求都要创建连接的缺点。HTTP1.0需要使用keep-alive参数来告知服务器端要建立一个长连接。</p>
</li>
<li><p>节约带宽： HTTP1.0中存在一些浪费带宽的现象，例如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了，并且不支持断点续传功能。HTTP1.1支持只发送header信息（不带任何body信息），如果服务器认为客户端有权限请求服务器，则返回100，客户端接收到100才开始把请求body发送到服务器；如果返回401，客户端就可以不用发送请求body了节约了带宽。</p>
</li>
<li><p>HOST域：在HTTP1.0中认为每台服务器都绑定一个唯一的IP地址，因此，请求消息中的URL并没有传递主机名（hostname），HTTP1.0没有host域。随着虚拟主机技术的发展，在一台物理服务器上可以存在多个虚拟主机（Multi-homed Web Servers），并且它们共享一个IP地址。HTTP1.1的请求消息和响应消息都支持host域，且请求消息中如果没有host域会报告一个错误（400 Bad Request）。</p>
</li>
<li><p>缓存处理：在HTTP1.0中主要使用header里的If-Modified-Since,Expires来做为缓存判断的标准，HTTP1.1则引入了更多的缓存控制策略例如Entity tag，If-Unmodified-Since, If-Match, If-None-Match等更多可供选择的缓存头来控制缓存策略。</p>
</li>
<li><p>错误通知的管理：在HTTP1.1中新增了24个错误状态响应码，如409（Conflict）表示请求的资源与资源的当前状态发生冲突；410（Gone）表示服务器上的某个资源被永久性的删除。</p>
</li>
</ol>
<h6 id="HTTP1-1和HTTP2-0的区别"><a href="#HTTP1-1和HTTP2-0的区别" class="headerlink" title="HTTP1.1和HTTP2.0的区别"></a>HTTP1.1和HTTP2.0的区别</h6><ol>
<li><p>多路复用：HTTP2.0使用了多路复用的技术，做到同一个连接并发处理多个请求，而且并发请求的数量比HTTP1.1大了好几个数量级。HTTP1.1也可以多建立几个TCP连接，来支持处理更多并发的请求，但是创建TCP连接本身也是有开销的。</p>
</li>
<li><p>头部数据压缩： 在HTTP1.1中，HTTP请求和响应都是由状态行、请求&#x2F;响应头部、消息主体三部分组成。一般而言，消息主体都会经过gzip压缩，或者本身传输的就是压缩过后的二进制文件，但状态行和头部却没有经过任何压缩，直接以纯文本传输。随着Web功能越来越复杂，每个页面产生的请求数也越来越多，导致消耗在头部的流量越来越多，尤其是每次都要传输UserAgent、Cookie这类不会频繁变动的内容，完全是一种浪费。</p>
<p>HTTP1.1不支持header数据的压缩，HTTP2.0使用HPACK算法对header的数据进行压缩，这样数据体积小了，在网络上传输就会更快。</p>
</li>
<li><p>服务器推送： 服务端推送是一种在客户端请求之前发送数据的机制。网页使用了许多资源：HTML、样式表、脚本、图片等等。在HTTP1.1中这些资源每一个都必须明确地请求。这是一个很慢的过程。浏览器从获取HTML开始，然后在它解析和评估页面的时候，增量地获取更多的资源。因为服务器必须等待浏览器做每一个请求，网络经常是空闲的和未充分使用的。</p>
<p>为了改善延迟，HTTP2.0引入了server push，它允许服务端推送资源给浏览器，在浏览器明确地请求之前，免得客户端再次创建连接发送请求到服务器端获取。这样客户端可以直接从本地加载这些资源，不用再通过网络。</p>
</li>
</ol>
<h6 id="Https的连接过程？"><a href="#Https的连接过程？" class="headerlink" title="Https的连接过程？"></a>Https的连接过程？</h6><ol>
<li><p>客户端向服务器发送请求，同时发送客户端支持的一套加密规则（包括对称加密、非对称加密、摘要算法）；</p>
</li>
<li><p>服务器从中选出一组加密算法与HASH算法，并将自己的身份信息以证书的形式发回给浏览器。证书里面包含了网站地址，加密公钥（用于非对称加密），以及证书的颁发机构等信息（证书中的私钥只能用于服务器端进行解密）；</p>
</li>
<li><p>客户端验证服务器的合法性，包括：证书是否过期，CA 是否可靠，发行者证书的公钥能否正确解开服务器证书的“发行者的数字签名”，服务器证书上的域名是否和服务器的实际域名相匹配；</p>
</li>
<li><p>如果证书受信任，或者用户接收了不受信任的证书，浏览器会生成一个随机密钥（用于对称算法），并用服务器提供的公钥加密（采用非对称算法对密钥加密）；使用Hash算法对握手消息进行摘要计算，并对摘要使用之前产生的密钥加密（对称算法）；将加密后的随机密钥和摘要一起发送给服务器；</p>
</li>
<li><p>服务器使用自己的私钥解密，得到对称加密的密钥，用这个密钥解密出Hash摘要值，并验证握手消息是否一致；如果一致，服务器使用对称加密的密钥加密握手消息发给浏览器；</p>
</li>
<li><p>浏览器解密并验证摘要，若一致，则握手结束。之后的数据传送都使用对称加密的密钥进行加密。</p>
</li>
</ol>
<p>总结：非对称加密算法用于在握手过程中加密生成的密码；对称加密算法用于对真正传输的数据进行加密；HASH算法用于验证数据的完整性。</p>
<h6 id="在浏览器中输入www-baidu-com后执行的全部过程"><a href="#在浏览器中输入www-baidu-com后执行的全部过程" class="headerlink" title="在浏览器中输入www.baidu.com后执行的全部过程"></a>在浏览器中输入<a href="http://www.baidu.com后执行的全部过程/">www.baidu.com后执行的全部过程</a></h6><p>事件顺序：</p>
<p>(1) 浏览器获取输入的域名<a href="http://www.baidu.com/">www.baidu.com</a></p>
<p>(2) 浏览器向DNS请求解析<a href="http://www.baidu.com的ip地址/">www.baidu.com的IP地址</a></p>
<p>(3) 域名系统DNS解析出百度服务器的IP地址</p>
<p>(4) 浏览器与该服务器建立TCP连接(默认端口号80)</p>
<p>(5) 浏览器发出HTTP请求，请求百度首页</p>
<p>(6) 服务器通过HTTP响应把首页文件发送给浏览器</p>
<p>(7) TCP连接释放</p>
<p>(8) 浏览器将首页文件进行解析，并将Web页显示给用户。</p>
<p>涉及到的协议</p>
<p>(1) 应用层：HTTP(WWW访问协议)，DNS(域名解析服务)</p>
<p>(2) 传输层：TCP(为HTTP提供可靠的数据传输)，UDP(DNS使用UDP传输)</p>
<p>(3) 网络层：IP(IP数据数据包传输和路由选择)，ICMP(提供网络传输过程中的差错检测)，ARP(将本机的默认网关IP地址映射成物理MAC地址)</p>
<h6 id="什么是对称加密、非对称加密？区别是什么？"><a href="#什么是对称加密、非对称加密？区别是什么？" class="headerlink" title="什么是对称加密、非对称加密？区别是什么？"></a>什么是对称加密、非对称加密？区别是什么？</h6><ul>
<li>对称加密：加密和解密采用相同的密钥。如：DES、RC2、RC4。</li>
<li>非对称加密：需要两个密钥：公钥和私钥。如果用公钥加密，需要用私钥才能解密。如：RSA。</li>
<li>区别：对称加密速度更快，通常用于大量数据的加密；非对称加密安全性更高（不需要传送私钥）。</li>
</ul>
<h6 id="数字签名、报文摘要的原理"><a href="#数字签名、报文摘要的原理" class="headerlink" title="数字签名、报文摘要的原理"></a>数字签名、报文摘要的原理</h6><ul>
<li><p>发送者A用私钥进行签名，接收者B用公钥验证签名。因为除A外没有人有私钥，所以B相信签名是来自A。A不可抵赖，B也不能伪造报文。</p>
</li>
<li><p>摘要算法：MD5、SHA。</p>
</li>
</ul>
<h4 id="GET和POST的区别？"><a href="#GET和POST的区别？" class="headerlink" title="GET和POST的区别？"></a>GET和POST的区别？</h4><ol>
<li><p>GET是幂等的，即读取同一个资源，总是得到相同的数据，POST不是幂等的；</p>
</li>
<li><p>GET一般用于从服务器获取资源，而POST有可能改变服务器上的资源；</p>
</li>
<li><p>请求形式上：GET请求的数据附在URL之后，在HTTP请求头中；POST请求的数据在请求体中；</p>
</li>
<li><p>安全性：GET请求可被缓存、收藏、保留到历史记录，且其请求数据明文出现在URL中。POST的参数不会被保存，安全性相对较高；</p>
</li>
<li><p>GET只允许ASCII字符，POST对数据类型没有要求，也允许二进制数据；</p>
</li>
<li><p>GET的长度有限制（操作系统或者浏览器），而POST数据大小无限制。</p>
</li>
</ol>
<h4 id="Session与Cookie的区别？"><a href="#Session与Cookie的区别？" class="headerlink" title="Session与Cookie的区别？"></a>Session与Cookie的区别？</h4><ol>
<li><p>Session是服务器端保持状态的方案，Cookie是客户端保持状态的方案；</p>
</li>
<li><p>Cookie保存在客户端本地，客户端请求服务器时会将Cookie一起提交；Session保存在服务端，通过检索Sessionid查看状态。保存Sessionid的方式可以采用Cookie，如果禁用了Cookie，可以使用URL重写机制（把会话ID保存在URL中）；</p>
</li>
<li><p>Session的实现常常依赖于Cookie机制，通过Cookie机制回传SessionID；</p>
</li>
<li><p>Cookie有大小限制并且浏览器对每个站点也有cookie的个数限制，Session没有大小限制，理论上只与服务器的内存大小有关；</p>
</li>
<li><p>Cookie存在安全隐患，通过拦截或本地文件找得到cookie后可以进行攻击，而Session由于保存在服务器端，相对更加安全；</p>
</li>
<li><p>Session是保存在服务器端上会存在一段时间才会消失，如果session过多会增加服务器的压力。</p>
</li>
</ol>
<h4 id="从输入网址到获得页面的过程-越详细越好-？"><a href="#从输入网址到获得页面的过程-越详细越好-？" class="headerlink" title="从输入网址到获得页面的过程 (越详细越好)？"></a>从输入网址到获得页面的过程 (越详细越好)？</h4><ol>
<li><p>浏览器查询 DNS，获取域名对应的IP地址：具体过程包括浏览器搜索自身的DNS缓存、搜索操作系统的DNS缓存、读取本地的Host文件和向本地DNS服务器进行查询等。对于向本地DNS服务器进行查询，如果要查询的域名包含在本地配置区域资源中，则返回解析结果给客户机，完成域名解析(此解析具有权威性)；如果要查询的域名不由本地DNS服务器区域解析，但该服务器已缓存了此网址映射关系，则调用这个IP地址映射，完成域名解析（此解析不具有权威性）。如果本地域名服务器并未缓存该网址映射关系，那么将根据其设置发起递归查询或者迭代查询；</p>
</li>
<li><p>浏览器获得域名对应的IP地址以后，浏览器向服务器请求建立连接，发起三次握手；</p>
</li>
<li><p>TCP&#x2F;IP连接建立起来后，浏览器向服务器发送HTTP请求；</p>
</li>
<li><p>服务器接收到这个请求，并根据路径参数映射到特定的请求处理器进行处理，并将处理结果及相应的视图返回给浏览器；</p>
</li>
<li><p>浏览器解析并渲染视图，若遇到对js文件、css文件及图片等静态资源的引用，则重复上述步骤并向服务器请求这些资源；</p>
</li>
<li><p>浏览器根据其请求到的资源、数据渲染页面，最终向用户呈现一个完整的页面。</p>
</li>
</ol>
<h4 id="HTTP请求有哪些常见状态码？"><a href="#HTTP请求有哪些常见状态码？" class="headerlink" title="HTTP请求有哪些常见状态码？"></a>HTTP请求有哪些常见状态码？</h4><ol>
<li><p>2xx状态码：操作成功。200 OK</p>
</li>
<li><p>3xx状态码：重定向。301 永久重定向；302暂时重定向</p>
</li>
<li><p>4xx状态码：客户端错误。400 Bad Request；401 Unauthorized；403 Forbidden；404 Not Found；</p>
</li>
<li><p>5xx状态码：服务端错误。500服务器内部错误；501服务不可用。</p>
</li>
</ol>
<h4 id="什么是RIP-Routing-Information-Protocol-距离矢量路由协议-算法是什么？"><a href="#什么是RIP-Routing-Information-Protocol-距离矢量路由协议-算法是什么？" class="headerlink" title="什么是RIP (Routing Information Protocol,距离矢量路由协议)? 算法是什么？"></a>什么是RIP (Routing Information Protocol,距离矢量路由协议)? 算法是什么？</h4><p>每个路由器维护一张表，记录该路由器到其它网络的”跳数“，路由器到与其直接连接的网络的跳数是1，每多经过一个路由器跳数就加1；更新该表时和相邻路由器交换路由信息；路由器允许一个路径最多包含15个路由器，如果跳数为16，则不可达。交付数据报时优先选取距离最短的路径。</p>
<p>优缺点：</p>
<ul>
<li>实现简单，开销小；</li>
<li>随着网络规模扩大开销也会增大；</li>
<li>最大距离为15，限制了网络的规模；</li>
<li>当网络出现故障时，要经过较长的时间才能将此信息传递到所有路由器。</li>
</ul>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
  </entry>
  <entry>
    <title>操作系统 - 操作系统</title>
    <url>/2022/05/24/2022-05-24-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<h1 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h1><span id="more"></span>

<h4 id="进程和线程的区别？"><a href="#进程和线程的区别？" class="headerlink" title="进程和线程的区别？"></a>进程和线程的区别？</h4><ul>
<li><p>进程（Process）是系统进行资源分配和调度的基本单位，线程（Thread）是CPU调度和分派的基本单位；</p>
</li>
<li><p>线程依赖于进程而存在，一个进程至少有一个线程；</p>
</li>
<li><p>进程有自己的独立地址空间，线程共享所属进程的地址空间；</p>
</li>
<li><p>进程是拥有系统资源的一个独立单位，而线程自己基本上不拥有系统资源，只拥有一点在运行中必不可少的资源(如程序计数器，一组寄存器和栈)，和其他线程共享本进程的相关资源如内存、I&#x2F;O、cpu等；</p>
</li>
<li><p>在进程切换时，涉及到整个当前进程CPU环境的保存、环境的设置以及新被调度运行的CPU环境的设置，而线程切换只需保存和设置少量的寄存器的内容，并不涉及存储器管理方面的操作，可见，进程切换的开销远大于线程切换的开销；</p>
</li>
<li><p>线程之间的通信更方便，同一进程下的线程共享全局变量等数据，而进程之间的通信需要以进程间通信(IPC)的方式进行；</p>
</li>
<li><p>多线程程序只要有一个线程崩溃，整个程序就崩溃了，但多进程程序中一个进程崩溃并不会对其它进程造成影响，因为进程有自己的独立地址空间，因此多进程更加健壮。</p>
</li>
</ul>
<h5 id="同一进程中的线程可以共享哪些数据？"><a href="#同一进程中的线程可以共享哪些数据？" class="headerlink" title="同一进程中的线程可以共享哪些数据？"></a>同一进程中的线程可以共享哪些数据？</h5><ul>
<li>进程代码段</li>
<li>进程的公有数据（全局变量、静态变量…）</li>
<li>进程打开的文件描述符</li>
<li>进程的当前目录</li>
<li>信号处理器&#x2F;信号处理函数：对收到的信号的处理方式</li>
<li>进程ID与进程组ID</li>
</ul>
<h5 id="线程独占哪些资源？"><a href="#线程独占哪些资源？" class="headerlink" title="线程独占哪些资源？"></a>线程独占哪些资源？</h5><ul>
<li>线程ID</li>
<li>一组寄存器的值</li>
<li>线程自身的栈（堆是共享的）</li>
<li>错误返回码：线程可能会产生不同的错误返回码，一个线程的错误返回码不应该被其它线程修改</li>
<li>信号掩码&#x2F;信号屏蔽字(Signal mask)：表示是否屏蔽&#x2F;阻塞相应的信号（SIGKILL,SIGSTOP除外）</li>
</ul>
<h4 id="进程间通信有哪些方式？"><a href="#进程间通信有哪些方式？" class="headerlink" title="进程间通信有哪些方式？"></a>进程间通信有哪些方式？</h4><ul>
<li><p>管道(Pipe)</p>
<ul>
<li><p>管道是半双工的，数据只能向一个方向流动；需要双方通信时，需要建立起两个管道；</p>
</li>
<li><p>一个进程向管道中写的内容被管道另一端的进程读出。写入的内容每次都添加在管道缓冲区的末尾，并且每次都是从缓冲区的头部读出数据；</p>
</li>
<li><p>只能用于父子进程或者兄弟进程之间(具有亲缘关系的进程)。</p>
</li>
</ul>
</li>
<li><p>命名管道</p>
</li>
<li><p>消息队列</p>
</li>
<li><p>信号(Signal)</p>
</li>
<li><p>共享内存</p>
</li>
<li><p>**信号量(Semaphore)**：初始化操作、P操作、V操作；P操作：信号量-1，检测是否小于0，小于则进程进入阻塞状态；V操作：信号量+1，若小于等于0，则从队列中唤醒一个等待的进程进入就绪态。</p>
</li>
<li><p>套接字(Socket)</p>
</li>
</ul>
<h4 id="进程同步问题"><a href="#进程同步问题" class="headerlink" title="进程同步问题"></a>进程同步问题</h4><p>管程 Monitor</p>
<p>管程将共享变量以及对这些共享变量的操作封装起来，形成一个具有一定接口的功能模块，这样只能通过管程提供的某个过程才能访问管程中的资源。进程只能互斥地使用管程，使用完之后必须释放管程并唤醒入口等待队列中的进程。</p>
<p>当一个进程试图进入管程时，在入口等待队列等待。若P进程唤醒了Q进程，则Q进程先执行，P在紧急等待队列中等待。（<strong>HOARE管程</strong>）</p>
<ol>
<li>wait操作：执行wait操作的进程进入条件变量链末尾，唤醒紧急等待队列或者入口队列中的进程；</li>
<li>signal操作：唤醒条件变量链中的进程，自己进入紧急等待队列，若条件变量链为空，则继续执行。（<strong>HOARE管程</strong>）</li>
</ol>
<p><strong>MESA管程</strong>：将HOARE中的signal换成了notify（或者broadcast通知所有满足条件的），进行通知而不是立马交换管程的使用权，在合适的时候，条件队列首位的进程可以进入，进入之前必须用while检查条件是否合适。优点：没有额外的进程切换。</p>
<p><strong>生产者-消费者问题</strong></p>
<p>问题描述：使用一个缓冲区来存放数据，只有缓冲区没有满，生产者才可以写入数据；只有缓冲区不为空，消费者才可以读出数据。</p>
<p>代码实现：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 伪代码描述 </span></span><br><span class="line"><span class="comment">// 定义信号量 full记录缓冲区物品数量 empty代表缓冲区空位数量 mutex为互斥量</span></span><br><span class="line">semaphore full = <span class="number">0</span>, empty = n, mutex = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生产者进程</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">producer</span><span class="params">()</span>&#123;</span><br><span class="line">	<span class="keyword">do</span>&#123;</span><br><span class="line">   	  P(empty);</span><br><span class="line">	  P(mutex);</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 生产者进行生产</span></span><br><span class="line">   	</span><br><span class="line">   	  V(mutex);</span><br><span class="line">   	  V(full);</span><br><span class="line"> 	&#125; <span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">consumer</span><span class="params">()</span>&#123;</span><br><span class="line">	<span class="keyword">do</span>&#123;</span><br><span class="line">	  P(full);</span><br><span class="line">	  P(mutex);</span><br><span class="line"></span><br><span class="line">    	<span class="comment">// 消费者进行消费</span></span><br><span class="line"></span><br><span class="line">	  V(mutex);</span><br><span class="line">	  V(empty);</span><br><span class="line"> 	&#125; <span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>哲学家就餐问题</strong></p>
<p>问题描述：有五位哲学家围绕着餐桌坐，每一位哲学家要么思考，要么吃饭。为了吃饭，哲学家必须拿起两双筷子（分别放于左右两端）不幸的是，筷子的数量和哲学家相等，所以每只筷子必须由两位哲学家共享。</p>
<p>代码实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">#define N <span class="number">5</span>  <span class="comment">// number of philosopher</span></span><br><span class="line">#define <span class="title function_">LEFT</span> <span class="params">(i + N - <span class="number">1</span>)</span>%N <span class="comment">// number of i&#x27;s left neighbors</span></span><br><span class="line">#define <span class="title function_">RIGHT</span> <span class="params">(i + <span class="number">1</span>)</span>%N <span class="comment">// number of i&#x27;s right neighbors</span></span><br><span class="line">#define THINKING <span class="number">0</span></span><br><span class="line">#define HUNGRY <span class="number">1</span></span><br><span class="line">#define EATING <span class="number">2</span></span><br><span class="line">typedef <span class="type">int</span> semaphore;</span><br><span class="line"><span class="type">int</span> state[N]; <span class="comment">// array to keep track of everyone&#x27;s state</span></span><br><span class="line"><span class="type">semaphore</span> <span class="variable">mutex</span> <span class="operator">=</span> <span class="number">1</span>; <span class="comment">// mutual exclusion of critical region</span></span><br><span class="line">semaphore s[N]; </span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">philosopher</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">	<span class="keyword">while</span> (TRUE) &#123;</span><br><span class="line">		think();</span><br><span class="line">		take_forks(i);</span><br><span class="line">		eat();</span><br><span class="line">		put_forks(i);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">take_forks</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">	down(&amp;mutex); <span class="comment">// enter critical region</span></span><br><span class="line">	state[i] = HUNGRY; <span class="comment">// record that i is hungry</span></span><br><span class="line">	test_forks(i); <span class="comment">// try to acquire two forks</span></span><br><span class="line">	up(&amp;mutex); <span class="comment">// exit critical region</span></span><br><span class="line">	down(&amp;s[i]); <span class="comment">// block if forks are not acquired</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">put_forks</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">	down(&amp;mutex); <span class="comment">// enter critical region</span></span><br><span class="line">	state[i] = THINKING; <span class="comment">// record that has finished eating</span></span><br><span class="line">	test_forks(LEFT); <span class="comment">// see if left neighbor can now eat</span></span><br><span class="line">	test_forks(RIGHT); <span class="comment">// see if right neighbor can now eat</span></span><br><span class="line">	up(&amp;mutex); <span class="comment">// exit critical region</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">test_forks</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> (state[i] == HUNGRY &amp;&amp; state[LEFT] != EATING &amp;&amp; state[RIGHT] != EATING) &#123;</span><br><span class="line">		state[i] = EATING;</span><br><span class="line">		up(&amp;s[i]);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>读者-写者问题</strong></p>
<h5 id="临界区的概念"><a href="#临界区的概念" class="headerlink" title="临界区的概念"></a>临界区的概念</h5><p>各个进程中对临界资源（互斥资源&#x2F;共享变量，一次只能给一个进程使用）进行操作的程序片段。    </p>
<h5 id="同步与互斥的概念"><a href="#同步与互斥的概念" class="headerlink" title="同步与互斥的概念"></a>同步与互斥的概念</h5><ul>
<li><p>同步：多个进程因为合作而使得进程的执行有一定的先后顺序。比如某个进程需要另一个进程提供的消息，获得消息之前进入阻塞态。</p>
</li>
<li><p>互斥：多个进程在同一时刻只有一个进程能进入临界区。</p>
</li>
</ul>
<h5 id="并发、并行、异步的区别"><a href="#并发、并行、异步的区别" class="headerlink" title="并发、并行、异步的区别"></a>并发、并行、异步的区别</h5><ul>
<li><p>并发：在一个时间段中同时有多个程序在运行，但其实任一时刻，只有一个程序在CPU上运行，宏观上的并发是通过不断的切换实现的。</p>
</li>
<li><p>多线程：并发运行的一段代码。是实现异步的手段。</p>
</li>
<li><p>并行（和串行相比）：在多CPU系统中，多个程序无论宏观还是微观上都是同时执行的。</p>
</li>
<li><p>异步（和同步相比）：同步是顺序执行，异步是在等待某个资源的时候继续做自己的事。</p>
</li>
</ul>
<h4 id="进程有哪几种状态"><a href="#进程有哪几种状态" class="headerlink" title="进程有哪几种状态?"></a>进程有哪几种状态?</h4><ul>
<li>就绪状态：进程已获得除处理机以外的所需资源，等待分配处理机资源。</li>
<li>运行状态：占用处理机资源运行，处于此状态的进程数小于等于CPU数。</li>
<li>阻塞状态： 进程等待某种条件，在条件满足之前无法执行。</li>
</ul>
<h4 id="进程调度策略有哪些？"><a href="#进程调度策略有哪些？" class="headerlink" title="进程调度策略有哪些？"></a>进程调度策略有哪些？</h4><h5 id="批处理系统"><a href="#批处理系统" class="headerlink" title="批处理系统"></a>批处理系统</h5><ol>
<li><strong>先来先服务 first-come first-serverd（FCFS）</strong></li>
</ol>
<ul>
<li>按照请求的顺序进行调度。</li>
<li>非抢占式，开销小，无饥饿问题，响应时间不确定（可能很慢）。</li>
<li>对短进程不利，对IO密集型进程不利。</li>
</ul>
<ol start="2">
<li><strong>最短作业优先 shortest job first（SJF）</strong><ul>
<li>按估计运行时间最短的顺序进行调度。</li>
<li>非抢占式，吞吐量高，开销可能较大，可能导致饥饿问题。</li>
<li>对短进程提供好的响应时间，对长进程不利。</li>
</ul>
</li>
<li><strong>最短剩余时间优先 shortest remaining time next（SRTN）</strong><ul>
<li><p>响应比 &#x3D; 1+ 等待时间&#x2F;处理时间。同时考虑了等待时间的长短和估计需要的执行时间长短，很好的平衡了长短进程。</p>
</li>
<li><p>非抢占，吞吐量高，开销可能较大，提供好的响应时间，无饥饿问题。</p>
</li>
</ul>
</li>
</ol>
<h5 id="交互式系统"><a href="#交互式系统" class="headerlink" title="交互式系统"></a>交互式系统</h5><p>交互式系统有大量的用户交互操作，在该系统中调度算法的目标是快速地进行响应。</p>
<ol>
<li><p><strong>时间片轮转 Round Robin</strong></p>
<ul>
<li>将所有就绪进程按 FCFS 的原则排成一个队列，用完时间片的进程排到队列最后。</li>
<li>抢占式（时间片用完时），开销小，无饥饿问题，为短进程提供好的响应时间。</li>
<li>若时间片小，进程切换频繁，吞吐量低；若时间片太长，实时性得不到保证。</li>
</ul>
</li>
<li><p><strong>优先级调度算法</strong></p>
<ul>
<li>为每个进程分配一个优先级，按优先级进行调度。为了防止低优先级的进程永远等不到调度，可以随着时间的推移增加等待进程的优先级。</li>
</ul>
</li>
<li><p><strong>多级反馈队列调度算法 Multilevel Feedback Queue</strong></p>
<ul>
<li><p>设置多个就绪队列1、2、3…，优先级递减，时间片递增。只有等到优先级更高的队列为空时才会调度当前队列中的进程。如果进程用完了当前队列的时间片还未执行完，则会被移到下一队列。</p>
</li>
<li><p>抢占式（时间片用完时），开销可能较大，对IO型进程有利，可能会出现饥饿问题。</p>
</li>
</ul>
</li>
</ol>
<h5 id="什么叫优先级反转？如何解决？"><a href="#什么叫优先级反转？如何解决？" class="headerlink" title="什么叫优先级反转？如何解决？"></a>什么叫优先级反转？如何解决？</h5><p>高优先级的进程等待被一个低优先级进程占用的资源时，就会出现优先级反转，即优先级较低的进程比优先级较高的进程先执行。</p>
<p>此处详细解释优先级反转带来的问题：如果有一个中等优先级的进程将低优先级的进程抢占，那么此时低优先级的进程无法正常进行并在后续释放被占用的资源，导致高优先级的任务一直被挂起，直到中等优先级的进程完成后，低优先级的进程才可以继续并在后续释放占用的资源，最后高优先级的进程才可以执行。导致的问题就是高优先级的进程在中等优先级的进程调度之后。</p>
<p>解决方法：</p>
<ul>
<li><p>优先级天花板(priority ceiling)：当任务申请某资源时，把该任务的优先级提升到可访问这个资源的所有任务中的最高优先级，这个优先级称为该资源的优先级天花板。简单易行。</p>
</li>
<li><p>优先级继承(priority inheritance)：当任务A申请共享资源S时，如果S正在被任务C使用，通过比较任务C与自身的优先级，如发现任务C的优先级小于自身的优先级，则将任务C的优先级提升到自身的优先级，任务C释放资源S后，再恢复任务C的原优先级。</p>
</li>
</ul>
<h4 id="什么是僵尸进程？"><a href="#什么是僵尸进程？" class="headerlink" title="什么是僵尸进程？"></a>什么是僵尸进程？</h4><p>一个子进程结束后，它的父进程并没有等待它（调用wait或者waitpid），那么这个子进程将成为一个僵尸进程。</p>
<p>僵尸进程是一个已经死亡的进程，但是并没有真正被销毁。它已经放弃了几乎所有内存空间，没有任何可执行代码，也不能被调度，仅仅在进程表中保留一个位置，记载该进程的进程ID、终止状态以及资源利用信息(CPU时间，内存使用量等等)供父进程收集，除此之外，僵尸进程不再占有任何内存空间。这个僵尸进程可能会一直留在系统中直到系统重启。</p>
<p><strong>危害：占用进程号，而系统所能使用的进程号是有限的；占用内存。</strong></p>
<p>以下情况不会产生僵尸进程：</p>
<ul>
<li><p>该进程的父进程先结束了。每个进程结束的时候，系统都会扫描是否存在子进程，如果有则用Init进程接管，成为该进程的父进程，并且会调用wait等待其结束。</p>
</li>
<li><p>父进程调用wait或者waitpid等待子进程结束（需要每隔一段时间查询子进程是否结束）。wait系统调用会使父进程暂停执行，直到它的一个子进程结束为止。waitpid则可以加入WNOHANG(wait-no-hang)选项，如果没有发现结束的子进程，就会立即返回，不会将调用waitpid的进程阻塞。同时，waitpid还可以选择是等待任一子进程（同wait），还是等待指定pid的子进程，还是等待同一进程组下的任一子进程，还是等待组ID等于pid的任一子进程。</p>
</li>
<li><p>子进程结束时，系统会产生SIGCHLD(signal-child)信号，可以注册一个信号处理函数，在该函数中调用waitpid，等待所有结束的子进程（注意：一般都需要循环调用waitpid，因为在信号处理函数开始执行之前，可能已经有多个子进程结束了，而信号处理函数只执行一次，所以要循环调用将所有结束的子进程回收）。</p>
</li>
<li><p>也可以用signal(SIGCLD, SIG_IGN)(signal-ignore)通知内核，表示忽略SIGCHLD信号，那么子进程结束后，内核会进行回收。</p>
</li>
</ul>
<h5 id="什么是孤儿进程？"><a href="#什么是孤儿进程？" class="headerlink" title="什么是孤儿进程？"></a>什么是孤儿进程？</h5><p>一个父进程已经结束了，但是它的子进程还在运行，那么这些子进程将成为孤儿进程。孤儿进程会被Init（进程ID为1）接管，当这些孤儿进程结束时由Init完成状态收集工作。</p>
<h4 id="线程同步有哪些方式？"><a href="#线程同步有哪些方式？" class="headerlink" title="线程同步有哪些方式？"></a>线程同步有哪些方式？</h4><p>为什么需要线程同步：线程有时候会和其他线程共享一些资源，比如内存、数据库等。当多个线程同时读写同一份共享资源的时候，可能会发生冲突。因此需要线程的同步，多个线程按顺序访问资源。</p>
<ul>
<li><strong>互斥量Mutex</strong>：互斥量是内核对象，只有拥有互斥对象的线程才有访问互斥资源的权限。因为互斥对象只有一个，所以可以保证互斥资源不会被多个线程同时访问；当前拥有互斥对象的线程处理完任务后必须将互斥对象交出，以便其他线程访问该资源。</li>
<li><strong>信号量 Semaphore</strong>：信号量是内核对象，它允许同一时刻多个线程访问同一资源，但是需要控制同一时刻访问此资源的最大线程数量。信号量对象保存了最大资源计数和当前可用资源计数，每增加一个线程对共享资源的访问，当前可用资源计数就减1，只要当前可用资源计数大于0，就可以发出信号量信号，如果为0，则将线程放入一个队列中等待。线程处理完共享资源后，应在离开的同时通过ReleaseSemaphore函数将当前可用资源数加1。如果信号量的取值只能为0或1，那么信号量就成为了互斥量。</li>
<li><strong>事件 Event</strong>：允许一个线程在处理完一个任务后，主动唤醒另外一个线程执行任务。事件分为手动重置事件和自动重置事件。手动重置事件被设置为激发状态后，会唤醒所有等待的线程，而且一直保持为激发状态，直到程序重新把它设置为未激发状态。自动重置事件被设置为激发状态后，会唤醒一个等待中的线程，然后自动恢复为未激发状态。</li>
<li><strong>临界区 Critical Section</strong>：任意时刻只允许一个线程对临界资源进行访问。拥有临界区对象的线程可以访问该临界资源，其它试图访问该资源的线程将被挂起，直到临界区对象被释放。</li>
</ul>
<h5 id="互斥量和临界区有什么区别？"><a href="#互斥量和临界区有什么区别？" class="headerlink" title="互斥量和临界区有什么区别？"></a>互斥量和临界区有什么区别？</h5><p>互斥量是可以命名的，可以用于不同进程之间的同步；而临界区只能用于同一进程中线程的同步。创建互斥量需要的资源更多，因此临界区的优势是速度快，节省资源。</p>
<h4 id="什么是协程？"><a href="#什么是协程？" class="headerlink" title="什么是协程？"></a>什么是协程？</h4><p>协程是一种用户态的轻量级线程，协程的调度完全由用户控制。协程拥有自己的寄存器上下文和栈。协程调度切换时，将寄存器上下文和栈保存到其他地方，在切回来的时候，恢复先前保存的寄存器上下文和栈，直接操作栈则基本没有内核切换的开销，可以不加锁的访问全局变量，所以上下文的切换非常快。</p>
<h5 id="协程多与线程进行比较？"><a href="#协程多与线程进行比较？" class="headerlink" title="协程多与线程进行比较？"></a>协程多与线程进行比较？</h5><ol>
<li>一个线程可以拥有多个协程，一个进程也可以单独拥有多个协程，这样python中则能使用多核CPU。</li>
<li>线程进程都是同步机制，而协程则是异步</li>
<li>协程能保留上一次调用时的状态，每次过程重入时，就相当于进入上一次调用的状态</li>
</ol>
<h4 id="进程的异常控制流：陷阱、中断、异常和信号"><a href="#进程的异常控制流：陷阱、中断、异常和信号" class="headerlink" title="进程的异常控制流：陷阱、中断、异常和信号"></a>进程的异常控制流：陷阱、中断、异常和信号</h4><ol>
<li><p>陷阱是有意造成的“异常”，是执行一条指令的结果。陷阱是同步的。陷阱的主要作用是实现系统调用。比如，进程可以执行 syscall n 指令向内核请求服务。当进程执行这条指令后，会中断当前的控制流，陷入到内核态，执行相应的系统调用。内核的处理程序在执行结束后，会将结果返回给进程，同时退回到用户态。进程此时继续执行下一条指令。</p>
</li>
<li><p>中断由处理器外部的硬件产生，不是执行某条指令的结果，也无法预测发生时机。由于中断独立于当前执行的程序，因此中断是异步事件。中断包括 I&#x2F;O 设备发出的 I&#x2F;O 中断、各种定时器引起的时钟中断、调试程序中设置的断点等引起的调试中断等。</p>
</li>
<li><p>异常是一种错误情况，是执行当前指令的结果，可能被错误处理程序修正，也可能直接终止应用程序。异常是同步的。这里特指因为执行当前指令而产生的错误情况，比如除法异常、缺页异常等。有些书上为了区分，也将这类“异常”称为“故障”。</p>
</li>
<li><p>信号是一种更高层的软件形式的异常，同样会中断进程的控制流，可以由进程进行处理。一个信号代表了一个消息。信号的作用是用来通知进程发生了某种系统事件。</p>
</li>
</ol>
<h4 id="什么是IO多路复用？怎么实现？"><a href="#什么是IO多路复用？怎么实现？" class="headerlink" title="什么是IO多路复用？怎么实现？"></a>什么是IO多路复用？怎么实现？</h4><p>IO多路复用（IO Multiplexing）是指单个进程&#x2F;线程就可以同时处理多个IO请求。</p>
<p>实现原理：用户将想要监视的文件描述符（File Descriptor）添加到select&#x2F;poll&#x2F;epoll函数中，由内核监视，函数阻塞。一旦有文件描述符就绪（读就绪或写就绪），或者超时（设置timeout），函数就会返回，然后该进程可以进行相应的读&#x2F;写操作。</p>
<h5 id="select-x2F-poll-x2F-epoll三者的区别？"><a href="#select-x2F-poll-x2F-epoll三者的区别？" class="headerlink" title="select&#x2F;poll&#x2F;epoll三者的区别？"></a>select&#x2F;poll&#x2F;epoll三者的区别？</h5><ul>
<li><p>select：将文件描述符放入一个集合中，调用select时，将这个集合从用户空间拷贝到内核空间（缺点1：每次都要复制，开销大），由内核根据就绪状态修改该集合的内容。（缺点2）集合大小有限制，32位机默认是1024（64位：2048）；采用水平触发机制。select函数返回后，需要通过遍历这个集合，找到就绪的文件描述符（缺点3：轮询的方式效率较低），当文件描述符的数量增加时，效率会线性下降；</p>
</li>
<li><p>poll：和select几乎没有区别，区别在于文件描述符的存储方式不同，poll采用链表的方式存储，没有最大存储数量的限制。</p>
</li>
<li><p>epoll：通过内核和用户空间共享内存，避免了不断复制的问题；支持的同时连接数上限很高（1G左右的内存支持10W左右的连接数）；文件描述符就绪时，采用回调机制，避免了轮询（回调函数将就绪的描述符添加到一个链表中，执行epoll_wait时，返回这个链表）；支持水平触发和边缘触发，采用边缘触发机制时，只有活跃的描述符才会触发回调函数。</p>
</li>
</ul>
<p>总结，区别主要在于：</p>
<ul>
<li>一个线程&#x2F;进程所能打开的最大连接数</li>
<li>文件描述符传递方式（是否复制）</li>
<li>水平触发 or 边缘触发</li>
<li>查询就绪的描述符时的效率（是否轮询）</li>
</ul>
<h5 id="什么时候使用select-x2F-poll，什么时候使用epoll？"><a href="#什么时候使用select-x2F-poll，什么时候使用epoll？" class="headerlink" title="什么时候使用select&#x2F;poll，什么时候使用epoll？"></a>什么时候使用select&#x2F;poll，什么时候使用epoll？</h5><p>当连接数较多并且有很多的不活跃连接时，epoll的效率比其它两者高很多；但是当连接数较少并且都十分活跃的情况下，由于epoll需要很多回调，因此性能可能低于其它两者。</p>
<h5 id="什么是文件描述符？"><a href="#什么是文件描述符？" class="headerlink" title="什么是文件描述符？"></a>什么是文件描述符？</h5><p>文件描述符在形式上是一个非负整数。实际上，它是一个索引值，指向内核为每一个进程所维护的该进程打开文件的记录表。当程序打开一个现有文件或者创建一个新文件时，内核向进程返回一个文件描述符。</p>
<p>内核通过文件描述符来访问文件。文件描述符指向一个文件。</p>
<h5 id="什么是水平触发？什么是边缘触发？"><a href="#什么是水平触发？什么是边缘触发？" class="headerlink" title="什么是水平触发？什么是边缘触发？"></a>什么是水平触发？什么是边缘触发？</h5><ul>
<li><p>水平触发（LT，Level Trigger）模式下，只要一个文件描述符就绪，就会触发通知，如果用户程序没有一次性把数据读写完，下次还会通知。</p>
</li>
<li><p>边缘触发（ET，Edge Trigger）模式下，当描述符从未就绪变为就绪时通知一次，之后不会再通知，直到再次从未就绪变为就绪（缓冲区从不可读&#x2F;写变为可读&#x2F;写）。</p>
</li>
<li><p>区别：边缘触发效率更高，减少了被重复触发的次数，函数不会返回大量用户程序可能不需要的文件描述符。</p>
</li>
<li><p>为什么边缘触发一定要用非阻塞（non-block）IO：避免由于一个描述符的阻塞读&#x2F;阻塞写操作让处理其它描述符的任务出现饥饿状态。</p>
</li>
</ul>
<h5 id="有哪些常见的IO模型？"><a href="#有哪些常见的IO模型？" class="headerlink" title="有哪些常见的IO模型？"></a>有哪些常见的IO模型？</h5><ul>
<li><p>同步阻塞IO（Blocking IO）：用户线程发起IO读&#x2F;写操作之后，线程阻塞，直到可以开始处理数据；对CPU资源的利用率不够。</p>
</li>
<li><p>同步非阻塞IO（Non-blocking IO）：发起IO请求之后可以立即返回，如果没有就绪的数据，需要不断地发起IO请求直到数据就绪；不断重复请求消耗了大量的CPU资源。</p>
</li>
<li><p>IO多路复用</p>
</li>
<li><p>异步IO（Asynchronous IO）：用户线程发出IO请求之后，继续执行，由内核进行数据的读取并放在用户指定的缓冲区内，在IO完成之后通知用户线程直接使用。</p>
</li>
</ul>
<h4 id="什么是用户态和内核态？"><a href="#什么是用户态和内核态？" class="headerlink" title="什么是用户态和内核态？"></a>什么是用户态和内核态？</h4><p>为了限制不同程序的访问能力，防止一些程序访问其它程序的内存数据，CPU划分了用户态和内核态两个权限等级。</p>
<ul>
<li>用户态只能受限地访问内存，且不允许访问外围设备，没有占用CPU的能力，CPU资源可以被其它程序获取；</li>
<li>内核态可以访问内存所有数据以及外围设备，也可以进行程序的切换。</li>
</ul>
<p>所有用户程序都运行在用户态，但有时需要进行一些内核态的操作，比如从硬盘或者键盘读数据，这时就需要进行系统调用，使用陷阱指令，CPU切换到内核态，执行相应的服务，再切换为用户态并返回系统调用的结果。</p>
<h5 id="为什么要分用户态和内核态？"><a href="#为什么要分用户态和内核态？" class="headerlink" title="为什么要分用户态和内核态？"></a>为什么要分用户态和内核态？</h5><ul>
<li>安全性：防止用户程序恶意或者不小心破坏系统&#x2F;内存&#x2F;硬件资源；</li>
<li>封装性：用户程序不需要实现更加底层的代码；</li>
<li>利于调度：如果多个用户程序都在等待键盘输入，这时就需要进行调度，统一交给操作系统调度更加方便。</li>
</ul>
<h5 id="如何从用户态切换到内核态？"><a href="#如何从用户态切换到内核态？" class="headerlink" title="如何从用户态切换到内核态？"></a>如何从用户态切换到内核态？</h5><ul>
<li>系统调用：比如读取命令行输入。本质上还是通过中断实现。</li>
<li>用户程序发生异常时：比如缺页异常。</li>
<li>外围设备的中断：外围设备完成用户请求的操作之后，会向CPU发出中断信号，这时CPU会转去处理对应的中断处理程序。</li>
</ul>
<h4 id="什么是死锁？"><a href="#什么是死锁？" class="headerlink" title="什么是死锁？"></a>什么是死锁？</h4><p>在两个或者多个并发进程中，每个进程持有某种资源而又等待其它进程释放它们现在保持着的资源，在未改变这种状态之前都不能向前推进，称这一组进程产生了死锁(deadlock)。</p>
<h5 id="死锁产生的必要条件？"><a href="#死锁产生的必要条件？" class="headerlink" title="死锁产生的必要条件？"></a>死锁产生的必要条件？</h5><ul>
<li>互斥：一个资源一次只能被一个进程使用；</li>
<li>占有并等待：一个进程至少占有一个资源，并在等待另一个被其它进程占用的资源；</li>
<li>非抢占：已经分配给一个进程的资源不能被强制性抢占，只能由进程完成任务之后自愿释放；</li>
<li>循环等待：若干进程之间形成一种头尾相接的环形等待资源关系，该环路中的每个进程都在等待下一个进程所占有的资源。</li>
</ul>
<h5 id="死锁有哪些处理方法？"><a href="#死锁有哪些处理方法？" class="headerlink" title="死锁有哪些处理方法？"></a>死锁有哪些处理方法？</h5><p><strong>鸵鸟策略</strong></p>
<p>直接忽略死锁。因为解决死锁问题的代价很高，因此鸵鸟策略这种不采取任务措施的方案会获得更高的性能。当发生死锁时不会对用户造成多大影响，或发生死锁的概率很低，可以采用鸵鸟策略。</p>
<p><strong>死锁预防</strong></p>
<p>基本思想是破坏形成死锁的四个必要条件：</p>
<ul>
<li><p>破坏互斥条件：允许某些资源同时被多个进程访问。但是有些资源本身并不具有这种属性，因此这种方案实用性有限；</p>
</li>
<li><p>破坏占有并等待条件：</p>
<ul>
<li>实行资源预先分配策略（当一个进程开始运行之前，必须一次性向系统申请它所需要的全部资源，否则不运行）；</li>
<li>或者只允许进程在没有占用资源的时候才能申请资源（申请资源前先释放占有的资源）；</li>
<li>缺点：很多时候无法预知一个进程所需的全部资源；同时，会降低资源利用率，降低系统的并发性。</li>
</ul>
</li>
<li><p>破坏非抢占条件：允许进程强行抢占被其它进程占有的资源。会降低系统性能；</p>
</li>
<li><p>破坏循环等待条件：对所有资源统一编号，所有进程对资源的请求必须按照序号递增的顺序提出，即只有占有了编号较小的资源才能申请编号较大的资源。这样避免了占有大号资源的进程去申请小号资源。</p>
</li>
</ul>
<p><strong>死锁避免</strong></p>
<p>动态地检测资源分配状态，以确保系统处于安全状态，只有处于安全状态时才会进行资源的分配。所谓安全状态是指：即使所有进程突然请求需要的所有资源，也能存在某种对进程的资源分配顺序，使得每一个进程运行完毕。</p>
<p>银行家算法</p>
<p><strong>死锁解除</strong></p>
<p>如何检测死锁：检测有向图是否存在环；或者使用类似死锁避免的检测算法。</p>
<p>死锁解除的方法：</p>
<ul>
<li><p>利用抢占：挂起某些进程，并抢占它的资源。但应防止某些进程被长时间挂起而处于饥饿状态；</p>
</li>
<li><p>利用回滚：让某些进程回退到足以解除死锁的地步，进程回退时自愿释放资源。要求系统保持进程的历史信息，设置还原点；</p>
</li>
<li><p>利用杀死进程：强制杀死某些进程直到死锁解除为止，可以按照优先级进行。</p>
</li>
</ul>
<h5 id="银行家算法"><a href="#银行家算法" class="headerlink" title="银行家算法"></a>银行家算法</h5><p><strong>概念</strong></p>
<p>银行家算法（ banker’s algorithm ）由 Dijkstra于1965提出，关键是将死锁的问题演示为一个银行家贷款的模型，由于能用于银行系统的现金贷款而出名。一个银行家向一群客户发放信用卡，每个客户有不同的信用额度。每个客户可以提出信用额度内的任意额度的请求，直到额度用完后再一次性还款。银行家承诺每个客户最终都能获得自己需要的额度。所谓“最终”，是说银行家可以先挂起某个额度请求较大的客户的请求，优先满足小额度的请求，等小额度的请求还款后，再处理挂起的请求。这样，资金能够永远流通。所以银行家算法其核心是：保证银行家系统的资源数至少不小于一个客户的所需要的资源数。</p>
<p><strong>算法原理</strong></p>
<p>银行家算法的基本思想是分配资源之前，判断系统是否是安全的；若是，才分配。每分配一次资源就测试一次是否安全，不是资源全部就位后才测试，注意理解checkError函数的循环顺序。</p>
<p> 我们可以把操作系统看作是银行家，操作系统管理的资源相当于银行家管理的资金，进程向操作系统请求分配资源相当于用户向银行家贷款。 为保证资金的安全，银行家规定：</p>
<ol>
<li><p>当一个顾客对资金的最大需求量不超过银行家现有的资金时就可接纳该顾客(试探性分配)；</p>
</li>
<li><p>顾客可以分期贷款，但贷款的总数不能超过最大需求量(可能一次并不能满足所需要的全部资源)；</p>
</li>
<li><p>当银行家现有的资金不能满足顾客尚需的贷款数额时，对顾客的贷款可推迟支付，但总能使顾客在有限的时间里得到贷款(不存在死锁)</p>
</li>
<li><p>当顾客得到所需的全部资金后，一定能在有限的时间里归还所有的资金(运行后释放)。</p>
</li>
</ol>
<p>操作系统按照银行家制定的规则为进程分配资源，当进程首次申请资源时，要测试该进程对资源的最大需求量，如果系统现存的资源可以满足它的最大需求量则按当前的申请量分配资源，否则就推迟分配。当进程在执行中继续申请资源时，先测试该进程本次申请的资源数是否超过了该资源所剩余的总量。若超过则拒绝分配资源，若能存在安全状态，则按当前的申请量分配资源，否则也要推迟分配。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">  <span class="number">1</span>:<span class="keyword">import</span> java.util.Arrays;</span><br><span class="line">  <span class="number">2</span>: <span class="keyword">import</span> javax.swing.JOptionPane;</span><br><span class="line">  <span class="number">3</span>: </span><br><span class="line">  <span class="number">4</span>: <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Banker</span> &#123;</span><br><span class="line">  <span class="number">5</span>: </span><br><span class="line">  <span class="number">6</span>:   <span class="comment">/*</span></span><br><span class="line"><span class="comment">  7:    * 资源向量必须全部设置成static，因为可能</span></span><br><span class="line"><span class="comment">  8:    * 同一个线程多次输入才满足条件</span></span><br><span class="line"><span class="comment">  9:    */</span></span><br><span class="line"> <span class="number">10</span>:   <span class="comment">//每个线程需要的资源数</span></span><br><span class="line"> <span class="number">11</span>:   <span class="keyword">static</span> <span class="type">int</span> max[][] = &#123; &#123; <span class="number">7</span>, <span class="number">5</span>, <span class="number">3</span> &#125;, &#123; <span class="number">3</span>, <span class="number">2</span>, <span class="number">2</span> &#125;, &#123; <span class="number">9</span>, <span class="number">0</span>, <span class="number">2</span> &#125;,</span><br><span class="line"> <span class="number">12</span>:     &#123; <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span> &#125;, &#123; <span class="number">4</span>, <span class="number">3</span>, <span class="number">3</span> &#125; &#125;;</span><br><span class="line"> <span class="number">13</span>:   <span class="comment">//系统可用资源数</span></span><br><span class="line"> <span class="number">14</span>:   <span class="keyword">static</span> <span class="type">int</span> avaliable[] = &#123;<span class="number">10</span>,<span class="number">5</span>,<span class="number">7</span>&#125;;</span><br><span class="line"> <span class="number">15</span>:   <span class="comment">//已经分配资源</span></span><br><span class="line"> <span class="number">16</span>:   <span class="keyword">static</span> <span class="type">int</span> allocation[][] = &#123; &#123; <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span> &#125;, &#123; <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span> &#125;, &#123; <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span> &#125;,</span><br><span class="line"> <span class="number">17</span>:     &#123; <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span> &#125;, &#123; <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span> &#125; &#125;;</span><br><span class="line"> <span class="number">18</span>:   <span class="comment">//每个进程还需要的资源数,初试一个资源也没分配；实际上应该等于max-avaliable</span></span><br><span class="line"> <span class="number">19</span>:   <span class="keyword">static</span> <span class="type">int</span> need[][] = Arrays.copyOf(max,max.length);</span><br><span class="line"> <span class="number">20</span>:   <span class="comment">//每次申请的资源数</span></span><br><span class="line"> <span class="number">21</span>:   <span class="keyword">static</span> <span class="type">int</span> request[] = &#123; <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span> &#125;;</span><br><span class="line"> <span class="number">22</span>:   <span class="comment">//NUM个线程，N种资源</span></span><br><span class="line"> <span class="number">23</span>:   <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">NUM</span> <span class="operator">=</span> <span class="number">5</span>, N = <span class="number">3</span>;</span><br><span class="line"> <span class="number">24</span>:   <span class="keyword">static</span> <span class="type">Function</span> <span class="variable">function</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Function</span>();</span><br><span class="line"> <span class="number">25</span>:   </span><br><span class="line"> <span class="number">26</span>:   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"> <span class="number">27</span>:     <span class="type">JOptionPane</span> <span class="variable">jpane</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JOptionPane</span>();</span><br><span class="line"> <span class="number">28</span>:     </span><br><span class="line"> <span class="number">29</span>:     <span class="comment">//是否进行模拟标志，没有布尔，因为从JOpotionpane输入</span></span><br><span class="line"> <span class="number">30</span>:     <span class="type">int</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"> <span class="number">31</span>:     </span><br><span class="line"> <span class="number">32</span>:     <span class="keyword">while</span>(<span class="number">1</span>==flag) &#123;</span><br><span class="line"> <span class="number">33</span>:       <span class="comment">/*</span></span><br><span class="line"><span class="comment"> 34:        * 用与判断线程号是否合法</span></span><br><span class="line"><span class="comment"> 35:        * 需要放在while内部，防止下次继续模拟时i还是上次输入的</span></span><br><span class="line"><span class="comment"> 36:        */</span></span><br><span class="line"> <span class="number">37</span>:       <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line"> <span class="number">38</span>:       <span class="keyword">while</span>(i&lt;<span class="number">0</span>||i&gt;=NUM) &#123;</span><br><span class="line"> <span class="number">39</span>:         <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> jpane.showInputDialog(<span class="string">&quot;输入申请资源的线程号(0到4)：&quot;</span>);</span><br><span class="line"> <span class="number">40</span>:         i = Integer.parseInt(str);</span><br><span class="line"> <span class="number">41</span>:         <span class="keyword">if</span>(i&lt;<span class="number">0</span>||i&gt;=NUM) &#123;</span><br><span class="line"> <span class="number">42</span>:           JOptionPane.showMessageDialog(jpane, <span class="string">&quot;输入的线程号不合法！！！&quot;</span>);</span><br><span class="line"> <span class="number">43</span>:         &#125;</span><br><span class="line"> <span class="number">44</span>:       &#125;</span><br><span class="line"> <span class="number">45</span>:       <span class="comment">//资源输入有效性标志</span></span><br><span class="line"> <span class="number">46</span>:       <span class="type">boolean</span> <span class="variable">tag</span> <span class="operator">=</span> <span class="literal">true</span>; </span><br><span class="line"> <span class="number">47</span>:       <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>; j&lt;N; j++) &#123;</span><br><span class="line"> <span class="number">48</span>:         <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> jpane.showInputDialog(<span class="string">&quot;输入线程&quot;</span>+i+<span class="string">&quot;所申请的资源&quot;</span>+j+<span class="string">&quot;数目：&quot;</span>);</span><br><span class="line"> <span class="number">49</span>:         request[j] = Integer.parseInt(str);</span><br><span class="line"> <span class="number">50</span>:         <span class="comment">//有效性检查</span></span><br><span class="line"> <span class="number">51</span>:         <span class="keyword">if</span>(request[j]&gt;need[i][j]) &#123;</span><br><span class="line"> <span class="number">52</span>:           JOptionPane.showMessageDialog(jpane, <span class="string">&quot;输入的资源数大于需要资源数！！！&quot;</span>);</span><br><span class="line"> <span class="number">53</span>:           tag = <span class="literal">false</span>;</span><br><span class="line"> <span class="number">54</span>:           <span class="keyword">break</span>;</span><br><span class="line"> <span class="number">55</span>:         &#125;<span class="keyword">else</span> &#123;</span><br><span class="line"> <span class="number">56</span>:           <span class="keyword">if</span>(request[j]&gt;avaliable[j]) &#123;</span><br><span class="line"> <span class="number">57</span>:             JOptionPane.showMessageDialog(jpane, <span class="string">&quot;输入的资源数大于可用资源数！！！&quot;</span>);</span><br><span class="line"> <span class="number">58</span>:             tag = <span class="literal">false</span>;</span><br><span class="line"> <span class="number">59</span>:             <span class="keyword">break</span>;</span><br><span class="line"> <span class="number">60</span>:           &#125;</span><br><span class="line"> <span class="number">61</span>:         &#125;</span><br><span class="line"> <span class="number">62</span>:       &#125;</span><br><span class="line"> <span class="number">63</span>:       <span class="comment">//是否存在安全序列</span></span><br><span class="line"> <span class="number">64</span>:       <span class="type">boolean</span> <span class="variable">vis</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line"> <span class="number">65</span>:       <span class="keyword">if</span>(tag) &#123;</span><br><span class="line"> <span class="number">66</span>:         function.allocateK(i);</span><br><span class="line"> <span class="number">67</span>:         vis = function.checkError(i);</span><br><span class="line"> <span class="number">68</span>:         <span class="keyword">if</span>(<span class="literal">false</span>==vis) &#123;</span><br><span class="line"> <span class="number">69</span>:           <span class="comment">//上面调用了allocateK，所以不仅需要释放，还需要恢复</span></span><br><span class="line"> <span class="number">70</span>:           function.freeKAndRestore(i);</span><br><span class="line"> <span class="number">71</span>:         &#125;<span class="keyword">else</span> &#123;</span><br><span class="line"> <span class="number">72</span>:           <span class="comment">//测试是否全部资源到位</span></span><br><span class="line"> <span class="number">73</span>:           <span class="type">boolean</span> <span class="variable">f</span> <span class="operator">=</span> function.checkRun(i);</span><br><span class="line"> <span class="number">74</span>:           <span class="keyword">if</span>(<span class="literal">true</span>==f) &#123;</span><br><span class="line"> <span class="number">75</span>:             JOptionPane.showMessageDialog(jpane</span><br><span class="line"> <span class="number">76</span>:                 ,<span class="string">&quot;进程&quot;</span>+i+<span class="string">&quot;全部资源到位！！！&quot;</span>+<span class="string">&quot;\n&quot;</span>+<span class="string">&quot;即将释放所占用资源&quot;</span>);</span><br><span class="line"> <span class="number">77</span>:             function.freeKNotRestore(i);</span><br><span class="line"> <span class="number">78</span>:           &#125;</span><br><span class="line"> <span class="number">79</span>:         &#125;</span><br><span class="line"> <span class="number">80</span>:       &#125;<span class="keyword">else</span> &#123;</span><br><span class="line"> <span class="number">81</span>:         <span class="comment">//实际上没必要清空，因为该数组是输入的，只为了展示一种良好习惯</span></span><br><span class="line"> <span class="number">82</span>:         Arrays.fill(request,<span class="number">0</span>);</span><br><span class="line"> <span class="number">83</span>:       &#125;</span><br><span class="line"> <span class="number">84</span>:       <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> JOptionPane.showInputDialog(<span class="string">&quot;是否继续模拟(1表示是，0退出)？&quot;</span>);</span><br><span class="line"> <span class="number">85</span>:       flag = Integer.parseInt(str);</span><br><span class="line"> <span class="number">86</span>:     &#125;</span><br><span class="line"> <span class="number">87</span>:   &#125;</span><br><span class="line"> <span class="number">88</span>: &#125;</span><br><span class="line"> <span class="number">89</span>: </span><br><span class="line"> <span class="number">90</span>: <span class="keyword">class</span> <span class="title class_">Function</span> &#123;</span><br><span class="line"> <span class="number">91</span>:   <span class="comment">/*</span></span><br><span class="line"><span class="comment"> 92:    * 实际上完全是静态的，没必要新new一个Banker</span></span><br><span class="line"><span class="comment"> 93:    */</span></span><br><span class="line"> <span class="number">94</span>:   <span class="type">Banker</span> <span class="variable">banker</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Banker</span>();</span><br><span class="line"> <span class="number">95</span>:   <span class="comment">//为线程k分配资源</span></span><br><span class="line"> <span class="number">96</span>:   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">allocateK</span><span class="params">(<span class="type">int</span> k)</span> &#123;</span><br><span class="line"> <span class="number">97</span>:     <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;banker.N; i++) &#123;</span><br><span class="line"> <span class="number">98</span>:       banker.avaliable[i] -= banker.request[i];</span><br><span class="line"> <span class="number">99</span>:       banker.need[k][i] -= banker.request[i];</span><br><span class="line"><span class="number">100</span>:       banker.allocation[k][i] += banker.request[i];</span><br><span class="line"><span class="number">101</span>:     &#125;</span><br><span class="line"><span class="number">102</span>:   &#125;</span><br><span class="line"><span class="number">103</span>:   <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">checkError</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line"><span class="number">104</span>:     <span class="type">int</span> <span class="variable">work</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="number">105</span>:     <span class="comment">//存储所有线程是否安全</span></span><br><span class="line"><span class="number">106</span>:     <span class="type">boolean</span>[] finish = <span class="keyword">new</span> <span class="title class_">boolean</span>[banker.NUM];</span><br><span class="line"><span class="number">107</span>:     Arrays.fill(finish,<span class="literal">false</span>);</span><br><span class="line"><span class="number">108</span>:     <span class="comment">//存储一个安全序列</span></span><br><span class="line"><span class="number">109</span>:     <span class="type">int</span> temp[] = <span class="keyword">new</span> <span class="title class_">int</span>[banker.NUM];</span><br><span class="line"><span class="number">110</span>:     Arrays.fill(temp,<span class="number">0</span>);</span><br><span class="line"><span class="number">111</span>:     <span class="comment">//temp数组下标</span></span><br><span class="line"><span class="number">112</span>:     <span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="number">113</span>:     </span><br><span class="line"><span class="number">114</span>:     <span class="comment">//线程号参数是i</span></span><br><span class="line"><span class="number">115</span>:     <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>; j&lt;banker.N; j++) &#123;</span><br><span class="line"><span class="number">116</span>:       work = banker.avaliable[j];</span><br><span class="line"><span class="number">117</span>:       <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> i;</span><br><span class="line"><span class="number">118</span>:       </span><br><span class="line"><span class="number">119</span>:       <span class="keyword">while</span>(k&lt;banker.NUM) &#123;</span><br><span class="line"><span class="number">120</span>:         <span class="keyword">if</span>(finish[k]==<span class="literal">false</span>&amp;&amp;work&gt;=banker.need[k][j]) &#123;</span><br><span class="line"><span class="number">121</span>:           <span class="comment">/*</span></span><br><span class="line"><span class="comment">122:            *  注意不是max数组，因为此时线程k</span></span><br><span class="line"><span class="comment">123:            *  所需资源不一定完全就位</span></span><br><span class="line"><span class="comment">124:            *  加的是allocation，因为进行此项检查前先试探性地</span></span><br><span class="line"><span class="comment">125:            *  分配给线程k资源了</span></span><br><span class="line"><span class="comment">126:            */</span></span><br><span class="line"><span class="number">127</span>:           <span class="comment">//满足该线程，回收该项资源，看是否满足其它线程</span></span><br><span class="line"><span class="number">128</span>:           work += banker.allocation[k][j];</span><br><span class="line"><span class="number">129</span>:           finish[k] = <span class="literal">true</span>;</span><br><span class="line"><span class="number">130</span>:           temp[t++] = k;</span><br><span class="line"><span class="number">131</span>:           k = <span class="number">0</span>;</span><br><span class="line"><span class="number">132</span>:           </span><br><span class="line"><span class="number">133</span>:         &#125;<span class="keyword">else</span> &#123;</span><br><span class="line"><span class="number">134</span>:           k++;</span><br><span class="line"><span class="number">135</span>:         &#125;</span><br><span class="line"><span class="number">136</span>:       &#125;</span><br><span class="line"><span class="number">137</span>:       <span class="comment">//和while平级</span></span><br><span class="line"><span class="number">138</span>:       <span class="keyword">for</span>(<span class="type">int</span> p=<span class="number">0</span>; p&lt;banker.NUM; p++) &#123;</span><br><span class="line"><span class="number">139</span>:         <span class="keyword">if</span>(finish[p]==<span class="literal">false</span>) &#123;</span><br><span class="line"><span class="number">140</span>:           <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="number">141</span>:         &#125;</span><br><span class="line"><span class="number">142</span>:       &#125;</span><br><span class="line"><span class="number">143</span>:     &#125;</span><br><span class="line"><span class="number">144</span>:     <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="number">145</span>:   &#125;</span><br><span class="line"><span class="number">146</span>:   <span class="comment">//释放线程k所占用资源并恢复</span></span><br><span class="line"><span class="number">147</span>:   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">freeKAndRestore</span><span class="params">(<span class="type">int</span> k)</span> &#123;</span><br><span class="line"><span class="number">148</span>:     <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;banker.N; i++) &#123;</span><br><span class="line"><span class="number">149</span>:       banker.avaliable[i] += banker.request[i];</span><br><span class="line"><span class="number">150</span>:       banker.need[k][i] += banker.request[i];</span><br><span class="line"><span class="number">151</span>:       banker.allocation[k][i] -= banker.request[i];</span><br><span class="line"><span class="number">152</span>:     &#125;</span><br><span class="line"><span class="number">153</span>:   &#125;</span><br><span class="line"><span class="number">154</span>:   <span class="comment">//仅仅释放线程k所占用资源，仅在某线程全部得到资源运行后才调用</span></span><br><span class="line"><span class="number">155</span>:   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">freeKNotRestore</span><span class="params">(<span class="type">int</span> k)</span> &#123;</span><br><span class="line"><span class="number">156</span>:     <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;banker.N; i++) &#123;</span><br><span class="line"><span class="number">157</span>:       banker.avaliable[i] = banker.avaliable[i] + banker.allocation[k][i];</span><br><span class="line"><span class="number">158</span>:     &#125;</span><br><span class="line"><span class="number">159</span>:   &#125;</span><br><span class="line"><span class="number">160</span>:   <span class="comment">//三种资源是否全部到位</span></span><br><span class="line"><span class="number">161</span>:   <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">checkRun</span><span class="params">(<span class="type">int</span> k)</span> &#123;</span><br><span class="line"><span class="number">162</span>:     <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="number">163</span>:     <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;banker.N; i++) &#123;</span><br><span class="line"><span class="number">164</span>:       <span class="keyword">if</span> (banker.need[k][i] == <span class="number">0</span>)</span><br><span class="line"><span class="number">165</span>:         n++;</span><br><span class="line"><span class="number">166</span>:     &#125;</span><br><span class="line"><span class="number">167</span>:     <span class="keyword">if</span> (n == <span class="number">3</span>)</span><br><span class="line"><span class="number">168</span>:       <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="number">169</span>:     <span class="keyword">else</span></span><br><span class="line"><span class="number">170</span>:       <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="number">171</span>:   &#125;</span><br><span class="line"><span class="number">172</span>: &#125;</span><br></pre></td></tr></table></figure>

<h4 id="分页和分段有什么区别？"><a href="#分页和分段有什么区别？" class="headerlink" title="分页和分段有什么区别？"></a>分页和分段有什么区别？</h4><ul>
<li><p>页式存储：用户空间划分为大小相等的部分称为页（page），内存空间划分为同样大小的区域称为页框，分配时以页为单位，按进程需要的页数分配，逻辑上相邻的页物理上不一定相邻。</p>
</li>
<li><p>段式存储：用户进程地址空间按照自身逻辑关系划分为若干个段（segment）（如代码段，数据段，堆栈段），内存空间被动态划分为长度不同的区域，分配时以段为单位，每段在内存中占据连续空间，各段可以不相邻。</p>
</li>
<li><p>段页式存储：用户进程先按段划分，段内再按页划分，内存划分和分配按页。</p>
</li>
</ul>
<p>区别：</p>
<ul>
<li><p>目的不同：分页的目的是管理内存，用于虚拟内存以获得更大的地址空间；分段的目的是满足用户的需要，使程序和数据可以被划分为逻辑上独立的地址空间；</p>
</li>
<li><p>大小不同：段的大小不固定，由其所完成的功能决定；页的大小固定，由系统决定；</p>
</li>
<li><p>地址空间维度不同：分段是二维地址空间（段号+段内偏移），分页是一维地址空间（每个进程一个页表&#x2F;多级页表，通过一个逻辑地址就能找到对应的物理地址）；</p>
</li>
<li><p>分段便于信息的保护和共享；分页的共享受到限制；</p>
</li>
<li><p>碎片：分段没有内碎片，但会产生外碎片；分页没有外碎片，但会产生内碎片（一个页填不满）。</p>
</li>
</ul>
<h4 id="什么是虚拟内存？"><a href="#什么是虚拟内存？" class="headerlink" title="什么是虚拟内存？"></a>什么是虚拟内存？</h4><p>每个程序都拥有自己的地址空间，这个地址空间被分成大小相等的页，这些页被映射到物理内存，但不需要所有的页都在物理内存中，当程序引用到不在物理内存中的页时，由操作系统将缺失的部分装入物理内存。这样，对于程序来说，逻辑上似乎有很大的内存空间，只是实际上有一部分是存储在磁盘上，因此叫做虚拟内存。</p>
<p>虚拟内存的优点是让程序可以获得更多的可用内存。</p>
<p>虚拟内存的实现方式、页表&#x2F;多级页表、缺页中断、不同的页面淘汰算法：答案。</p>
<h5 id="如何进行地址空间到物理内存的映射？"><a href="#如何进行地址空间到物理内存的映射？" class="headerlink" title="如何进行地址空间到物理内存的映射？"></a>如何进行地址空间到物理内存的映射？</h5><p>内存管理单元（MMU）管理着逻辑地址和物理地址的转换，其中的页表（Page table）存储着页（逻辑地址）和页框（物理内存空间）的映射表，页表中还包含包含有效位（是在内存还是磁盘）、访问位（是否被访问过）、修改位（内存中是否被修改过）、保护位（只读还是可读写）。逻辑地址：页号+页内地址（偏移）。每个进程一个页表，放在内存，页表起始地址在PCB&#x2F;寄存器中。</p>
<h5 id="有哪些页面置换算法？"><a href="#有哪些页面置换算法？" class="headerlink" title="有哪些页面置换算法？"></a>有哪些页面置换算法？</h5><p>在程序运行过程中，如果要访问的页面不在内存中，就发生缺页中断从而将该页调入内存中。此时如果内存已无空闲空间，系统必须从内存中调出一个页面到磁盘中来腾出空间。页面置换算法的主要目标是使页面置换频率最低（也可以说缺页率最低）。</p>
<ul>
<li><p>最佳页面置换算法OPT（Optimal replacement algorithm）：置换以后不需要或者最远的将来才需要的页面，是一种理论上的算法，是最优策略。</p>
</li>
<li><p>先进先出FIFO：置换在内存中驻留时间最长的页面。缺点：有可能将那些经常被访问的页面也被换出，从而使缺页率升高。</p>
</li>
<li><p>第二次机会算法SCR：按FIFO选择某一页面，若其访问位为1，给第二次机会，并将访问位置0。</p>
</li>
<li><p>时钟算法 Clock：SCR中需要将页面在链表中移动（第二次机会的时候要将这个页面从链表头移到链表尾），时钟算法使用环形链表，再使用一个指针指向最老的页面，避免了移动页面的开销。</p>
</li>
<li><p>最近未使用算法NRU（Not Recently Used）：检查访问位R、修改位M，优先置换R&#x3D;M&#x3D;0，其次是（R&#x3D;0, M&#x3D;1）。</p>
</li>
<li><p>最近最少使用算法LRU（Least Recently Used）：置换出未使用时间最长的一页；实现方式：维护时间戳，或者维护一个所有页面的链表。当一个页面被访问时，将这个页面移到链表表头。这样就能保证链表表尾的页面是最近最久未访问的。</p>
</li>
<li><p>最不经常使用算法NFU：置换出访问次数最少的页面。</p>
</li>
</ul>
<p><strong>局部性原理</strong></p>
<ul>
<li>时间上：最近被访问的页在不久的将来还会被访问；</li>
<li>空间上：内存中被访问的页周围的页也很可能被访问。</li>
</ul>
<p><strong>什么是颠簸现象</strong></p>
<p>颠簸本质上是指频繁的页调度行为。进程发生缺页中断时必须置换某一页。然而，其他所有的页都在使用，它置换一个页，但又立刻再次需要这个页。因此会不断产生缺页中断，导致整个系统的效率急剧下降，这种现象称为颠簸。内存颠簸的解决策略包括：</p>
<ul>
<li>修改页面置换算法；</li>
<li>降低同时运行的程序的数量；</li>
<li>终止该进程或增加物理内存容量。</li>
</ul>
<h4 id="缓冲区溢出问题"><a href="#缓冲区溢出问题" class="headerlink" title="缓冲区溢出问题"></a>缓冲区溢出问题</h4><h5 id="什么是缓冲区溢出"><a href="#什么是缓冲区溢出" class="headerlink" title="什么是缓冲区溢出?"></a>什么是缓冲区溢出?</h5><p>C 语言使用运行时栈来存储过程信息。每个函数的信息存储在一个栈帧中，包括寄存器、局部变量、参数、返回地址等。C 对于数组引用不进行任何边界检查，因此对越界的数组元素的写操作会破坏存储在栈中的状态信息，这种现象称为缓冲区溢出。缓冲区溢出会破坏程序运行，也可以被用来进行攻击计算机，如使用一个指向攻击代码的指针覆盖返回地址。</p>
<h5 id="缓冲区溢出的防范方式"><a href="#缓冲区溢出的防范方式" class="headerlink" title="缓冲区溢出的防范方式"></a>缓冲区溢出的防范方式</h5><p>防范缓冲区溢出攻击的机制有三种：随机化、栈保护和限制可执行代码区域。</p>
<ul>
<li><p>随机化：包括栈随机化（程序开始时在栈上分配一段随机大小的空间）和地址空间布局随机化（Address-Space Layout Randomization，ASLR，即每次运行时程序的不同部分，包括代码段、数据段、栈、堆等都会被加载到内存空间的不同区域），但只能增加攻击一个系统的难度，不能完全保证安全。</p>
</li>
<li><p>栈保护：在每个函数的栈帧的局部变量和栈状态之间存储一个随机产生的特殊的值，称为金丝雀值（canary）。在恢复寄存器状态和函数返回之前，程序检测这个金丝雀值是否被改变了，如果是，那么程序异常终止。</p>
</li>
<li><p>限制可执行代码区域：内存页的访问形式有三种：可读、可写、可执行，只有编译器产生的那部分代码所处的内存才是可执行的，其他页限制为只允许读和写。</p>
</li>
</ul>
<h4 id="磁盘调度"><a href="#磁盘调度" class="headerlink" title="磁盘调度"></a>磁盘调度</h4><p>过程：磁头（找到对应的盘面）；磁道（一个盘面上的同心圆环，寻道时间）；扇区（旋转时间）。为减小寻道时间的调度算法：</p>
<ul>
<li>先来先服务</li>
<li>最短寻道时间优先</li>
<li>电梯算法：电梯总是保持一个方向运行，直到该方向没有请求为止，然后改变运行方向。</li>
</ul>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
  </entry>
  <entry>
    <title>java基础知识-泛型机制详解 - java</title>
    <url>/2022/05/25/2022-05-25-java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86-%E6%B3%9B%E5%9E%8B%E6%9C%BA%E5%88%B6%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<h1 id="泛型机制详解"><a href="#泛型机制详解" class="headerlink" title="泛型机制详解"></a>泛型机制详解</h1><span id="more"></span>

<h3 id="为什么会引入泛型"><a href="#为什么会引入泛型" class="headerlink" title="为什么会引入泛型"></a>为什么会引入泛型</h3><p>泛型的本质是为了参数化类型（在不创建新的类型的情况下，通过泛型指定的不同类型来控制形参具体限制的类型）。也就是说在泛型使用过程中，操作的数据类型被指定为一个参数，这种参数类型可以用在类、接口和方法中，分别被称为泛型类、泛型接口、泛型方法。</p>
<p>引入泛型的意义在于：</p>
<ul>
<li><strong>适用于多种数据类型执行相同的代码</strong>（代码复用）</li>
</ul>
<p>我们通过一个例子来阐述，先看下下面的代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">    System.out.println(a + <span class="string">&quot;+&quot;</span> + b + <span class="string">&quot;=&quot;</span> + (a + b));</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">float</span> <span class="title function_">add</span><span class="params">(<span class="type">float</span> a, <span class="type">float</span> b)</span> &#123;</span><br><span class="line">    System.out.println(a + <span class="string">&quot;+&quot;</span> + b + <span class="string">&quot;=&quot;</span> + (a + b));</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">double</span> <span class="title function_">add</span><span class="params">(<span class="type">double</span> a, <span class="type">double</span> b)</span> &#123;</span><br><span class="line">    System.out.println(a + <span class="string">&quot;+&quot;</span> + b + <span class="string">&quot;=&quot;</span> + (a + b));</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果没有泛型，要实现不同类型的加法，每种类型都需要重载一个add方法；通过泛型，我们可以复用为一个方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> &lt;T <span class="keyword">extends</span> <span class="title class_">Number</span>&gt; <span class="type">double</span> <span class="title function_">add</span><span class="params">(T a, T b)</span> &#123;</span><br><span class="line">    System.out.println(a + <span class="string">&quot;+&quot;</span> + b + <span class="string">&quot;=&quot;</span> + (a.doubleValue() + b.doubleValue()));</span><br><span class="line">    <span class="keyword">return</span> a.doubleValue() + b.doubleValue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>泛型中的类型在使用时指定，不需要强制类型转换（<strong>类型安全</strong>，编译器会<strong>检查类型</strong>）</li>
</ul>
<p>看下这个例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">List</span> <span class="variable">list</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">list.add(<span class="string">&quot;xxString&quot;</span>);</span><br><span class="line">list.add(<span class="number">100d</span>);</span><br><span class="line">list.add(<span class="keyword">new</span> <span class="title class_">Person</span>());</span><br></pre></td></tr></table></figure>

<p>我们在使用上述list中，list中的元素都是Object类型（无法约束其中的类型），所以在取出集合元素时需要人为的强制类型转化到具体的目标类型，且很容易出现<code>java.lang.ClassCastException</code>异常。</p>
<p>引入泛型，它将提供类型的约束，提供编译前的检查：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">// list中只能放String, 不能放其它类型的元素</span></span><br></pre></td></tr></table></figure>

<h3 id="泛型的基本使用"><a href="#泛型的基本使用" class="headerlink" title="泛型的基本使用"></a>泛型的基本使用</h3><h4 id="泛型类"><a href="#泛型类" class="headerlink" title="泛型类"></a>泛型类</h4><p>从一个简单的泛型类看起：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span>&lt;T&gt;&#123;         <span class="comment">// 此处可以随便写标识符号，T是type的简称  </span></span><br><span class="line">    <span class="keyword">private</span> T <span class="keyword">var</span> ;     <span class="comment">// var的类型由T指定，即：由外部指定  </span></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">getVar</span><span class="params">()</span>&#123;  <span class="comment">// 返回值的类型由外部决定  </span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">var</span> ;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setVar</span><span class="params">(T <span class="keyword">var</span>)</span>&#123;  <span class="comment">// 设置的类型也由外部决定  </span></span><br><span class="line">        <span class="built_in">this</span>.<span class="keyword">var</span> = <span class="keyword">var</span> ;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GenericsDemo06</span>&#123;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span>&#123;  </span><br><span class="line">        Point&lt;String&gt; p = <span class="keyword">new</span> <span class="title class_">Point</span>&lt;String&gt;() ;     <span class="comment">// 里面的var类型为String类型  </span></span><br><span class="line">        p.setVar(<span class="string">&quot;it&quot;</span>) ;                            <span class="comment">// 设置字符串  </span></span><br><span class="line">        System.out.println(p.getVar().length()) ;   <span class="comment">// 取得字符串的长度  </span></span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>多元泛型</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Notepad</span>&lt;K,V&gt;&#123;       <span class="comment">// 此处指定了两个泛型类型  </span></span><br><span class="line">    <span class="keyword">private</span> K key ;     <span class="comment">// 此变量的类型由外部决定  </span></span><br><span class="line">    <span class="keyword">private</span> V value ;   <span class="comment">// 此变量的类型由外部决定  </span></span><br><span class="line">    <span class="keyword">public</span> K <span class="title function_">getKey</span><span class="params">()</span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.key ;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">public</span> V <span class="title function_">getValue</span><span class="params">()</span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.value ;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setKey</span><span class="params">(K key)</span>&#123;  </span><br><span class="line">        <span class="built_in">this</span>.key = key ;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setValue</span><span class="params">(V value)</span>&#123;  </span><br><span class="line">        <span class="built_in">this</span>.value = value ;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GenericsDemo09</span>&#123;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span>&#123;  </span><br><span class="line">        Notepad&lt;String,Integer&gt; t = <span class="literal">null</span> ;        <span class="comment">// 定义两个泛型类型的对象  </span></span><br><span class="line">        t = <span class="keyword">new</span> <span class="title class_">Notepad</span>&lt;String,Integer&gt;() ;       <span class="comment">// 里面的key为String，value为Integer  </span></span><br><span class="line">        t.setKey(<span class="string">&quot;汤姆&quot;</span>) ;        <span class="comment">// 设置第一个内容  </span></span><br><span class="line">        t.setValue(<span class="number">20</span>) ;            <span class="comment">// 设置第二个内容  </span></span><br><span class="line">        System.out.print(<span class="string">&quot;姓名；&quot;</span> + t.getKey()) ;      <span class="comment">// 取得信息  </span></span><br><span class="line">        System.out.print(<span class="string">&quot;，年龄；&quot;</span> + t.getValue()) ;       <span class="comment">// 取得信息  </span></span><br><span class="line">  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="泛型接口"><a href="#泛型接口" class="headerlink" title="泛型接口"></a>泛型接口</h4><p>简单的泛型接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Info</span>&lt;T&gt;&#123;        <span class="comment">// 在接口上定义泛型  </span></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">getVar</span><span class="params">()</span> ; <span class="comment">// 定义抽象方法，抽象方法的返回值就是泛型类型  </span></span><br><span class="line">&#125;  </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">InfoImpl</span>&lt;T&gt; <span class="keyword">implements</span> <span class="title class_">Info</span>&lt;T&gt;&#123;   <span class="comment">// 定义泛型接口的子类  </span></span><br><span class="line">    <span class="keyword">private</span> T <span class="keyword">var</span> ;             <span class="comment">// 定义属性  </span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">InfoImpl</span><span class="params">(T <span class="keyword">var</span>)</span>&#123;     <span class="comment">// 通过构造方法设置属性内容  </span></span><br><span class="line">        <span class="built_in">this</span>.setVar(<span class="keyword">var</span>) ;    </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setVar</span><span class="params">(T <span class="keyword">var</span>)</span>&#123;  </span><br><span class="line">        <span class="built_in">this</span>.<span class="keyword">var</span> = <span class="keyword">var</span> ;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">getVar</span><span class="params">()</span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.<span class="keyword">var</span> ;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GenericsDemo24</span>&#123;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String arsg[])</span>&#123;  </span><br><span class="line">        Info&lt;String&gt; i = <span class="literal">null</span>;        <span class="comment">// 声明接口对象  </span></span><br><span class="line">        i = <span class="keyword">new</span> <span class="title class_">InfoImpl</span>&lt;String&gt;(<span class="string">&quot;汤姆&quot;</span>) ;  <span class="comment">// 通过子类实例化对象  </span></span><br><span class="line">        System.out.println(<span class="string">&quot;内容：&quot;</span> + i.getVar()) ;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<h4 id="泛型方法"><a href="#泛型方法" class="headerlink" title="泛型方法"></a>泛型方法</h4><p>泛型方法，是在调用方法的时候指明泛型的具体类型。</p>
<ul>
<li>定义泛型方法语法格式</li>
</ul>
<p><img src="/../images/note33.png" alt="note33"></p>
<ul>
<li>调用泛型方法语法格式</li>
</ul>
<p><img src="/../images/note34.png" alt="note34"></p>
<p>说明一下，定义泛型方法时，必须在返回值前边加一个<code>&lt;T&gt;</code>，来声明这是一个泛型方法，持有一个泛型<code>T</code>，然后才可以用泛型T作为方法的返回值。</p>
<p><code>Class&lt;T&gt;</code>的作用就是指明泛型的具体类型，而<code>Class&lt;T&gt;</code>类型的变量c，可以用来创建泛型类的对象。</p>
<p>为什么要用变量c来创建对象呢？既然是泛型方法，就代表着我们不知道具体的类型是什么，也不知道构造方法如何，因此没有办法去new一个对象，但可以利用变量c的newInstance方法去创建对象，也就是利用反射创建对象。</p>
<p>泛型方法要求的参数是<code>Class&lt;T&gt;</code>类型，而<code>Class.forName()</code>方法的返回值也是<code>Class&lt;T&gt;</code>，因此可以用<code>Class.forName()</code>作为参数。其中，<code>forName()</code>方法中的参数是何种类型，返回的<code>Class&lt;T&gt;</code>就是何种类型。在本例中，<code>forName()</code>方法中传入的是User类的完整路径，因此返回的是<code>Class&lt;User&gt;</code>类型的对象，因此调用泛型方法时，变量c的类型就是<code>Class&lt;User&gt;</code>，因此泛型方法中的泛型T就被指明为User，因此变量obj的类型为User。</p>
<p>当然，泛型方法不是仅仅可以有一个参数<code>Class&lt;T&gt;</code>，可以根据需要添加其他参数。</p>
<p><strong>为什么要使用泛型方法呢</strong>？因为泛型类要在实例化的时候就指明类型，如果想换一种类型，不得不重新new一次，可能不够灵活；而泛型方法可以在调用的时候指明类型，更加灵活。</p>
<h4 id="泛型的上下限"><a href="#泛型的上下限" class="headerlink" title="泛型的上下限"></a>泛型的上下限</h4><ul>
<li><strong>先看下如下的代码，很明显是会报错的</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_">A</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如下两个方法不会报错</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">funA</span><span class="params">(A a)</span> &#123;</span><br><span class="line">    <span class="comment">// ...          </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">funB</span><span class="params">(B b)</span> &#123;</span><br><span class="line">    funA(b);</span><br><span class="line">    <span class="comment">// ...             </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如下funD方法会报错</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">funC</span><span class="params">(List&lt;A&gt; listA)</span> &#123;</span><br><span class="line">    <span class="comment">// ...          </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">funD</span><span class="params">(List&lt;B&gt; listB)</span> &#123;</span><br><span class="line">    funC(listB); <span class="comment">// Unresolved compilation problem: The method doPrint(List&lt;A&gt;) in the type test is not applicable for the arguments (List&lt;B&gt;)</span></span><br><span class="line">    <span class="comment">// ...             </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为了解决泛型中隐含的转换问题，Java泛型加入了类型参数的上下边界机制。<code>&lt;? extends A&gt;</code>表示该类型参数可以是A(上边界)或者A的子类类型。编译时擦除到类型A，即用A类型代替类型参数。这种方法可以解决开始遇到的问题，编译器知道类型参数的范围，如果传入的实例类型B是在这个范围内的话允许转换，这时只要一次类型转换就可以了，运行时会把对象当做A的实例看待。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">funC</span><span class="params">(List&lt;? extends A&gt; listA)</span> &#123;</span><br><span class="line">    <span class="comment">// ...          </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">funD</span><span class="params">(List&lt;B&gt; listB)</span> &#123;</span><br><span class="line">    funC(listB); <span class="comment">// OK</span></span><br><span class="line">    <span class="comment">// ...             </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>泛型上下限的引入</strong></li>
</ul>
<p>在使用泛型的时候，我们可以为传入的泛型类型实参进行上下边界的限制，如：类型实参只准传入某种类型的父类或某种类型的子类。</p>
<p>上限</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Info</span>&lt;T <span class="keyword">extends</span> <span class="title class_">Number</span>&gt;&#123;    <span class="comment">// 此处泛型只能是数字类型</span></span><br><span class="line">    <span class="keyword">private</span> T <span class="keyword">var</span> ;        <span class="comment">// 定义泛型变量</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setVar</span><span class="params">(T <span class="keyword">var</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.<span class="keyword">var</span> = <span class="keyword">var</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">getVar</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.<span class="keyword">var</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span>&#123;    <span class="comment">// 直接打印</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.<span class="keyword">var</span>.toString() ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">demo1</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span>&#123;</span><br><span class="line">        Info&lt;Integer&gt; i1 = <span class="keyword">new</span> <span class="title class_">Info</span>&lt;Integer&gt;() ;        <span class="comment">// 声明Integer的泛型对象</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下限</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Info</span>&lt;T&gt;&#123;</span><br><span class="line">    <span class="keyword">private</span> T <span class="keyword">var</span> ;        <span class="comment">// 定义泛型变量</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setVar</span><span class="params">(T <span class="keyword">var</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.<span class="keyword">var</span> = <span class="keyword">var</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">getVar</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.<span class="keyword">var</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span>&#123;    <span class="comment">// 直接打印</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.<span class="keyword">var</span>.toString() ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GenericsDemo21</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span>&#123;</span><br><span class="line">        Info&lt;String&gt; i1 = <span class="keyword">new</span> <span class="title class_">Info</span>&lt;String&gt;() ;        <span class="comment">// 声明String的泛型对象</span></span><br><span class="line">        Info&lt;Object&gt; i2 = <span class="keyword">new</span> <span class="title class_">Info</span>&lt;Object&gt;() ;        <span class="comment">// 声明Object的泛型对象</span></span><br><span class="line">        i1.setVar(<span class="string">&quot;hello&quot;</span>) ;</span><br><span class="line">        i2.setVar(<span class="keyword">new</span> <span class="title class_">Object</span>()) ;</span><br><span class="line">        fun(i1) ;</span><br><span class="line">        fun(i2) ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">fun</span><span class="params">(Info&lt;? <span class="built_in">super</span> String&gt; temp)</span>&#123;    <span class="comment">// 只能接收String或Object类型的泛型，String类的父类只有Object类</span></span><br><span class="line">        System.out.print(temp + <span class="string">&quot;, &quot;</span>) ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>小结</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;?&gt; 无限制通配符</span><br><span class="line">&lt;? <span class="keyword">extends</span> <span class="title class_">E</span>&gt; extends 关键字声明了类型的上界，表示参数化的类型可能是所指定的类型，或者是此类型的子类</span><br><span class="line">&lt;? <span class="built_in">super</span> E&gt; <span class="built_in">super</span> 关键字声明了类型的下界，表示参数化的类型可能是指定的类型，或者是此类型的父类</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用原则《Effictive Java》</span></span><br><span class="line"><span class="comment">// 为了获得最大限度的灵活性，要在表示 生产者或者消费者 的输入参数上使用通配符，使用的规则就是：生产者有上限、消费者有下限</span></span><br><span class="line"><span class="number">1.</span> 如果参数化类型表示一个 T 的生产者，使用 &lt; ? <span class="keyword">extends</span> <span class="title class_">T</span>&gt;;</span><br><span class="line"><span class="number">2.</span> 如果它表示一个 T 的消费者，就使用 &lt; ? <span class="built_in">super</span> T&gt;；</span><br><span class="line"><span class="number">3.</span> 如果既是生产又是消费，那使用通配符就没什么意义了，因为你需要的是精确的参数类型。</span><br></pre></td></tr></table></figure>

<ul>
<li><p>再看一个实际例子，<strong>加深印象</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span>  &lt;E <span class="keyword">extends</span> <span class="title class_">Comparable</span>&lt;? <span class="built_in">super</span> E&gt;&gt; E <span class="title function_">max</span><span class="params">(List&lt;? extends E&gt; e1)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (e1 == <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//迭代器返回的元素属于 E 的某个子类型</span></span><br><span class="line">    Iterator&lt;? <span class="keyword">extends</span> <span class="title class_">E</span>&gt; iterator = e1.iterator();</span><br><span class="line">    <span class="type">E</span> <span class="variable">result</span> <span class="operator">=</span> iterator.next();</span><br><span class="line">    <span class="keyword">while</span> (iterator.hasNext())&#123;</span><br><span class="line">        <span class="type">E</span> <span class="variable">next</span> <span class="operator">=</span> iterator.next();</span><br><span class="line">        <span class="keyword">if</span> (next.compareTo(result) &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            result = next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码中的类型参数 E 的范围是<code>&lt;E extends Comparable&lt;? super E&gt;&gt;</code>，我们可以分步查看：</p>
</li>
<li><p>要进行比较，所以 E 需要是可比较的类，因此需要 <code>extends Comparable&lt;…&gt;</code>（注意这里不要和继承的 <code>extends</code> 搞混了，不一样）</p>
</li>
<li><p><code>Comparable&lt; ? super E&gt;</code> 要对 E 进行比较，即 E 的消费者，所以需要用 super</p>
</li>
<li><p>而参数 <code>List&lt; ? extends E&gt;</code> 表示要操作的数据是 E 的子类的列表，指定上限，这样容器才够大</p>
</li>
</ul>
<p><strong>多个限制</strong></p>
<p>使用&amp;符号</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="comment">//工资低于2500元的上斑族并且站立的乘客车票打8折</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T <span class="keyword">extends</span> <span class="title class_">Staff</span> &amp; Passenger&gt; <span class="keyword">void</span> <span class="title function_">discount</span><span class="params">(T t)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(t.getSalary()&lt;<span class="number">2500</span> &amp;&amp; t.isStanding())&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;恭喜你！您的车票打八折！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        discount(<span class="keyword">new</span> <span class="title class_">Me</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="泛型数组"><a href="#泛型数组" class="headerlink" title="泛型数组"></a>泛型数组</h4><p>首先，我们泛型数组相关的申明：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt;[] list11 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;[<span class="number">10</span>]; <span class="comment">//编译错误，非法创建 </span></span><br><span class="line">List&lt;String&gt;[] list12 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;?&gt;[<span class="number">10</span>]; <span class="comment">//编译错误，需要强转类型 </span></span><br><span class="line">List&lt;String&gt;[] list13 = (List&lt;String&gt;[]) <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;?&gt;[<span class="number">10</span>]; <span class="comment">//OK，但是会有警告 </span></span><br><span class="line">List&lt;?&gt;[] list14 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;[<span class="number">10</span>]; <span class="comment">//编译错误，非法创建 </span></span><br><span class="line">List&lt;?&gt;[] list15 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;?&gt;[<span class="number">10</span>]; <span class="comment">//OK </span></span><br><span class="line">List&lt;String&gt;[] list6 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>[<span class="number">10</span>]; <span class="comment">//OK，但是会有警告</span></span><br></pre></td></tr></table></figure>

<p>讨巧的使用场景</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GenericsDemo30</span>&#123;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span>&#123;  </span><br><span class="line">        Integer i[] = fun1(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>) ;   <span class="comment">// 返回泛型数组  </span></span><br><span class="line">        fun2(i) ;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; T[] fun1(T...arg)&#123;  <span class="comment">// 接收可变参数  </span></span><br><span class="line">        <span class="keyword">return</span> arg ;            <span class="comment">// 返回泛型数组  </span></span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="keyword">void</span> <span class="title function_">fun2</span><span class="params">(T param[])</span>&#123;   <span class="comment">// 输出  </span></span><br><span class="line">        System.out.print(<span class="string">&quot;接收泛型数组：&quot;</span>) ;  </span><br><span class="line">        <span class="keyword">for</span>(T t:param)&#123;  </span><br><span class="line">            System.out.print(t + <span class="string">&quot;、&quot;</span>) ;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>合理使用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ArrayWithTypeToken</span><span class="params">(Class&lt;T&gt; type, <span class="type">int</span> size)</span> &#123;</span><br><span class="line">    array = (T[]) Array.newInstance(type, size);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="深入理解泛型"><a href="#深入理解泛型" class="headerlink" title="深入理解泛型"></a>深入理解泛型</h3><h4 id="如何理解Java中的泛型是伪泛型？泛型中类型擦除"><a href="#如何理解Java中的泛型是伪泛型？泛型中类型擦除" class="headerlink" title="如何理解Java中的泛型是伪泛型？泛型中类型擦除"></a>如何理解Java中的泛型是伪泛型？泛型中类型擦除</h4><p>Java泛型这个特性是从JDK 1.5才开始加入的，因此为了兼容之前的版本，Java泛型的实现采取了“<strong>伪泛型</strong>”的策略，即Java在语法上支持泛型，但是在编译阶段会进行所谓的“<strong>类型擦除</strong>”（Type Erasure），将所有的泛型表示（尖括号中的内容）都替换为具体的类型（其对应的原生态类型），就像完全没有泛型一样.</p>
<p><strong>泛型的类型擦除原则</strong>是：</p>
<ul>
<li>消除类型参数声明，即删除<code>&lt;&gt;</code>及其包围的部分。</li>
<li>根据类型参数的上下界推断并替换所有的类型参数为原生态类型：如果类型参数是无限制通配符或没有上下界限定则替换为Object，如果存在上下界限定则根据子类替换原则取类型参数的最左边限定类型（即父类）。</li>
<li>为了保证类型安全，必要时插入强制类型转换代码。</li>
<li>自动产生“桥接方法”以保证擦除类型后的代码仍然具有泛型的“多态性”。</li>
</ul>
<p><strong>那么如何进行擦除的呢</strong>？</p>
<ul>
<li>擦除类定义中的类型参数 - 无限制类型擦除</li>
</ul>
<p>当类定义中的类型参数没有任何限制时，在类型擦除中直接被替换为Object，即形如<code>&lt;T&gt;</code>和<code>&lt;?&gt;</code>的类型参数都被替换为Object。</p>
<p><img src="/../images/note35.png" alt="note35"></p>
<ul>
<li>擦除类定义中的类型参数 - 有限制类型擦除</li>
</ul>
<p>当类定义中的类型参数存在限制（上下界）时，在类型擦除中替换为类型参数的上界或者下界，比如形如<code>&lt;T extends Number&gt;</code>和<code>&lt;? extends Number&gt;</code>的类型参数被替换为<code>Number</code>，<code>&lt;? super Number&gt;</code>被替换为Object。</p>
<p><img src="/../images/note36.png" alt="note36"></p>
<ul>
<li>擦除方法定义中的类型参数</li>
</ul>
<p>擦除方法定义中的类型参数原则和擦除类定义中的类型参数是一样的，这里仅以擦除方法定义中的有限制类型参数为例。</p>
<p><img src="/../images/note37.png" alt="note37"></p>
<h4 id="如何证明类型的擦除呢？"><a href="#如何证明类型的擦除呢？" class="headerlink" title="如何证明类型的擦除呢？"></a>如何证明类型的擦除呢？</h4><ul>
<li>原始类型相等</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        ArrayList&lt;String&gt; list1 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line">        list1.add(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line"></span><br><span class="line">        ArrayList&lt;Integer&gt; list2 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br><span class="line">        list2.add(<span class="number">123</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(list1.getClass() == list2.getClass()); <span class="comment">// true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，我们定义了两个ArrayList数组，不过一个是<code>ArrayList&lt;String&gt;</code>泛型类型的，只能存储字符串；一个是<code>ArrayList&lt;Integer&gt;</code>泛型类型的，只能存储整数，最后，我们通过list1对象和list2对象的<code>getClass()</code>方法获取他们的类的信息，最后发现结果为true。说明泛型类型String和Integer都被擦除掉了，只剩下原始类型。</p>
<ul>
<li>通过反射添加其它类型元素</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">        ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br><span class="line"></span><br><span class="line">        list.add(<span class="number">1</span>);  <span class="comment">//这样调用 add 方法只能存储整形，因为泛型类型的实例为 Integer</span></span><br><span class="line"></span><br><span class="line">        list.getClass().getMethod(<span class="string">&quot;add&quot;</span>, Object.class).invoke(list, <span class="string">&quot;asd&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; list.size(); i++) &#123;</span><br><span class="line">            System.out.println(list.get(i));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在程序中定义了一个<code>ArrayList</code>泛型类型实例化为<code>Integer</code>对象，如果直接调用<code>add()</code>方法，那么只能存储整数数据，不过当我们利用反射调用<code>add()</code>方法的时候，却可以存储字符串，这说明了<code>Integer</code>泛型实例在编译之后被擦除掉了，只保留了原始类型。</p>
<h4 id="如何理解类型擦除后保留的原始类型"><a href="#如何理解类型擦除后保留的原始类型" class="headerlink" title="如何理解类型擦除后保留的原始类型?"></a>如何理解类型擦除后保留的原始类型?</h4><p><strong>原始类型</strong> 就是擦除去了泛型信息，最后在字节码中的类型变量的真正类型，无论何时定义一个泛型，相应的原始类型都会被自动提供，类型变量擦除，并使用其限定类型（无限定的变量用Object）替换。</p>
<ul>
<li>原始类型Object</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Pair</span>&lt;T&gt; &#123;  </span><br><span class="line">    <span class="keyword">private</span> T value;  </span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">getValue</span><span class="params">()</span> &#123;  </span><br><span class="line">        <span class="keyword">return</span> value;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setValue</span><span class="params">(T  value)</span> &#123;  </span><br><span class="line">        <span class="built_in">this</span>.value = value;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>Pair的原始类型为:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Pair</span> &#123;  </span><br><span class="line">    <span class="keyword">private</span> Object value;  </span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">getValue</span><span class="params">()</span> &#123;  </span><br><span class="line">        <span class="keyword">return</span> value;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setValue</span><span class="params">(Object  value)</span> &#123;  </span><br><span class="line">        <span class="built_in">this</span>.value = value;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为在<code>Pair&lt;T&gt;</code>中，<code>T</code> 是一个无限定的类型变量，所以用Object替换，其结果就是一个普通的类，如同泛型加入Java语言之前的已经实现的样子。在程序中可以包含不同类型的Pair，如<code>Pair&lt;String&gt;</code>或<code>Pair&lt;Integer&gt;</code>，但是擦除类型后他们的就成为原始的Pair类型了，原始类型都是Object。</p>
<p>从上面章节，我们也可以明白ArrayList被擦除类型后，原始类型也变为Object，所以通过反射我们就可以存储字符串了。</p>
<p>如果类型变量有限定，那么原始类型就用第一个边界的类型变量类替换。</p>
<p>比如: Pair这样声明的话</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Pair</span>&lt;T <span class="keyword">extends</span> <span class="title class_">Comparable</span>&gt; &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>著作权归<a href="https://pdai.tech所有./">https://pdai.tech所有。</a> 链接：<a href="https://pdai.tech/md/java/basic/java-basic-x-generic.html">https://pdai.tech/md/java/basic/java-basic-x-generic.html</a></p>
<p>那么原始类型就是Comparable。</p>
<p>要区分原始类型和泛型变量的类型。</p>
<p>在调用泛型方法时，可以指定泛型，也可以不指定泛型:</p>
<ul>
<li>在不指定泛型的情况下，泛型变量的类型为该方法中的几种类型的同一父类的最小级，直到Object</li>
<li>在指定泛型的情况下，该方法的几种类型必须是该泛型的实例的类型或者其子类</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;  </span><br><span class="line"></span><br><span class="line">        <span class="comment">/**不指定泛型的时候*/</span>  </span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> Test.add(<span class="number">1</span>, <span class="number">2</span>); <span class="comment">//这两个参数都是Integer，所以T为Integer类型  </span></span><br><span class="line">        <span class="type">Number</span> <span class="variable">f</span> <span class="operator">=</span> Test.add(<span class="number">1</span>, <span class="number">1.2</span>); <span class="comment">//这两个参数一个是Integer，以风格是Float，所以取同一父类的最小级，为Number  </span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> Test.add(<span class="number">1</span>, <span class="string">&quot;asd&quot;</span>); <span class="comment">//这两个参数一个是Integer，以风格是Float，所以取同一父类的最小级，为Object  </span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/**指定泛型的时候*/</span>  </span><br><span class="line">        <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> Test.&lt;Integer&gt;add(<span class="number">1</span>, <span class="number">2</span>); <span class="comment">//指定了Integer，所以只能为Integer类型或者其子类  </span></span><br><span class="line">        <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> Test.&lt;Integer&gt;add(<span class="number">1</span>, <span class="number">2.2</span>); <span class="comment">//编译错误，指定了Integer，不能为Float  </span></span><br><span class="line">        <span class="type">Number</span> <span class="variable">c</span> <span class="operator">=</span> Test.&lt;Number&gt;add(<span class="number">1</span>, <span class="number">2.2</span>); <span class="comment">//指定为Number，所以可以为Integer和Float  </span></span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    <span class="comment">//这是一个简单的泛型方法  </span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; T <span class="title function_">add</span><span class="params">(T x,T y)</span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> y;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其实在泛型类中，不指定泛型的时候，也差不多，只不过这个时候的泛型为Object，就比如ArrayList中，如果不指定泛型，那么这个ArrayList可以存储任意的对象。</p>
<ul>
<li>Object泛型</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;  </span><br><span class="line">    <span class="type">ArrayList</span> <span class="variable">list</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();  </span><br><span class="line">    list.add(<span class="number">1</span>);  </span><br><span class="line">    list.add(<span class="string">&quot;121&quot;</span>);  </span><br><span class="line">    list.add(<span class="keyword">new</span> <span class="title class_">Date</span>());  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<h4 id="如何理解泛型的编译期检查？"><a href="#如何理解泛型的编译期检查？" class="headerlink" title="如何理解泛型的编译期检查？"></a>如何理解泛型的编译期检查？</h4><p>Java编译器是通过先检查代码中泛型的类型，然后在进行类型擦除，再进行编译。</p>
<p>例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span>  <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;  </span><br><span class="line"></span><br><span class="line">    ArrayList&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();  </span><br><span class="line">    list.add(<span class="string">&quot;123&quot;</span>);  </span><br><span class="line">    list.add(<span class="number">123</span>);<span class="comment">//编译错误  </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的程序中，使用add方法添加一个整型，在IDE中，直接会报错，说明这就是在编译之前的检查，因为如果是在编译之后检查，类型擦除后，原始类型为Object，是应该允许任意引用类型添加的。可实际上却不是这样的，这恰恰说明了关于泛型变量的使用，是会在编译之前检查的。</p>
<p>那么，<strong>这个类型检查是针对谁的呢</strong>？我们先看看参数化类型和原始类型的兼容。</p>
<p>以 ArrayList举例子，以前的写法:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ArrayList</span> <span class="variable">list</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();  </span><br></pre></td></tr></table></figure>

<p>现在的写法:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ArrayList&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br></pre></td></tr></table></figure>

<p>如果是与以前的代码兼容，各种引用传值之间，必然会出现如下的情况：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ArrayList&lt;String&gt; list1 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>(); <span class="comment">//第一种 情况</span></span><br><span class="line"><span class="type">ArrayList</span> <span class="variable">list2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;(); <span class="comment">//第二种 情况</span></span><br></pre></td></tr></table></figure>

<p>这样是没有错误的，不过会有个编译时警告。</p>
<p>不过在第一种情况，可以实现与完全使用泛型参数一样的效果，第二种则没有效果。</p>
<p>因为类型检查就是编译时完成的，new ArrayList()只是在内存中开辟了一个存储空间，可以存储任何类型对象，而真正涉及类型检查的是它的引用，因为我们是使用它引用list1来调用它的方法，比如说调用add方法，所以list1引用能完成泛型类型的检查。而引用list2没有使用泛型，所以不行。</p>
<p>例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;  </span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;  </span><br><span class="line"></span><br><span class="line">        ArrayList&lt;String&gt; list1 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>();  </span><br><span class="line">        list1.add(<span class="string">&quot;1&quot;</span>); <span class="comment">//编译通过  </span></span><br><span class="line">        list1.add(<span class="number">1</span>); <span class="comment">//编译错误  </span></span><br><span class="line">        <span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> list1.get(<span class="number">0</span>); <span class="comment">//返回类型就是String  </span></span><br><span class="line"></span><br><span class="line">        <span class="type">ArrayList</span> <span class="variable">list2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();  </span><br><span class="line">        list2.add(<span class="string">&quot;1&quot;</span>); <span class="comment">//编译通过  </span></span><br><span class="line">        list2.add(<span class="number">1</span>); <span class="comment">//编译通过  </span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">object</span> <span class="operator">=</span> list2.get(<span class="number">0</span>); <span class="comment">//返回类型就是Object  </span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;().add(<span class="string">&quot;11&quot;</span>); <span class="comment">//编译通过  </span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;().add(<span class="number">22</span>); <span class="comment">//编译错误  </span></span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;().get(<span class="number">0</span>); <span class="comment">//返回类型就是String  </span></span><br><span class="line">    &#125;  </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>通过上面的例子，我们可以明白，<strong>类型检查就是针对引用的，谁是一个引用，用这个引用调用泛型方法，就会对这个引用调用的方法进行类型检测，而无关它真正引用的对象</strong>。</p>
<p><strong>泛型中参数的类型为什么不考虑继承关系</strong>？</p>
<p>在Java中，像下面形式的引用传递是不允许的:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ArrayList&lt;String&gt; list1 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Object&gt;(); <span class="comment">//编译错误  </span></span><br><span class="line">ArrayList&lt;Object&gt; list2 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;(); <span class="comment">//编译错误</span></span><br></pre></td></tr></table></figure>

<ul>
<li>我们先看第一种情况，将第一种情况拓展成下面的形式：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ArrayList&lt;Object&gt; list1 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Object&gt;();  </span><br><span class="line">list1.add(<span class="keyword">new</span> <span class="title class_">Object</span>());  </span><br><span class="line">list1.add(<span class="keyword">new</span> <span class="title class_">Object</span>());  </span><br><span class="line">ArrayList&lt;String&gt; list2 = list1; <span class="comment">//编译错误</span></span><br></pre></td></tr></table></figure>

<p>实际上，在第4行代码的时候，就会有编译错误。那么，我们先假设它编译没错。那么当我们使用list2引用用get()方法取值的时候，返回的都是String类型的对象（上面提到了，类型检测是根据引用来决定的），可是它里面实际上已经被我们存放了Object类型的对象，这样就会有<code>ClassCastException</code>了。所以为了避免这种极易出现的错误，Java不允许进行这样的引用传递。（这也是泛型出现的原因，就是为了解决类型转换的问题，我们不能违背它的初衷）。</p>
<ul>
<li>再看第二种情况，将第二种情况拓展成下面的形式：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ArrayList&lt;String&gt; list1 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();  </span><br><span class="line">list1.add(<span class="keyword">new</span> <span class="title class_">String</span>());  </span><br><span class="line">list1.add(<span class="keyword">new</span> <span class="title class_">String</span>());</span><br><span class="line"></span><br><span class="line">ArrayList&lt;Object&gt; list2 = list1; <span class="comment">//编译错误</span></span><br></pre></td></tr></table></figure>

<p>没错，这样的情况比第一种情况好的多，最起码，在我们用list2取值的时候不会出现ClassCastException，因为是从String转换为Object。可是，这样做有什么意义呢，泛型出现的原因，就是为了解决类型转换的问题。</p>
<p>我们使用了泛型，到头来，还是要自己强转，违背了泛型设计的初衷。所以java不允许这么干。再说，你如果又用list2往里面add()新的对象，那么到时候取得时候，我怎么知道我取出来的到底是String类型的，还是Object类型的呢？</p>
<p>所以，要格外注意，泛型中的引用传递的问题。</p>
<h4 id="如何理解泛型的多态？泛型的桥接方法"><a href="#如何理解泛型的多态？泛型的桥接方法" class="headerlink" title="如何理解泛型的多态？泛型的桥接方法"></a>如何理解泛型的多态？泛型的桥接方法</h4><p>类型擦除会造成多态的冲突，而JVM解决方法就是桥接方法。</p>
<p>现在有这样一个泛型类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Pair</span>&lt;T&gt; &#123;  </span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> T value;  </span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">getValue</span><span class="params">()</span> &#123;  </span><br><span class="line">        <span class="keyword">return</span> value;  </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setValue</span><span class="params">(T value)</span> &#123;  </span><br><span class="line">        <span class="built_in">this</span>.value = value;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后我们想要一个子类继承它。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">DateInter</span> <span class="keyword">extends</span> <span class="title class_">Pair</span>&lt;Date&gt; &#123;  </span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setValue</span><span class="params">(Date value)</span> &#123;  </span><br><span class="line">        <span class="built_in">super</span>.setValue(value);  </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="keyword">public</span> Date <span class="title function_">getValue</span><span class="params">()</span> &#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.getValue();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个子类中，我们设定父类的泛型类型为<code>Pair&lt;Date&gt;</code>，在子类中，我们覆盖了父类的两个方法，我们的原意是这样的：将父类的泛型类型限定为Date，那么父类里面的两个方法的参数都为Date类型。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Date <span class="title function_">getValue</span><span class="params">()</span> &#123;  </span><br><span class="line">    <span class="keyword">return</span> value;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setValue</span><span class="params">(Date value)</span> &#123;  </span><br><span class="line">    <span class="built_in">this</span>.value = value;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以，我们在子类中重写这两个方法一点问题也没有，实际上，从他们的<code>@Override</code>标签中也可以看到，一点问题也没有，实际上是这样的吗？</p>
<p>分析：实际上，类型擦除后，父类的的泛型类型全部变为了原始类型Object，所以父类编译之后会变成下面的样子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Pair</span> &#123;  </span><br><span class="line">    <span class="keyword">private</span> Object value;  </span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">getValue</span><span class="params">()</span> &#123;  </span><br><span class="line">        <span class="keyword">return</span> value;  </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setValue</span><span class="params">(Object  value)</span> &#123;  </span><br><span class="line">        <span class="built_in">this</span>.value = value;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>再看子类的两个重写的方法的类型：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setValue</span><span class="params">(Date value)</span> &#123;  </span><br><span class="line">    <span class="built_in">super</span>.setValue(value);  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="meta">@Override</span>  </span><br><span class="line"><span class="keyword">public</span> Date <span class="title function_">getValue</span><span class="params">()</span> &#123;  </span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">super</span>.getValue();  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>先来分析setValue方法，父类的类型是Object，而子类的类型是Date，参数类型不一样，这如果实在普通的继承关系中，根本就不会是重写，而是重载。 我们在一个main方法测试一下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException &#123;  </span><br><span class="line">        <span class="type">DateInter</span> <span class="variable">dateInter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DateInter</span>();  </span><br><span class="line">        dateInter.setValue(<span class="keyword">new</span> <span class="title class_">Date</span>());                  </span><br><span class="line">        dateInter.setValue(<span class="keyword">new</span> <span class="title class_">Object</span>()); <span class="comment">//编译错误  </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果是重载，那么子类中两个setValue方法，一个是参数Object类型，一个是Date类型，可是我们发现，根本就没有这样的一个子类继承自父类的Object类型参数的方法。所以说，却是是重写了，而不是重载了。</p>
<p><strong>为什么会这样呢</strong>？</p>
<p>原因是这样的，我们传入父类的泛型类型是Date，<code>Pair&lt;Date&gt;</code>，我们的本意是将泛型类变为如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Pair</span> &#123;  </span><br><span class="line">    <span class="keyword">private</span> Date value;  </span><br><span class="line">    <span class="keyword">public</span> Date <span class="title function_">getValue</span><span class="params">()</span> &#123;  </span><br><span class="line">        <span class="keyword">return</span> value;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setValue</span><span class="params">(Date value)</span> &#123;  </span><br><span class="line">        <span class="built_in">this</span>.value = value;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后再子类中重写参数类型为Date的那两个方法，实现继承中的多态。</p>
<p>可是由于种种原因，虚拟机并不能将泛型类型变为Date，只能将类型擦除掉，变为原始类型Object。这样，我们的本意是进行重写，实现多态。可是类型擦除后，只能变为了重载。这样，类型擦除就和多态有了冲突。JVM知道你的本意吗？知道！！！可是它能直接实现吗，不能！！！如果真的不能的话，那我们怎么去重写我们想要的Date类型参数的方法啊。</p>
<p>于是JVM采用了一个特殊的方法，来完成这项功能，那就是桥方法。</p>
<p>首先，我们用javap -c className的方式反编译下DateInter子类的字节码，结果如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">com</span>.tao.test.DateInter <span class="keyword">extends</span> <span class="title class_">com</span>.tao.test.Pair&lt;java.util.Date&gt; &#123;  </span><br><span class="line">  com.tao.test.DateInter();  </span><br><span class="line">    Code:  </span><br><span class="line">       <span class="number">0</span>: aload_0  </span><br><span class="line">       <span class="number">1</span>: invokespecial #<span class="number">8</span>                  <span class="comment">// Method com/tao/test/Pair.&quot;&lt;init&gt;&quot;:()V  </span></span><br><span class="line">       <span class="number">4</span>: <span class="keyword">return</span>  </span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setValue</span><span class="params">(java.util.Date)</span>;  <span class="comment">//我们重写的setValue方法  </span></span><br><span class="line">    Code:  </span><br><span class="line">       <span class="number">0</span>: aload_0  </span><br><span class="line">       <span class="number">1</span>: aload_1  </span><br><span class="line">       <span class="number">2</span>: invokespecial #<span class="number">16</span>                 <span class="comment">// Method com/tao/test/Pair.setValue:(Ljava/lang/Object;)V  </span></span><br><span class="line">       <span class="number">5</span>: <span class="keyword">return</span>  </span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> java.util.Date <span class="title function_">getValue</span><span class="params">()</span>;    <span class="comment">//我们重写的getValue方法  </span></span><br><span class="line">    Code:  </span><br><span class="line">       <span class="number">0</span>: aload_0  </span><br><span class="line">       <span class="number">1</span>: invokespecial #<span class="number">23</span>                 <span class="comment">// Method com/tao/test/Pair.getValue:()Ljava/lang/Object;  </span></span><br><span class="line">       <span class="number">4</span>: checkcast     #<span class="number">26</span>                 <span class="comment">// class java/util/Date  </span></span><br><span class="line">       <span class="number">7</span>: areturn  </span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> java.lang.Object <span class="title function_">getValue</span><span class="params">()</span>;     <span class="comment">//编译时由编译器生成的巧方法  </span></span><br><span class="line">    Code:  </span><br><span class="line">       <span class="number">0</span>: aload_0  </span><br><span class="line">       <span class="number">1</span>: invokevirtual #<span class="number">28</span>                 <span class="comment">// Method getValue:()Ljava/util/Date 去调用我们重写的getValue方法;  </span></span><br><span class="line">       <span class="number">4</span>: areturn  </span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setValue</span><span class="params">(java.lang.Object)</span>;   <span class="comment">//编译时由编译器生成的巧方法  </span></span><br><span class="line">    Code:  </span><br><span class="line">       <span class="number">0</span>: aload_0  </span><br><span class="line">       <span class="number">1</span>: aload_1  </span><br><span class="line">       <span class="number">2</span>: checkcast     #<span class="number">26</span>                 <span class="comment">// class java/util/Date  </span></span><br><span class="line">       <span class="number">5</span>: invokevirtual #<span class="number">30</span>                 <span class="comment">// Method setValue:(Ljava/util/Date; 去调用我们重写的setValue方法)V  </span></span><br><span class="line">       <span class="number">8</span>: <span class="keyword">return</span>  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从编译的结果来看，我们本意重写setValue和getValue方法的子类，竟然有4个方法，其实不用惊奇，最后的两个方法，就是编译器自己生成的桥方法。可以看到桥方法的参数类型都是Object，也就是说，子类中真正覆盖父类两个方法的就是这两个我们看不到的桥方法。而打在我们自己定义的setvalue和getValue方法上面的@Oveerride只不过是假象。而桥方法的内部实现，就只是去调用我们自己重写的那两个方法。</p>
<p>所以，虚拟机巧妙的使用了桥方法，来解决了类型擦除和多态的冲突。</p>
<p>不过，要提到一点，这里面的setValue和getValue这两个桥方法的意义又有不同。</p>
<p>setValue方法是为了解决类型擦除与多态之间的冲突。</p>
<p>而getValue却有普遍的意义，怎么说呢，如果这是一个普通的继承关系：</p>
<p>那么父类的setValue方法如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">getValue</span><span class="params">()</span> &#123;  </span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">super</span>.getValue();  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而子类重写的方法是：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Date <span class="title function_">getValue</span><span class="params">()</span> &#123;  </span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">super</span>.getValue();  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其实这在普通的类继承中也是普遍存在的重写，这就是协变。</p>
<p>并且，还有一点也许会有疑问，子类中的巧方法<code>Object getValue()</code>和<code>Date getValue()</code>是同时存在的，可是如果是常规的两个方法，他们的方法签名是一样的，也就是说虚拟机根本不能分别这两个方法。如果是我们自己编写Java代码，这样的代码是无法通过编译器的检查的，但是虚拟机却是允许这样做的，因为虚拟机通过参数类型和返回类型来确定一个方法，所以编译器为了实现泛型的多态允许自己做这个看起来“不合法”的事情，然后交给虚拟器去区别。</p>
<h4 id="如何理解基本类型不能作为泛型类型？"><a href="#如何理解基本类型不能作为泛型类型？" class="headerlink" title="如何理解基本类型不能作为泛型类型？"></a>如何理解基本类型不能作为泛型类型？</h4><p>比如，我们没有<code>ArrayList&lt;int&gt;</code>，只有<code>ArrayList&lt;Integer&gt;</code>, 为何？</p>
<p>因为当类型擦除后，ArrayList的原始类型变为Object，但是Object类型不能存储int值，只能引用Integer的值。</p>
<p>另外需要注意，我们能够使用<code>list.add(1)</code>是因为Java基础类型的自动装箱拆箱操作。</p>
<h4 id="如何理解泛型类型不能实例化？"><a href="#如何理解泛型类型不能实例化？" class="headerlink" title="如何理解泛型类型不能实例化？"></a>如何理解泛型类型不能实例化？</h4><p>不能实例化泛型类型, 这本质上是由于类型擦除决定的：</p>
<p>我们可以看到如下代码会在编译器中报错：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">T</span> <span class="variable">test</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">T</span>(); <span class="comment">// ERROR</span></span><br></pre></td></tr></table></figure>

<p>因为在 Java 编译期没法确定泛型参数化类型，也就找不到对应的类字节码文件，所以自然就不行了，此外由于<code>T</code> 被擦除为 <code>Object</code>，如果可以 <code>new T()</code> 则就变成了 <code>new Object()</code>，失去了本意。     如果我们确实需要实例化一个泛型，应该如何做呢？可以通过反射实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> &lt;T&gt; T <span class="title function_">newTclass</span> <span class="params">(Class &lt; T &gt; clazz)</span> <span class="keyword">throws</span> InstantiationException, IllegalAccessException &#123;</span><br><span class="line">    <span class="type">T</span> <span class="variable">obj</span> <span class="operator">=</span> clazz.newInstance();</span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="泛型数组：能不能采用具体的泛型类型进行初始化？"><a href="#泛型数组：能不能采用具体的泛型类型进行初始化？" class="headerlink" title="泛型数组：能不能采用具体的泛型类型进行初始化？"></a>泛型数组：能不能采用具体的泛型类型进行初始化？</h4><p>我们先来看下Oracle官网提供的一个例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt;[] lsa = <span class="keyword">new</span> <span class="title class_">List</span>&lt;String&gt;[<span class="number">10</span>]; <span class="comment">// Not really allowed.</span></span><br><span class="line"><span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> lsa;</span><br><span class="line">Object[] oa = (Object[]) o;</span><br><span class="line">List&lt;Integer&gt; li = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br><span class="line">li.add(<span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">3</span>));</span><br><span class="line">oa[<span class="number">1</span>] = li; <span class="comment">// Unsound, but passes run time store check</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> lsa[<span class="number">1</span>].get(<span class="number">0</span>); <span class="comment">// Run-time error ClassCastException.</span></span><br></pre></td></tr></table></figure>

<p>由于 JVM 泛型的擦除机制，所以上面代码可以给 <code>oa[1]</code> 赋值为 ArrayList 也不会出现异常，但是在取出数据的时候却要做一次类型转换，所以就会出现 <code>ClassCastException</code>，如果可以进行泛型数组的声明则上面说的这种情况在编译期不会出现任何警告和错误，只有在运行时才会出错，但是泛型的出现就是为了消灭 <code>ClassCastException</code>，所以如果 Java 支持泛型数组初始化操作就是搬起石头砸自己的脚。</p>
<p>而对于下面的代码来说是成立的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;?&gt;[] lsa = <span class="keyword">new</span> <span class="title class_">List</span>&lt;?&gt;[<span class="number">10</span>]; <span class="comment">// OK, array of unbounded wildcard type.</span></span><br><span class="line"><span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> lsa;</span><br><span class="line">Object[] oa = (Object[]) o;</span><br><span class="line">List&lt;Integer&gt; li = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br><span class="line">li.add(<span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">3</span>));</span><br><span class="line">oa[<span class="number">1</span>] = li; <span class="comment">// Correct.</span></span><br><span class="line"><span class="type">Integer</span> <span class="variable">i</span> <span class="operator">=</span> (Integer) lsa[<span class="number">1</span>].get(<span class="number">0</span>); <span class="comment">// OK</span></span><br></pre></td></tr></table></figure>

<p>所以说采用通配符的方式初始化泛型数组是允许的，因为对于通配符的方式最后取出数据是要做显式类型转换的，符合预期逻辑。综述就是说Java 的泛型数组初始化时数组类型不能是具体的泛型类型，只能是通配符的形式，因为具体类型会导致可存入任意类型对象，在取出时会发生类型转换异常，会与泛型的设计思想冲突，而通配符形式本来就需要自己强转，符合预期。</p>
<h4 id="泛型数组：如何正确的初始化泛型数组实例？"><a href="#泛型数组：如何正确的初始化泛型数组实例？" class="headerlink" title="泛型数组：如何正确的初始化泛型数组实例？"></a>泛型数组：如何正确的初始化泛型数组实例？</h4><p>这个无论我们通过<code>new ArrayList[10]</code> 的形式还是通过泛型通配符的形式初始化泛型数组实例都是存在警告的，也就是说仅仅语法合格，运行时潜在的风险需要我们自己来承担，因此那些方式初始化泛型数组都不是最优雅的方式。</p>
<p>我们在使用到泛型数组的场景下应该尽量使用列表集合替换，此外也可以通过使用 <code>java.lang.reflect.Array.newInstance(Class&lt;T&gt; componentType, int length)</code> 方法来创建一个具有指定类型和维度的数组，如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayWithTypeToken</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> T[] array;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ArrayWithTypeToken</span><span class="params">(Class&lt;T&gt; type, <span class="type">int</span> size)</span> &#123;</span><br><span class="line">        array = (T[]) Array.newInstance(type, size);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(<span class="type">int</span> index, T item)</span> &#123;</span><br><span class="line">        array[index] = item;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">get</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> array[index];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> T[] create() &#123;</span><br><span class="line">        <span class="keyword">return</span> array;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">ArrayWithTypeToken&lt;Integer&gt; arrayToken = <span class="keyword">new</span> <span class="title class_">ArrayWithTypeToken</span>&lt;Integer&gt;(Integer.class, <span class="number">100</span>);</span><br><span class="line">Integer[] array = arrayToken.create();</span><br></pre></td></tr></table></figure>

<p>所以使用反射来初始化泛型数组算是优雅实现，因为泛型类型 <code>T</code>在运行时才能被确定下来，我们能创建泛型数组也必然是在 Java 运行时想办法，而运行时能起作用的技术最好的就是反射了。</p>
<h4 id="如何理解泛型类中的静态方法和静态变量？"><a href="#如何理解泛型类中的静态方法和静态变量？" class="headerlink" title="如何理解泛型类中的静态方法和静态变量？"></a>如何理解泛型类中的静态方法和静态变量？</h4><p>泛型类中的静态方法和静态变量不可以使用泛型类所声明的泛型类型参数</p>
<p>举例说明：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test2</span>&lt;T&gt; &#123;    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> T one;   <span class="comment">//编译错误    </span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span>  T <span class="title function_">show</span><span class="params">(T one)</span>&#123; <span class="comment">//编译错误    </span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;    </span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为泛型类中的泛型参数的实例化是在定义对象的时候指定的，而静态变量和静态方法不需要使用对象来调用。对象都没有创建，如何确定这个泛型参数是何种类型，所以当然是错误的。</p>
<p>但是要注意区分下面的一种情况：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test2</span>&lt;T&gt; &#123;    </span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T &gt;T <span class="title function_">show</span><span class="params">(T one)</span>&#123; <span class="comment">//这是正确的    </span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;    </span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为这是一个泛型方法，在泛型方法中使用的T是自己在方法中定义的 T，而不是泛型类中的T。</p>
<h4 id="如何理解异常中使用泛型？"><a href="#如何理解异常中使用泛型？" class="headerlink" title="如何理解异常中使用泛型？"></a>如何理解异常中使用泛型？</h4><ul>
<li><strong>不能抛出也不能捕获泛型类的对象</strong>。事实上，泛型类扩展Throwable都不合法。例如：下面的定义将不会通过编译：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Problem</span>&lt;T&gt; <span class="keyword">extends</span> <span class="title class_">Exception</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为什么不能扩展Throwable，因为异常都是在运行时捕获和抛出的，而在编译的时候，泛型信息全都会被擦除掉，那么，假设上面的编译可行，那么，在看下面的定义：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">catch</span>(Problem&lt;Integer&gt; e1) &#123;</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">catch</span>(Problem&lt;Number&gt; e2) &#123;</span><br><span class="line"></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>类型信息被擦除后，那么两个地方的catch都变为原始类型Object，那么也就是说，这两个地方的catch变的一模一样,就相当于下面的这样：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">catch</span>(Problem&lt;Object&gt; e1) &#123;</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">catch</span>(Problem&lt;Object&gt; e2) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个当然就是不行的。</p>
<ul>
<li><strong>不能再catch子句中使用泛型变量</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T <span class="keyword">extends</span> <span class="title class_">Throwable</span>&gt; <span class="keyword">void</span> <span class="title function_">doWork</span><span class="params">(Class&lt;T&gt; t)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125; <span class="keyword">catch</span>(T e) &#123; <span class="comment">//编译错误</span></span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为泛型信息在编译的时候已经变为原始类型，也就是说上面的T会变为原始类型Throwable，那么如果可以再catch子句中使用泛型变量，那么，下面的定义呢：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T <span class="keyword">extends</span> <span class="title class_">Throwable</span>&gt; <span class="keyword">void</span> <span class="title function_">doWork</span><span class="params">(Class&lt;T&gt; t)</span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">catch</span>(T e) &#123; <span class="comment">//编译错误</span></span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">catch</span>(IndexOutOfBounds e) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;                         </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>根据异常捕获的原则，一定是子类在前面，父类在后面，那么上面就违背了这个原则。即使你在使用该静态方法的使用T是<code>ArrayIndexOutofBounds</code>，在编译之后还是会变成Throwable，<code>ArrayIndexOutofBounds</code>是IndexOutofBounds的子类，违背了异常捕获的原则。所以java为了避免这样的情况，禁止在catch子句中使用泛型变量。</p>
<ul>
<li>但是在异常声明中可以使用类型变量。下面方法是合法的。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span>&lt;T <span class="keyword">extends</span> <span class="title class_">Throwable</span>&gt; <span class="keyword">void</span> <span class="title function_">doWork</span><span class="params">(T t)</span> <span class="keyword">throws</span> T &#123;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125; <span class="keyword">catch</span>(Throwable realCause) &#123;</span><br><span class="line">        t.initCause(realCause);</span><br><span class="line">        <span class="keyword">throw</span> t; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="如何获取泛型的参数类型？"><a href="#如何获取泛型的参数类型？" class="headerlink" title="如何获取泛型的参数类型？"></a>如何获取泛型的参数类型？</h4><p>既然类型被擦除了，那么如何获取泛型的参数类型呢？可以通过反射（<code>java.lang.reflect.Type</code>）获取泛型</p>
<p><code>java.lang.reflect.Type</code>是Java中所有类型的公共高级接口, 代表了Java中的所有类型. Type体系中类型的包括：数组类型(GenericArrayType)、参数化类型(ParameterizedType)、类型变量(TypeVariable)、通配符类型(WildcardType)、原始类型(Class)、基本类型(Class), 以上这些类型都实现Type接口。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GenericType</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> T data;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">getData</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setData</span><span class="params">(T data)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.data = data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        GenericType&lt;String&gt; genericType = <span class="keyword">new</span> <span class="title class_">GenericType</span>&lt;String&gt;() &#123;&#125;;</span><br><span class="line">        <span class="type">Type</span> <span class="variable">superclass</span> <span class="operator">=</span> genericType.getClass().getGenericSuperclass();</span><br><span class="line">        <span class="comment">//getActualTypeArguments 返回确切的泛型参数, 如Map&lt;String, Integer&gt;返回[String, Integer]</span></span><br><span class="line">        <span class="type">Type</span> <span class="variable">type</span> <span class="operator">=</span> ((ParameterizedType) superclass).getActualTypeArguments()[<span class="number">0</span>]; </span><br><span class="line">        System.out.println(type);<span class="comment">//class java.lang.String</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中 <code>ParameterizedType</code>:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ParameterizedType</span> <span class="keyword">extends</span> <span class="title class_">Type</span> &#123;</span><br><span class="line">    <span class="comment">// 返回确切的泛型参数, 如Map&lt;String, Integer&gt;返回[String, Integer]</span></span><br><span class="line">    Type[] getActualTypeArguments();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//返回当前class或interface声明的类型, 如List&lt;?&gt;返回List</span></span><br><span class="line">    Type <span class="title function_">getRawType</span><span class="params">()</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//返回所属类型. 如,当前类型为O&lt;T&gt;.I&lt;S&gt;, 则返回O&lt;T&gt;. 顶级类型将返回null </span></span><br><span class="line">    Type <span class="title function_">getOwnerType</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>java</category>
      </categories>
  </entry>
  <entry>
    <title>java基础知识-SPI机制详解 - java</title>
    <url>/2022/05/26/2022-05-26-java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86-SPI%E6%9C%BA%E5%88%B6%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<h1 id="SPI机制详解"><a href="#SPI机制详解" class="headerlink" title="SPI机制详解"></a>SPI机制详解</h1><span id="more"></span>

<h3 id="什么是SPI机制"><a href="#什么是SPI机制" class="headerlink" title="什么是SPI机制"></a>什么是SPI机制</h3><p>SPI（Service Provider Interface），是JDK内置的一种 服务提供发现机制，可以用来启用框架扩展和替换组件，主要是被框架的开发人员使用，比如java.sql.Driver接口，其他不同厂商可以针对同一接口做出不同的实现，MySQL和PostgreSQL都有不同的实现提供给用户，而Java的SPI机制可以为某个接口寻找服务实现。Java中SPI机制主要思想是将装配的控制权移到程序之外，在模块化设计中这个机制尤其重要，其核心思想就是 <strong>解耦</strong>。</p>
<p>SPI整体机制图如下：</p>
<p><img src="/../images/13.jpg" alt="13"></p>
<p>当服务的提供者提供了一种接口的实现之后，需要在classpath下的<code>META-INF/services/</code>目录里创建一个以服务接口命名的文件，这个文件里的内容就是这个接口的具体的实现类。当其他的程序需要这个服务的时候，就可以通过查找这个jar包（一般都是以jar包做依赖）的<code>META-INF/services/</code>中的配置文件，配置文件中有接口的具体实现类名，可以根据这个类名进行加载实例化，就可以使用该服务了。JDK中查找服务的实现的工具类是：<code>java.util.ServiceLoader</code>。</p>
<h3 id="SPI机制的简单示例"><a href="#SPI机制的简单示例" class="headerlink" title="SPI机制的简单示例"></a>SPI机制的简单示例</h3><p>我们现在需要使用一个内容搜索接口，搜索的实现可能是基于文件系统的搜索，也可能是基于数据库的搜索。</p>
<ul>
<li>先定义好接口</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Search</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">searchDoc</span><span class="params">(String keyword)</span>;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>文件搜索实现</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">著作权归https:<span class="comment">//pdai.tech所有。</span></span><br><span class="line">链接：https:<span class="comment">//pdai.tech/md/java/advanced/java-advanced-spi.html</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileSearch</span> <span class="keyword">implements</span> <span class="title class_">Search</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">searchDoc</span><span class="params">(String keyword)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;文件搜索 &quot;</span>+keyword);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>数据库搜索实现</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">著作权归https:<span class="comment">//pdai.tech所有。</span></span><br><span class="line">链接：https:<span class="comment">//pdai.tech/md/java/advanced/java-advanced-spi.html</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DatabaseSearch</span> <span class="keyword">implements</span> <span class="title class_">Search</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">searchDoc</span><span class="params">(String keyword)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;数据搜索 &quot;</span>+keyword);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>resources 接下来可以在resources下新建META-INF&#x2F;services&#x2F;目录，然后新建接口全限定名的文件：<code>com.cainiao.ys.spi.learn.Search</code>，里面加上我们需要用到的实现类</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">com.cainiao.ys.spi.learn.Search</span><br></pre></td></tr></table></figure>

<ul>
<li>测试方法</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestCase</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        ServiceLoader&lt;Search&gt; s = ServiceLoader.load(Search.class);</span><br><span class="line">        Iterator&lt;Search&gt; iterator = s.iterator();</span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">           <span class="type">Search</span> <span class="variable">search</span> <span class="operator">=</span>  iterator.next();</span><br><span class="line">           search.searchDoc(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到输出结果：文件搜索 hello world</p>
<p>如果在<code>com.cainiao.ys.spi.learn.Search</code>文件里写上两个实现类，那最后的输出结果就是两行了。</p>
<p>这就是因为<code>ServiceLoader.load(Search.class)</code>在加载某接口时，会去<code>META-INF/services</code>下找接口的全限定名文件，再根据里面的内容加载相应的实现类。</p>
<p>这就是spi的思想，接口的实现由provider实现，provider只用在提交的jar包里的<code>META-INF/services</code>下根据平台定义的接口新建文件，并添加进相应的实现类内容就好。</p>
<h3 id="SPI机制的广泛应用"><a href="#SPI机制的广泛应用" class="headerlink" title="SPI机制的广泛应用"></a>SPI机制的广泛应用</h3><h4 id="SPI机制-JDBC-DriverManager"><a href="#SPI机制-JDBC-DriverManager" class="headerlink" title="SPI机制 - JDBC DriverManager"></a>SPI机制 - JDBC DriverManager</h4><p>在JDBC4.0之前，我们开发有连接数据库的时候，通常会用Class.forName(“com.mysql.jdbc.Driver”)这句先加载数据库相关的驱动，然后再进行获取连接等的操作。<strong>而JDBC4.0之后不需要用Class.forName(“com.mysql.jdbc.Driver”)来加载驱动，直接获取连接就可以了，现在这种方式就是使用了Java的SPI扩展机制来实现</strong>。</p>
<p><u>JDBC接口定义</u></p>
<p>首先在java中定义了接口<code>java.sql.Driver</code>，并没有具体的实现，具体的实现都是由不同厂商来提供的。</p>
<p><u>mysql实现</u></p>
<p>在mysql的jar包<code>mysql-connector-java-6.0.6.jar</code>中，可以找到<code>META-INF/services</code>目录，该目录下会有一个名字为<code>java.sql.Driver</code>的文件，文件内容是<code>com.mysql.cj.jdbc.Driver</code>，这里面的内容就是针对Java中定义的接口的实现。</p>
<p><u>postgresql实现</u></p>
<p>同样在postgresql的jar包<code>postgresql-42.0.0.jar</code>中，也可以找到同样的配置文件，文件内容是<code>org.postgresql.Driver</code>，这是postgresql对Java的<code>java.sql.Driver</code>的实现。</p>
<p><u>使用方法</u></p>
<p>上面说了，现在使用SPI扩展来加载具体的驱动，我们在Java中写连接数据库的代码的时候，不需要再使用<code>Class.forName(&quot;com.mysql.jdbc.Driver&quot;)</code>来加载驱动了，而是直接使用如下代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> <span class="string">&quot;jdbc:xxxx://xxxx:xxxx/xxxx&quot;</span>;</span><br><span class="line"><span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> DriverManager.getConnection(url,username,password);</span><br><span class="line">.....</span><br></pre></td></tr></table></figure>

<p>这里并没有涉及到spi的使用，接着看下面的解析。</p>
<p><u>源码实现</u></p>
<p>上面的使用方法，就是我们普通的连接数据库的代码，并没有涉及到SPI的东西，但是有一点我们可以确定的是，我们没有写有关具体驱动的硬编码<code>Class.forName(&quot;com.mysql.jdbc.Driver&quot;)</code>！</p>
<p>上面的代码可以直接获取数据库连接进行操作，但是跟SPI有啥关系呢？上面代码没有了加载驱动的代码，我们怎么去确定使用哪个数据库连接的驱动呢？这里就涉及到使用Java的SPI扩展机制来查找相关驱动的东西了，关于驱动的查找其实都在<code>DriverManager</code>中，<code>DriverManager</code>是Java中的实现，用来获取数据库连接，在<code>DriverManager</code>中有一个静态代码块如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    loadInitialDrivers();</span><br><span class="line">    println(<span class="string">&quot;JDBC DriverManager initialized&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到是加载实例化驱动的，接着看loadInitialDrivers方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">loadInitialDrivers</span><span class="params">()</span> &#123;</span><br><span class="line">    String drivers;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        drivers = AccessController.doPrivileged(<span class="keyword">new</span> <span class="title class_">PrivilegedAction</span>&lt;String&gt;() &#123;</span><br><span class="line">            <span class="keyword">public</span> String <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> System.getProperty(<span class="string">&quot;jdbc.drivers&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">        drivers = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    AccessController.doPrivileged(<span class="keyword">new</span> <span class="title class_">PrivilegedAction</span>&lt;Void&gt;() &#123;</span><br><span class="line">        <span class="keyword">public</span> Void <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">			<span class="comment">//使用SPI的ServiceLoader来加载接口的实现</span></span><br><span class="line">            ServiceLoader&lt;Driver&gt; loadedDrivers = ServiceLoader.load(Driver.class);</span><br><span class="line">            Iterator&lt;Driver&gt; driversIterator = loadedDrivers.iterator();</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                <span class="keyword">while</span>(driversIterator.hasNext()) &#123;</span><br><span class="line">                    driversIterator.next();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span>(Throwable t) &#123;</span><br><span class="line">            <span class="comment">// Do nothing</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    println(<span class="string">&quot;DriverManager.initialize: jdbc.drivers = &quot;</span> + drivers);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (drivers == <span class="literal">null</span> || drivers.equals(<span class="string">&quot;&quot;</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    String[] driversList = drivers.split(<span class="string">&quot;:&quot;</span>);</span><br><span class="line">    println(<span class="string">&quot;number of Drivers:&quot;</span> + driversList.length);</span><br><span class="line">    <span class="keyword">for</span> (String aDriver : driversList) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            println(<span class="string">&quot;DriverManager.Initialize: loading &quot;</span> + aDriver);</span><br><span class="line">            Class.forName(aDriver, <span class="literal">true</span>,</span><br><span class="line">                    ClassLoader.getSystemClassLoader());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">            println(<span class="string">&quot;DriverManager.Initialize: load failed: &quot;</span> + ex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码主要步骤是：</p>
<ul>
<li>从系统变量中获取有关驱动的定义。</li>
<li>使用SPI来获取驱动的实现。</li>
<li>遍历使用SPI获取到的具体实现，实例化各个实现类。</li>
<li>根据第一步获取到的驱动列表来实例化具体实现类。</li>
</ul>
<p>我们主要关注2,3步，这两步是SPI的用法，首先看第二步，使用SPI来获取驱动的实现，对应的代码是：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ServiceLoader&lt;Driver&gt; loadedDrivers = ServiceLoader.load(Driver.class);</span><br></pre></td></tr></table></figure>

<p>这里没有去<code>META-INF/services</code>目录下查找配置文件，也没有加载具体实现类，做的事情就是封装了我们的接口类型和类加载器，并初始化了一个迭代器。</p>
<p>接着看第三步，遍历使用SPI获取到的具体实现，实例化各个实现类，对应的代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//获取迭代器</span></span><br><span class="line">Iterator&lt;Driver&gt; driversIterator = loadedDrivers.iterator();</span><br><span class="line"><span class="comment">//遍历所有的驱动实现</span></span><br><span class="line"><span class="keyword">while</span>(driversIterator.hasNext()) &#123;</span><br><span class="line">    driversIterator.next();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在遍历的时候，首先调用<code>driversIterator.hasNext()</code>方法，这里会搜索classpath下以及jar包中所有的<code>META-INF/services</code>目录下的<code>java.sql.Driver</code>文件，并找到文件中的实现类的名字，此时并没有实例化具体的实现类（ServiceLoader具体的源码实现在下面）。</p>
<p>然后是调用<code>driversIterator.next();</code>方法，此时就会根据驱动名字具体实例化各个实现类了。现在驱动就被找到并实例化了。</p>
<p>可以看下截图，我在测试项目中添加了两个jar包，<code>mysql-connector-java-6.0.6.jar</code>和<code>postgresql-42.0.0.0.jar</code>，跟踪到DriverManager中之后：</p>
<p><img src="/../images/note42.png" alt="note42"></p>
<p>可以看到此时迭代器中有两个驱动，mysql和postgresql的都被加载了。</p>
<h4 id="SPI机制-Common-Logging"><a href="#SPI机制-Common-Logging" class="headerlink" title="SPI机制 - Common-Logging"></a>SPI机制 - Common-Logging</h4><p>common-logging（也称Jakarta Commons Logging，缩写 JCL）是常用的日志库门面。</p>
<p>首先，日志实例是通过LogFactory的getLog(String)方法创建的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="title function_">getLog</span><span class="params">(Class clazz)</span> <span class="keyword">throws</span> LogConfigurationException &#123;</span><br><span class="line">    <span class="keyword">return</span> getFactory().getInstance(clazz);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>LogFatory是一个抽象类，它负责加载具体的日志实现，分析其Factory getFactory()方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> org.apache.commons.logging.LogFactory <span class="title function_">getFactory</span><span class="params">()</span> <span class="keyword">throws</span> LogConfigurationException &#123;</span><br><span class="line">    <span class="comment">// Identify the class loader we will be using</span></span><br><span class="line">    <span class="type">ClassLoader</span> <span class="variable">contextClassLoader</span> <span class="operator">=</span> getContextClassLoaderInternal();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (contextClassLoader == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// This is an odd enough situation to report about. This</span></span><br><span class="line">        <span class="comment">// output will be a nuisance on JDK1.1, as the system</span></span><br><span class="line">        <span class="comment">// classloader is null in that environment.</span></span><br><span class="line">        <span class="keyword">if</span> (isDiagnosticsEnabled()) &#123;</span><br><span class="line">            logDiagnostic(<span class="string">&quot;Context classloader is null.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Return any previously registered factory for this class loader</span></span><br><span class="line">    org.apache.commons.logging.<span class="type">LogFactory</span> <span class="variable">factory</span> <span class="operator">=</span> getCachedFactory(contextClassLoader);</span><br><span class="line">    <span class="keyword">if</span> (factory != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> factory;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (isDiagnosticsEnabled()) &#123;</span><br><span class="line">        logDiagnostic(</span><br><span class="line">                <span class="string">&quot;[LOOKUP] LogFactory implementation requested for the first time for context classloader &quot;</span> +</span><br><span class="line">                        objectId(contextClassLoader));</span><br><span class="line">        logHierarchy(<span class="string">&quot;[LOOKUP] &quot;</span>, contextClassLoader);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Load properties file.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// If the properties file exists, then its contents are used as</span></span><br><span class="line">    <span class="comment">// &quot;attributes&quot; on the LogFactory implementation class. One particular</span></span><br><span class="line">    <span class="comment">// property may also control which LogFactory concrete subclass is</span></span><br><span class="line">    <span class="comment">// used, but only if other discovery mechanisms fail..</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// As the properties file (if it exists) will be used one way or</span></span><br><span class="line">    <span class="comment">// another in the end we may as well look for it first.</span></span><br><span class="line">    <span class="comment">// classpath根目录下寻找commons-logging.properties</span></span><br><span class="line">    <span class="type">Properties</span> <span class="variable">props</span> <span class="operator">=</span> getConfigurationFile(contextClassLoader, FACTORY_PROPERTIES);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Determine whether we will be using the thread context class loader to</span></span><br><span class="line">    <span class="comment">// load logging classes or not by checking the loaded properties file (if any).</span></span><br><span class="line">    <span class="comment">// classpath根目录下commons-logging.properties是否配置use_tccl</span></span><br><span class="line">    <span class="type">ClassLoader</span> <span class="variable">baseClassLoader</span> <span class="operator">=</span> contextClassLoader;</span><br><span class="line">    <span class="keyword">if</span> (props != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">useTCCLStr</span> <span class="operator">=</span> props.getProperty(TCCL_KEY);</span><br><span class="line">        <span class="keyword">if</span> (useTCCLStr != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// The Boolean.valueOf(useTCCLStr).booleanValue() formulation</span></span><br><span class="line">            <span class="comment">// is required for Java 1.2 compatibility.</span></span><br><span class="line">            <span class="keyword">if</span> (Boolean.valueOf(useTCCLStr).booleanValue() == <span class="literal">false</span>) &#123;</span><br><span class="line">                <span class="comment">// Don&#x27;t use current context classloader when locating any</span></span><br><span class="line">                <span class="comment">// LogFactory or Log classes, just use the class that loaded</span></span><br><span class="line">                <span class="comment">// this abstract class. When this class is deployed in a shared</span></span><br><span class="line">                <span class="comment">// classpath of a container, it means webapps cannot deploy their</span></span><br><span class="line">                <span class="comment">// own logging implementations. It also means that it is up to the</span></span><br><span class="line">                <span class="comment">// implementation whether to load library-specific config files</span></span><br><span class="line">                <span class="comment">// from the TCCL or not.</span></span><br><span class="line">                baseClassLoader = thisClassLoader;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里真正开始决定使用哪个factory</span></span><br><span class="line">    <span class="comment">// 首先，尝试查找vm系统属性org.apache.commons.logging.LogFactory，其是否指定factory</span></span><br><span class="line">    <span class="comment">// Determine which concrete LogFactory subclass to use.</span></span><br><span class="line">    <span class="comment">// First, try a global system property</span></span><br><span class="line">    <span class="keyword">if</span> (isDiagnosticsEnabled()) &#123;</span><br><span class="line">        logDiagnostic(<span class="string">&quot;[LOOKUP] Looking for system property [&quot;</span> + FACTORY_PROPERTY +</span><br><span class="line">                <span class="string">&quot;] to define the LogFactory subclass to use...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">factoryClass</span> <span class="operator">=</span> getSystemProperty(FACTORY_PROPERTY, <span class="literal">null</span>);</span><br><span class="line">        <span class="keyword">if</span> (factoryClass != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (isDiagnosticsEnabled()) &#123;</span><br><span class="line">                logDiagnostic(<span class="string">&quot;[LOOKUP] Creating an instance of LogFactory class &#x27;&quot;</span> + factoryClass +</span><br><span class="line">                        <span class="string">&quot;&#x27; as specified by system property &quot;</span> + FACTORY_PROPERTY);</span><br><span class="line">            &#125;</span><br><span class="line">            factory = newFactory(factoryClass, baseClassLoader, contextClassLoader);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (isDiagnosticsEnabled()) &#123;</span><br><span class="line">                logDiagnostic(<span class="string">&quot;[LOOKUP] No system property [&quot;</span> + FACTORY_PROPERTY + <span class="string">&quot;] defined.&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (SecurityException e) &#123;</span><br><span class="line">        <span class="keyword">if</span> (isDiagnosticsEnabled()) &#123;</span><br><span class="line">            logDiagnostic(<span class="string">&quot;[LOOKUP] A security exception occurred while trying to create an&quot;</span> +</span><br><span class="line">                    <span class="string">&quot; instance of the custom factory class&quot;</span> + <span class="string">&quot;: [&quot;</span> + trim(e.getMessage()) +</span><br><span class="line">                    <span class="string">&quot;]. Trying alternative implementations...&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// ignore</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (RuntimeException e) &#123;</span><br><span class="line">        <span class="comment">// This is not consistent with the behaviour when a bad LogFactory class is</span></span><br><span class="line">        <span class="comment">// specified in a services file.</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">// One possible exception that can occur here is a ClassCastException when</span></span><br><span class="line">        <span class="comment">// the specified class wasn&#x27;t castable to this LogFactory type.</span></span><br><span class="line">        <span class="keyword">if</span> (isDiagnosticsEnabled()) &#123;</span><br><span class="line">            logDiagnostic(<span class="string">&quot;[LOOKUP] An exception occurred while trying to create an&quot;</span> +</span><br><span class="line">                    <span class="string">&quot; instance of the custom factory class&quot;</span> + <span class="string">&quot;: [&quot;</span> +</span><br><span class="line">                    trim(e.getMessage()) +</span><br><span class="line">                    <span class="string">&quot;] as specified by a system property.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">throw</span> e;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第二，尝试使用java spi服务发现机制，载META-INF/services下寻找org.apache.commons.logging.LogFactory实现</span></span><br><span class="line">    <span class="comment">// Second, try to find a service by using the JDK1.3 class</span></span><br><span class="line">    <span class="comment">// discovery mechanism, which involves putting a file with the name</span></span><br><span class="line">    <span class="comment">// of an interface class in the META-INF/services directory, where the</span></span><br><span class="line">    <span class="comment">// contents of the file is a single line specifying a concrete class</span></span><br><span class="line">    <span class="comment">// that implements the desired interface.</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (factory == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (isDiagnosticsEnabled()) &#123;</span><br><span class="line">            logDiagnostic(<span class="string">&quot;[LOOKUP] Looking for a resource file of name [&quot;</span> + SERVICE_ID +</span><br><span class="line">                    <span class="string">&quot;] to define the LogFactory subclass to use...&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// META-INF/services/org.apache.commons.logging.LogFactory, SERVICE_ID</span></span><br><span class="line">            <span class="keyword">final</span> <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> getResourceAsStream(contextClassLoader, SERVICE_ID);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (is != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">// This code is needed by EBCDIC and other strange systems.</span></span><br><span class="line">                <span class="comment">// It&#x27;s a fix for bugs reported in xerces</span></span><br><span class="line">                BufferedReader rd;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    rd = <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(is, <span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">                &#125; <span class="keyword">catch</span> (java.io.UnsupportedEncodingException e) &#123;</span><br><span class="line">                    rd = <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(is));</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="type">String</span> <span class="variable">factoryClassName</span> <span class="operator">=</span> rd.readLine();</span><br><span class="line">                rd.close();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (factoryClassName != <span class="literal">null</span> &amp;&amp; !<span class="string">&quot;&quot;</span>.equals(factoryClassName)) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (isDiagnosticsEnabled()) &#123;</span><br><span class="line">                        logDiagnostic(<span class="string">&quot;[LOOKUP]  Creating an instance of LogFactory class &quot;</span> +</span><br><span class="line">                                factoryClassName +</span><br><span class="line">                                <span class="string">&quot; as specified by file &#x27;&quot;</span> + SERVICE_ID +</span><br><span class="line">                                <span class="string">&quot;&#x27; which was present in the path of the context classloader.&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    factory = newFactory(factoryClassName, baseClassLoader, contextClassLoader);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// is == null</span></span><br><span class="line">                <span class="keyword">if</span> (isDiagnosticsEnabled()) &#123;</span><br><span class="line">                    logDiagnostic(<span class="string">&quot;[LOOKUP] No resource file with name &#x27;&quot;</span> + SERVICE_ID + <span class="string">&quot;&#x27; found.&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">            <span class="comment">// note: if the specified LogFactory class wasn&#x27;t compatible with LogFactory</span></span><br><span class="line">            <span class="comment">// for some reason, a ClassCastException will be caught here, and attempts will</span></span><br><span class="line">            <span class="comment">// continue to find a compatible class.</span></span><br><span class="line">            <span class="keyword">if</span> (isDiagnosticsEnabled()) &#123;</span><br><span class="line">                logDiagnostic(</span><br><span class="line">                        <span class="string">&quot;[LOOKUP] A security exception occurred while trying to create an&quot;</span> +</span><br><span class="line">                                <span class="string">&quot; instance of the custom factory class&quot;</span> +</span><br><span class="line">                                <span class="string">&quot;: [&quot;</span> + trim(ex.getMessage()) +</span><br><span class="line">                                <span class="string">&quot;]. Trying alternative implementations...&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// ignore</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第三，尝试从classpath根目录下的commons-logging.properties中查找org.apache.commons.logging.LogFactory属性指定的factory</span></span><br><span class="line">    <span class="comment">// Third try looking into the properties file read earlier (if found)</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (factory == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (props != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (isDiagnosticsEnabled()) &#123;</span><br><span class="line">                logDiagnostic(</span><br><span class="line">                        <span class="string">&quot;[LOOKUP] Looking in properties file for entry with key &#x27;&quot;</span> + FACTORY_PROPERTY +</span><br><span class="line">                                <span class="string">&quot;&#x27; to define the LogFactory subclass to use...&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">String</span> <span class="variable">factoryClass</span> <span class="operator">=</span> props.getProperty(FACTORY_PROPERTY);</span><br><span class="line">            <span class="keyword">if</span> (factoryClass != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (isDiagnosticsEnabled()) &#123;</span><br><span class="line">                    logDiagnostic(</span><br><span class="line">                            <span class="string">&quot;[LOOKUP] Properties file specifies LogFactory subclass &#x27;&quot;</span> + factoryClass + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                factory = newFactory(factoryClass, baseClassLoader, contextClassLoader);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// <span class="doctag">TODO:</span> think about whether we need to handle exceptions from newFactory</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (isDiagnosticsEnabled()) &#123;</span><br><span class="line">                    logDiagnostic(<span class="string">&quot;[LOOKUP] Properties file has no entry specifying LogFactory subclass.&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (isDiagnosticsEnabled()) &#123;</span><br><span class="line">                logDiagnostic(<span class="string">&quot;[LOOKUP] No properties file available to determine&quot;</span> + <span class="string">&quot; LogFactory subclass from..&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 最后，使用后备factory实现，org.apache.commons.logging.impl.LogFactoryImpl</span></span><br><span class="line">    <span class="comment">// Fourth, try the fallback implementation class</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (factory == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (isDiagnosticsEnabled()) &#123;</span><br><span class="line">            logDiagnostic(</span><br><span class="line">                    <span class="string">&quot;[LOOKUP] Loading the default LogFactory implementation &#x27;&quot;</span> + FACTORY_DEFAULT +</span><br><span class="line">                            <span class="string">&quot;&#x27; via the same classloader that loaded this LogFactory&quot;</span> +</span><br><span class="line">                            <span class="string">&quot; class (ie not looking in the context classloader).&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Note: unlike the above code which can try to load custom LogFactory</span></span><br><span class="line">        <span class="comment">// implementations via the TCCL, we don&#x27;t try to load the default LogFactory</span></span><br><span class="line">        <span class="comment">// implementation via the context classloader because:</span></span><br><span class="line">        <span class="comment">// * that can cause problems (see comments in newFactory method)</span></span><br><span class="line">        <span class="comment">// * no-one should be customising the code of the default class</span></span><br><span class="line">        <span class="comment">// Yes, we do give up the ability for the child to ship a newer</span></span><br><span class="line">        <span class="comment">// version of the LogFactoryImpl class and have it used dynamically</span></span><br><span class="line">        <span class="comment">// by an old LogFactory class in the parent, but that isn&#x27;t</span></span><br><span class="line">        <span class="comment">// necessarily a good idea anyway.</span></span><br><span class="line">        factory = newFactory(FACTORY_DEFAULT, thisClassLoader, contextClassLoader);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (factory != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">            * Always cache using context class loader.</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">        cacheFactory(contextClassLoader, factory);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (props != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">Enumeration</span> <span class="variable">names</span> <span class="operator">=</span> props.propertyNames();</span><br><span class="line">            <span class="keyword">while</span> (names.hasMoreElements()) &#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> (String) names.nextElement();</span><br><span class="line">                <span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> props.getProperty(name);</span><br><span class="line">                factory.setAttribute(name, value);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> factory;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看出，抽象类LogFactory加载具体实现的步骤如下：</p>
<ul>
<li>从vm系统属性org.apache.commons.logging.LogFactory</li>
<li>使用SPI服务发现机制，发现org.apache.commons.logging.LogFactory的实现</li>
<li>查找classpath根目录commons-logging.properties的org.apache.commons.logging.LogFactory属性是否指定factory实现</li>
<li>使用默认factory实现，org.apache.commons.logging.impl.LogFactoryImpl</li>
</ul>
<p>LogFactory的getLog()方法返回类型是org.apache.commons.logging.Log接口，提供了从trace到fatal方法。可以确定，如果日志实现提供者只要实现该接口，并且使用继承自org.apache.commons.logging.LogFactory的子类创建Log，必然可以构建一个松耦合的日志系统。</p>
<h4 id="SPI机制-插件体系"><a href="#SPI机制-插件体系" class="headerlink" title="SPI机制 - 插件体系"></a>SPI机制 - 插件体系</h4><p>其实最具spi思想的应该属于插件开发，我们项目中也用到的这种思想，后面再说，这里具体说一下eclipse的插件思想。</p>
<p>Eclipse使用OSGi作为插件系统的基础，动态添加新插件和停止现有插件，以动态的方式管理组件生命周期。</p>
<p>一般来说，插件的文件结构必须在指定目录下包含以下三个文件：</p>
<ul>
<li><code>META-INF/MANIFEST.MF</code>: 项目基本配置信息，版本、名称、启动器等</li>
<li><code>build.properties</code>: 项目的编译配置信息，包括，源代码路径、输出路径</li>
<li><code>plugin.xml</code>：插件的操作配置信息，包含弹出菜单及点击菜单后对应的操作执行类等</li>
</ul>
<p>当eclipse启动时，会遍历plugins文件夹中的目录，扫描每个插件的清单文件<code>MANIFEST.MF</code>，并建立一个内部模型来记录它所找到的每个插件的信息，就实现了动态添加新的插件。</p>
<p>这也意味着是eclipse制定了一系列的规则，像是文件结构、类型、参数等。插件开发者遵循这些规则去开发自己的插件，eclipse并不需要知道插件具体是怎样开发的，只需要在启动的时候根据配置文件解析、加载到系统里就好了，是spi思想的一种体现。</p>
<h4 id="SPI机制-Spring中SPI机制"><a href="#SPI机制-Spring中SPI机制" class="headerlink" title="SPI机制 - Spring中SPI机制"></a>SPI机制 - Spring中SPI机制</h4><p>在springboot的自动装配过程中，最终会加载<code>META-INF/spring.factories</code>文件，而加载的过程是由<code>SpringFactoriesLoader</code>加载的。从CLASSPATH下的每个Jar包中搜寻所有<code>META-INF/spring.factories</code>配置文件，然后将解析properties文件，找到指定名称的配置后返回。需要注意的是，其实这里不仅仅是会去ClassPath路径下查找，会扫描所有路径下的Jar包，只不过这个文件只会在Classpath下的jar包中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">FACTORIES_RESOURCE_LOCATION</span> <span class="operator">=</span> <span class="string">&quot;META-INF/spring.factories&quot;</span>;</span><br><span class="line"><span class="comment">// spring.factories文件的格式为：key=value1,value2,value3</span></span><br><span class="line"><span class="comment">// 从所有的jar包中找到META-INF/spring.factories文件</span></span><br><span class="line"><span class="comment">// 然后从文件中解析出key=factoryClass类名称的所有value值</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title function_">loadFactoryNames</span><span class="params">(Class&lt;?&gt; factoryClass, ClassLoader classLoader)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">factoryClassName</span> <span class="operator">=</span> factoryClass.getName();</span><br><span class="line">    <span class="comment">// 取得资源文件的URL</span></span><br><span class="line">    Enumeration&lt;URL&gt; urls = (classLoader != <span class="literal">null</span> ? classLoader.getResources(FACTORIES_RESOURCE_LOCATION) : ClassLoader.getSystemResources(FACTORIES_RESOURCE_LOCATION));</span><br><span class="line">    List&lt;String&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line">    <span class="comment">// 遍历所有的URL</span></span><br><span class="line">    <span class="keyword">while</span> (urls.hasMoreElements()) &#123;</span><br><span class="line">        <span class="type">URL</span> <span class="variable">url</span> <span class="operator">=</span> urls.nextElement();</span><br><span class="line">        <span class="comment">// 根据资源文件URL解析properties文件，得到对应的一组@Configuration类</span></span><br><span class="line">        <span class="type">Properties</span> <span class="variable">properties</span> <span class="operator">=</span> PropertiesLoaderUtils.loadProperties(<span class="keyword">new</span> <span class="title class_">UrlResource</span>(url));</span><br><span class="line">        <span class="type">String</span> <span class="variable">factoryClassNames</span> <span class="operator">=</span> properties.getProperty(factoryClassName);</span><br><span class="line">        <span class="comment">// 组装数据，并返回</span></span><br><span class="line">        result.addAll(Arrays.asList(StringUtils.commaDelimitedListToStringArray(factoryClassNames)));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="SPI机制深入理解"><a href="#SPI机制深入理解" class="headerlink" title="SPI机制深入理解"></a>SPI机制深入理解</h3><h4 id="SPI机制通常怎么使用"><a href="#SPI机制通常怎么使用" class="headerlink" title="SPI机制通常怎么使用"></a>SPI机制通常怎么使用</h4><p>看完上面的几个例子解析，应该都能知道大概的流程了：</p>
<ul>
<li>有关组织或者公司定义标准。</li>
<li>具体厂商或者框架开发者实现。</li>
<li>程序猿使用。</li>
</ul>
<p><u>定义标准</u></p>
<p>定义标准，就是定义接口。比如接口<code>java.sql.Driver</code></p>
<p><u>具体厂商或者框架开发者实现</u></p>
<p>厂商或者框架开发者开发具体的实现：</p>
<p>在<code>META-INF/services</code>目录下定义一个名字为接口全限定名的文件，比如<code>java.sql.Driver</code>文件，文件内容是具体的实现名字，比如<code>me.cxis.sql.MyDriver</code>。</p>
<p>写具体的实现<code>me.cxis.sql.MyDriver</code>，都是对接口Driver的实现。</p>
<p> <u>程序猿使用</u></p>
<p>我们会引用具体厂商的jar包来实现我们的功能：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ServiceLoader&lt;Driver&gt; loadedDrivers = ServiceLoader.load(Driver.class);</span><br><span class="line"><span class="comment">//获取迭代器</span></span><br><span class="line">Iterator&lt;Driver&gt; driversIterator = loadedDrivers.iterator();</span><br><span class="line"><span class="comment">//遍历</span></span><br><span class="line"><span class="keyword">while</span>(driversIterator.hasNext()) &#123;</span><br><span class="line">    driversIterator.next();</span><br><span class="line">    <span class="comment">//可以做具体的业务逻辑</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><u>使用规范</u></p>
<p>最后总结一下jdk spi需要遵循的规范</p>
<p><img src="/../images/14.jpg" alt="14"></p>
<h4 id="SPI和API的区别是什么"><a href="#SPI和API的区别是什么" class="headerlink" title="SPI和API的区别是什么"></a>SPI和API的区别是什么</h4><blockquote>
<p>这里实际包含两个问题，第一个SPI和API的区别？第二个什么时候用API，什么时候用SPI？</p>
</blockquote>
<blockquote>
<p>SPI - “接口”位于“调用方”所在的“包”中</p>
</blockquote>
<ul>
<li>概念上更依赖调用方。</li>
<li>组织上位于调用方所在的包中。</li>
<li>实现位于独立的包中。</li>
<li>常见的例子是：插件模式的插件。</li>
</ul>
<p>API - “接口”位于“实现方”所在的“包”中</p>
<ul>
<li>概念上更接近实现方。</li>
<li>组织上位于实现方所在的包中。</li>
<li>实现和接口在一个包中。</li>
</ul>
<p><img src="/../images/note43.png" alt="note43"></p>
<p><img src="/../images/note44.png" alt="note44"></p>
<h4 id="SPI机制实现原理"><a href="#SPI机制实现原理" class="headerlink" title="SPI机制实现原理"></a>SPI机制实现原理</h4><p>不妨看下JDK中<code>ServiceLoader&lt;S&gt;</code>方法的具体实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//ServiceLoader实现了Iterable接口，可以遍历所有的服务实现者</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">ServiceLoader</span>&lt;S&gt;</span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">Iterable</span>&lt;S&gt;</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//查找配置文件的目录</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">PREFIX</span> <span class="operator">=</span> <span class="string">&quot;META-INF/services/&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//表示要被加载的服务的类或接口</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Class&lt;S&gt; service;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//这个ClassLoader用来定位，加载，实例化服务提供者</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ClassLoader loader;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 访问控制上下文</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AccessControlContext acc;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 缓存已经被实例化的服务提供者，按照实例化的顺序存储</span></span><br><span class="line">    <span class="keyword">private</span> LinkedHashMap&lt;String,S&gt; providers = <span class="keyword">new</span> <span class="title class_">LinkedHashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 迭代器</span></span><br><span class="line">    <span class="keyword">private</span> LazyIterator lookupIterator;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//重新加载，就相当于重新创建ServiceLoader了，用于新的服务提供者安装到正在运行的Java虚拟机中的情况。</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">reload</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//清空缓存中所有已实例化的服务提供者</span></span><br><span class="line">        providers.clear();</span><br><span class="line">        <span class="comment">//新建一个迭代器，该迭代器会从头查找和实例化服务提供者</span></span><br><span class="line">        lookupIterator = <span class="keyword">new</span> <span class="title class_">LazyIterator</span>(service, loader);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//私有构造器</span></span><br><span class="line">    <span class="comment">//使用指定的类加载器和服务创建服务加载器</span></span><br><span class="line">    <span class="comment">//如果没有指定类加载器，使用系统类加载器，就是应用类加载器。</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">ServiceLoader</span><span class="params">(Class&lt;S&gt; svc, ClassLoader cl)</span> &#123;</span><br><span class="line">        service = Objects.requireNonNull(svc, <span class="string">&quot;Service interface cannot be null&quot;</span>);</span><br><span class="line">        loader = (cl == <span class="literal">null</span>) ? ClassLoader.getSystemClassLoader() : cl;</span><br><span class="line">        acc = (System.getSecurityManager() != <span class="literal">null</span>) ? AccessController.getContext() : <span class="literal">null</span>;</span><br><span class="line">        reload();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//解析失败处理的方法</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">fail</span><span class="params">(Class&lt;?&gt; service, String msg, Throwable cause)</span></span><br><span class="line">        <span class="keyword">throws</span> ServiceConfigurationError</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ServiceConfigurationError</span>(service.getName() + <span class="string">&quot;: &quot;</span> + msg,</span><br><span class="line">                                            cause);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">fail</span><span class="params">(Class&lt;?&gt; service, String msg)</span></span><br><span class="line">        <span class="keyword">throws</span> ServiceConfigurationError</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ServiceConfigurationError</span>(service.getName() + <span class="string">&quot;: &quot;</span> + msg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">fail</span><span class="params">(Class&lt;?&gt; service, URL u, <span class="type">int</span> line, String msg)</span></span><br><span class="line">        <span class="keyword">throws</span> ServiceConfigurationError</span><br><span class="line">    &#123;</span><br><span class="line">        fail(service, u + <span class="string">&quot;:&quot;</span> + line + <span class="string">&quot;: &quot;</span> + msg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//解析服务提供者配置文件中的一行</span></span><br><span class="line">    <span class="comment">//首先去掉注释校验，然后保存</span></span><br><span class="line">    <span class="comment">//返回下一行行号</span></span><br><span class="line">    <span class="comment">//重复的配置项和已经被实例化的配置项不会被保存</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">parseLine</span><span class="params">(Class&lt;?&gt; service, URL u, BufferedReader r, <span class="type">int</span> lc,</span></span><br><span class="line"><span class="params">                          List&lt;String&gt; names)</span></span><br><span class="line">        <span class="keyword">throws</span> IOException, ServiceConfigurationError</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//读取一行</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">ln</span> <span class="operator">=</span> r.readLine();</span><br><span class="line">        <span class="keyword">if</span> (ln == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//#号代表注释行</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">ci</span> <span class="operator">=</span> ln.indexOf(<span class="string">&#x27;#&#x27;</span>);</span><br><span class="line">        <span class="keyword">if</span> (ci &gt;= <span class="number">0</span>) ln = ln.substring(<span class="number">0</span>, ci);</span><br><span class="line">        ln = ln.trim();</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> ln.length();</span><br><span class="line">        <span class="keyword">if</span> (n != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((ln.indexOf(<span class="string">&#x27; &#x27;</span>) &gt;= <span class="number">0</span>) || (ln.indexOf(<span class="string">&#x27;\t&#x27;</span>) &gt;= <span class="number">0</span>))</span><br><span class="line">                fail(service, u, lc, <span class="string">&quot;Illegal configuration-file syntax&quot;</span>);</span><br><span class="line">            <span class="type">int</span> <span class="variable">cp</span> <span class="operator">=</span> ln.codePointAt(<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span> (!Character.isJavaIdentifierStart(cp))</span><br><span class="line">                fail(service, u, lc, <span class="string">&quot;Illegal provider-class name: &quot;</span> + ln);</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> Character.charCount(cp); i &lt; n; i += Character.charCount(cp)) &#123;</span><br><span class="line">                cp = ln.codePointAt(i);</span><br><span class="line">                <span class="keyword">if</span> (!Character.isJavaIdentifierPart(cp) &amp;&amp; (cp != <span class="string">&#x27;.&#x27;</span>))</span><br><span class="line">                    fail(service, u, lc, <span class="string">&quot;Illegal provider-class name: &quot;</span> + ln);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!providers.containsKey(ln) &amp;&amp; !names.contains(ln))</span><br><span class="line">                names.add(ln);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> lc + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//解析配置文件，解析指定的url配置文件</span></span><br><span class="line">    <span class="comment">//使用parseLine方法进行解析，未被实例化的服务提供者会被保存到缓存中去</span></span><br><span class="line">    <span class="keyword">private</span> Iterator&lt;String&gt; <span class="title function_">parse</span><span class="params">(Class&lt;?&gt; service, URL u)</span></span><br><span class="line">        <span class="keyword">throws</span> ServiceConfigurationError</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">in</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">BufferedReader</span> <span class="variable">r</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        ArrayList&lt;String&gt; names = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            in = u.openStream();</span><br><span class="line">            r = <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(in, <span class="string">&quot;utf-8&quot;</span>));</span><br><span class="line">            <span class="type">int</span> <span class="variable">lc</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> ((lc = parseLine(service, u, r, lc, names)) &gt;= <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> names.iterator();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//服务提供者查找的迭代器</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">LazyIterator</span></span><br><span class="line">        <span class="keyword">implements</span> <span class="title class_">Iterator</span>&lt;S&gt;</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        Class&lt;S&gt; service;<span class="comment">//服务提供者接口</span></span><br><span class="line">        ClassLoader loader;<span class="comment">//类加载器</span></span><br><span class="line">        Enumeration&lt;URL&gt; configs = <span class="literal">null</span>;<span class="comment">//保存实现类的url</span></span><br><span class="line">        Iterator&lt;String&gt; pending = <span class="literal">null</span>;<span class="comment">//保存实现类的全名</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">nextName</span> <span class="operator">=</span> <span class="literal">null</span>;<span class="comment">//迭代器中下一个实现类的全名</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="title function_">LazyIterator</span><span class="params">(Class&lt;S&gt; service, ClassLoader loader)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.service = service;</span><br><span class="line">            <span class="built_in">this</span>.loader = loader;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">hasNextService</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (nextName != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (configs == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="type">String</span> <span class="variable">fullName</span> <span class="operator">=</span> PREFIX + service.getName();</span><br><span class="line">                    <span class="keyword">if</span> (loader == <span class="literal">null</span>)</span><br><span class="line">                        configs = ClassLoader.getSystemResources(fullName);</span><br><span class="line">                    <span class="type">else</span></span><br><span class="line">                        <span class="variable">configs</span> <span class="operator">=</span> loader.getResources(fullName);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> ((pending == <span class="literal">null</span>) || !pending.hasNext()) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!configs.hasMoreElements()) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                pending = parse(service, configs.nextElement());</span><br><span class="line">            &#125;</span><br><span class="line">            nextName = pending.next();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> S <span class="title function_">nextService</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (!hasNextService())</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NoSuchElementException</span>();</span><br><span class="line">            <span class="type">String</span> <span class="variable">cn</span> <span class="operator">=</span> nextName;</span><br><span class="line">            nextName = <span class="literal">null</span>;</span><br><span class="line">            Class&lt;?&gt; c = <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                c = Class.forName(cn, <span class="literal">false</span>, loader);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!service.isAssignableFrom(c)) &#123;</span><br><span class="line">                fail(service, <span class="string">&quot;Provider &quot;</span> + cn  + <span class="string">&quot; not a subtype&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="type">S</span> <span class="variable">p</span> <span class="operator">=</span> service.cast(c.newInstance());</span><br><span class="line">                providers.put(cn, p);</span><br><span class="line">                <span class="keyword">return</span> p;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (acc == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> hasNextService();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                PrivilegedAction&lt;Boolean&gt; action = <span class="keyword">new</span> <span class="title class_">PrivilegedAction</span>&lt;Boolean&gt;() &#123;</span><br><span class="line">                    <span class="keyword">public</span> Boolean <span class="title function_">run</span><span class="params">()</span> &#123; <span class="keyword">return</span> hasNextService(); &#125;</span><br><span class="line">                &#125;;</span><br><span class="line">                <span class="keyword">return</span> AccessController.doPrivileged(action, acc);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> S <span class="title function_">next</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (acc == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> nextService();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                PrivilegedAction&lt;S&gt; action = <span class="keyword">new</span> <span class="title class_">PrivilegedAction</span>&lt;S&gt;() &#123;</span><br><span class="line">                    <span class="keyword">public</span> S <span class="title function_">run</span><span class="params">()</span> &#123; <span class="keyword">return</span> nextService(); &#125;</span><br><span class="line">                &#125;;</span><br><span class="line">                <span class="keyword">return</span> AccessController.doPrivileged(action, acc);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnsupportedOperationException</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取迭代器</span></span><br><span class="line">    <span class="comment">//返回遍历服务提供者的迭代器</span></span><br><span class="line">    <span class="comment">//以懒加载的方式加载可用的服务提供者</span></span><br><span class="line">    <span class="comment">//懒加载的实现是：解析配置文件和实例化服务提供者的工作由迭代器本身完成</span></span><br><span class="line">    <span class="keyword">public</span> Iterator&lt;S&gt; <span class="title function_">iterator</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Iterator</span>&lt;S&gt;() &#123;</span><br><span class="line">            <span class="comment">//按照实例化顺序返回已经缓存的服务提供者实例</span></span><br><span class="line">            Iterator&lt;Map.Entry&lt;String,S&gt;&gt; knownProviders</span><br><span class="line">                = providers.entrySet().iterator();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (knownProviders.hasNext())</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">return</span> lookupIterator.hasNext();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">public</span> S <span class="title function_">next</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (knownProviders.hasNext())</span><br><span class="line">                    <span class="keyword">return</span> knownProviders.next().getValue();</span><br><span class="line">                <span class="keyword">return</span> lookupIterator.next();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnsupportedOperationException</span>();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//为指定的服务使用指定的类加载器来创建一个ServiceLoader</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;S&gt; ServiceLoader&lt;S&gt; <span class="title function_">load</span><span class="params">(Class&lt;S&gt; service,</span></span><br><span class="line"><span class="params">                                            ClassLoader loader)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ServiceLoader</span>&lt;&gt;(service, loader);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//使用线程上下文的类加载器来创建ServiceLoader</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;S&gt; ServiceLoader&lt;S&gt; <span class="title function_">load</span><span class="params">(Class&lt;S&gt; service)</span> &#123;</span><br><span class="line">        <span class="type">ClassLoader</span> <span class="variable">cl</span> <span class="operator">=</span> Thread.currentThread().getContextClassLoader();</span><br><span class="line">        <span class="keyword">return</span> ServiceLoader.load(service, cl);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//使用扩展类加载器为指定的服务创建ServiceLoader</span></span><br><span class="line">    <span class="comment">//只能找到并加载已经安装到当前Java虚拟机中的服务提供者，应用程序类路径中的服务提供者将被忽略</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;S&gt; ServiceLoader&lt;S&gt; <span class="title function_">loadInstalled</span><span class="params">(Class&lt;S&gt; service)</span> &#123;</span><br><span class="line">        <span class="type">ClassLoader</span> <span class="variable">cl</span> <span class="operator">=</span> ClassLoader.getSystemClassLoader();</span><br><span class="line">        <span class="type">ClassLoader</span> <span class="variable">prev</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">while</span> (cl != <span class="literal">null</span>) &#123;</span><br><span class="line">            prev = cl;</span><br><span class="line">            cl = cl.getParent();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ServiceLoader.load(service, prev);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;java.util.ServiceLoader[&quot;</span> + service.getName() + <span class="string">&quot;]&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>首先</strong>，ServiceLoader实现了<code>Iterable</code>接口，所以它有迭代器的属性，这里主要都是实现了迭代器的<code>hasNext</code>和<code>next</code>方法。这里主要都是调用的<code>lookupIterator</code>的相应<code>hasNext</code>和<code>next</code>方法，<code>lookupIterator</code>是懒加载迭代器。</p>
<p><strong>其次</strong>，<code>LazyIterator</code>中的<code>hasNext</code>方法，静态变量PREFIX就是<code>”META-INF/services/”</code>目录，这也就是为什么需要在<code>classpath</code>下的<code>META-INF/services/</code>目录里创建一个以服务接口命名的文件。</p>
<p><strong>最后</strong>，通过反射方法<code>Class.forName()</code>加载类对象，并用<code>newInstance</code>方法将类实例化，并把实例化后的类缓存到<code>providers</code>对象中，(<code>LinkedHashMap&lt;String,S&gt;</code>类型）然后返回实例对象。</p>
<p>所以我们可以看到<code>ServiceLoader</code>不是实例化以后，就去读取配置文件中的具体实现，并进行实例化。而是等到使用迭代器去遍历的时候，才会加载对应的配置文件去解析，调用<code>hasNext</code>方法的时候会去加载配置文件进行解析，调用<code>next</code>方法的时候进行实例化并缓存。</p>
<p>所有的配置文件只会加载一次，服务提供者也只会被实例化一次，重新加载配置文件可使用<code>reload</code>方法。</p>
<h4 id="SPI机制的缺陷"><a href="#SPI机制的缺陷" class="headerlink" title="SPI机制的缺陷"></a>SPI机制的缺陷</h4><p>通过上面的解析，可以发现，我们使用SPI机制的缺陷：</p>
<ul>
<li>不能按需加载，需要遍历所有的实现，并实例化，然后在循环中才能找到我们需要的实现。如果不想用某些实现类，或者某些类实例化很耗时，它也被载入并实例化了，这就造成了浪费。</li>
<li>获取某个实现类的方式不够灵活，只能通过 Iterator 形式获取，不能根据某个参数来获取对应的实现类。</li>
<li>多个并发多线程使用 ServiceLoader 类的实例是不安全的。</li>
</ul>
]]></content>
      <categories>
        <category>java</category>
      </categories>
  </entry>
  <entry>
    <title>java基础知识-注解机制详解 - java</title>
    <url>/2022/05/25/2022-05-25-java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86-%E6%B3%A8%E8%A7%A3%E6%9C%BA%E5%88%B6%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<h1 id="注解机制详解"><a href="#注解机制详解" class="headerlink" title="注解机制详解"></a>注解机制详解</h1><span id="more"></span>

<h3 id="注解基础"><a href="#注解基础" class="headerlink" title="注解基础"></a>注解基础</h3><p>注解是JDK1.5版本开始引入的一个特性，用于对代码进行说明，可以对包、类、接口、字段、方法参数、局部变量等进行注解。它主要的作用有以下四方面：</p>
<ul>
<li>生成文档，通过代码里标识的元数据生成javadoc文档。</li>
<li>编译检查，通过代码里标识的元数据让编译器在编译期间进行检查验证。</li>
<li>编译时动态处理，编译时通过代码里标识的元数据动态处理，例如动态生成代码。</li>
<li>运行时动态处理，运行时通过代码里标识的元数据动态处理，例如使用反射注入实例</li>
</ul>
<p>这么来说是比较抽象的，我们具体看下注解的常见分类：</p>
<ul>
<li><strong>Java自带的标准注解</strong>，包括<code>@Override</code>、<code>@Deprecated</code>和<code>@SuppressWarnings</code>，分别用于标明重写某个方法、标明某个类或方法过时、标明要忽略的警告，用这些注解标明后编译器就会进行检查。</li>
<li><strong>元注解</strong>，元注解是用于定义注解的注解，包括<code>@Retention</code>、<code>@Target</code>、<code>@Inherited</code>、<code>@Documented</code>，<code>@Retention</code>用于标明注解被保留的阶段，<code>@Target</code>用于标明注解使用的范围，<code>@Inherited</code>用于标明注解可继承，<code>@Documented</code>用于标明是否生成javadoc文档。</li>
<li><strong>自定义注解</strong>，可以根据自己的需求定义注解，并可用元注解对自定义注解进行注解。</li>
</ul>
<h4 id="Java内置注解"><a href="#Java内置注解" class="headerlink" title="Java内置注解"></a>Java内置注解</h4><p>我们从最为常见的Java内置的注解开始说起，先看下下面的代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_">A</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * 重载父类的test方法</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * 被弃用的方法</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">    <span class="meta">@Deprecated</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">oldMethod</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * 忽略告警</span></span><br><span class="line"><span class="comment">        * </span></span><br><span class="line"><span class="comment">        * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;rawtypes&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> List <span class="title function_">processList</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">List</span> <span class="variable">list</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Java 1.5开始自带的标准注解，包括<code>@Override</code>、<code>@Deprecated</code>和<code>@SuppressWarnings</code>：</p>
<ul>
<li><code>@Override</code>：表示当前的方法定义将覆盖父类中的方法</li>
<li><code>@Deprecated</code>：表示代码被弃用，如果使用了被@Deprecated注解的代码则编译器将发出警告</li>
<li><code>@SuppressWarnings</code>：表示关闭编译器警告信息</li>
</ul>
<p><u>内置注解 - @Override</u></p>
<p>我们先来看一下这个注解类型的定义：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.METHOD)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.SOURCE)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Override &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从它的定义我们可以看到，这个注解可以被用来修饰方法，并且它只在编译时有效，在编译后的class文件中便不再存在。这个注解的作用我们大家都不陌生，那就是告诉编译器被修饰的方法是重写的父类的中的相同签名的方法，编译器会对此做出检查，若发现父类中不存在这个方法或是存在的方法签名不同，则会报错。</p>
<p><u>内置注解 - @Deprecated</u></p>
<p>这个注解的定义如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(value=&#123;CONSTRUCTOR, FIELD, LOCAL_VARIABLE, METHOD, PACKAGE, PARAMETER, TYPE&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Deprecated &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从它的定义我们可以知道，它会被文档化，能够保留到运行时，能够修饰构造方法、属性、局部变量、方法、包、参数、类型。这个注解的作用是告诉编译器被修饰的程序元素已被“废弃”，不再建议用户使用。</p>
<p><u>内置注解 - @SuppressWarnings</u></p>
<p>这个注解我们也比较常用到，先来看下它的定义：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target(&#123;TYPE, FIELD, METHOD, PARAMETER, CONSTRUCTOR, LOCAL_VARIABLE&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.SOURCE)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> SuppressWarnings &#123;</span><br><span class="line">    String[] value();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>它能够修饰的程序元素包括类型、属性、方法、参数、构造器、局部变量，只能存活在源码时，取值为String[]。它的作用是告诉编译器忽略指定的警告信息，它可以取的值如下所示：</p>
<table>
<thead>
<tr>
<th align="center">参数</th>
<th align="center">作用</th>
<th align="center">原描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">all</td>
<td align="center">抑制所有警告</td>
<td align="center">to suppress all warnings</td>
</tr>
<tr>
<td align="center">boxing</td>
<td align="center">抑制装箱、拆箱操作时候的警告</td>
<td align="center">to suppress warnings relative to boxing&#x2F;unboxing operations</td>
</tr>
<tr>
<td align="center">cast</td>
<td align="center">抑制映射相关的警告</td>
<td align="center">to suppress warnings relative to cast operations</td>
</tr>
<tr>
<td align="center">dep-ann</td>
<td align="center">抑制启用注释的警告</td>
<td align="center">to suppress warnings relative to deprecated annotation</td>
</tr>
<tr>
<td align="center">deprecation</td>
<td align="center">抑制过期方法警告</td>
<td align="center">to suppress warnings relative to deprecation</td>
</tr>
<tr>
<td align="center">fallthrough</td>
<td align="center">抑制确在switch中缺失breaks的警告</td>
<td align="center">to suppress warnings relative to missing breaks in switch statements</td>
</tr>
<tr>
<td align="center">finally</td>
<td align="center">抑制finally模块没有返回的警告</td>
<td align="center">to suppress warnings relative to finally block that don’t return</td>
</tr>
<tr>
<td align="center">hiding</td>
<td align="center">抑制与隐藏变数的区域变数相关的警告</td>
<td align="center">to suppress warnings relative to locals that hide variable（）</td>
</tr>
<tr>
<td align="center">incomplete-switch</td>
<td align="center">忽略没有完整的switch语句</td>
<td align="center">to suppress warnings relative to missing entries in a switch statement (enum case)</td>
</tr>
<tr>
<td align="center">nls</td>
<td align="center">忽略非nls格式的字符</td>
<td align="center">to suppress warnings relative to non-nls string literals</td>
</tr>
<tr>
<td align="center">null</td>
<td align="center">忽略对null的操作</td>
<td align="center">to suppress warnings relative to null analysis</td>
</tr>
<tr>
<td align="center">rawtype</td>
<td align="center">使用generics时忽略没有指定相应的类型</td>
<td align="center">to suppress warnings relative to un-specific types when using</td>
</tr>
<tr>
<td align="center">restriction</td>
<td align="center">抑制与使用不建议或禁止参照相关的警告</td>
<td align="center">to suppress warnings relative to usage of discouraged or</td>
</tr>
<tr>
<td align="center">serial</td>
<td align="center">忽略在serializable类中没有声明serialVersionUID变量</td>
<td align="center">to suppress warnings relative to missing serialVersionUID field for a serializable class</td>
</tr>
<tr>
<td align="center">static-access</td>
<td align="center">抑制不正确的静态访问方式警告</td>
<td align="center">to suppress warnings relative to incorrect static access</td>
</tr>
<tr>
<td align="center">synthetic-access</td>
<td align="center">抑制子类没有按最优方法访问内部类的警告</td>
<td align="center">to suppress warnings relative to unoptimized access from inner classes</td>
</tr>
<tr>
<td align="center">unchecked</td>
<td align="center">抑制没有进行类型检查操作的警告</td>
<td align="center">to suppress warnings relative to unchecked operations</td>
</tr>
<tr>
<td align="center">unqualified-field-access</td>
<td align="center">抑制没有权限访问的域的警告</td>
<td align="center">to suppress warnings relative to field access unqualified</td>
</tr>
<tr>
<td align="center">unused</td>
<td align="center">抑制没被使用过的代码的警告</td>
<td align="center">to suppress warnings relative to unused code</td>
</tr>
</tbody></table>
<h4 id="元注解"><a href="#元注解" class="headerlink" title="元注解"></a>元注解</h4><p>上述内置注解的定义中使用了一些元注解（注解类型进行注解的注解类），在JDK 1.5中提供了4个标准的元注解：<code>@Target</code>，<code>@Retention</code>，<code>@Documented</code>，<code>@Inherited</code>, 在JDK 1.8中提供了两个元注解 <code>@Repeatable</code>和<code>@Native</code>。</p>
<p><u>元注解 - @Target</u></p>
<p>Target注解的作用是：描述注解的使用范围（即：被修饰的注解可以用在什么地方） 。</p>
<p>Target注解用来说明那些被它所注解的注解类可修饰的对象范围：注解可以用于修饰 packages、types（类、接口、枚举、注解类）、类成员（方法、构造方法、成员变量、枚举值）、方法参数和本地变量（如循环变量、catch参数），在定义注解类时使用了@Target 能够更加清晰的知道它能够被用来修饰哪些对象，它的取值范围定义在ElementType 枚举中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">ElementType</span> &#123;</span><br><span class="line"> </span><br><span class="line">    TYPE, <span class="comment">// 类、接口、枚举类</span></span><br><span class="line"> </span><br><span class="line">    FIELD, <span class="comment">// 成员变量（包括：枚举常量）</span></span><br><span class="line"> </span><br><span class="line">    METHOD, <span class="comment">// 成员方法</span></span><br><span class="line"> </span><br><span class="line">    PARAMETER, <span class="comment">// 方法参数</span></span><br><span class="line"> </span><br><span class="line">    CONSTRUCTOR, <span class="comment">// 构造方法</span></span><br><span class="line"> </span><br><span class="line">    LOCAL_VARIABLE, <span class="comment">// 局部变量</span></span><br><span class="line"> </span><br><span class="line">    ANNOTATION_TYPE, <span class="comment">// 注解类</span></span><br><span class="line"> </span><br><span class="line">    PACKAGE, <span class="comment">// 可用于修饰：包</span></span><br><span class="line"> </span><br><span class="line">    TYPE_PARAMETER, <span class="comment">// 类型参数，JDK 1.8 新增</span></span><br><span class="line"> </span><br><span class="line">    TYPE_USE <span class="comment">// 使用类型的任何地方，JDK 1.8 新增</span></span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> <u>元注解 - @Retention &amp; @RetentionTarget</u></p>
<p> Reteniton注解的作用是：描述注解保留的时间范围（即：被描述的注解在它所修饰的类中可以被保留到何时） </p>
<p>Reteniton注解用来限定那些被它所注解的注解类在注解到其他类上以后，可被保留到何时，一共有三种策略，定义在RetentionPolicy枚举中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">RetentionPolicy</span> &#123;</span><br><span class="line"> </span><br><span class="line">    SOURCE,    <span class="comment">// 源文件保留</span></span><br><span class="line">    CLASS,       <span class="comment">// 编译期保留，默认值</span></span><br><span class="line">    RUNTIME   <span class="comment">// 运行期保留，可通过反射去获取注解信息</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为了验证应用了这三种策略的注解类有何区别，分别使用三种策略各定义一个注解类做测试。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Retention(RetentionPolicy.SOURCE)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> SourcePolicy &#123;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.CLASS)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> ClassPolicy &#123;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> RuntimePolicy &#123;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>用定义好的三个注解类分别去注解一个方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RetentionTest</span> &#123;</span><br><span class="line"> </span><br><span class="line">	<span class="meta">@SourcePolicy</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sourcePolicy</span><span class="params">()</span> &#123;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="meta">@ClassPolicy</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">classPolicy</span><span class="params">()</span> &#123;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="meta">@RuntimePolicy</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">runtimePolicy</span><span class="params">()</span> &#123;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过执行 <code>javap -verbose RetentionTest</code>命令获取到的RetentionTest 的 class 字节码内容如下。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="keyword">public</span> retention.RetentionTest();</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">1</span>, locals=<span class="number">1</span>, args_size=<span class="number">1</span></span><br><span class="line">         <span class="number">0</span>: aload_0</span><br><span class="line">         <span class="number">1</span>: invokespecial #<span class="number">1</span>                  <span class="comment">// Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">         <span class="number">4</span>: <span class="keyword">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">3</span>: <span class="number">0</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sourcePolicy</span><span class="params">()</span>;</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">0</span>, locals=<span class="number">1</span>, args_size=<span class="number">1</span></span><br><span class="line">         <span class="number">0</span>: <span class="keyword">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">7</span>: <span class="number">0</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">classPolicy</span><span class="params">()</span>;</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">0</span>, locals=<span class="number">1</span>, args_size=<span class="number">1</span></span><br><span class="line">         <span class="number">0</span>: <span class="keyword">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">11</span>: <span class="number">0</span></span><br><span class="line">    RuntimeInvisibleAnnotations:</span><br><span class="line">      <span class="number">0</span>: #<span class="number">11</span>()</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">runtimePolicy</span><span class="params">()</span>;</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">0</span>, locals=<span class="number">1</span>, args_size=<span class="number">1</span></span><br><span class="line">         <span class="number">0</span>: <span class="keyword">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">15</span>: <span class="number">0</span></span><br><span class="line">    RuntimeVisibleAnnotations:</span><br><span class="line">      <span class="number">0</span>: #<span class="number">14</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从 RetentionTest 的字节码内容我们可以得出以下两点结论：</p>
<ul>
<li>编译器并没有记录下 sourcePolicy() 方法的注解信息；</li>
<li>编译器分别使用了 <code>RuntimeInvisibleAnnotations</code> 和 <code>RuntimeVisibleAnnotations</code> 属性去记录了<code>classPolicy()</code>方法 和 <code>runtimePolicy()</code>方法 的注解信息；</li>
</ul>
<p><u>元注解 - @Documented</u></p>
<p>Documented注解的作用是：描述在使用 javadoc 工具为类生成帮助文档时是否要保留其注解信息。</p>
<p>以下代码在使用Javadoc工具可以生成<code>@TestDocAnnotation</code>注解信息。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.annotation.Documented;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.ElementType;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Target;</span><br><span class="line"> </span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Target(&#123;ElementType.TYPE,ElementType.METHOD&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> TestDocAnnotation &#123;</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">public</span> String <span class="title function_">value</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;default&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@TestDocAnnotation(&quot;myMethodDoc&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testDoc</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><u>元注解 - @Inherited</u></p>
<p>Inherited注解的作用：被它修饰的Annotation将具有继承性。如果某个类使用了被@Inherited修饰的Annotation，则其子类将自动具有该注解。</p>
<p>我们来测试下这个注解：</p>
<ul>
<li>定义<code>@Inherited</code>注解：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(&#123;ElementType.TYPE,ElementType.METHOD&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> TestInheritedAnnotation &#123;</span><br><span class="line">    String [] values();</span><br><span class="line">    <span class="type">int</span> <span class="title function_">number</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>使用这个注解</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@TestInheritedAnnotation(values = &#123;&quot;value&quot;&#125;, number = 10)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">extends</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> Student.class;</span><br><span class="line">        Annotation[] annotations = clazz.getAnnotations();</span><br><span class="line">        <span class="keyword">for</span> (Annotation annotation : annotations) &#123;</span><br><span class="line">            System.out.println(annotation.toString());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>输出</li>
</ul>
<p>即使Student类没有显示地被注解<code>@TestInheritedAnnotation</code>，但是它的父类Person被注解，而且<code>@TestInheritedAnnotation</code>被<code>@Inherited</code>注解，因此Student类自动有了该注解。</p>
<p><u>元注解 - @Repeatable (Java8)</u></p>
<p>允许在同一申明类型(类，属性，或方法)的多次使用同一个注解</p>
<p>java 8之前也有重复使用注解的解决方案，但可读性不是很好，比如下面的代码:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Authority &#123;</span><br><span class="line">     String <span class="title function_">role</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Authorities &#123;</span><br><span class="line">    Authority[] value();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RepeatAnnotationUseOldVersion</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Authorities(&#123;@Authority(role=&quot;Admin&quot;),@Authority(role=&quot;Manager&quot;)&#125;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doSomeThing</span><span class="params">()</span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由另一个注解来存储重复注解，在使用时候，用存储注解Authorities来扩展重复注解。</p>
<p>我们再来看看java 8里面的做法:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Repeatable(Authorities.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Authority &#123;</span><br><span class="line">     String <span class="title function_">role</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Authorities &#123;</span><br><span class="line">    Authority[] value();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RepeatAnnotationUseNewVersion</span> &#123;</span><br><span class="line">    <span class="meta">@Authority(role=&quot;Admin&quot;)</span></span><br><span class="line">    <span class="meta">@Authority(role=&quot;Manager&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doSomeThing</span><span class="params">()</span>&#123; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不同的地方是，创建重复注解Authority时，加上@Repeatable,指向存储注解Authorities，在使用时候，直接可以重复使用Authority注解。从上面例子看出，java 8里面做法更适合常规的思维，可读性强一点。</p>
<p><u>元注解 - @Native (Java8)</u></p>
<p>使用 @Native 注解修饰成员变量，则表示这个变量可以被本地代码引用，常常被代码生成工具使用。</p>
<h4 id="注解与反射接口"><a href="#注解与反射接口" class="headerlink" title="注解与反射接口"></a>注解与反射接口</h4><p>定义注解后，如何获取注解中的内容呢？反射包java.lang.reflect下的AnnotatedElement接口提供这些方法。这里注意：只有注解被定义为RUNTIME后，该注解才能是运行时可见，当class文件被装载时被保存在class文件中的Annotation才会被虚拟机读取。</p>
<p>AnnotatedElement 接口是所有程序元素（Class、Method和Constructor）的父接口，所以程序通过反射获取了某个类的AnnotatedElement对象之后，程序就可以调用该对象的方法来访问Annotation信息。我们看下具体的先关接口。</p>
<ul>
<li><code>boolean isAnnotationPresent(Class&lt;?extends Annotation&gt; annotationClass)</code></li>
</ul>
<p>判断该程序元素上是否包含指定类型的注解，存在则返回true，否则返回false。注意：此方法会忽略注解对应的注解容器。</p>
<ul>
<li><code>&lt;T extends Annotation&gt; T getAnnotation(Class&lt;T&gt; annotationClass)</code></li>
</ul>
<p>返回该程序元素上存在的、指定类型的注解，如果该类型注解不存在，则返回null。</p>
<ul>
<li><code>Annotation[] getAnnotations()</code></li>
</ul>
<p>返回该程序元素上存在的所有注解，若没有注解，返回长度为0的数组。</p>
<ul>
<li><code>&lt;T extends Annotation&gt; T[] getAnnotationsByType(Class&lt;T&gt; annotationClass)</code></li>
</ul>
<p>返回该程序元素上存在的、指定类型的注解数组。没有注解对应类型的注解时，返回长度为0的数组。该方法的调用者可以随意修改返回的数组，而不会对其他调用者返回的数组产生任何影响。<code>getAnnotationsByType</code>方法与 <code>getAnnotation</code>的区别在于，<code>getAnnotationsByType</code>会检测注解对应的重复注解容器。若程序元素为类，当前类上找不到注解，且该注解为可继承的，则会去父类上检测对应的注解。</p>
<ul>
<li><code>&lt;T extends Annotation&gt; T getDeclaredAnnotation(Class&lt;T&gt; annotationClass)</code></li>
</ul>
<p>返回直接存在于此元素上的所有注解。与此接口中的其他方法不同，该方法将忽略继承的注释。如果没有注释直接存在于此元素上，则返回null。</p>
<ul>
<li><code>&lt;T extends Annotation&gt; T[] getDeclaredAnnotationsByType(Class&lt;T&gt; annotationClass)</code></li>
</ul>
<p>返回直接存在于此元素上的所有注解。与此接口中的其他方法不同，该方法将忽略继承的注释</p>
<ul>
<li><code>Annotation[] getDeclaredAnnotations()</code></li>
</ul>
<p>返回直接存在于此元素上的所有注解及注解对应的重复注解容器。与此接口中的其他方法不同，该方法将忽略继承的注解。如果没有注释直接存在于此元素上，则返回长度为零的一个数组。该方法的调用者可以随意修改返回的数组，而不会对其他调用者返回的数组产生任何影响。</p>
<h4 id="自定义注解"><a href="#自定义注解" class="headerlink" title="自定义注解"></a>自定义注解</h4><ul>
<li>定义自己的注解</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.pdai.java.annotation;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.ElementType;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Retention;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.RetentionPolicy;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Target;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Target(ElementType.METHOD)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyMethodAnnotation &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">title</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">description</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>使用注解</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.pdai.java.annotation;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.FileNotFoundException;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Annotation;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestMethodAnnotation</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@MyMethodAnnotation(title = &quot;toStringMethod&quot;, description = &quot;override toString method&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Override toString method&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Deprecated</span></span><br><span class="line">    <span class="meta">@MyMethodAnnotation(title = &quot;old static method&quot;, description = &quot;deprecated old static method&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">oldMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;old method, don&#x27;t use it.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressWarnings(&#123;&quot;unchecked&quot;, &quot;deprecation&quot;&#125;)</span></span><br><span class="line">    <span class="meta">@MyMethodAnnotation(title = &quot;test method&quot;, description = &quot;suppress warning static method&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">genericsTest</span><span class="params">()</span> <span class="keyword">throws</span> FileNotFoundException &#123;</span><br><span class="line">        <span class="type">List</span> <span class="variable">l</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">        l.add(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">        oldMethod();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>用反射接口获取注解信息</li>
</ul>
<p>在TestMethodAnnotation中添加Main方法进行测试：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 获取所有methods</span></span><br><span class="line">        Method[] methods = TestMethodAnnotation.class.getClassLoader()</span><br><span class="line">                .loadClass((<span class="string">&quot;com.pdai.java.annotation.TestMethodAnnotation&quot;</span>))</span><br><span class="line">                .getMethods();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历</span></span><br><span class="line">        <span class="keyword">for</span> (Method method : methods) &#123;</span><br><span class="line">            <span class="comment">// 方法上是否有MyMethodAnnotation注解</span></span><br><span class="line">            <span class="keyword">if</span> (method.isAnnotationPresent(MyMethodAnnotation.class)) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 获取并遍历方法上的所有注解</span></span><br><span class="line">                    <span class="keyword">for</span> (Annotation anno : method.getDeclaredAnnotations()) &#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;Annotation in Method &#x27;&quot;</span></span><br><span class="line">                                + method + <span class="string">&quot;&#x27; : &quot;</span> + anno);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 获取MyMethodAnnotation对象信息</span></span><br><span class="line">                    <span class="type">MyMethodAnnotation</span> <span class="variable">methodAnno</span> <span class="operator">=</span> method</span><br><span class="line">                            .getAnnotation(MyMethodAnnotation.class);</span><br><span class="line"></span><br><span class="line">                    System.out.println(methodAnno.title());</span><br><span class="line"></span><br><span class="line">                &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">                    ex.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (SecurityException | ClassNotFoundException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>测试的输出</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Annotation in Method <span class="string">&#x27;public static void com.pdai.java.annotation.TestMethodAnnotation.oldMethod()&#x27;</span> : <span class="meta">@java</span>.lang.Deprecated()</span><br><span class="line">Annotation in Method <span class="string">&#x27;public static void com.pdai.java.annotation.TestMethodAnnotation.oldMethod()&#x27;</span> : <span class="meta">@com</span>.pdai.java.annotation.MyMethodAnnotation(title=old <span class="keyword">static</span> method, description=deprecated old <span class="keyword">static</span> method)</span><br><span class="line">old <span class="keyword">static</span> method</span><br><span class="line">Annotation in Method <span class="string">&#x27;public static void com.pdai.java.annotation.TestMethodAnnotation.genericsTest() throws java.io.FileNotFoundException&#x27;</span> : <span class="meta">@com</span>.pdai.java.annotation.MyMethodAnnotation(title=test method, description=suppress warning <span class="keyword">static</span> method)</span><br><span class="line">test method</span><br><span class="line">Annotation in Method <span class="string">&#x27;public java.lang.String com.pdai.java.annotation.TestMethodAnnotation.toString()&#x27;</span> : <span class="meta">@com</span>.pdai.java.annotation.MyMethodAnnotation(title=toStringMethod, description=override toString method)</span><br><span class="line">toStringMethod</span><br></pre></td></tr></table></figure>

<h3 id="深入理解注解"><a href="#深入理解注解" class="headerlink" title="深入理解注解"></a>深入理解注解</h3><h4 id="Java8提供了哪些新的注解？"><a href="#Java8提供了哪些新的注解？" class="headerlink" title="Java8提供了哪些新的注解？"></a>Java8提供了哪些新的注解？</h4><ul>
<li><code>@Repeatable</code></li>
</ul>
<p>允许在同一申明类型(类，属性，或方法)的多次使用同一个注解</p>
<p>java 8之前也有重复使用注解的解决方案，但可读性不是很好，比如下面的代码:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Authority &#123;</span><br><span class="line">     String <span class="title function_">role</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Authorities &#123;</span><br><span class="line">    Authority[] value();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RepeatAnnotationUseOldVersion</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Authorities(&#123;@Authority(role=&quot;Admin&quot;),@Authority(role=&quot;Manager&quot;)&#125;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doSomeThing</span><span class="params">()</span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由另一个注解来存储重复注解，在使用时候，用存储注解Authorities来扩展重复注解。</p>
<p>我们再来看看java 8里面的做法:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Repeatable(Authorities.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Authority &#123;</span><br><span class="line">     String <span class="title function_">role</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Authorities &#123;</span><br><span class="line">    Authority[] value();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RepeatAnnotationUseNewVersion</span> &#123;</span><br><span class="line">    <span class="meta">@Authority(role=&quot;Admin&quot;)</span></span><br><span class="line">    <span class="meta">@Authority(role=&quot;Manager&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doSomeThing</span><span class="params">()</span>&#123; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不同的地方是，创建重复注解Authority时，加上@Repeatable,指向存储注解Authorities，在使用时候，直接可以重复使用Authority注解。从上面例子看出，java 8里面做法更适合常规的思维，可读性强一点。</p>
<ul>
<li><code>ElementType.TYPE_USE</code></li>
</ul>
<ol>
<li>在java 8之前，注解只能是在声明的地方所使用，比如类，方法，属性；</li>
<li>java 8里面，注解可以应用在任何地方，比如:</li>
</ol>
<p>创建类实例</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="meta">@Interned</span> MyObject();</span><br></pre></td></tr></table></figure>

<p>类型映射</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">myString = (<span class="meta">@NonNull</span> String) str;</span><br></pre></td></tr></table></figure>

<p>implements 语句中</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">UnmodifiableList</span>&lt;T&gt; implements <span class="meta">@Readonly</span> List&lt;<span class="meta">@Readonly</span> T&gt; &#123; … &#125;</span><br></pre></td></tr></table></figure>

<p>throw exception声明</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">monitorTemperature</span><span class="params">()</span> <span class="keyword">throws</span> <span class="meta">@Critical</span> TemperatureException &#123; … &#125;</span><br></pre></td></tr></table></figure>

<p>需要注意的是，<strong>类型注解只是语法而不是语义，并不会影响java的编译时间，加载时间，以及运行时间，也就是说，编译成class文件的时候并不包含类型注解</strong>。</p>
<p><strong>类型注解的作用</strong></p>
<p>先看看下面代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Collections.emptyList().add(<span class="string">&quot;One&quot;</span>);</span><br><span class="line"><span class="type">int</span> i=Integer.parseInt(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">System.console().readLine();</span><br></pre></td></tr></table></figure>

<p>上面的代码编译是通过的，但运行是会分别报UnsupportedOperationException； NumberFormatException；NullPointerException异常，这些都是runtime error；</p>
<p>类型注解被用来支持在Java的程序中做强类型检查。配合插件式的check framework，可以在编译的时候检测出runtime error，以提高代码质量。这就是类型注解的作用了。</p>
<p>check framework是第三方工具，配合Java的类型注解效果就是1+1&gt;2。它可以嵌入到javac编译器里面，可以配合ant和maven使用, 地址是<a href="http://types.cs.washington.edu/checker-framework/%E3%80%82">http://types.cs.washington.edu/checker-framework/。</a> check framework可以找到类型注解出现的地方并检查，举个简单的例子:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> checkers.nullness.quals.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GetStarted</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">sample</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="meta">@NonNull</span> <span class="type">Object</span> <span class="variable">ref</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用javac编译上面的类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">javac -processor checkers.nullness.NullnessChecker GetStarted.java</span><br></pre></td></tr></table></figure>

<p>编译是通过，但如果修改成</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@NonNull</span> <span class="type">Object</span> <span class="variable">ref</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br></pre></td></tr></table></figure>

<p>再次编译，则出现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">GetStarted.java:<span class="number">5</span>: incompatible types.</span><br><span class="line">found   : <span class="meta">@Nullable</span> &lt;nulltype&gt;</span><br><span class="line">required: <span class="meta">@NonNull</span> Object</span><br><span class="line">        <span class="meta">@NonNull</span> <span class="type">Object</span> <span class="variable">ref</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">                              ^</span><br><span class="line"><span class="number">1</span> error</span><br></pre></td></tr></table></figure>

<p><strong>类型注解向下兼容的解决方案</strong></p>
<p>如果你不想使用类型注解检测出来错误，则不需要processor，直接javac GetStarted.java是可以编译通过的，这是在java 8 with Type Annotation Support版本里面可以，但java 5,6,7版本都不行，因为javac编译器不知道@NonNull是什么东西，但check framework 有个向下兼容的解决方案，就是将类型注解nonnull用&#x2F;**&#x2F;注释起来，比如上面例子修改为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> checkers.nullness.quals.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GetStarted</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">sample</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">/*@NonNull*/</span> <span class="type">Object</span> <span class="variable">ref</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>关于JSR 308</strong></p>
<p>JSR 308想要解决在Java 1.5注解中出现的两个问题:</p>
<ul>
<li>在句法上对注解的限制: 只能把注解写在声明的地方</li>
<li>类型系统在语义上的限制: 类型系统还做不到预防所有的bug</li>
</ul>
<p>JSR 308 通过如下方法解决上述两个问题:</p>
<ul>
<li>对Java语言的句法进行扩充，允许注解出现在更多的位置上。包括: 方法接收器(method receivers，译注: 例public int size() @Readonly { … })，泛型参数，数组，类型转换，类型测试，对象创建，类型参数绑定，类继承和throws子句。其实就是类型注解，现在是java 8的一个特性</li>
<li>通过引入可插拔的类型系统(pluggable type systems)能够创建功能更强大的注解处理器。类型检查器对带有类型限定注解的源码进行分析，一旦发现不匹配等错误之处就会产生警告信息。其实就是check framework</li>
</ul>
<p>对JSR308，有人反对，觉得更复杂更静态了，比如</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@NotEmpty</span> List&lt;<span class="meta">@NonNull</span> String&gt; strings = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;<span class="meta">@NonNull</span> String&gt;()&gt;</span><br></pre></td></tr></table></figure>

<p>换成动态语言为</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">var</span> <span class="variable">strings</span> <span class="operator">=</span> [<span class="string">&quot;one&quot;</span>, <span class="string">&quot;two&quot;</span>];</span><br></pre></td></tr></table></figure>

<p>有人赞成，说到底，代码才是“最根本”的文档。代码中包含的注解清楚表明了代码编写者的意图。当没有及时更新或者有遗漏的时候，恰恰是注解中包含的意图信息，最容易在其他文档中被丢失。而且将运行时的错误转到编译阶段，不但可以加速开发进程，还可以节省测试时检查bug的时间。</p>
<ul>
<li><code>ElementType.TYPE_PARAMETER</code></li>
</ul>
<p><code>ElementType.TYPE_USE</code>(此类型包括类型声明和类型参数声明，是为了方便设计者进行类型检查)包含了<code>ElementType.TYPE</code>(类、接口（包括注解类型）和枚举的声明)和<code>ElementType.TYPE_PARAMETER</code>(类型参数声明), 不妨再看个例子</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 自定义ElementType.TYPE_PARAMETER注解</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(ElementType.TYPE_PARAMETER)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyNotEmpty &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义ElementType.TYPE_USE注解</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(ElementType.TYPE_USE)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyNotNull &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TypeParameterAndTypeUseAnnotation</span>&lt;<span class="meta">@MyNotEmpty</span> T&gt;&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//使用TYPE_PARAMETER类型，会编译不通过</span></span><br><span class="line"><span class="comment">//		public @MyNotEmpty T test(@MyNotEmpty T a)&#123;</span></span><br><span class="line"><span class="comment">//			new ArrayList&lt;@MyNotEmpty String&gt;();</span></span><br><span class="line"><span class="comment">//				return a;</span></span><br><span class="line"><span class="comment">//		&#125;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//使用TYPE_USE类型，编译通过</span></span><br><span class="line">  <span class="keyword">public</span> <span class="meta">@MyNotNull</span> T <span class="title function_">test2</span><span class="params">(<span class="meta">@MyNotNull</span> T a)</span>&#123;</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;<span class="meta">@MyNotNull</span> String&gt;();</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="注解支持继承吗？"><a href="#注解支持继承吗？" class="headerlink" title="注解支持继承吗？"></a>注解支持继承吗？</h4><p>注解是不支持继承的</p>
<p>不能使用关键字extends来继承某个@interface，但注解在编译后，编译器会自动继承java.lang.annotation.Annotation接口.</p>
<p>虽然反编译后发现注解继承了Annotation接口，请记住，即使Java的接口可以实现多继承，但定义注解时依然无法使用extends关键字继承@interface。</p>
<p>区别于注解的继承，被注解的子类继承父类注解可以用@Inherited： 如果某个类使用了被@Inherited修饰的Annotation，则其子类将自动具有该注解。</p>
<h4 id="注解实现的原理？"><a href="#注解实现的原理？" class="headerlink" title="注解实现的原理？"></a>注解实现的原理？</h4><h3 id="注解的应用场景"><a href="#注解的应用场景" class="headerlink" title="注解的应用场景"></a>注解的应用场景</h3><h4 id="配置化到注解化-框架的演进"><a href="#配置化到注解化-框架的演进" class="headerlink" title="配置化到注解化 - 框架的演进"></a>配置化到注解化 - 框架的演进</h4><p>Spring 框架 配置化到注解化的转变。</p>
<h4 id="继承实现到注解实现-Junit3到Junit4"><a href="#继承实现到注解实现-Junit3到Junit4" class="headerlink" title="继承实现到注解实现 - Junit3到Junit4"></a>继承实现到注解实现 - Junit3到Junit4</h4><p>一个模块的封装大多数人都是通过继承和组合等模式来实现的，但是如果结合注解将可以极大程度提高实现的优雅度（降低耦合度）。而Junit3 到Junit4的演化就是最好的一个例子。</p>
<ul>
<li>被测试类</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloWorld</span> &#123;</span><br><span class="line"> 	</span><br><span class="line"> 	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sayHello</span><span class="params">()</span>&#123;</span><br><span class="line"> 		System.out.println(<span class="string">&quot;hello....&quot;</span>);</span><br><span class="line"> 		<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NumberFormatException</span>();</span><br><span class="line"> 	&#125;</span><br><span class="line"> 	</span><br><span class="line"> 	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sayWorld</span><span class="params">()</span>&#123;</span><br><span class="line"> 		System.out.println(<span class="string">&quot;world....&quot;</span>);</span><br><span class="line"> 	&#125;</span><br><span class="line"> 	</span><br><span class="line"> 	<span class="keyword">public</span> String <span class="title function_">say</span><span class="params">()</span>&#123;</span><br><span class="line"> 		<span class="keyword">return</span> <span class="string">&quot;hello world!&quot;</span>;</span><br><span class="line"> 	&#125;</span><br><span class="line"> 	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>Junit 3 实现UT</li>
</ul>
<p>通过继承 TestCase来实现，初始化是通过Override父类方法来进行，测试方式通过test的前缀方法获取。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloWorldTest</span> <span class="keyword">extends</span> <span class="title class_">TestCase</span>&#123;</span><br><span class="line"> 	<span class="keyword">private</span> HelloWorld hw;</span><br><span class="line"> 	</span><br><span class="line"> 	<span class="meta">@Override</span></span><br><span class="line"> 	<span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">setUp</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"> 		<span class="built_in">super</span>.setUp();</span><br><span class="line"> 		hw=<span class="keyword">new</span> <span class="title class_">HelloWorld</span>();</span><br><span class="line"> 	&#125;</span><br><span class="line"> 	</span><br><span class="line"> 	<span class="comment">//1.测试没有返回值</span></span><br><span class="line"> 	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testHello</span><span class="params">()</span>&#123;</span><br><span class="line"> 		<span class="keyword">try</span> &#123;</span><br><span class="line"> 			hw.sayHello();</span><br><span class="line"> 		&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line"> 			System.out.println(<span class="string">&quot;发生异常.....&quot;</span>);</span><br><span class="line"> 		&#125;</span><br><span class="line"> 		</span><br><span class="line"> 	&#125;</span><br><span class="line"> 	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testWorld</span><span class="params">()</span>&#123;</span><br><span class="line"> 		hw.sayWorld();</span><br><span class="line"> 	&#125;</span><br><span class="line"> 	<span class="comment">//2.测试有返回值的方法</span></span><br><span class="line"> 	<span class="comment">// 返回字符串</span></span><br><span class="line"> 	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testSay</span><span class="params">()</span>&#123;</span><br><span class="line"> 		assertEquals(<span class="string">&quot;测试失败&quot;</span>, hw.say(), <span class="string">&quot;hello world!&quot;</span>);</span><br><span class="line"> 	&#125;</span><br><span class="line"> 	<span class="comment">//返回对象</span></span><br><span class="line"> 	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testObj</span><span class="params">()</span>&#123;</span><br><span class="line"> 		assertNull(<span class="string">&quot;测试对象不为空&quot;</span>, <span class="literal">null</span>);</span><br><span class="line"> 		assertNotNull(<span class="string">&quot;测试对象为空&quot;</span>,<span class="keyword">new</span> <span class="title class_">String</span>());</span><br><span class="line"> 	&#125;</span><br><span class="line"> 	<span class="meta">@Override</span></span><br><span class="line"> 	<span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">tearDown</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"> 		<span class="built_in">super</span>.tearDown();</span><br><span class="line"> 		hw=<span class="literal">null</span>;</span><br><span class="line"> 	&#125;	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>Junit 4 实现UT</li>
</ul>
<p>通过定义@Before，@Test，@After等等注解来实现。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloWorldTest</span> &#123;</span><br><span class="line"> 	<span class="keyword">private</span> HelloWorld hw;</span><br><span class="line"> </span><br><span class="line"> 	<span class="meta">@Before</span></span><br><span class="line"> 	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setUp</span><span class="params">()</span> &#123;</span><br><span class="line"> 		hw = <span class="keyword">new</span> <span class="title class_">HelloWorld</span>();</span><br><span class="line"> 	&#125;</span><br><span class="line"> </span><br><span class="line"> 	<span class="meta">@Test(expected=NumberFormatException.class)</span></span><br><span class="line"> 	<span class="comment">// 1.测试没有返回值,有别于junit3的使用，更加方便</span></span><br><span class="line"> 	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testHello</span><span class="params">()</span> &#123;</span><br><span class="line"> 		hw.sayHello();</span><br><span class="line"> 	&#125;</span><br><span class="line"> 	<span class="meta">@Test</span></span><br><span class="line"> 	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testWorld</span><span class="params">()</span> &#123;</span><br><span class="line"> 		hw.sayWorld();</span><br><span class="line"> 	&#125;</span><br><span class="line"> 	</span><br><span class="line"> 	<span class="meta">@Test</span></span><br><span class="line"> 	<span class="comment">// 2.测试有返回值的方法</span></span><br><span class="line"> 	<span class="comment">// 返回字符串</span></span><br><span class="line"> 	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testSay</span><span class="params">()</span> &#123;</span><br><span class="line"> 		assertEquals(<span class="string">&quot;测试失败&quot;</span>, hw.say(), <span class="string">&quot;hello world!&quot;</span>);</span><br><span class="line"> 	&#125;</span><br><span class="line"> 	</span><br><span class="line"> 	<span class="meta">@Test</span></span><br><span class="line"> 	<span class="comment">// 返回对象</span></span><br><span class="line"> 	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testObj</span><span class="params">()</span> &#123;</span><br><span class="line"> 		assertNull(<span class="string">&quot;测试对象不为空&quot;</span>, <span class="literal">null</span>);</span><br><span class="line"> 		assertNotNull(<span class="string">&quot;测试对象为空&quot;</span>, <span class="keyword">new</span> <span class="title class_">String</span>());</span><br><span class="line"> 	&#125;</span><br><span class="line"> </span><br><span class="line"> 	<span class="meta">@After</span></span><br><span class="line"> 	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">tearDown</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"> 		hw = <span class="literal">null</span>;</span><br><span class="line"> 	&#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="自定义注解和AOP-通过切面实现解耦"><a href="#自定义注解和AOP-通过切面实现解耦" class="headerlink" title="自定义注解和AOP - 通过切面实现解耦"></a>自定义注解和AOP - 通过切面实现解耦</h4><p>最为常见的就是使用Spring AOP切面实现<strong>统一的操作日志管理</strong>，我这里找了一个开源项目中的例子（只展示主要代码），给你展示下如何通过注解实现解耦的。</p>
<ul>
<li>自定义Log注解</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target(&#123; ElementType.PARAMETER, ElementType.METHOD &#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Log &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 模块 </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">title</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 功能</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> BusinessType <span class="title function_">businessType</span><span class="params">()</span> <span class="keyword">default</span> BusinessType.OTHER;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 操作人类别</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> OperatorType <span class="title function_">operatorType</span><span class="params">()</span> <span class="keyword">default</span> OperatorType.MANAGE;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 是否保存请求的参数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSaveRequestData</span><span class="params">()</span> <span class="keyword">default</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>实现日志的切面, 对自定义注解Log作切点进行拦截</li>
</ul>
<p>即对注解了@Log的方法进行切点拦截，</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LogAspect</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">log</span> <span class="operator">=</span> LoggerFactory.getLogger(LogAspect.class);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 配置织入点 - 自定义注解的包路径</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Pointcut(&quot;@annotation(com.xxx.aspectj.lang.annotation.Log)&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">logPointCut</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 处理完请求后执行</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> joinPoint 切点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@AfterReturning(pointcut = &quot;logPointCut()&quot;, returning = &quot;jsonResult&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doAfterReturning</span><span class="params">(JoinPoint joinPoint, Object jsonResult)</span> &#123;</span><br><span class="line">        handleLog(joinPoint, <span class="literal">null</span>, jsonResult);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 拦截异常操作</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> joinPoint 切点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> e 异常</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@AfterThrowing(value = &quot;logPointCut()&quot;, throwing = &quot;e&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doAfterThrowing</span><span class="params">(JoinPoint joinPoint, Exception e)</span> &#123;</span><br><span class="line">        handleLog(joinPoint, e, <span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">handleLog</span><span class="params">(<span class="keyword">final</span> JoinPoint joinPoint, <span class="keyword">final</span> Exception e, Object jsonResult)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 获得注解</span></span><br><span class="line">            <span class="type">Log</span> <span class="variable">controllerLog</span> <span class="operator">=</span> getAnnotationLog(joinPoint);</span><br><span class="line">            <span class="keyword">if</span> (controllerLog == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 获取当前的用户</span></span><br><span class="line">            <span class="type">User</span> <span class="variable">currentUser</span> <span class="operator">=</span> ShiroUtils.getSysUser();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// *========数据库日志=========*//</span></span><br><span class="line">            <span class="type">OperLog</span> <span class="variable">operLog</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OperLog</span>();</span><br><span class="line">            operLog.setStatus(BusinessStatus.SUCCESS.ordinal());</span><br><span class="line">            <span class="comment">// 请求的地址</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">ip</span> <span class="operator">=</span> ShiroUtils.getIp();</span><br><span class="line">            operLog.setOperIp(ip);</span><br><span class="line">            <span class="comment">// 返回参数</span></span><br><span class="line">            operLog.setJsonResult(JSONObject.toJSONString(jsonResult));</span><br><span class="line"></span><br><span class="line">            operLog.setOperUrl(ServletUtils.getRequest().getRequestURI());</span><br><span class="line">            <span class="keyword">if</span> (currentUser != <span class="literal">null</span>) &#123;</span><br><span class="line">                operLog.setOperName(currentUser.getLoginName());</span><br><span class="line">                <span class="keyword">if</span> (StringUtils.isNotNull(currentUser.getDept())</span><br><span class="line">                        &amp;&amp; StringUtils.isNotEmpty(currentUser.getDept().getDeptName())) &#123;</span><br><span class="line">                    operLog.setDeptName(currentUser.getDept().getDeptName());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (e != <span class="literal">null</span>) &#123;</span><br><span class="line">                operLog.setStatus(BusinessStatus.FAIL.ordinal());</span><br><span class="line">                operLog.setErrorMsg(StringUtils.substring(e.getMessage(), <span class="number">0</span>, <span class="number">2000</span>));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 设置方法名称</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">className</span> <span class="operator">=</span> joinPoint.getTarget().getClass().getName();</span><br><span class="line">            <span class="type">String</span> <span class="variable">methodName</span> <span class="operator">=</span> joinPoint.getSignature().getName();</span><br><span class="line">            operLog.setMethod(className + <span class="string">&quot;.&quot;</span> + methodName + <span class="string">&quot;()&quot;</span>);</span><br><span class="line">            <span class="comment">// 设置请求方式</span></span><br><span class="line">            operLog.setRequestMethod(ServletUtils.getRequest().getMethod());</span><br><span class="line">            <span class="comment">// 处理设置注解上的参数</span></span><br><span class="line">            getControllerMethodDescription(controllerLog, operLog);</span><br><span class="line">            <span class="comment">// 保存数据库</span></span><br><span class="line">            AsyncManager.me().execute(AsyncFactory.recordOper(operLog));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception exp) &#123;</span><br><span class="line">            <span class="comment">// 记录本地异常日志</span></span><br><span class="line">            log.error(<span class="string">&quot;==前置通知异常==&quot;</span>);</span><br><span class="line">            log.error(<span class="string">&quot;异常信息:&#123;&#125;&quot;</span>, exp.getMessage());</span><br><span class="line">            exp.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取注解中对方法的描述信息 用于Controller层注解</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> log 日志</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> operLog 操作日志</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getControllerMethodDescription</span><span class="params">(Log log, OperLog operLog)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 设置action动作</span></span><br><span class="line">        operLog.setBusinessType(log.businessType().ordinal());</span><br><span class="line">        <span class="comment">// 设置标题</span></span><br><span class="line">        operLog.setTitle(log.title());</span><br><span class="line">        <span class="comment">// 设置操作人类别</span></span><br><span class="line">        operLog.setOperatorType(log.operatorType().ordinal());</span><br><span class="line">        <span class="comment">// 是否需要保存request，参数和值</span></span><br><span class="line">        <span class="keyword">if</span> (log.isSaveRequestData()) &#123;</span><br><span class="line">            <span class="comment">// 获取参数的信息，传入到数据库中。</span></span><br><span class="line">            setRequestValue(operLog);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取请求的参数，放到log中</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> operLog</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> request</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">setRequestValue</span><span class="params">(OperLog operLog)</span> &#123;</span><br><span class="line">        Map&lt;String, String[]&gt; map = ServletUtils.getRequest().getParameterMap();</span><br><span class="line">        <span class="type">String</span> <span class="variable">params</span> <span class="operator">=</span> JSONObject.toJSONString(map);</span><br><span class="line">        operLog.setOperParam(StringUtils.substring(params, <span class="number">0</span>, <span class="number">2000</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 是否存在注解，如果存在就获取</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Log <span class="title function_">getAnnotationLog</span><span class="params">(JoinPoint joinPoint)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Signature</span> <span class="variable">signature</span> <span class="operator">=</span> joinPoint.getSignature();</span><br><span class="line">        <span class="type">MethodSignature</span> <span class="variable">methodSignature</span> <span class="operator">=</span> (MethodSignature) signature;</span><br><span class="line">        <span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> methodSignature.getMethod();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (method != <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> method.getAnnotation(Log.class);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>使用@Log注解</li>
</ul>
<p>以一个简单的CRUD操作为例, 这里展示部分代码：每对“部门”进行操作就会产生一条操作日志存入数据库。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/system/dept&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DeptController</span> <span class="keyword">extends</span> <span class="title class_">BaseController</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> <span class="variable">prefix</span> <span class="operator">=</span> <span class="string">&quot;system/dept&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> IDeptService deptService;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 新增保存部门</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Log(title = &quot;部门管理&quot;, businessType = BusinessType.INSERT)</span></span><br><span class="line">    <span class="meta">@RequiresPermissions(&quot;system:dept:add&quot;)</span></span><br><span class="line">    <span class="meta">@PostMapping(&quot;/add&quot;)</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="keyword">public</span> AjaxResult <span class="title function_">addSave</span><span class="params">(<span class="meta">@Validated</span> Dept dept)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (UserConstants.DEPT_NAME_NOT_UNIQUE.equals(deptService.checkDeptNameUnique(dept))) &#123;</span><br><span class="line">            <span class="keyword">return</span> error(<span class="string">&quot;新增部门&#x27;&quot;</span> + dept.getDeptName() + <span class="string">&quot;&#x27;失败，部门名称已存在&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> toAjax(deptService.insertDept(dept));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 保存</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Log(title = &quot;部门管理&quot;, businessType = BusinessType.UPDATE)</span></span><br><span class="line">    <span class="meta">@RequiresPermissions(&quot;system:dept:edit&quot;)</span></span><br><span class="line">    <span class="meta">@PostMapping(&quot;/edit&quot;)</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="keyword">public</span> AjaxResult <span class="title function_">editSave</span><span class="params">(<span class="meta">@Validated</span> Dept dept)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (UserConstants.DEPT_NAME_NOT_UNIQUE.equals(deptService.checkDeptNameUnique(dept))) &#123;</span><br><span class="line">            <span class="keyword">return</span> error(<span class="string">&quot;修改部门&#x27;&quot;</span> + dept.getDeptName() + <span class="string">&quot;&#x27;失败，部门名称已存在&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(dept.getParentId().equals(dept.getDeptId())) &#123;</span><br><span class="line">            <span class="keyword">return</span> error(<span class="string">&quot;修改部门&#x27;&quot;</span> + dept.getDeptName() + <span class="string">&quot;&#x27;失败，上级部门不能是自己&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> toAjax(deptService.updateDept(dept));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 删除</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Log(title = &quot;部门管理&quot;, businessType = BusinessType.DELETE)</span></span><br><span class="line">    <span class="meta">@RequiresPermissions(&quot;system:dept:remove&quot;)</span></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/remove/&#123;deptId&#125;&quot;)</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="keyword">public</span> AjaxResult <span class="title function_">remove</span><span class="params">(<span class="meta">@PathVariable(&quot;deptId&quot;)</span> Long deptId)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (deptService.selectDeptCount(deptId) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> AjaxResult.warn(<span class="string">&quot;存在下级部门,不允许删除&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (deptService.checkDeptExistUser(deptId)) &#123;</span><br><span class="line">            <span class="keyword">return</span> AjaxResult.warn(<span class="string">&quot;部门存在用户,不允许删除&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> toAjax(deptService.deleteDeptById(deptId));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同样的，你也可以看到权限管理也是通过类似的注解（<code>@RequiresPermissions</code>）机制来实现的。所以我们可以看到，通过注解+AOP最终的目标是为了实现模块的解耦。</p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
  </entry>
  <entry>
    <title>java基础知识-异常机制详解 - java</title>
    <url>/2022/05/26/2022-05-26-java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86-%E5%BC%82%E5%B8%B8%E6%9C%BA%E5%88%B6%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<h1 id="异常机制详解"><a href="#异常机制详解" class="headerlink" title="异常机制详解"></a>异常机制详解</h1><span id="more"></span>

<h3 id="异常的层次结构"><a href="#异常的层次结构" class="headerlink" title="异常的层次结构"></a>异常的层次结构</h3><p>异常指不期而至的各种状况，如：文件找不到、网络连接失败、非法参数等。异常是一个事件，它发生在程序运行期间，干扰了正常的指令流程。Java通 过API中Throwable类的众多子类描述各种不同的异常。因而，Java异常都是对象，是Throwable子类的实例，描述了出现在一段编码中的 错误条件。当条件生成时，错误将引发异常。</p>
<p>Java异常类层次结构图：</p>
<p><img src="/../images/note38.png" alt="note38"></p>
<h4 id="Throwable"><a href="#Throwable" class="headerlink" title="Throwable"></a>Throwable</h4><p>Throwable 是 Java 语言中所有错误与异常的超类。</p>
<p>Throwable 包含两个子类：Error（错误）和 Exception（异常），它们通常用于指示发生了异常情况。</p>
<p>Throwable 包含了其线程创建时线程执行堆栈的快照，它提供了 printStackTrace() 等接口用于获取堆栈跟踪数据等信息。</p>
<h4 id="Error（错误）"><a href="#Error（错误）" class="headerlink" title="Error（错误）"></a>Error（错误）</h4><p>Error 类及其子类：程序中无法处理的错误，表示运行应用程序中出现了严重的错误。</p>
<p>此类错误一般表示代码运行时 JVM 出现问题。通常有 Virtual MachineError（虚拟机运行错误）、NoClassDefFoundError（类定义错误）等。比如 OutOfMemoryError：内存不足错误；StackOverflowError：栈溢出错误。此类错误发生时，JVM 将终止线程。</p>
<h4 id="Exception（异常）"><a href="#Exception（异常）" class="headerlink" title="Exception（异常）"></a>Exception（异常）</h4><p>程序本身可以捕获并且可以处理的异常。Exception 这种异常又分为两类：运行时异常和编译时异常。</p>
<ul>
<li><strong>运行时异常</strong></li>
</ul>
<p>都是RuntimeException类及其子类异常，如NullPointerException(空指针异常)、IndexOutOfBoundsException(下标越界异常)等，这些异常是不检查异常，程序中可以选择捕获处理，也可以不处理。这些异常一般是由程序逻辑错误引起的，程序应该从逻辑角度尽可能避免这类异常的发生。</p>
<p>运行时异常的特点是Java编译器不会检查它，也就是说，当程序中可能出现这类异常，即使没有用try-catch语句捕获它，也没有用throws子句声明抛出它，也会编译通过。</p>
<ul>
<li><strong>非运行时异常</strong> （编译异常）</li>
</ul>
<p>是RuntimeException以外的异常，类型上都属于Exception类及其子类。从程序语法角度讲是必须进行处理的异常，如果不处理，程序就不能编译通过。如IOException、SQLException等以及用户自定义的Exception异常，一般情况下不自定义检查异常。</p>
<h4 id="可查的异常（checked-exceptions）和不可查的异常（unchecked-exceptions）"><a href="#可查的异常（checked-exceptions）和不可查的异常（unchecked-exceptions）" class="headerlink" title="可查的异常（checked exceptions）和不可查的异常（unchecked exceptions）"></a>可查的异常（checked exceptions）和不可查的异常（unchecked exceptions）</h4><ul>
<li><strong>可查异常</strong>（编译器要求必须处置的异常）：</li>
</ul>
<p>正确的程序在运行中，很容易出现的、情理可容的异常状况。可查异常虽然是异常状况，但在一定程度上它的发生是可以预计的，而且一旦发生这种异常状况，就必须采取某种方式进行处理。</p>
<p>除了RuntimeException及其子类以外，其他的Exception类及其子类都属于可查异常。这种异常的特点是Java编译器会检查它，也就是说，当程序中可能出现这类异常，要么用try-catch语句捕获它，要么用throws子句声明抛出它，否则编译不会通过。</p>
<ul>
<li><strong>不可查异常</strong>(编译器不要求强制处置的异常)</li>
</ul>
<p>包括运行时异常（RuntimeException与其子类）和错误（Error）。</p>
<h3 id="异常基础"><a href="#异常基础" class="headerlink" title="异常基础"></a>异常基础</h3><h4 id="异常关键字"><a href="#异常关键字" class="headerlink" title="异常关键字"></a>异常关键字</h4><ul>
<li><strong>try</strong> – 用于监听。将要被监听的代码(可能抛出异常的代码)放在try语句块之内，当try语句块内发生异常时，异常就被抛出。</li>
<li><strong>catch</strong> – 用于捕获异常。catch用来捕获try语句块中发生的异常。</li>
<li><strong>finally</strong> – finally语句块总是会被执行。它主要用于回收在try块里打开的物力资源(如数据库连接、网络连接和磁盘文件)。只有finally块，执行完成之后，才会回来执行try或者catch块中的return或者throw语句，如果finally中使用了return或者throw等终止方法的语句，则就不会跳回执行，直接停止。</li>
<li><strong>throw</strong> – 用于抛出异常。</li>
<li><strong>throws</strong> – 用在方法签名中，用于声明该方法可能抛出的异常。</li>
</ul>
<h4 id="异常的声明-throws"><a href="#异常的声明-throws" class="headerlink" title="异常的声明(throws)"></a>异常的声明(throws)</h4><p>在Java中，当前执行的语句必属于某个方法，Java解释器调用main方法执行开始执行程序。若方法中存在检查异常，如果不对其捕获，那必须在方法头中显式声明该异常，以便于告知方法调用者此方法有异常，需要进行处理。 在方法中声明一个异常，方法头中使用关键字throws，后面接上要声明的异常。若声明多个异常，则使用逗号分割。如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span> <span class="keyword">throws</span> IOException, FileNotFoundException&#123;</span><br><span class="line">    <span class="comment">//something statements</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意：若是父类的方法没有声明异常，则子类继承方法后，也不能声明异常。</p>
<p>通常，应该捕获那些知道如何处理的异常，将不知道如何处理的异常继续传递下去。传递异常可以在方法签名处使用 throws 关键字声明可能会抛出的异常。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">readFile</span><span class="params">(String filePath)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(filePath);</span><br><span class="line">    String result;</span><br><span class="line">    <span class="type">BufferedReader</span> <span class="variable">reader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">FileReader</span>(file));</span><br><span class="line">    <span class="keyword">while</span>((result = reader.readLine())!=<span class="literal">null</span>) &#123;</span><br><span class="line">        System.out.println(result);</span><br><span class="line">    &#125;</span><br><span class="line">    reader.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Throws抛出异常的规则：</p>
<ul>
<li>如果是不可查异常（unchecked exception），即Error、RuntimeException或它们的子类，那么可以不使用throws关键字来声明要抛出的异常，编译仍能顺利通过，但在运行时会被系统抛出。</li>
<li>必须声明方法可抛出的任何可查异常（checked exception）。即如果一个方法可能出现受可查异常，要么用try-catch语句捕获，要么用throws子句声明将它抛出，否则会导致编译错误</li>
<li>仅当抛出了异常，该方法的调用者才必须处理或者重新抛出该异常。当方法的调用者无力处理该异常的时候，应该继续抛出，而不是囫囵吞枣。</li>
<li>调用方法必须遵循任何可查异常的处理和声明规则。若覆盖一个方法，则不能声明与覆盖方法不同的异常。声明的任何异常必须是被覆盖方法所声明异常的同类或子类。</li>
</ul>
<h4 id="异常的抛出-throw"><a href="#异常的抛出-throw" class="headerlink" title="异常的抛出(throw)"></a>异常的抛出(throw)</h4><p>如果代码可能会引发某种错误，可以创建一个合适的异常类实例并抛出它，这就是抛出异常。如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">double</span> <span class="title function_">method</span><span class="params">(<span class="type">int</span> value)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(value == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ArithmeticException</span>(<span class="string">&quot;参数不能为0&quot;</span>); <span class="comment">//抛出一个运行时异常</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">5.0</span> / value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>大部分情况下都不需要手动抛出异常，因为Java的大部分方法要么已经处理异常，要么已声明异常。所以一般都是捕获异常或者再往上抛。</p>
<p>有时我们会从 catch 中抛出一个异常，目的是为了改变异常的类型。多用于在多系统集成时，当某个子系统故障，异常类型可能有多种，可以用统一的异常类型向外暴露，不需暴露太多内部异常细节。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">readFile</span><span class="params">(String filePath)</span> <span class="keyword">throws</span> MyException &#123;    </span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// code</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        <span class="type">MyException</span> <span class="variable">ex</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyException</span>(<span class="string">&quot;read file failed.&quot;</span>);</span><br><span class="line">        ex.initCause(e);</span><br><span class="line">        <span class="keyword">throw</span> ex;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="异常的自定义"><a href="#异常的自定义" class="headerlink" title="异常的自定义"></a>异常的自定义</h4><p>习惯上，定义一个异常类应包含两个构造函数，一个无参构造函数和一个带有详细描述信息的构造函数（Throwable 的 toString 方法会打印这些详细信息，调试时很有用）, 比如上面用到的自定义MyException：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyException</span> <span class="keyword">extends</span> <span class="title class_">Exception</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyException</span><span class="params">()</span>&#123; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyException</span><span class="params">(String msg)</span>&#123;</span><br><span class="line">        <span class="built_in">super</span>(msg);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="异常的捕获"><a href="#异常的捕获" class="headerlink" title="异常的捕获"></a>异常的捕获</h4><p>异常捕获处理的方法通常有：</p>
<ul>
<li>try-catch</li>
<li>try-catch-finally</li>
<li>try-finally</li>
<li>try-with-resource</li>
</ul>
<p><u>try-catch</u></p>
<p>在一个 try-catch 语句块中可以捕获多个异常类型，并对不同类型的异常做出不同的处理</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">readFile</span><span class="params">(String filePath)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// code</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">        <span class="comment">// handle FileNotFoundException</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">        <span class="comment">// handle IOException</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同一个 catch 也可以捕获多种类型异常，用 | 隔开</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">readFile</span><span class="params">(String filePath)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// code</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (FileNotFoundException | UnknownHostException e) &#123;</span><br><span class="line">        <span class="comment">// handle FileNotFoundException or UnknownHostException</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">        <span class="comment">// handle IOException</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><u>try-catch-finally</u></p>
<ul>
<li>常规语法</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;                        </span><br><span class="line">    <span class="comment">//执行程序代码，可能会出现异常                 </span></span><br><span class="line">&#125; <span class="keyword">catch</span>(Exception e) &#123;   </span><br><span class="line">    <span class="comment">//捕获异常并处理   </span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">//必执行的代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>执行的顺序<ul>
<li>当try没有捕获到异常时：try语句块中的语句逐一被执行，程序将跳过catch语句块，执行finally语句块和其后的语句；</li>
<li>当try捕获到异常，catch语句块里没有处理此异常的情况：当try语句块里的某条语句出现异常时，而没有处理此异常的catch语句块时，此异常将会抛给JVM处理，finally语句块里的语句还是会被执行，但finally语句块后的语句不会被执行；</li>
<li>当try捕获到异常，catch语句块里有处理此异常的情况：在try语句块中是按照顺序来执行的，当执行到某一条语句出现异常时，程序将跳到catch语句块，并与catch语句块逐一匹配，找到与之对应的处理程序，其他的catch语句块将不会被执行，而try语句块中，出现异常之后的语句也不会被执行，catch语句块执行完后，执行finally语句块里的语句，最后执行finally语句块后的语句；</li>
</ul>
</li>
</ul>
<p><img src="/../images/note37.jpg"></p>
<ul>
<li>一个完整的例子</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">readFile</span><span class="params">(String filePath)</span> <span class="keyword">throws</span> MyException &#123;</span><br><span class="line">    <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(filePath);</span><br><span class="line">    String result;</span><br><span class="line">    <span class="type">BufferedReader</span> <span class="variable">reader</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        reader = <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">FileReader</span>(file));</span><br><span class="line">        <span class="keyword">while</span>((result = reader.readLine())!=<span class="literal">null</span>) &#123;</span><br><span class="line">            System.out.println(result);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;readFile method catch block.&quot;</span>);</span><br><span class="line">        <span class="type">MyException</span> <span class="variable">ex</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyException</span>(<span class="string">&quot;read file failed.&quot;</span>);</span><br><span class="line">        ex.initCause(e);</span><br><span class="line">        <span class="keyword">throw</span> ex;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;readFile method finally block.&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">null</span> != reader) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                reader.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><u>try-finally</u></p>
<p>可以直接用try-finally吗？ 可以。</p>
<p>try块中引起异常，异常代码之后的语句不再执行，直接执行finally语句。 try块没有引发异常，则执行完try块就执行finally语句。</p>
<p>try-finally可用在不需要捕获异常的代码，可以保证资源在使用后被关闭。例如IO流中执行完相应操作后，关闭相应资源；使用Lock对象保证线程同步，通过finally可以保证锁会被释放；数据库连接代码时，关闭连接操作等等。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//以Lock加锁为例，演示try-finally</span></span><br><span class="line"><span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">//需要加锁的代码</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    lock.unlock(); <span class="comment">//保证锁一定被释放</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>finally遇见如下情况不会执行：</p>
<ul>
<li>在前面的代码中用了System.exit()退出程序。</li>
<li>finally语句块中发生了异常。</li>
<li>程序所在的线程死亡。</li>
<li>关闭CPU。</li>
</ul>
<p><u>try-with-resource</u></p>
<p>try-with-resource是Java 7中引入的，很容易被忽略。</p>
<p>上面例子中，finally 中的 close 方法也可能抛出 IOException, 从而覆盖了原始异常。JAVA 7 提供了更优雅的方式来实现资源的自动释放，自动释放的资源需要是实现了 AutoCloseable 接口的类。</p>
<ul>
<li>代码实现</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span>  <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">tryWithResourceTest</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">try</span> (<span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;c:/abc&quot;</span>),<span class="string">&quot;UTF-8&quot;</span>))&#123;</span><br><span class="line">        <span class="comment">// code</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">        <span class="comment">// handle exception</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>看下Scanner</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Scanner</span> <span class="keyword">implements</span> <span class="title class_">Iterator</span>&lt;String&gt;, Closeable &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Closeable</span> <span class="keyword">extends</span> <span class="title class_">AutoCloseable</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">close</span><span class="params">()</span> <span class="keyword">throws</span> IOException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>try 代码块退出时，会自动调用 scanner.close 方法，和把 scanner.close 方法放在 finally 代码块中不同的是，若 scanner.close 抛出异常，则会被抑制，抛出的仍然为原始异常。被抑制的异常会由 addSusppressed 方法添加到原来的异常，如果想要获取被抑制的异常列表，可以调用 getSuppressed 方法来获取。</p>
<h4 id="异常基础总结"><a href="#异常基础总结" class="headerlink" title="异常基础总结"></a>异常基础总结</h4><ul>
<li>try、catch和finally都不能单独使用，只能是try-catch、try-finally或者try-catch-finally。</li>
<li>try语句块监控代码，出现异常就停止执行下面的代码，然后将异常移交给catch语句块来处理。</li>
<li>finally语句块中的代码一定会被执行，常用于回收资源 。</li>
<li>throws：声明一个异常，告知方法调用者。</li>
<li>throw ：抛出一个异常，至于该异常被捕获还是继续抛出都与它无关。</li>
</ul>
<p>Java编程思想一书中，对异常的总结。</p>
<ul>
<li><p>在恰当的级别处理问题。（在知道该如何处理的情况下了捕获异常。）</p>
</li>
<li><p>解决问题并且重新调用产生异常的方法。</p>
</li>
<li><p>进行少许修补，然后绕过异常发生的地方继续执行。</p>
</li>
<li><p>用别的数据进行计算，以代替方法预计会返回的值。</p>
</li>
<li><p>把当前运行环境下能做的事尽量做完，然后把相同的异常重抛到更高层。</p>
</li>
<li><p>把当前运行环境下能做的事尽量做完，然后把不同的异常抛到更高层。</p>
</li>
<li><p>终止程序。</p>
</li>
<li><p>进行简化（如果你的异常模式使问题变得太复杂，那么用起来会非常痛苦）。</p>
</li>
<li><p>让类库和程序更安全。</p>
</li>
</ul>
<h4 id="常用的异常"><a href="#常用的异常" class="headerlink" title="常用的异常"></a>常用的异常</h4><p>在Java中提供了一些异常用来描述经常发生的错误，对于这些异常，有的需要程序员进行捕获处理或声明抛出，有的是由Java虚拟机自动进行捕获处理。Java中常见的异常类:</p>
<p><strong>RuntimeException</strong></p>
<ul>
<li>java.lang.ArrayIndexOutOfBoundsException 数组索引越界异常。当对数组的索引值为负数或大于等于数组大小时抛出。</li>
<li>java.lang.ArithmeticException 算术条件异常。譬如：整数除零等。</li>
<li>java.lang.NullPointerException 空指针异常。当应用试图在要求使用对象的地方使用了null时，抛出该异常。譬如：调用null对象的实例方法、访问null对象的属性、计算null对象的长度、使用throw语句抛出null等等</li>
<li>java.lang.ClassNotFoundException 找不到类异常。当应用试图根据字符串形式的类名构造类，而在遍历CLASSPAH之后找不到对应名称的class文件时，抛出该异常。</li>
<li>java.lang.NegativeArraySizeException  数组长度为负异常</li>
<li>java.lang.ArrayStoreException 数组中包含不兼容的值抛出的异常</li>
<li>java.lang.SecurityException 安全性异常</li>
<li>java.lang.IllegalArgumentException 非法参数异常</li>
</ul>
<p><strong>IOException</strong></p>
<ul>
<li>IOException：操作输入流和输出流时可能出现的异常。</li>
<li>EOFException 文件已结束异常</li>
<li>FileNotFoundException 文件未找到异常</li>
</ul>
<p><strong>其他</strong></p>
<ul>
<li>ClassCastException    类型转换异常类</li>
<li>ArrayStoreException  数组中包含不兼容的值抛出的异常</li>
<li>SQLException   操作数据库异常类</li>
<li>NoSuchFieldException   字段未找到异常</li>
<li>NoSuchMethodException   方法未找到抛出的异常</li>
<li>NumberFormatException    字符串转换为数字抛出的异常</li>
<li>StringIndexOutOfBoundsException 字符串索引超出范围抛出的异常</li>
<li>IllegalAccessException  不允许访问某类异常</li>
<li>InstantiationException  当应用程序试图使用Class类中的newInstance()方法创建一个类的实例，而指定的类对象无法被实例化时，抛出该异常</li>
</ul>
<h3 id="异常实践"><a href="#异常实践" class="headerlink" title="异常实践"></a>异常实践</h3><p>当你抛出或捕获异常的时候，有很多不同的情况需要考虑，而且大部分事情都是为了改善代码的可读性或者 API 的可用性。</p>
<p>异常不仅仅是一个错误控制机制，也是一个通信媒介。因此，为了和同事更好的合作，一个团队必须要制定出一个最佳实践和规则，只有这样，团队成员才能理解这些通用概念，同时在工作中使用它。</p>
<p>这里给出几个被很多团队使用的异常处理最佳实践。</p>
<h4 id="只针对不正常的情况才使用异常"><a href="#只针对不正常的情况才使用异常" class="headerlink" title="只针对不正常的情况才使用异常"></a>只针对不正常的情况才使用异常</h4><p>异常只应该被用于不正常的条件，它们永远不应该被用于正常的控制流。《阿里手册》中：【强制】Java 类库中定义的可以通过预检查方式规避的RuntimeException异常不应该通过catch 的方式来处理，比如：NullPointerException，IndexOutOfBoundsException等等。</p>
<p>比如，在解析字符串形式的数字时，可能存在数字格式错误，不得通过catch Exception来实现</p>
<ul>
<li>代码1</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (obj != <span class="literal">null</span>) &#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>代码2</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123; </span><br><span class="line">  obj.method(); </span><br><span class="line">&#125; <span class="keyword">catch</span> (NullPointerException e) &#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>主要原因有三点：</p>
<ul>
<li>异常机制的设计初衷是用于不正常的情况，所以很少会会JVM实现试图对它们的性能进行优化。所以，创建、抛出和捕获异常的开销是很昂贵的。</li>
<li>把代码放在try-catch中返回阻止了JVM实现本来可能要执行的某些特定的优化。</li>
<li>对数组进行遍历的标准模式并不会导致冗余的检查，有些现代的JVM实现会将它们优化掉。</li>
</ul>
<h4 id="在-finally-块中清理资源或者使用-try-with-resource-语句"><a href="#在-finally-块中清理资源或者使用-try-with-resource-语句" class="headerlink" title="在 finally 块中清理资源或者使用 try-with-resource 语句"></a>在 finally 块中清理资源或者使用 try-with-resource 语句</h4><p>当使用类似InputStream这种需要使用后关闭的资源时，一个常见的错误就是在try块的最后关闭资源。</p>
<ul>
<li>错误示例</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doNotCloseResourceInTry</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">FileInputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;./tmp.txt&quot;</span>);</span><br><span class="line">        inputStream = <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(file);</span><br><span class="line">        <span class="comment">// use the inputStream to read a file</span></span><br><span class="line">        <span class="comment">// do NOT do this</span></span><br><span class="line">        inputStream.close();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">        log.error(e);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        log.error(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>问题就是，只有没有异常抛出的时候，这段代码才可以正常工作。try 代码块内代码会正常执行，并且资源可以正常关闭。但是，使用 try 代码块是有原因的，一般调用一个或多个可能抛出异常的方法，而且，你自己也可能会抛出一个异常，这意味着代码可能不会执行到 try 代码块的最后部分。结果就是，你并没有关闭资源。</p>
<p>所以，你应该把清理工作的代码放到 finally 里去，或者使用 try-with-resource 特性。</p>
<ul>
<li>方法一：使用 finally 代码块</li>
</ul>
<p>与前面几行 try 代码块不同，finally 代码块总是会被执行。不管 try 代码块成功执行之后还是你在 catch 代码块中处理完异常后都会执行。因此，你可以确保你清理了所有打开的资源。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">closeResourceInFinally</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">FileInputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;./tmp.txt&quot;</span>);</span><br><span class="line">        inputStream = <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(file);</span><br><span class="line">        <span class="comment">// use the inputStream to read a file</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">        log.error(e);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (inputStream != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                inputStream.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                log.error(e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>方法二：Java 7 的 try-with-resource 语法</li>
</ul>
<p>如果你的资源实现了 AutoCloseable 接口，你可以使用这个语法。大多数的 Java 标准资源都继承了这个接口。当你在 try 子句中打开资源，资源会在 try 代码块执行后或异常处理后自动关闭。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">automaticallyCloseResource</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;./tmp.txt&quot;</span>);</span><br><span class="line">    <span class="keyword">try</span> (<span class="type">FileInputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(file);) &#123;</span><br><span class="line">        <span class="comment">// use the inputStream to read a file</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">        log.error(e);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        log.error(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="尽量使用标准的异常"><a href="#尽量使用标准的异常" class="headerlink" title="尽量使用标准的异常"></a>尽量使用标准的异常</h4><p>代码重用是值得提倡的，这是一条通用规则，异常也不例外。</p>
<p>重用现有的异常有几个好处：</p>
<ul>
<li>它使得你的API更加易于学习和使用，因为它与程序员原来已经熟悉的习惯用法是一致的。</li>
<li>对于用到这些API的程序而言，它们的可读性更好，因为它们不会充斥着程序员不熟悉的异常。</li>
<li>异常类越少，意味着内存占用越小，并且转载这些类的时间开销也越小。</li>
</ul>
<p>Java标准异常中有几个是经常被使用的异常。如下表格：</p>
<table>
<thead>
<tr>
<th align="center">异常</th>
<th align="center">使用场合</th>
</tr>
</thead>
<tbody><tr>
<td align="center">IllegalArgumentException</td>
<td align="center">参数的值不合适</td>
</tr>
<tr>
<td align="center">IllegalStateException</td>
<td align="center">参数的状态不合适</td>
</tr>
<tr>
<td align="center">NullPointerException</td>
<td align="center">在null被禁止的情况下参数值为null</td>
</tr>
<tr>
<td align="center">IndexOutOfBoundsException</td>
<td align="center">下标越界</td>
</tr>
<tr>
<td align="center">ConcurrentModificationException</td>
<td align="center">在禁止并发修改的情况下，对象检测到并发修改</td>
</tr>
<tr>
<td align="center">UnsupportedOperationExceptio</td>
<td align="center">对象不支持客户请求的方法</td>
</tr>
</tbody></table>
<p>虽然它们是Java平台库迄今为止最常被重用的异常，但是，在许可的条件下，其它的异常也可以被重用。例如，如果你要实现诸如复数或者矩阵之类的算术对象，那么重用ArithmeticException和NumberFormatException将是非常合适的。如果一个异常满足你的需要，则不要犹豫，使用就可以，不过你一定要确保抛出异常的条件与该异常的文档中描述的条件一致。这种重用必须建立在语义的基础上，而不是名字的基础上。</p>
<p>最后，一定要清楚，选择重用哪一种异常并没有必须遵循的规则。例如，考虑纸牌对象的情形，假设有一个用于发牌操作的方法，它的参数(handSize)是发一手牌的纸牌张数。假设调用者在这个参数中传递的值大于整副牌的剩余张数。那么这种情形既可以被解释为IllegalArgumentException(handSize的值太大)，也可以被解释为IllegalStateException(相对客户的请求而言，纸牌对象的纸牌太少)。</p>
<h4 id="对异常进行文档说明"><a href="#对异常进行文档说明" class="headerlink" title="对异常进行文档说明"></a>对异常进行文档说明</h4><p>当在方法上声明抛出异常时，也需要进行文档说明。目的是为了给调用者提供尽可能多的信息，从而可以更好地避免或处理异常。</p>
<p>在 Javadoc 添加 @throws 声明，并且描述抛出异常的场景。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Method description</span></span><br><span class="line"><span class="comment">* </span></span><br><span class="line"><span class="comment">* <span class="doctag">@throws</span> MyBusinessException - businuess exception description</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doSomething</span><span class="params">(String input)</span> <span class="keyword">throws</span> MyBusinessException &#123;</span><br><span class="line">   <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同时，在抛出MyBusinessException 异常时，需要尽可能精确地描述问题和相关信息，这样无论是打印到日志中还是在监控工具中，都能够更容易被人阅读，从而可以更好地定位具体错误信息、错误的严重程度等。</p>
<h4 id="优先捕获最具体的异常"><a href="#优先捕获最具体的异常" class="headerlink" title="优先捕获最具体的异常"></a>优先捕获最具体的异常</h4><p>大多数 IDE 都可以帮助你实现这个最佳实践。当你尝试首先捕获较不具体的异常时，它们会报告无法访问的代码块。</p>
<p>但问题在于，只有匹配异常的第一个 catch 块会被执行。 因此，如果首先捕获 IllegalArgumentException ，则永远不会到达应该处理更具体的 NumberFormatException 的 catch 块，因为它是 IllegalArgumentException 的子类。</p>
<p>总是优先捕获最具体的异常类，并将不太具体的 catch 块添加到列表的末尾。</p>
<p>你可以在下面的代码片断中看到这样一个 try-catch 语句的例子。 第一个 catch 块处理所有 NumberFormatException 异常，第二个处理所有非 NumberFormatException 异常的IllegalArgumentException 异常。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">catchMostSpecificExceptionFirst</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        doSomething(<span class="string">&quot;A message&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (NumberFormatException e) &#123;</span><br><span class="line">        log.error(e);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IllegalArgumentException e) &#123;</span><br><span class="line">        log.error(e)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="不要捕获-Throwable-类"><a href="#不要捕获-Throwable-类" class="headerlink" title="不要捕获 Throwable 类"></a>不要捕获 Throwable 类</h4><p>Throwable 是所有异常和错误的超类。你可以在 catch 子句中使用它，但是你永远不应该这样做！</p>
<p>如果在 catch 子句中使用 Throwable ，它不仅会捕获所有异常，也将捕获所有的错误。JVM 抛出错误，指出不应该由应用程序处理的严重问题。 典型的例子是 OutOfMemoryError 或者 StackOverflowError 。两者都是由应用程序控制之外的情况引起的，无法处理。</p>
<p>所以，最好不要捕获 Throwable ，除非你确定自己处于一种特殊的情况下能够处理错误。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doNotCatchThrowable</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// do something</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        <span class="comment">// don&#x27;t do this!</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="不要忽略异常"><a href="#不要忽略异常" class="headerlink" title="不要忽略异常"></a>不要忽略异常</h4><p>很多时候，开发者很有自信不会抛出异常，因此写了一个catch块，但是没有做任何处理或者记录日志。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doNotIgnoreExceptions</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// do something</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (NumberFormatException e) &#123;</span><br><span class="line">        <span class="comment">// this will never happen</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但现实是经常会出现无法预料的异常，或者无法确定这里的代码未来是不是会改动(删除了阻止异常抛出的代码)，而此时由于异常被捕获，使得无法拿到足够的错误信息来定位问题。</p>
<p>合理的做法是至少要记录异常的信息。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">logAnException</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// do something</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (NumberFormatException e) &#123;</span><br><span class="line">        log.error(<span class="string">&quot;This should never happen: &quot;</span> + e); <span class="comment">// see this line</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="不要记录并抛出异常"><a href="#不要记录并抛出异常" class="headerlink" title="不要记录并抛出异常"></a>不要记录并抛出异常</h4><p>这可能是本文中最常被忽略的最佳实践。</p>
<p>可以发现很多代码甚至类库中都会有捕获异常、记录日志并再次抛出的逻辑。如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Long</span>(<span class="string">&quot;xyz&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (NumberFormatException e) &#123;</span><br><span class="line">    log.error(e);</span><br><span class="line">    <span class="keyword">throw</span> e;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个处理逻辑看着是合理的。但这经常会给同一个异常输出多条日志。如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">17</span>:<span class="number">44</span>:<span class="number">28</span>,<span class="number">945</span> ERROR TestExceptionHandling:<span class="number">65</span> - java.lang.NumberFormatException: For input string: <span class="string">&quot;xyz&quot;</span></span><br><span class="line">Exception in thread <span class="string">&quot;main&quot;</span> java.lang.NumberFormatException: For input string: <span class="string">&quot;xyz&quot;</span></span><br><span class="line">at java.lang.NumberFormatException.forInputString(NumberFormatException.java:<span class="number">65</span>)</span><br><span class="line">at java.lang.Long.parseLong(Long.java:<span class="number">589</span>)</span><br><span class="line">at java.lang.Long.(Long.java:<span class="number">965</span>)</span><br><span class="line">at com.stackify.example.TestExceptionHandling.logAndThrowException(TestExceptionHandling.java:<span class="number">63</span>)</span><br><span class="line">at com.stackify.example.TestExceptionHandling.main(TestExceptionHandling.java:<span class="number">58</span>)</span><br></pre></td></tr></table></figure>

<p>如上所示，后面的日志也没有附加更有用的信息。如果想要提供更加有用的信息，那么可以将异常包装为自定义异常。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">wrapException</span><span class="params">(String input)</span> <span class="keyword">throws</span> MyBusinessException &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// do something</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (NumberFormatException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">MyBusinessException</span>(<span class="string">&quot;A message that describes the error.&quot;</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因此，仅仅当想要处理异常时才去捕获，否则只需要在方法签名中声明让调用者去处理。</p>
<h4 id="包装异常时不要抛弃原始的异常"><a href="#包装异常时不要抛弃原始的异常" class="headerlink" title="包装异常时不要抛弃原始的异常"></a>包装异常时不要抛弃原始的异常</h4><p>捕获标准异常并包装为自定义异常是一个很常见的做法。这样可以添加更为具体的异常信息并能够做针对的异常处理。 在你这样做时，请确保将原始异常设置为原因（注：参考下方代码 NumberFormatException e 中的原始异常 e ）。Exception 类提供了特殊的构造函数方法，它接受一个 Throwable 作为参数。否则，你将会丢失堆栈跟踪和原始异常的消息，这将会使分析导致异常的异常事件变得困难。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">wrapException</span><span class="params">(String input)</span> <span class="keyword">throws</span> MyBusinessException &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// do something</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (NumberFormatException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">MyBusinessException</span>(<span class="string">&quot;A message that describes the error.&quot;</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="不要使用异常控制程序的流程"><a href="#不要使用异常控制程序的流程" class="headerlink" title="不要使用异常控制程序的流程"></a>不要使用异常控制程序的流程</h4><p>不应该使用异常控制应用的执行流程，例如，本应该使用if语句进行条件判断的情况下，你却使用异常处理，这是非常不好的习惯，会严重影响应用的性能。</p>
<h4 id="不要在finally块中使用return"><a href="#不要在finally块中使用return" class="headerlink" title="不要在finally块中使用return"></a>不要在finally块中使用return</h4><p>try块中的return语句执行成功后，并不马上返回，而是继续执行finally块中的语句，如果此处存在return语句，则在此直接返回，无情丢弃掉try块中的返回点。</p>
<p>如下是一个反例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">checkReturn</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// x等于1，此处不返回</span></span><br><span class="line">        <span class="keyword">return</span> ++x;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 返回的结果是2</span></span><br><span class="line">        <span class="keyword">return</span> ++x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="深入理解异常"><a href="#深入理解异常" class="headerlink" title="深入理解异常"></a>深入理解异常</h3><h4 id="JVM处理异常的机制？"><a href="#JVM处理异常的机制？" class="headerlink" title="JVM处理异常的机制？"></a>JVM处理异常的机制？</h4><p>提到JVM处理异常的机制，就需要提及Exception Table，以下称为异常表。我们暂且不急于介绍异常表，先看一个简单的 Java 处理异常的小例子。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">simpleTryCatch</span><span class="params">()</span> &#123;</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">       testNPE();</span><br><span class="line">   &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">       e.printStackTrace();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码是一个很简单的例子，用来捕获处理一个潜在的空指针异常。</p>
<p>当然如果只是看简简单单的代码，我们很难看出什么高深之处，更没有了今天文章要谈论的内容。</p>
<p>所以这里我们需要借助一把神兵利器，它就是javap,一个用来拆解class文件的工具，和javac一样由JDK提供。</p>
<p>然后我们使用javap来分析这段代码（需要先使用javac编译）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//javap -c Main</span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">simpleTryCatch</span><span class="params">()</span>;</span><br><span class="line">    Code:</span><br><span class="line">       <span class="number">0</span>: invokestatic  #<span class="number">3</span>                  <span class="comment">// Method testNPE:()V</span></span><br><span class="line">       <span class="number">3</span>: goto          <span class="number">11</span></span><br><span class="line">       <span class="number">6</span>: astore_0</span><br><span class="line">       <span class="number">7</span>: aload_0</span><br><span class="line">       <span class="number">8</span>: invokevirtual #<span class="number">5</span>                  <span class="comment">// Method java/lang/Exception.printStackTrace:()V</span></span><br><span class="line">      <span class="number">11</span>: <span class="keyword">return</span></span><br><span class="line">    Exception table:</span><br><span class="line">       from    to  target type</span><br><span class="line">           <span class="number">0</span>     <span class="number">3</span>     <span class="number">6</span>   Class java/lang/Exception</span><br></pre></td></tr></table></figure>

<p>看到上面的代码，应该会有会心一笑，因为终于看到了Exception table，也就是我们要研究的异常表。</p>
<p>异常表中包含了一个或多个异常处理者(Exception Handler)的信息，这些信息包含如下</p>
<ul>
<li><strong>from</strong> 可能发生异常的起始点</li>
<li><strong>to</strong> 可能发生异常的结束点</li>
<li><strong>target</strong> 上述from和to之前发生异常后的异常处理者的位置</li>
<li><strong>type</strong> 异常处理者处理的异常的类信息</li>
</ul>
<p><strong>那么异常表用在什么时候呢</strong></p>
<p>答案是异常发生的时候，当一个异常发生时</p>
<ul>
<li>1.JVM会在当前出现异常的方法中，查找异常表，是否有合适的处理者来处理</li>
<li>2.如果当前方法异常表不为空，并且异常符合处理者的from和to节点，并且type也匹配，则JVM调用位于target的调用者来处理。</li>
<li>3.如果上一条未找到合理的处理者，则继续查找异常表中的剩余条目</li>
<li>4.如果当前方法的异常表无法处理，则向上查找（弹栈处理）刚刚调用该方法的调用处，并重复上面的操作。</li>
<li>5.如果所有的栈帧被弹出，仍然没有处理，则抛给当前的Thread，Thread则会终止。</li>
<li>6.如果当前Thread为最后一个非守护线程，且未处理异常，则会导致JVM终止运行。</li>
</ul>
<p>以上就是JVM处理异常的一些机制。</p>
<p><strong>try catch -finally</strong></p>
<p>除了简单的try-catch外，我们还常常和finally做结合使用。比如这样的代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">simpleTryCatchFinally</span><span class="params">()</span> &#123;</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">       testNPE();</span><br><span class="line">   &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">       e.printStackTrace();</span><br><span class="line">   &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">       System.out.println(<span class="string">&quot;Finally&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同样我们使用javap分析一下代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">simpleTryCatchFinally</span><span class="params">()</span>;</span><br><span class="line">    Code:</span><br><span class="line">       <span class="number">0</span>: invokestatic  #<span class="number">3</span>                  <span class="comment">// Method testNPE:()V</span></span><br><span class="line">       <span class="number">3</span>: getstatic     #<span class="number">6</span>                  <span class="comment">// Field java/lang/System.out:Ljava/io/PrintStream;</span></span><br><span class="line">       <span class="number">6</span>: ldc           #<span class="number">7</span>                  <span class="comment">// String Finally</span></span><br><span class="line">       <span class="number">8</span>: invokevirtual #<span class="number">8</span>                  <span class="comment">// Method java/io/PrintStream.println:(Ljava/lang/String;)V</span></span><br><span class="line">      <span class="number">11</span>: goto          <span class="number">41</span></span><br><span class="line">      <span class="number">14</span>: astore_0</span><br><span class="line">      <span class="number">15</span>: aload_0</span><br><span class="line">      <span class="number">16</span>: invokevirtual #<span class="number">5</span>                  <span class="comment">// Method java/lang/Exception.printStackTrace:()V</span></span><br><span class="line">      <span class="number">19</span>: getstatic     #<span class="number">6</span>                  <span class="comment">// Field java/lang/System.out:Ljava/io/PrintStream;</span></span><br><span class="line">      <span class="number">22</span>: ldc           #<span class="number">7</span>                  <span class="comment">// String Finally</span></span><br><span class="line">      <span class="number">24</span>: invokevirtual #<span class="number">8</span>                  <span class="comment">// Method java/io/PrintStream.println:(Ljava/lang/String;)V</span></span><br><span class="line">      <span class="number">27</span>: goto          <span class="number">41</span></span><br><span class="line">      <span class="number">30</span>: astore_1</span><br><span class="line">      <span class="number">31</span>: getstatic     #<span class="number">6</span>                  <span class="comment">// Field java/lang/System.out:Ljava/io/PrintStream;</span></span><br><span class="line">      <span class="number">34</span>: ldc           #<span class="number">7</span>                  <span class="comment">// String Finally</span></span><br><span class="line">      <span class="number">36</span>: invokevirtual #<span class="number">8</span>                  <span class="comment">// Method java/io/PrintStream.println:(Ljava/lang/String;)V</span></span><br><span class="line">      <span class="number">39</span>: aload_1</span><br><span class="line">      <span class="number">40</span>: athrow</span><br><span class="line">      <span class="number">41</span>: <span class="keyword">return</span></span><br><span class="line">    Exception table:</span><br><span class="line">       from    to  target type</span><br><span class="line">           <span class="number">0</span>     <span class="number">3</span>    <span class="number">14</span>   Class java/lang/Exception</span><br><span class="line">           <span class="number">0</span>     <span class="number">3</span>    <span class="number">30</span>   any</span><br><span class="line">          <span class="number">14</span>    <span class="number">19</span>    <span class="number">30</span>   any</span><br></pre></td></tr></table></figure>

<p>和之前有所不同，这次异常表中，有三条数据，而我们仅仅捕获了一个Exception, 异常表的后两个item的type为any; 上面的三条异常表item的意思为:</p>
<ul>
<li>如果0到3之间，发生了Exception类型的异常，调用14位置的异常处理者。</li>
<li>如果0到3之间，无论发生什么异常，都调用30位置的处理者</li>
<li>如果14到19之间（即catch部分），不论发生什么异常，都调用30位置的处理者。</li>
</ul>
<p>再次分析上面的Java代码，finally里面的部分已经被提取到了try部分和catch部分。我们再次调一下代码来看一下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">simpleTryCatchFinally</span><span class="params">()</span>;</span><br><span class="line">    Code:</span><br><span class="line">      <span class="comment">//try 部分提取finally代码，如果没有异常发生，则执行输出finally操作，直至goto到41位置，执行返回操作。  </span></span><br><span class="line"></span><br><span class="line">       <span class="number">0</span>: invokestatic  #<span class="number">3</span>                  <span class="comment">// Method testNPE:()V</span></span><br><span class="line">       <span class="number">3</span>: getstatic     #<span class="number">6</span>                  <span class="comment">// Field java/lang/System.out:Ljava/io/PrintStream;</span></span><br><span class="line">       <span class="number">6</span>: ldc           #<span class="number">7</span>                  <span class="comment">// String Finally</span></span><br><span class="line">       <span class="number">8</span>: invokevirtual #<span class="number">8</span>                  <span class="comment">// Method java/io/PrintStream.println:(Ljava/lang/String;)V</span></span><br><span class="line">      <span class="number">11</span>: goto          <span class="number">41</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">//catch部分提取finally代码，如果没有异常发生，则执行输出finally操作，直至执行got到41位置，执行返回操作。</span></span><br><span class="line">      <span class="number">14</span>: astore_0</span><br><span class="line">      <span class="number">15</span>: aload_0</span><br><span class="line">      <span class="number">16</span>: invokevirtual #<span class="number">5</span>                  <span class="comment">// Method java/lang/Exception.printStackTrace:()V</span></span><br><span class="line">      <span class="number">19</span>: getstatic     #<span class="number">6</span>                  <span class="comment">// Field java/lang/System.out:Ljava/io/PrintStream;</span></span><br><span class="line">      <span class="number">22</span>: ldc           #<span class="number">7</span>                  <span class="comment">// String Finally</span></span><br><span class="line">      <span class="number">24</span>: invokevirtual #<span class="number">8</span>                  <span class="comment">// Method java/io/PrintStream.println:(Ljava/lang/String;)V</span></span><br><span class="line">      <span class="number">27</span>: goto          <span class="number">41</span></span><br><span class="line">      <span class="comment">//finally部分的代码如果被调用，有可能是try部分，也有可能是catch部分发生异常。</span></span><br><span class="line">      <span class="number">30</span>: astore_1</span><br><span class="line">      <span class="number">31</span>: getstatic     #<span class="number">6</span>                  <span class="comment">// Field java/lang/System.out:Ljava/io/PrintStream;</span></span><br><span class="line">      <span class="number">34</span>: ldc           #<span class="number">7</span>                  <span class="comment">// String Finally</span></span><br><span class="line">      <span class="number">36</span>: invokevirtual #<span class="number">8</span>                  <span class="comment">// Method java/io/PrintStream.println:(Ljava/lang/String;)V</span></span><br><span class="line">      <span class="number">39</span>: aload_1</span><br><span class="line">      <span class="number">40</span>: athrow     <span class="comment">//如果异常没有被catch捕获，而是到了这里，执行完finally的语句后，仍然要把这个异常抛出去，传递给调用处。</span></span><br><span class="line">      <span class="number">41</span>: <span class="keyword">return</span></span><br></pre></td></tr></table></figure>

<p><strong>Catch先后顺序的问题</strong></p>
<p>我们在代码中的catch的顺序决定了异常处理者在异常表的位置，所以，越是具体的异常要先处理，否则就会出现下面的问题</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">misuseCatchException</span><span class="params">()</span> &#123;</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">       testNPE();</span><br><span class="line">   &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">       t.printStackTrace();</span><br><span class="line">   &#125; <span class="keyword">catch</span> (Exception e) &#123; <span class="comment">//error occurs during compilings with tips Exception Java.lang.Exception has already benn caught.</span></span><br><span class="line">       e.printStackTrace();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码会导致编译失败，因为先捕获Throwable后捕获Exception，会导致后面的catch永远无法被执行。</p>
<p><strong>Return 和finally的问题</strong></p>
<p>这算是我们扩展的一个相对比较极端的问题，就是类似这样的代码，既有return，又有finally，那么finally导致会不会执行</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">tryCatchReturn</span><span class="params">()</span> &#123;</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">       testNPE();</span><br><span class="line">       <span class="keyword">return</span>  <span class="string">&quot;OK&quot;</span>;</span><br><span class="line">   &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="string">&quot;ERROR&quot;</span>;</span><br><span class="line">   &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">       System.out.println(<span class="string">&quot;tryCatchReturn&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>答案是finally会执行，那么还是使用上面的方法，我们来看一下为什么finally会执行。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> java.lang.String <span class="title function_">tryCatchReturn</span><span class="params">()</span>;</span><br><span class="line">    Code:</span><br><span class="line">       <span class="number">0</span>: invokestatic  #<span class="number">3</span>                  <span class="comment">// Method testNPE:()V</span></span><br><span class="line">       <span class="number">3</span>: ldc           #<span class="number">6</span>                  <span class="comment">// String OK</span></span><br><span class="line">       <span class="number">5</span>: astore_0</span><br><span class="line">       <span class="number">6</span>: getstatic     #<span class="number">7</span>                  <span class="comment">// Field java/lang/System.out:Ljava/io/PrintStream;</span></span><br><span class="line">       <span class="number">9</span>: ldc           #<span class="number">8</span>                  <span class="comment">// String tryCatchReturn</span></span><br><span class="line">      <span class="number">11</span>: invokevirtual #<span class="number">9</span>                  <span class="comment">// Method java/io/PrintStream.println:(Ljava/lang/String;)V</span></span><br><span class="line">      <span class="number">14</span>: aload_0</span><br><span class="line">      <span class="number">15</span>: areturn       返回OK字符串，areturn意思为<span class="keyword">return</span> a reference from a method</span><br><span class="line">      <span class="number">16</span>: astore_0</span><br><span class="line">      <span class="number">17</span>: ldc           #<span class="number">10</span>                 <span class="comment">// String ERROR</span></span><br><span class="line">      <span class="number">19</span>: astore_1</span><br><span class="line">      <span class="number">20</span>: getstatic     #<span class="number">7</span>                  <span class="comment">// Field java/lang/System.out:Ljava/io/PrintStream;</span></span><br><span class="line">      <span class="number">23</span>: ldc           #<span class="number">8</span>                  <span class="comment">// String tryCatchReturn</span></span><br><span class="line">      <span class="number">25</span>: invokevirtual #<span class="number">9</span>                  <span class="comment">// Method java/io/PrintStream.println:(Ljava/lang/String;)V</span></span><br><span class="line">      <span class="number">28</span>: aload_1</span><br><span class="line">      <span class="number">29</span>: areturn  <span class="comment">//返回ERROR字符串</span></span><br><span class="line">      <span class="number">30</span>: astore_2</span><br><span class="line">      <span class="number">31</span>: getstatic     #<span class="number">7</span>                  <span class="comment">// Field java/lang/System.out:Ljava/io/PrintStream;</span></span><br><span class="line">      <span class="number">34</span>: ldc           #<span class="number">8</span>                  <span class="comment">// String tryCatchReturn</span></span><br><span class="line">      <span class="number">36</span>: invokevirtual #<span class="number">9</span>                  <span class="comment">// Method java/io/PrintStream.println:(Ljava/lang/String;)V</span></span><br><span class="line">      <span class="number">39</span>: aload_2</span><br><span class="line">      <span class="number">40</span>: athrow  如果<span class="keyword">catch</span>有未处理的异常，抛出去。</span><br></pre></td></tr></table></figure>

<h4 id="异常是否耗时？为什么会耗时？"><a href="#异常是否耗时？为什么会耗时？" class="headerlink" title="异常是否耗时？为什么会耗时？"></a>异常是否耗时？为什么会耗时？</h4><p>说用异常慢，首先来看看异常慢在哪里？有多慢？下面的测试用例简单的测试了建立对象、建立异常对象、抛出并接住异常对象三者的耗时对比：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExceptionTest</span> &#123;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> testTimes;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ExceptionTest</span><span class="params">(<span class="type">int</span> testTimes)</span> &#123;  </span><br><span class="line">        <span class="built_in">this</span>.testTimes = testTimes;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">newObject</span><span class="params">()</span> &#123;  </span><br><span class="line">        <span class="type">long</span> <span class="variable">l</span> <span class="operator">=</span> System.nanoTime();  </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; testTimes; i++) &#123;  </span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Object</span>();  </span><br><span class="line">        &#125;  </span><br><span class="line">        System.out.println(<span class="string">&quot;建立对象：&quot;</span> + (System.nanoTime() - l));  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">newException</span><span class="params">()</span> &#123;  </span><br><span class="line">        <span class="type">long</span> <span class="variable">l</span> <span class="operator">=</span> System.nanoTime();  </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; testTimes; i++) &#123;  </span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Exception</span>();  </span><br><span class="line">        &#125;  </span><br><span class="line">        System.out.println(<span class="string">&quot;建立异常对象：&quot;</span> + (System.nanoTime() - l));  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">catchException</span><span class="params">()</span> &#123;  </span><br><span class="line">        <span class="type">long</span> <span class="variable">l</span> <span class="operator">=</span> System.nanoTime();  </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; testTimes; i++) &#123;  </span><br><span class="line">            <span class="keyword">try</span> &#123;  </span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Exception</span>();  </span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">        System.out.println(<span class="string">&quot;建立、抛出并接住异常对象：&quot;</span> + (System.nanoTime() - l));  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;  </span><br><span class="line">        <span class="type">ExceptionTest</span> <span class="variable">test</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ExceptionTest</span>(<span class="number">10000</span>);  </span><br><span class="line">        test.newObject();  </span><br><span class="line">        test.newException();  </span><br><span class="line">        test.catchException();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">建立对象：<span class="number">575817</span>  </span><br><span class="line">建立异常对象：<span class="number">9589080</span>  </span><br><span class="line">建立、抛出并接住异常对象：<span class="number">47394475</span>  </span><br></pre></td></tr></table></figure>

<p>建立一个异常对象，是建立一个普通Object耗时的约20倍（实际上差距会比这个数字更大一些，因为循环也占用了时间，追求精确的读者可以再测一下空循环的耗时然后在对比前减掉这部分），而抛出、接住一个异常对象，所花费时间大约是建立异常对象的4倍。</p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
  </entry>
  <entry>
    <title>JavaWeb--servlet详解</title>
    <url>/2022/03/18/JavaWeb--servlet%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<h3 id="Servlet详解"><a href="#Servlet详解" class="headerlink" title="Servlet详解"></a>Servlet详解</h3><p>Java Servlet 是运行在 Web 服务器或应用服务器上的程序，它是作为来自 Web 浏览器或其他 HTTP 客户端的请求和 HTTP 服务器上的数据库或应用程序之间的中间层。</p>
<p>使用 Servlet，您可以收集来自网页表单的用户输入，呈现来自数据库或者其他源的记录，还可以动态创建网页。</p>
<span id="more"></span>

<h3 id="1、Servlet规范"><a href="#1、Servlet规范" class="headerlink" title="1、Servlet规范"></a>1、Servlet规范</h3><ol>
<li>servlet规范来自于JAVAEE规范中的一种</li>
<li>作用：</li>
</ol>
<ul>
<li>在servlet规范中，指定【动态资源文件】开发步骤</li>
<li>在servlet规范中，指定http服务器调用动态资源文件规范</li>
<li>在servlet规范中，指定htpp服务器管理动态资源文件实例对象规范</li>
</ul>
<h3 id="2、servlet接口实现类"><a href="#2、servlet接口实现类" class="headerlink" title="2、servlet接口实现类"></a>2、servlet接口实现类</h3><ol>
<li><p>servlet接口来自于servlet规范下的接口，这个接口存在Http服务器提供的jar包</p>
</li>
<li><p>Tomcat服务器下lib文件有一个servlet-api.jar存放servlet接口（javax.servlet.Servlet接口）</p>
<p><img src="/../images/61.PNG" alt="61"></p>
</li>
<li><p>servlet规范中任务，Http服务器能调用的【动态资源文件】必须是一个<strong>servlet接口实现类</strong></p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">#例子</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>&#123;</span><br><span class="line">	<span class="comment">//不是动态资源文件，Tomcat无权调用</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Teacher</span> <span class="keyword">implements</span> <span class="title class_">Servlet</span>&#123;</span><br><span class="line">	<span class="comment">//合法动态资源文件，Tomcat有权调用</span></span><br><span class="line">	<span class="type">Servlet</span> <span class="variable">odj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Teacher</span>();</span><br><span class="line">	obj.doGet();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3、servlet接口实现类开发步骤"><a href="#3、servlet接口实现类开发步骤" class="headerlink" title="3、servlet接口实现类开发步骤"></a>3、servlet接口实现类开发步骤</h3><ol>
<li><strong>第一步</strong>：创建一个java类继承于HttpServlet父类，使之成为一个Servlet接口实现类</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> tianzedeng</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2022/3/18 - 9:54</span></span><br><span class="line"><span class="comment"> * 子类-&gt;父类-&gt;A接口</span></span><br><span class="line"><span class="comment"> * 此时子类也是A接口实现类</span></span><br><span class="line"><span class="comment"> * 若子类直接实现A接口，需要重写所有方法</span></span><br><span class="line"><span class="comment"> * 抽象类作用：降低接口实现类对接口实现过程中的难度</span></span><br><span class="line"><span class="comment"> *              将接口中不需要使用抽象方法交给抽象类进行完成</span></span><br><span class="line"><span class="comment"> *              这样接口实现类只需要对接口需要的方法进行重写</span></span><br><span class="line"><span class="comment"> *  servlet接口中的方法：</span></span><br><span class="line"><span class="comment"> *                  init()</span></span><br><span class="line"><span class="comment"> *                  getConfig()</span></span><br><span class="line"><span class="comment"> *                  service()//仅仅需要使用此方法</span></span><br><span class="line"><span class="comment"> *                  getServletInfo</span></span><br><span class="line"><span class="comment"> *                  destroy()</span></span><br><span class="line"><span class="comment"> *  Tomcat根据Servlet规范调用Servlet接口实现类规则：</span></span><br><span class="line"><span class="comment"> *          1.Tomcat有权创建Servlet接口实现类实例对象</span></span><br><span class="line"><span class="comment"> *          Servlet oneServlet = new OneServlet（）;</span></span><br><span class="line"><span class="comment"> *          2.Tomcat根据实例对象调用service方法处理当前请求</span></span><br><span class="line"><span class="comment"> *          oneServlet.service();</span></span><br><span class="line"><span class="comment"> *	oneServlet----extends---&gt;(abstract)HttpServlet----extends---&gt;					 (abstract)GenericServlet----implements---&gt;Servlet接口</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<p><img src="/../images/OneController.png" alt="67"></p>
<p>2.<strong>第二步</strong>：重写HttpServlet父类两个方法。doGet或doPost。</p>
<p>浏览器——get方式—-&gt;oneServlet.doGet()</p>
<p>浏览器——post方式—-&gt;oneServlet.doPost()</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;oneServlet类针对浏览器发送GET请求方式处理&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doPost</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;oneServlet类针对浏览器发送POST请求方式处理&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用方式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*伪代码*/</span></span><br><span class="line">HttpServlet：service()&#123;</span><br><span class="line">	<span class="keyword">if</span>(请求方式 == GET)&#123;</span><br><span class="line">		<span class="built_in">this</span>.doGet</span><br><span class="line">	&#125;<span class="keyword">else</span> <span class="keyword">if</span>(请求方式 == POST)&#123;</span><br><span class="line">        <span class="built_in">this</span>.doPost</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">OneServlet:doGet doPost</span><br><span class="line">		   <span class="type">Servlet</span> <span class="variable">oneServlet</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OneServlet</span>（）;</span><br><span class="line">		   oneServlet.service();</span><br></pre></td></tr></table></figure>

<p>总结：</p>
<p>​    1.重写规则：</p>
<p><strong>访问修饰符的限制一定要不小于被重写方法的访问修饰符</strong>；</p>
<p>比如：Object类有个toString()方法，开始重写这个方法的时候我们总容易忘记Public修饰符，出错的原因就是：没有加任何访问修饰符的方法具有包访问权限，Default访问权限小于Public访问权限，所以编译器出错。</p>
<p><strong>参数列表必须与被重写方法的相同。</strong></p>
<p><strong>重写的方法的返回值必须和被重写的方法的返回一致或者兼容；</strong></p>
<p><strong>重写的方法所抛出的异常必须和被重写方法的所抛出的异常一致，或者是其子类；</strong></p>
<p><strong>被重写的方法不能为private，子类再写一个同名的方法并不是对父类方法进行重写(Override)，而是重新生成一个新的方法；</strong></p>
<p><strong>静态方法不能被重写。</strong></p>
<p><strong>不能重写被标识为final的方法，子类中必须重写父类中的abstract方法 。</strong></p>
<p>​    2.抽象类作用：</p>
<p>​    3.子类实现接口规则：</p>
<p>​    4.this指向：</p>
<p>​    5.继承规则：</p>
<p>3、<strong>第三步</strong>：将Servlet接口实现类信息【注册】到Tomcat服务器中</p>
<p>【网站】-【web】-【WEB-INF】-web.xml</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"># 将Servlet接口实现类类路径地址交给Tomcat</span><br><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>tzd<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span>#声明一个变量存储servlet接口实现类类路径</span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>com.tzd.controller.OneServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span>#声明servlet接口实现类</span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"></span><br><span class="line">Tomcat String tzd = &quot;com.tzd.controller.OneServlet&quot;;</span><br><span class="line"></span><br><span class="line">#为了降低用户访问Servlet接口实现类难度，需要设置简短请求别名</span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>tzd<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/one<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line"></span><br><span class="line">#访问地址：http://localhost:8080/myweb/one/</span><br></pre></td></tr></table></figure>

<h3 id="4、servlet对象生命周期"><a href="#4、servlet对象生命周期" class="headerlink" title="4、servlet对象生命周期"></a>4、servlet对象生命周期</h3><p>​    1、网站中所有的servlet接口实现类的实例对象，只能由http服务器负责创建。开发人员不能手动创建servlet接口实现类的实例对象。</p>
<p>​    2、在默认情况下，http服务器接收到对于当前servlet接口实现类第一次请求时自动创建这个servlet接口实现类的实例对象。</p>
<p>​    在手动配置情况下，要求http服务器在启动时自动创建某个servlet接口实现类的实例对象。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>tzd<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span>	#声明一个变量存储servlet接口实现类类路径</span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>com.tzd.controller.OneServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span>  #声明servlet接口实现类</span><br><span class="line">    <span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>1<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span>	#填写大于0的证书</span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>​    3、在http服务器运行期间，一个servlet接口实现类只能被创建出一个实例对象。</p>
<p>​    4、在http服务器关闭时刻，自动将网站中所有的servlet对象进行销毁。</p>
<h3 id="5、HttpServletResponse接口"><a href="#5、HttpServletResponse接口" class="headerlink" title="5、HttpServletResponse接口"></a>5、HttpServletResponse接口</h3><p><strong>介绍</strong></p>
<ol>
<li>HttpServletResponse接口来自于Servlet规范中，在Tomcat中存在servlet-api.jar。</li>
<li>HTTPServletResponse接口实现类由Http服务器提供。</li>
<li>HTTPServletResponse接口负责将doGet&#x2F;doPost方法执行结果写入到<strong>响应体</strong>交给浏览器</li>
<li>开发人员习惯于将HttpServletResponse接口修饰的对象称为<strong>响应对象</strong></li>
</ol>
<p><strong>主要功能</strong></p>
<ol>
<li>将执行结果以二进制形式写入<strong>响应体</strong></li>
<li>设置响应头中content-type属性值，从而控制浏览器使用对应编译器将响应体二进制数据编译为文字、图片、视频、命令</li>
<li>设置响应头中location属性，将一个请求地址赋值为location，从而控制浏览器向指定服务器发送请求</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">#输入：<span class="number">97</span> 输出：a</span><br><span class="line">#原因：out.write方法可以将字符、字符串、ASCII码写入响应体</span><br><span class="line"><span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">97</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">PrintWriter</span> <span class="variable">writer</span> <span class="operator">=</span> response.getWriter();</span><br><span class="line"><span class="comment">//writer.write(result);</span></span><br><span class="line">writer.print(result);</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> <span class="string">&quot;java&lt;br&gt;html&lt;br&gt;&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;红烧排骨&lt;br&gt;猪肉炖粉条&lt;br&gt;&quot;</span>;</span><br><span class="line"><span class="comment">//设置响应头content-type</span></span><br><span class="line">response.setContentType(<span class="string">&quot;text/html;charset=utf-8&quot;</span>);</span><br><span class="line"><span class="comment">//向Tomcat索要输出流</span></span><br><span class="line"><span class="type">PrintWriter</span> <span class="variable">writer</span> <span class="operator">=</span> response.getWriter();</span><br><span class="line"><span class="comment">//通过输出流将结果写入响应体</span></span><br><span class="line">writer.print(result);</span><br><span class="line">writer.print(str);</span><br></pre></td></tr></table></figure>

<h3 id="6、HttpServletRequest接口"><a href="#6、HttpServletRequest接口" class="headerlink" title="6、HttpServletRequest接口"></a>6、HttpServletRequest接口</h3><p><strong>介绍</strong></p>
<ol>
<li>HttpServletRequest接口来自于Servlet规范中，在Tomcat中存在servlet-api.jar。</li>
<li>HTTPServletRequest接口实现类由Http服务器提供。</li>
<li>HTTPServletRequest接口负责将doGet&#x2F;doPost方法运行时读取http请求协议包中信息。</li>
<li>开发人员习惯于将HTTPServletRequest接口修饰的对象称为<strong>请求对象</strong></li>
</ol>
<p><strong>作用</strong></p>
<ol>
<li>可以读取Http请求协议包中<strong>请求行</strong>信息</li>
<li>可以读取保存在Http请求协议中<strong>请求头</strong>或者<strong>请求体</strong>中请求参数信息</li>
<li>可以代替浏览器向Http服务器申请资源文件调用</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">*问题：</span><br><span class="line"> * 以get方式发送中文参数内容时，得到正常结果</span><br><span class="line"> * 以post方式发送中文参数时，出现乱码</span><br><span class="line"> * 原因：</span><br><span class="line"> * 浏览器以get方式发送请求时，请求参数保存在请求头，在http请求协议包到达http服务器之后，首先就是解码</span><br><span class="line"> * 请求头二进制内容由tomcat负责解码，默认是utf-<span class="number">8</span>字符集</span><br><span class="line"> *</span><br><span class="line"> * 浏览器以post方式发送请求时，请求参数保存在请求体</span><br><span class="line"> * 请求体二进制内容是由当前的请求对象request负责解码。默认使用ISO-<span class="number">8858</span>-<span class="number">1</span>字符集</span><br><span class="line"> *</span><br><span class="line"> * 解决方案：</span><br><span class="line"> *在post请求方式下，读取请求体的内容之前，应该通知请求对象使用utf-<span class="number">8</span>字符集对请求体内容进行一次重新解码</span><br><span class="line"> */</span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doPost</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="comment">//通知请求对象，用utf-8字符集对请求体内容进行一次重新解码</span></span><br><span class="line">        request.setCharacterEncoding(<span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line">        <span class="comment">//通过请求对象，读取请求体参数信息</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> request.getParameter(<span class="string">&quot;userName&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;从请求体得到的参数值&quot;</span>+value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="comment">//通过请求对象，读取请求头的参数信息</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">userName</span> <span class="operator">=</span> request.getParameter(<span class="string">&quot;userName&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;从请求头得到的参数值&quot;</span>+userName);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>7、请求对象和响应对象生命周期</p>
<p><img src="/../images/68.PNG" alt="68"></p>
<ol>
<li><p>在http服务器接收到浏览器发送的http请求协议包之后，自动为当前的http请求协议包生成一个<strong>请求对象</strong>和一个<strong>响应对象</strong>。</p>
</li>
<li><p>在http服务器调用doGet&#x2F;doPost方法时，负责将<strong>请求对象</strong>和<strong>响应对象</strong>作为实参传递到方法中，确保方法正确执行。</p>
</li>
<li><p>在http服务器准备推送响应协议包之前，负责将本次请求关联的<strong>请求对象</strong>和<strong>响应对象</strong>销毁。</p>
<p><strong>请求对象</strong>和<strong>响应对象</strong>生命周期贯穿一次请求的处理过程中</p>
</li>
</ol>
<p><img src="/../images/69.PNG" alt="69"></p>
<h3 id="7、用户信息注册流程"><a href="#7、用户信息注册流程" class="headerlink" title="7、用户信息注册流程"></a>7、用户信息注册流程</h3><p><img src="/../images/70.PNG" alt="70"></p>
<p>user_add.html</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>用户信息注册<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">center</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;/myweb/user/add&quot;</span> <span class="attr">method</span>=<span class="string">&quot;get&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">table</span> <span class="attr">border</span>=<span class="string">&quot;2&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">td</span>&gt;</span>用户姓名：<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;userName&quot;</span>/&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">td</span>&gt;</span>用户密码：<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;password&quot;</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span>/&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">td</span>&gt;</span>用户性别：<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">td</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">name</span>=<span class="string">&quot;sex&quot;</span> <span class="attr">value</span>=<span class="string">&quot;男&quot;</span>/&gt;</span>男</span><br><span class="line">                        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">name</span>=<span class="string">&quot;sex&quot;</span> <span class="attr">value</span>=<span class="string">&quot;女&quot;</span>/&gt;</span>女</span><br><span class="line">                    <span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">td</span>&gt;</span>用户邮箱：<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;email&quot;</span>/&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;用户注册&quot;</span>/&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;reset&quot;</span> <span class="attr">value</span>=<span class="string">&quot;重置&quot;</span>/&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">center</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>实体类Users</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.tzd.entity;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> tianzedeng</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2022/3/24 - 20:20</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Users</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Integer userId;</span><br><span class="line">    <span class="keyword">private</span> String userName;</span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line">    <span class="keyword">private</span> String sex;</span><br><span class="line">    <span class="keyword">private</span> String email;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">getUserId</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> userId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setUserId</span><span class="params">(Integer userId)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.userId = userId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getUserName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> userName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setUserName</span><span class="params">(String userName)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.userName = userName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getPassword</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> password;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setPassword</span><span class="params">(String password)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.password = password;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getSex</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> sex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setSex</span><span class="params">(String sex)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.sex = sex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getEmail</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> email;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setEmail</span><span class="params">(String email)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.email = email;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Users</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Users</span><span class="params">(Integer userId, String userName, String password, String sex, String email)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.userId = userId;</span><br><span class="line">        <span class="built_in">this</span>.userName = userName;</span><br><span class="line">        <span class="built_in">this</span>.password = password;</span><br><span class="line">        <span class="built_in">this</span>.sex = sex;</span><br><span class="line">        <span class="built_in">this</span>.email = email;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>JDBC封装</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.tzd.util;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.swing.plaf.PanelUI;</span><br><span class="line"><span class="keyword">import</span> java.sql.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> tianzedeng</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2022/3/24 - 20:25</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JdbcUtil</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">URL</span> <span class="operator">=</span> <span class="string">&quot;jdbc:mysql://localhost:3306/servlet&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">USERNAME</span> <span class="operator">=</span> <span class="string">&quot;root&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">PASSWORD</span> <span class="operator">=</span> <span class="string">&quot;root&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">PreparedStatement</span> <span class="variable">preparedStatement</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将jar包中driver实现类加载到jvm中</span></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            Class.forName(<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (ClassNotFoundException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//封装连接通道创建细节</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Connection <span class="title function_">getConnection</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            connection = DriverManager.getConnection(URL,USERNAME,PASSWORD);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (SQLException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> connection;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//封装交通工具创建细节</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> PreparedStatement <span class="title function_">createStatement</span><span class="params">(String sql)</span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            preparedStatement = getConnection().prepareStatement(sql);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (SQLException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> preparedStatement;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//preparedStatement和connection</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">close</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (preparedStatement!=<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                preparedStatement.close();</span><br><span class="line">            &#125;<span class="keyword">catch</span> (SQLException e)&#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (connection!=<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                connection.close();</span><br><span class="line">            &#125;<span class="keyword">catch</span> (SQLException e)&#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">close</span><span class="params">(ResultSet resultSet)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (resultSet!=<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                resultSet.close();</span><br><span class="line">            &#125;<span class="keyword">catch</span> (SQLException e)&#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>数据持久层UserDao</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.tzd.dao;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.tzd.entity.Users;</span><br><span class="line"><span class="keyword">import</span> com.tzd.util.JdbcUtil;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.sql.PreparedStatement;</span><br><span class="line"><span class="keyword">import</span> java.sql.SQLException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> tianzedeng</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2022/3/25 - 13:59</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserDao</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">JdbcUtil</span> <span class="variable">jdbcUtil</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JdbcUtil</span>();</span><br><span class="line">    <span class="comment">//用户注册</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">add</span><span class="params">(Users users)</span>&#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;insert into users(userName,password,sex,email) values (?,?,?,?)&quot;</span>;</span><br><span class="line">        <span class="type">PreparedStatement</span> <span class="variable">preparedStatement</span> <span class="operator">=</span> jdbcUtil.createStatement(sql);</span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">        preparedStatement.setString(<span class="number">1</span>,users.getUserName());</span><br><span class="line">        preparedStatement.setString(<span class="number">2</span>,users.getPassword());</span><br><span class="line">        preparedStatement.setString(<span class="number">3</span>,users.getSex());</span><br><span class="line">        preparedStatement.setString(<span class="number">4</span>,users.getEmail());</span><br><span class="line">        result =preparedStatement.executeUpdate();</span><br><span class="line">        &#125;<span class="keyword">catch</span> (SQLException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            jdbcUtil.close();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>数据访问UserAddServlet</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.tzd.controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.tzd.dao.UserDao;</span><br><span class="line"><span class="keyword">import</span> com.tzd.entity.Users;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletException;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.PrintWriter;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> tianzedeng</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2022/3/25 - 10:50</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserAddServlet</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        String userName,password,sex,email;</span><br><span class="line">        <span class="type">UserDao</span> <span class="variable">userDao</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserDao</span>();</span><br><span class="line">        <span class="type">Users</span> <span class="variable">users</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">PrintWriter</span> <span class="variable">printWriter</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//1.调用请求对象 读取请求头里面的参数信息 得到用户注册信息</span></span><br><span class="line">        userName = request.getParameter(<span class="string">&quot;userName&quot;</span>);</span><br><span class="line">        password = request.getParameter(<span class="string">&quot;password&quot;</span>);</span><br><span class="line">        sex = request.getParameter(<span class="string">&quot;sex&quot;</span>);</span><br><span class="line">        email = request.getParameter(<span class="string">&quot;email&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.调用UserDao将用户信息填充到Insert命令中并借助JDBC规范发送到数据库中</span></span><br><span class="line">        users = <span class="keyword">new</span> <span class="title class_">Users</span>(<span class="literal">null</span>,userName,password,sex,email);</span><br><span class="line">        result =  userDao.add(users);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.调用响应对象将处理结果以二进制形式写入响应体</span></span><br><span class="line">        response.setContentType(<span class="string">&quot;text/html;charset=utf-8&quot;</span>);</span><br><span class="line">        printWriter = response.getWriter();</span><br><span class="line">        <span class="keyword">if</span> (result == <span class="number">1</span>)&#123;</span><br><span class="line">            printWriter.print(<span class="string">&quot;&lt;font style=&#x27;color:red;font-size:40&#x27;&gt;用户注册成功&lt;/font&gt;&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            printWriter.print(<span class="string">&quot;&lt;font style=&#x27;color:red;font-size:40&#x27;&gt;用户注册失败&lt;/font&gt;&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//Tomcat负责销毁请求对象和响应对象</span></span><br><span class="line">    <span class="comment">//Tomcat负责将http响应协议包推送到发起请求的浏览器上</span></span><br><span class="line">    <span class="comment">//浏览器根据响应头conten-type指定编译器对响应体二进制内容编辑</span></span><br><span class="line">    <span class="comment">//浏览器将编辑后结果在窗口中展示给用户</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="8、用户查询信息"><a href="#8、用户查询信息" class="headerlink" title="8、用户查询信息"></a>8、用户查询信息</h3><p><img src="/../images/71.png" alt="71"></p>
<p>在UserDao中创建FindAll()方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> List <span class="title function_">findAll</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;select * from users&quot;</span>;</span><br><span class="line">    <span class="type">PreparedStatement</span> <span class="variable">preparedStatement</span> <span class="operator">=</span> jdbcUtil.createStatement(sql);</span><br><span class="line">    ResultSet resultSet;</span><br><span class="line">    <span class="type">List</span> <span class="variable">userList</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        resultSet = preparedStatement.executeQuery();</span><br><span class="line">        <span class="keyword">while</span> (resultSet.next())&#123;</span><br><span class="line">            <span class="type">Integer</span> <span class="variable">userId</span> <span class="operator">=</span> resultSet.getInt(<span class="string">&quot;userId&quot;</span>);</span><br><span class="line">            <span class="type">String</span> <span class="variable">userName</span> <span class="operator">=</span> resultSet.getString(<span class="string">&quot;userName&quot;</span>);</span><br><span class="line">            <span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> resultSet.getString(<span class="string">&quot;password&quot;</span>);</span><br><span class="line">            <span class="type">String</span> <span class="variable">sex</span> <span class="operator">=</span> resultSet.getString(<span class="string">&quot;sex&quot;</span>);</span><br><span class="line">            <span class="type">String</span> <span class="variable">email</span> <span class="operator">=</span> resultSet.getString(<span class="string">&quot;email&quot;</span>);</span><br><span class="line">            <span class="type">Users</span> <span class="variable">users</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Users</span>(userId,userName,password,sex,email);</span><br><span class="line">            userList.add(users);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        jdbcUtil.close();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> userList;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>新建UserFindServlet类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.tzd.controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.tzd.dao.UserDao;</span><br><span class="line"><span class="keyword">import</span> com.tzd.entity.Users;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletException;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.PrintWriter;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> tianzedeng</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2022/3/25 - 15:01</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserFindServlet</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="type">UserDao</span> <span class="variable">userDao</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserDao</span>();</span><br><span class="line">        PrintWriter printWriter;</span><br><span class="line">        <span class="comment">//调用Dao将查询命令推送到数据库服务器上，得到所有用户信息【List】</span></span><br><span class="line">        List&lt;Users&gt; userList = userDao.findAll();</span><br><span class="line">        <span class="comment">//调用响应对象，将用户信息结合&lt;table&gt;标签命令以二进制形式写入响应体</span></span><br><span class="line">        response.setContentType(<span class="string">&quot;text/html;charset=utf-8&quot;</span>);</span><br><span class="line">        printWriter = response.getWriter();</span><br><span class="line">        printWriter.print(<span class="string">&quot;&lt;table border=&#x27;2&#x27; align=&#x27;center&#x27;&gt;&quot;</span>);</span><br><span class="line">        printWriter.print(<span class="string">&quot;&lt;tr&gt;&quot;</span>);</span><br><span class="line">        printWriter.print(<span class="string">&quot;&lt;td&gt;用户编号&lt;/td&gt;&quot;</span>);</span><br><span class="line">        printWriter.print(<span class="string">&quot;&lt;td&gt;用户姓名&lt;/td&gt;&quot;</span>);</span><br><span class="line">        printWriter.print(<span class="string">&quot;&lt;td&gt;用户密码&lt;/td&gt;&quot;</span>);</span><br><span class="line">        printWriter.print(<span class="string">&quot;&lt;td&gt;用户性别&lt;/td&gt;&quot;</span>);</span><br><span class="line">        printWriter.print(<span class="string">&quot;&lt;td&gt;用户邮箱&lt;/td&gt;&quot;</span>);</span><br><span class="line">        printWriter.print(<span class="string">&quot;&lt;/tr&gt;&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (Users users : userList) &#123;</span><br><span class="line">            printWriter.print(<span class="string">&quot;&lt;tr&gt;&quot;</span>);</span><br><span class="line">            printWriter.print(<span class="string">&quot;&lt;td&gt;&quot;</span> + users.getUserId() + <span class="string">&quot;&lt;/td&gt;&quot;</span>);</span><br><span class="line">            printWriter.print(<span class="string">&quot;&lt;td&gt;&quot;</span> + users.getUserName() + <span class="string">&quot;&lt;/td&gt;&quot;</span>);</span><br><span class="line">            printWriter.print(<span class="string">&quot;&lt;td&gt;******&lt;/td&gt;&quot;</span>);</span><br><span class="line">            printWriter.print(<span class="string">&quot;&lt;td&gt;&quot;</span> + users.getSex() + <span class="string">&quot;&lt;/td&gt;&quot;</span>);</span><br><span class="line">            printWriter.print(<span class="string">&quot;&lt;td&gt;&quot;</span> + users.getEmail() + <span class="string">&quot;&lt;/td&gt;&quot;</span>);</span><br><span class="line">            printWriter.print(<span class="string">&quot;&lt;/tr&gt;&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        printWriter.print(<span class="string">&quot;&lt;/table&gt;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="9、登录验证"><a href="#9、登录验证" class="headerlink" title="9、登录验证"></a>9、登录验证</h3><p><img src="/../images/72.PNG" alt="72"></p>
<p>login.html</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>用户登录<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">center</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">font</span> <span class="attr">style</span>=<span class="string">&quot;color: red;font-size: 30px&quot;</span>&gt;</span>登录信息不存在，请重新登录<span class="tag">&lt;/<span class="name">font</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;/myweb/login&quot;</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">table</span> <span class="attr">border</span>=<span class="string">&quot;2&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">td</span>&gt;</span>用户名<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;userName&quot;</span>/&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">td</span>&gt;</span>密码<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;password&quot;</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span>/&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;登录&quot;</span>/&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;reset&quot;</span>/&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">center</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>UserDao</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//登录验证</span></span><br><span class="line">   <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">login</span><span class="params">(String userName,String password)</span>&#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span><span class="string">&quot;select count(*) from users where userName=? and password=?&quot;</span>;</span><br><span class="line">        <span class="type">PreparedStatement</span> <span class="variable">preparedStatement</span> <span class="operator">=</span> JdbcUtil.createStatement(sql);</span><br><span class="line">        <span class="type">ResultSet</span> <span class="variable">resultSet</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            preparedStatement.setString(<span class="number">1</span>, userName);</span><br><span class="line">            preparedStatement.setString(<span class="number">2</span>, password);</span><br><span class="line">            resultSet = preparedStatement.executeQuery();</span><br><span class="line">            <span class="keyword">while</span> (resultSet.next())&#123;</span><br><span class="line">                result = resultSet.getInt(<span class="string">&quot;count(*)&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (SQLException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            jdbcUtil.close();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>LoginServlet</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.tzd.controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.tzd.dao.UserDao;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletException;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"><span class="keyword">import</span> javax.swing.*;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> tianzedeng</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2022/3/28 - 10:26</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoginServlet</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doPost</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        String userName,password;</span><br><span class="line">        <span class="type">UserDao</span> <span class="variable">userDao</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserDao</span>();</span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//调用请求对象对请求体使用utf-8字符集进行重新编写</span></span><br><span class="line">        request.setCharacterEncoding(<span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line">        <span class="comment">//调用请求对象读取请求参数体信息</span></span><br><span class="line">        userName = request.getParameter(<span class="string">&quot;userName&quot;</span>);</span><br><span class="line">        password = request.getParameter(<span class="string">&quot;password&quot;</span>);</span><br><span class="line">        <span class="comment">//调用Dao将查询验证信息推送到数据库服务器上</span></span><br><span class="line">        result = userDao.login(userName,password);</span><br><span class="line">        <span class="comment">//调用响应对象，根据验证结果将不同的资源文件地址写到响应头，返回给浏览器</span></span><br><span class="line">        <span class="keyword">if</span> (result == <span class="number">1</span>)&#123;</span><br><span class="line">            response.sendRedirect(<span class="string">&quot;/myweb/index.html&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            response.sendRedirect(<span class="string">&quot;/myweb/login_error.html&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="10、资源文件"><a href="#10、资源文件" class="headerlink" title="10、资源文件"></a>10、资源文件</h3><p>1、前提：用户可以记住网站名，但是不会记住网站资源文件</p>
<p>2、用户发送了一个针对某个网站的默认请求文件时，此时由http服务器自动从当前网站返回的资源文件</p>
<p>​    正常请求：<a href="http://localhost:8080/myweb/index.html">http://localhost:8080/myweb/index.html</a></p>
<p>​    默认请求：<a href="http://localhost:8080/myweb/">http://localhost:8080/myweb/</a></p>
<p>3、Tomcat对于资源文件定位规则</p>
<ul>
<li><p>规则位置：Tomcat安装位置&#x2F;conf&#x2F;web.xml</p>
</li>
<li><p>规则命令：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">  <span class="comment">&lt;!-- ==================== Default Welcome File List ===================== --&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- When a request URI refers to a directory, the default servlet looks  --&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- for a &quot;welcome file&quot; within that directory and, if present, to the   --&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- corresponding resource URI for display.                              --&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- If no welcome files are present, the default servlet either serves a --&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- directory listing (see default servlet configuration on how to       --&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- customize) or returns a 404 status, depending on the value of the    --&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- listings setting.                                                    --&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--                                                                      --&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- If you define welcome files in your own application&#x27;s web.xml        --&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- deployment descriptor, that list *replaces* the list configured      --&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- here, so be sure to include any of the default values that you wish  --&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- to use within your application.                                       --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">welcome-file-list</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">welcome-file</span>&gt;</span>index.html<span class="tag">&lt;/<span class="name">welcome-file</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">welcome-file</span>&gt;</span>index.htm<span class="tag">&lt;/<span class="name">welcome-file</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">welcome-file</span>&gt;</span>index.jsp<span class="tag">&lt;/<span class="name">welcome-file</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">welcome-file-list</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>设置当前网络的默认欢迎资源文件规则</p>
<p>规则位置：网站&#x2F;web&#x2F;WEB-INF&#x2F;web.xml</p>
<p>规则命令：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">welcome-file-list</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">welcome-file</span>&gt;</span>login.html<span class="tag">&lt;/<span class="name">welcome-file</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">welcome-file-list</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>网站设置自定义默认文件定位规则，此时Tomcat默认规则将失效。</p>
</li>
</ul>
<h3 id="11、http状态码"><a href="#11、http状态码" class="headerlink" title="11、http状态码"></a>11、http状态码</h3><ol>
<li><p>介绍</p>
<ul>
<li>由三位数字组成的一个符号</li>
<li>由http服务器在推送响应包之前，根据本次请求处理情况，将http状态码写入到响应包中状态行上</li>
<li>如果http服务器针对本次请求，返回了对应的资源文件。通过http状态码通知浏览器应该如何处理这个结果；如果http服务器针对本次请求，无法返回对应的资源文件，通过http状态码向浏览器解释不能提供的服务的原因</li>
</ul>
</li>
<li><p>分类</p>
<ul>
<li><p>组成    100-599；分为5个大类</p>
</li>
<li><p>1xx：最有特征的是100：通知浏览器本次返回的资源文件并不是一个独立的资源文件，需要浏览器在接收响应包之后，继续向http服务器索要依赖的其它资源文件。</p>
<p><img src="/../images/73.PNG" alt="73"></p>
</li>
<li><p>2xx：最有特征的是200:：通知浏览器本次返回的资源文件是一个完整独立的资源文件，浏览器在接收到之后，不需要索要其它关联文件。</p>
</li>
<li><p>3xx：最有特征302：通知浏览器本次返回的不是一个资源文件内容而是一个资源文件地址，需要浏览器根据这个地址自动发起请求来索要这个资源文件。</p>
<p>response.sendRedirect(“资源文件地址”)写入到响应头中location，而这个行为导致Tomcat将302状态码写入到状态行。</p>
</li>
<li><p>4xx：404，通知浏览器，由于在服务端没有定位到被访问的资源文件因此无法提供帮助。</p>
<p>​          405，通知到浏览器，在服务端已经定位到被访问的资源文件（Servlet），但是这个Servlet对于浏览器采用的请求方式不能处理。</p>
</li>
<li><p>5xx：500，通知到浏览器，在服务端已经定位到被访问的资源文件（Servlet），这个servlet可以去接收浏览器的请求方式，但是Servlet在处理请求期间，由于JAVA异常导致处理失败。</p>
</li>
</ul>
</li>
</ol>
<h3 id="12、多个servlet之间的调用规则"><a href="#12、多个servlet之间的调用规则" class="headerlink" title="12、多个servlet之间的调用规则"></a>12、多个servlet之间的调用规则</h3><ol>
<li><p>前提条件：</p>
<p>某些来自于浏览器发送请求，往往需要服务端中多个servlet协同处理。但是浏览器一次只能访问一个servlet，导致用户需要手动通过浏览器发起多次请求才能得到服务。这样增加用户获得服务难度，导致用户放弃访问当前网站。</p>
</li>
<li><p>提高用户使用感受规则：</p>
<p>无论本次请求涉及到多少个servlet，用户只需要手动通知浏览器发起一次请求即可。</p>
</li>
<li><p>实现方案：</p>
<ul>
<li>重定向解决方案</li>
<li>请求转发解决方案</li>
</ul>
</li>
</ol>
<h3 id="13、重定向解决方案"><a href="#13、重定向解决方案" class="headerlink" title="13、重定向解决方案"></a>13、重定向解决方案</h3><p><img src="/../images/74.PNG" alt="74"></p>
<p><strong>原理</strong>：用户第一次通过手动方式通知浏览器访问OneServlet。OneServlet工作完毕之后，将TwoServlet地址写入到响应头location属性中，导致Tomcat将302状态码写入到状态行。</p>
<p>在浏览器接收到响应包后，会读取302状态。此时浏览器自动根据响应头中location属性地址发起第二次请求，访问TwoServlet去完成请求中剩余任务。</p>
<p><strong>实现命令</strong>：response.sendRedirect(“请求地址”)，将地址写入响应包中的location属性中。</p>
<p><strong>特征：</strong></p>
<ol>
<li>请求地址：既可以把当前网站内部的资源文件地址发送给浏览器，也可以把其它网站资源文件地址发送给浏览器。</li>
<li>请求次数：浏览器至少发送两次请求，但是只有第一次请求是用户手动发送。后续请求都是浏览器自动发送的。</li>
<li>请求方式：重定向解决方案中，通过地址栏通知浏览器发起下一次请求，因此通过重定向解决方案调用的资源文件接收的请求方式一定是GET。</li>
</ol>
<p><strong>缺点：</strong></p>
<p>重定向解决方案需要在浏览器与服务器之间进行多次往返，大量时间消耗在往返次数上，增加用户等待服务时间。</p>
<h3 id="14、请求转发方案"><a href="#14、请求转发方案" class="headerlink" title="14、请求转发方案"></a>14、请求转发方案</h3><p><img src="/../images/75.PNG" alt="75"></p>
<p><strong>原理：</strong>用户第一次通过手动的方式要求浏览器去访问oneServlet，OneServlet工作完毕之后，通过当前的请求对象代替浏览器向Tomcat发送请求，申请调用TwoServlet。Tomcat在接收到这个请求之后，自动调用TwoServlet来完成剩余任务。</p>
<p><strong>实现命令：</strong>请求对象代替浏览器向Tomcat发送请求。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1.通过当前请求对象生成资源文件中申请发送报告</span></span><br><span class="line"><span class="type">RequestDiaptcher</span> <span class="variable">requestDispatcher</span> <span class="operator">=</span> request.getRequestDispatcher(<span class="string">&quot;/资源文件名&quot;</span>)；</span><br><span class="line"><span class="comment">//2.将报告对象发送给Tomcat</span></span><br><span class="line">requestDispatcher.forward(当前的请求对象,当前的响应对象);</span><br></pre></td></tr></table></figure>

<p><strong>优点：</strong></p>
<ol>
<li>无论本次请求涉及到多少个Servlet，用户只需要手动通过浏览器发送一次请求。</li>
<li>Servlet之间调用发生在服务端计算机上，节省服务器与浏览器之间往返次数，增加处理服务速度。</li>
</ol>
<p><strong>特征：</strong></p>
<ol>
<li>请求次数：在请求转发过程中，浏览器只发送一次请求。</li>
<li>请求地址：只能向Tomcat服务器申请调用当前网站下资源文件地址。</li>
<li>请求方式：在请求转发过程中，浏览器只发送了一个http请求包。参与本次请求的所有Servlet共享同一个请求包协议，因此这些Servlet接收的请求方式与浏览器发送的请求方式保持一致。</li>
</ol>
<h3 id="15、多个Servlet之间数据共享实现方案"><a href="#15、多个Servlet之间数据共享实现方案" class="headerlink" title="15、多个Servlet之间数据共享实现方案"></a>15、多个Servlet之间数据共享实现方案</h3><p><strong>数据共享</strong>：OneServlet工作完毕后，将产生数据交给TwoServlet来使用</p>
<p><strong>Servlet规范中提供四种数据共享方案</strong>：</p>
<ol>
<li>ServletContext接口</li>
<li>Cookie接口</li>
<li>HttpSession接口</li>
<li>HttpServletRequest接口</li>
</ol>
<h3 id="16、ServletContext接口"><a href="#16、ServletContext接口" class="headerlink" title="16、ServletContext接口"></a>16、ServletContext接口</h3><p><strong>介绍：</strong></p>
<ol>
<li>来自于Servlet规范中一个接口。在Tomcat中存在servlet-api.jar，在Tomcat中负责提供这个接口的实现类。</li>
<li>如果两个Servlet来自于同一个网站。彼此之间通过网站的ServletContext实例对象实现数据共享。</li>
<li>开发人员习惯于将ServletContext对象称为全局作用域对象。</li>
</ol>
<p><strong>工作原理：</strong></p>
<p><img src="/../images/76.PNG" alt="76"></p>
<p>​    </p>
<p>每一个网站都存在一个全局作用域对象。在这个全局作用域对象相当于一个Map。在这个网站中OneServlet可以将一个数据存入到全局作用域对象，当前网站中其它Servlet此时都可以从全局作用域对象得到这个数据进行使用。</p>
<p><strong>全局作用域对象的声明周期</strong></p>
<ol>
<li><p>在Http服务器启动过程中，自动为当前网站在内存中创建一个全局作用域对象。</p>
</li>
<li><p>在Http服务器运行期间，一个网站只有一个全局作用域对象。</p>
</li>
<li><p>在Http服务器运行期间，全局作用域对象一直处于存活状态。</p>
</li>
<li><p>正在Http服务器准备关闭时，负责将当前网站中全局作用域对象进行销毁处理。</p>
<p>全局作用域对象生命周期贯穿网站整个运行期间。</p>
</li>
</ol>
<p><strong>命令的实现</strong></p>
<p>同一个网站中，OneServlet将数据共享给TwoServlet。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">OneServlet&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest request,HttpServletResponse response)</span>&#123;</span><br><span class="line">		<span class="comment">//通过请求对象向Tomcat索要当前网站中全局作用域对象</span></span><br><span class="line">        <span class="type">ServletContext</span> <span class="variable">application</span> <span class="operator">=</span> request.getServletContext();</span><br><span class="line">        <span class="comment">//将数据添加到全局作用域对象作为共享数据</span></span><br><span class="line">        application.setAttribute(<span class="string">&quot;key1&quot;</span>,data);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">TwoServlet&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest request,HttpServletResponse response)</span>&#123;</span><br><span class="line">        <span class="comment">//通过请求对象向Tomcat索要当前网站中全局作用域对象</span></span><br><span class="line">        <span class="type">ServletContext</span> <span class="variable">application</span> <span class="operator">=</span> request.getServletContext();</span><br><span class="line">        <span class="comment">//从全局作用域对象中得到指定关键字对应数据</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">data</span> <span class="operator">=</span> application.getAttribute(<span class="string">&quot;key1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="17、cookie接口"><a href="#17、cookie接口" class="headerlink" title="17、cookie接口"></a>17、cookie接口</h3><p><img src="/../images/77.PNG" alt="77"></p>
<p><strong>介绍</strong></p>
<ol>
<li>cookie来自于Servlet规范中一个工具类，存在于Tomcat提供servlet-api.jar中。</li>
<li>如果两个Servlet来自于同一个网站。并且为同一个浏览器&#x2F;用户提供服务，此时借助于cokkie对象进行数据共享。</li>
<li>cookie存放当前用户的私人数据，在共享数据过程中提高服务质量。</li>
<li>在现实生活中，cookie相当于用户在服务端得到会员卡。</li>
</ol>
<p><strong>原理</strong></p>
<ol>
<li>用户通过浏览器第一次向网站发送请求是申请OneServlet。</li>
<li>OneServlet在运行期间创建一个cookie存储与当前用户相关的数据。</li>
<li>OneServlet工作完毕后，将cookie写入到响应头交还给当前浏览器。</li>
<li>浏览器收到响应包后，将cookie存储在浏览器的缓存中。</li>
<li>一段时间后，用户通过同一个浏览器再次向网站请求申请TwoServlet时。浏览器需要无条件的将网站推送过来的cookie写入到请求头中发送过去。</li>
<li>此时TwoServlet在运行时，就可以通过读取请求头中cookie中信息，得到OneServlet提供的共享数据。</li>
</ol>
<p><strong>实现命令</strong></p>
<p>同一个OneServlet与TwoServlet借助于cookie实现数据共享。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">OneServlet&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest request,HttpServletResponse response)</span>&#123;</span><br><span class="line">        <span class="comment">//1.创建一个cookie对象，保存共享数据（当前用户数据）</span></span><br><span class="line">        <span class="comment">//cookie相当于一个map，一个cookie中只能存放一个键值对，这个键值对的key和value只能是string类型，键值对中的key不能是中文</span></span><br><span class="line">        <span class="type">Cookie</span> <span class="variable">card</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cookie</span>(<span class="string">&quot;key1&quot;</span>,<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">        <span class="type">Cookie</span> <span class="variable">card1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cookie</span>(<span class="string">&quot;key2&quot;</span>,<span class="string">&quot;efg&quot;</span>);</span><br><span class="line">        <span class="comment">//2.将cookie写入到响应头，交给浏览器</span></span><br><span class="line">        response.addCookie(card);</span><br><span class="line">        response.addCookie(card2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//浏览器或用户  &lt;---------响应包	【200】</span></span><br><span class="line"><span class="comment">//							  【cookie:key1=abc】</span></span><br><span class="line"><span class="comment">//		                      【】</span></span><br><span class="line"><span class="comment">//							  【处理结果】</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//浏览器向网站发送请求访问TwoServlet----&gt;请求包【url：/myweb/two method:get】</span></span><br><span class="line"><span class="comment">//										  【请求参数：xxxx</span></span><br><span class="line"><span class="comment">//											cookie:key1=abc</span></span><br><span class="line"><span class="comment">//											】</span></span><br><span class="line"><span class="comment">//										  【】</span></span><br><span class="line"><span class="comment">//										  【】</span></span><br><span class="line">TwoServlet&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest request,HttpServletResponse response)</span>&#123;</span><br><span class="line">        <span class="comment">//1.调用请求对象从请求头得到浏览器返回的cookie</span></span><br><span class="line">        Cookie cookieArray[] = request.getCookies();</span><br><span class="line">        <span class="comment">//2.循环遍历数据得到每一个cookie的key和value</span></span><br><span class="line">        <span class="keyword">for</span>(Cookie card:cookieArray)&#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> cookie.getName();</span><br><span class="line">            <span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> card.getValue();</span><br><span class="line">        &#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>实战</strong></p>
<p><img src="/../images/78.PNG" alt="78"></p>
<p>index.html</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">center</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">font</span> <span class="attr">style</span>=<span class="string">&quot;color: red;font-size: 40px&quot;</span>&gt;</span>新会员申请开卡<span class="tag">&lt;/<span class="name">font</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;/cookie/one&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">table</span> <span class="attr">border</span>=<span class="string">&quot;2&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">td</span>&gt;</span>用户名<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;userName&quot;</span>/&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">td</span>&gt;</span>预存金额<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;money&quot;</span>/&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;申请开卡&quot;</span>/&gt;</span>&gt;<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;reset&quot;</span>/&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">center</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>OneServlet</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.tzd.controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletException;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.Cookie;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> tianzedeng</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2022/3/28 - 20:41</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OneServlet</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="comment">//1.调用请求对象读取请求头参数信息</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">userName</span> <span class="operator">=</span> request.getParameter(<span class="string">&quot;userName&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">money</span> <span class="operator">=</span> request.getParameter(<span class="string">&quot;money&quot;</span>);</span><br><span class="line">        <span class="comment">//2.开卡</span></span><br><span class="line">        <span class="type">Cookie</span> <span class="variable">card1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cookie</span>(<span class="string">&quot;userName&quot;</span>,userName);</span><br><span class="line">        <span class="type">Cookie</span> <span class="variable">card2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cookie</span>(<span class="string">&quot;money&quot;</span>,money);</span><br><span class="line">        <span class="comment">//3.发卡，将cookie写入到响应头中，交给浏览器</span></span><br><span class="line">        response.addCookie(card1);</span><br><span class="line">        response.addCookie(card2);</span><br><span class="line">        <span class="comment">//4.通知tomcat将点餐页面内容写入到响应体交给浏览器（请求转发）</span></span><br><span class="line">        request.getRequestDispatcher(<span class="string">&quot;/index2.html&quot;</span>).forward(request,response);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>index2.html</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>点餐<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">center</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">font</span> <span class="attr">style</span>=<span class="string">&quot;color: red;font-size: 40px&quot;</span>&gt;</span>点餐页面<span class="tag">&lt;/<span class="name">font</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;/cookie/two&quot;</span>&gt;</span></span><br><span class="line">        食物类型：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">name</span>=<span class="string">&quot;food&quot;</span> <span class="attr">value</span>=<span class="string">&quot;饺子&quot;</span>/&gt;</span>饺子(30元)</span><br><span class="line">                  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">name</span>=<span class="string">&quot;food&quot;</span> <span class="attr">value</span>=<span class="string">&quot;面条&quot;</span>/&gt;</span>面条(20元)</span><br><span class="line">                  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">name</span>=<span class="string">&quot;food&quot;</span> <span class="attr">value</span>=<span class="string">&quot;盖饭&quot;</span>/&gt;</span>盖饭(15元)</span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;划卡消费&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">center</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>TwoServlet</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.tzd.controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletException;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.Cookie;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.PrintWriter;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> tianzedeng</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2022/3/28 - 20:53</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TwoServlet</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">jiaozi_money</span> <span class="operator">=</span> <span class="number">30</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">noodle_money</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">gaifan_money</span> <span class="operator">=</span> <span class="number">15</span>;</span><br><span class="line">        String food;</span><br><span class="line">        <span class="type">String</span> <span class="variable">userName</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        Integer money;</span><br><span class="line">        <span class="type">int</span> consume=<span class="number">0</span>,balance = <span class="number">0</span>;</span><br><span class="line">        Cookie cookArray[];</span><br><span class="line">        response.setContentType(<span class="string">&quot;text/html;charset=utf-8&quot;</span>);</span><br><span class="line">        <span class="type">PrintWriter</span> <span class="variable">printWriter</span> <span class="operator">=</span> response.getWriter();</span><br><span class="line">        <span class="type">Cookie</span> <span class="variable">newCard</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">//1.读取请求头中的参数信息，得到用户点餐食物类型</span></span><br><span class="line">        food = request.getParameter(<span class="string">&quot;food&quot;</span>);</span><br><span class="line">        <span class="comment">//2.读取请求头中的cookie</span></span><br><span class="line">        cookArray = request.getCookies();</span><br><span class="line">        <span class="comment">//3.刷卡消费</span></span><br><span class="line">        <span class="keyword">for</span> (Cookie card:cookArray)&#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> card.getName();</span><br><span class="line">            <span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> card.getValue();</span><br><span class="line">            <span class="keyword">if</span> (<span class="string">&quot;userName&quot;</span>.equals(key))&#123;</span><br><span class="line">                userName = value;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="string">&quot;money&quot;</span>.equals(key))&#123;</span><br><span class="line">                money = Integer.valueOf(value);</span><br><span class="line">                <span class="keyword">if</span> (<span class="string">&quot;饺子&quot;</span>.equals(food))&#123;</span><br><span class="line">                    <span class="keyword">if</span> (jiaozi_money &gt; money)&#123;</span><br><span class="line">                        printWriter.print(<span class="string">&quot;用户&quot;</span>+userName+<span class="string">&quot;余额不足，请充值&quot;</span>);</span><br><span class="line">                    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                        newCard = <span class="keyword">new</span> <span class="title class_">Cookie</span>(<span class="string">&quot;money&quot;</span>,(money-jiaozi_money)+<span class="string">&quot;&quot;</span>);</span><br><span class="line">                        consume = jiaozi_money;</span><br><span class="line">                        balance = money-jiaozi_money;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;面条&quot;</span>.equals(food))&#123;</span><br><span class="line">                    <span class="keyword">if</span> (noodle_money &gt; money)&#123;</span><br><span class="line">                        printWriter.print(<span class="string">&quot;用户&quot;</span>+userName+<span class="string">&quot;余额不足，请充值&quot;</span>);</span><br><span class="line">                    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                        newCard = <span class="keyword">new</span> <span class="title class_">Cookie</span>(<span class="string">&quot;money&quot;</span>,(money-noodle_money)+<span class="string">&quot;&quot;</span>);</span><br><span class="line">                        consume = noodle_money;</span><br><span class="line">                        balance = money-noodle_money;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;盖饭&quot;</span>.equals(food))&#123;</span><br><span class="line">                    <span class="keyword">if</span> (gaifan_money &gt; money)&#123;</span><br><span class="line">                        printWriter.print(<span class="string">&quot;用户&quot;</span>+userName+<span class="string">&quot;余额不足，请充值&quot;</span>);</span><br><span class="line">                    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                        newCard = <span class="keyword">new</span> <span class="title class_">Cookie</span>(<span class="string">&quot;money&quot;</span>,(money-gaifan_money)+<span class="string">&quot;&quot;</span>);</span><br><span class="line">                        consume = gaifan_money;</span><br><span class="line">                        balance = money-gaifan_money;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//4.将用户会员卡返还给用户</span></span><br><span class="line">        response.addCookie(newCard);</span><br><span class="line">        <span class="comment">//5.将消费记录写到响应体中</span></span><br><span class="line">        printWriter.print(<span class="string">&quot;用户：&quot;</span>+userName+<span class="string">&quot;本次消费：&quot;</span>+consume+<span class="string">&quot;余额为：&quot;</span>+balance);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>cookie销毁时机</strong></p>
<ol>
<li><p>在默认情况下，cookie对象存放在浏览器的缓存中。因此只要关闭浏览器，cookie对象就被销毁。</p>
</li>
<li><p>在手动设置情况下，可以要求浏览器将接收的cookie存放在客户端计算机的硬盘上，同时需要指定cookie在硬盘上的存活时间。在存活时间内范围内，关闭浏览器关闭客户端计算机，关闭服务器，都不会导致cookie被销毁。在存活时间到达时，cookie自动从硬盘上删除。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">cookie.setMaxAge(<span class="number">60</span>);</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="18、HttpSession接口"><a href="#18、HttpSession接口" class="headerlink" title="18、HttpSession接口"></a>18、HttpSession接口</h3><p><strong>介绍</strong></p>
<ol>
<li>HttpSession接口来自于Servlet规范下的一个接口。存在于Tomcat中servlet-api.jar，其实现类由Http服务器提供。Tomcat提供实现类存在于servlet-api.jar。</li>
<li>如果两个servlet来自于同一个网站，并且为同一个浏览器&#x2F;用户提供服务，此时借助于HttpSession对象进行数据共享。</li>
<li>开发人员习惯于将HttpSession接口修饰对象称为会话作用域对象。</li>
</ol>
<p><strong>HttpSession与Cookie区别</strong></p>
<ol>
<li>存储位置：cookie存放在客户端计算机中（浏览器内存&#x2F;硬盘）；HttpSession存放在服务端计算机内存。</li>
<li>数据类型：cookie对象存储共享数据类型只能是String；HttpSession对象可以存储任意类型的共享数据Object。</li>
<li>数据数量：一个cookie对象只能存储一个共享数据；HttpSession使用map集合存储共享数据，可以存储任意数量共享数据。</li>
<li>参照物：cookie相当于客户在服务端会员卡；HttpSession相当于客户在服务端的私人保险柜。</li>
</ol>
<p><strong>命令实现</strong></p>
<p>同一个网站下OneServlet将数据传递给TwoServlet</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">OneServlet&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest request,HttpServletResponse response)</span>&#123;</span><br><span class="line">        <span class="comment">//1.调用请求对象向Tomcat索要当前用户在服务器的私人储物柜</span></span><br><span class="line">        <span class="type">HttpSession</span> <span class="variable">session</span> <span class="operator">=</span> request.getSession();</span><br><span class="line">        <span class="comment">//2.将数据添加到用户私人储物柜</span></span><br><span class="line">        session.setAttribute(<span class="string">&quot;key1&quot;</span>,共享数据);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//浏览器访问/myweb中TwoServlet</span></span><br><span class="line">TwoServlet&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest request,HttpServletResponse response)</span>&#123;</span><br><span class="line">        <span class="comment">//1.调用请求对象向Tomcat索要当前用户在服务器的私人储物柜</span></span><br><span class="line">        <span class="type">HttpSession</span> <span class="variable">session</span> <span class="operator">=</span> request.getSession();</span><br><span class="line">        <span class="comment">//2.从会话作用域对象得到OneServlet提供的共享数据</span></span><br><span class="line">        Object 共享数据 = session.getAttribute(<span class="string">&quot;key1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>模拟购物车</strong></p>
<p><img src="/../images/79.PNG" alt="79"></p>
<p><strong>HttpSession与用户关联</strong>（cookie）</p>
<p><img src="/../images/80.PNG" alt="80"></p>
<p><strong>getSession()和getSession(false)</strong></p>
<ol>
<li>getSession()：如果当前用户在服务端已经拥有了自己的私人储物柜，要求tomcat将这个私人储物柜进行返回；如果当前用户在服务端尚未拥有自己的私人储物柜，要求tomcat为当前用户创建一个全新的私人储物柜。</li>
<li>getSession(false)：如果当前用户在服务端已经拥有了自己的私人储物柜，要求tomcat将这个私人储物柜进行返回；如果当前用户在服务端尚未拥有自己的私人储物柜，此时tomcat将返回null。</li>
</ol>
<p><strong>HttpSession销毁时机</strong></p>
<ol>
<li>用户与HttpSession关联时使用的cookie只能存放在浏览器缓存中。</li>
<li>在浏览器关闭时，意味着用户与其HttpSession关系被切断。</li>
<li>由于Tomcat无法监测浏览器何时关闭，因此在浏览器关闭时，并不会导致tomcat将浏览器关联的HttpSession进行销毁。</li>
<li>为了解决这个问题，tomcat为每个HttpSession对象设置空闲时间，这个空闲时间默认是30分钟。如果当前HttpSession对象空闲时间达到30分钟，此时tomcat认为用户已经放弃了自己的HttpSession，tomcat就会销毁这个HttpSession。</li>
</ol>
<p><strong>HttpSession空闲时间手动设置</strong></p>
<p>在当前网站&#x2F;web&#x2F;WEB-INF&#x2F;web.xml</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;session-config&gt;</span><br><span class="line">	&lt;session-timeout&gt;<span class="number">5</span>&lt;/session-timeout&gt;	<span class="comment">//当前网站每一个session最大空闲时间为5分钟</span></span><br><span class="line">&lt;/session-config&gt;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>JavaWeb</category>
      </categories>
      <tags>
        <tag>JavaWeb</tag>
      </tags>
  </entry>
  <entry>
    <title>JUC高并发编程-共享模型之管程</title>
    <url>/2022/05/16/2022-05-16-JUC%E9%AB%98%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-%E5%85%B1%E4%BA%AB%E6%A8%A1%E5%9E%8B%E4%B9%8B%E7%AE%A1%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="共享模型之管程"><a href="#共享模型之管程" class="headerlink" title="共享模型之管程"></a>共享模型之管程</h1><span id="more"></span>

<h3 id="共享模型之管程-1"><a href="#共享模型之管程-1" class="headerlink" title="共享模型之管程"></a>共享模型之管程</h3><h4 id="共享带来的问题"><a href="#共享带来的问题" class="headerlink" title="共享带来的问题"></a>共享带来的问题</h4><h5 id="Java的体现"><a href="#Java的体现" class="headerlink" title="Java的体现"></a>Java的体现</h5><p>两个线程对初始值为0的静态变量一个做自增，一个自减，各做5000次，结果是0 吗？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="type">int</span> <span class="variable">counter</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; <span class="number">5000</span>;i++)&#123;</span><br><span class="line">            counter++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,<span class="string">&quot;t1&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; <span class="number">5000</span>;i++)&#123;</span><br><span class="line">            counter--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,<span class="string">&quot;t2&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    t1.start();</span><br><span class="line">    t2.start();</span><br><span class="line">    t1.join();</span><br><span class="line">    t2.join();</span><br><span class="line">    log.debug(<span class="string">&quot;&#123;&#125;&quot;</span>,counter);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h5><p>以上结果可能是正数、负数、零。因为java中对静态变量的自增，自减并不是原子操作，要彻底理解，必须从字节码来进行分析。</p>
<p>例如对于i++而言（i为静态变量），实际会产生如下的JVM字节码指令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">getstatic	i	//准备静态变量i的值</span><br><span class="line">iconst_1		//准备常量1</span><br><span class="line">iadd			//自增</span><br><span class="line">putstatic	i	//将修改后的值存入静态变量i</span><br></pre></td></tr></table></figure>

<p>i–也类似</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">getstatic	i	//准备静态变量i的值</span><br><span class="line">iconst_1		//准备常量1</span><br><span class="line">isub			//自减</span><br><span class="line">putstatic	i	//将修改后的值存入静态变量i</span><br></pre></td></tr></table></figure>

<p>java的内存模型如下，完成静态变量的自增，自减需要在主存和工作内存中进行数据交换：</p>
<p><img src="G:/Blog/source/images/img52.PNG" alt="img52"></p>
<p>如果是单线程以上8行代码是顺序执行（不会交错）没有问题：</p>
<p><img src="G:/Blog/source/images/img53.PNG" alt="img53"></p>
<p>但是多线程下这8行代码可能交错运行：</p>
<p>出现负数的情况：</p>
<p><img src="G:/Blog/source/images/img54.PNG" alt="img54"></p>
<p>出现正数的情况：</p>
<p><img src="G:/Blog/source/images/img55.PNG" alt="img55"></p>
<h5 id="临界区（Critical-Section）"><a href="#临界区（Critical-Section）" class="headerlink" title="临界区（Critical Section）"></a>临界区（Critical Section）</h5><ul>
<li>一个程序运行多个线程本身是没有问题的</li>
<li>问题出在多个线程访问共享资源<ul>
<li>多个线程共享资源其实也没有问题</li>
<li>在多个线程对共享资源读写操作时发生指令交错，就会出现问题</li>
</ul>
</li>
<li>一段代码块如果存在对共享资源的多线程读写操作，称这段代码块为临界区</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="type">int</span> <span class="variable">counter</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">increment</span><span class="params">()</span></span><br><span class="line"><span class="comment">//临界区</span></span><br><span class="line">&#123;</span><br><span class="line">    counter++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">decrement</span><span class="params">()</span></span><br><span class="line"><span class="comment">//临界区</span></span><br><span class="line">&#123;</span><br><span class="line">    counter--;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="竞态条件（Race-Condition）"><a href="#竞态条件（Race-Condition）" class="headerlink" title="竞态条件（Race Condition）"></a>竞态条件（Race Condition）</h5><p>多个线程在临界区内执行，由于代码的执行序列不同而导致结果无法预测，称之为发生了竞态条件。</p>
<h4 id="synchronized解决方法"><a href="#synchronized解决方法" class="headerlink" title="synchronized解决方法"></a>synchronized解决方法</h4><h5 id="应用之互斥"><a href="#应用之互斥" class="headerlink" title="应用之互斥"></a>应用之互斥</h5><p>为了避免临界区的竞态条件发生，有多种手段可以达到目的。</p>
<ul>
<li>阻塞式的解决方案：synchronized，Lock</li>
<li>非阻塞式的解决方案：原子变量</li>
</ul>
<p>使用synchronized来解决上述问题，即俗称的【对象锁】，它采用互斥的方式让同一时刻至多只有一个线程能持有【对象锁】，其它线程再想获取这个【对象锁】时就会阻塞住。这样就能保证拥有锁的线程可以安全的执行临界区内的代码，不用担心线程上下文切换。</p>
<p>注意：虽然java中互斥和同步都可以采用synchronized关键字来完成，但它们还是有区别的：</p>
<ul>
<li>互斥是保证临界区的竞态条件发生，同一时刻只能有一个线程执行临界区代码</li>
<li>同步是由于线程执行的先后、顺序不同、需要一个线程等待其它线程运行到某个点</li>
</ul>
<p><strong>synchronized语法</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(对象)</span><br><span class="line">&#123;</span><br><span class="line">    临界区</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>解决</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="type">int</span> <span class="variable">counter</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">room</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException&#123;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; <span class="number">5000</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span>(room)&#123;</span><br><span class="line">                counter++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,<span class="string">&quot;t1&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; <span class="number">5000</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span>(room)&#123;</span><br><span class="line">                counter--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,<span class="string">&quot;t2&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    t1.start();</span><br><span class="line">    t2.start();</span><br><span class="line">    t1.join();</span><br><span class="line">    t2.join();</span><br><span class="line">    log.debug(<span class="string">&quot;&#123;&#125;&quot;</span>,counter);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>理解：</p>
<ul>
<li>synchronized中的对象，可以想象为一个房间（room），有唯一入口（门）房间只能一次进入一人进行计算，线程t1，t2想象成两个人。</li>
<li>当线程t1执行到synchronized（room）时就好比t1进入了这个房间，并锁住了门拿走了钥匙，在门内执行count++代码。</li>
<li>这时候如果t2也运行到了synchronized（room）时，它发现门被锁住了，只能在门外等待，发生了上下文切换，阻塞住了。</li>
<li>这中间即使t1的cpu时间片不幸用完，被踢出了门外（不要错误理解为锁住了对象就能一直执行下去），这时门还是锁住的，t1仍拿着钥匙，t2线程还在阻塞状态进不来，只有下次轮到t1自己再次获得时间片时才能开门进入。</li>
<li>当t1执行完synchronized块内的代码，这时候才会从obj房间出来并解开门上的锁，唤醒t2线程把钥匙给他。t2线程这时才可以进入obj房间，锁住了门拿上钥匙，执行它的count–代码。</li>
</ul>
<p>synchronized实际是用对象锁保证了临界区内代码的原子性，临界区内的代码对外是不可分割的，不会被线程切换所打断。</p>
<h5 id="面向对象改进"><a href="#面向对象改进" class="headerlink" title="面向对象改进"></a>面向对象改进</h5><p>把需要保护的共享变量放入一个类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException&#123;</span><br><span class="line">    <span class="type">Room</span> <span class="variable">room</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Room</span>();</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; <span class="number">5000</span>;i++)&#123;</span><br><span class="line">           room.increment();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,<span class="string">&quot;t1&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; <span class="number">5000</span>;i++)&#123;</span><br><span class="line">            room.decrement();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,<span class="string">&quot;t2&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    t1.start();</span><br><span class="line">    t2.start();</span><br><span class="line">    t1.join();</span><br><span class="line">    t2.join();</span><br><span class="line">    log.debug(<span class="string">&quot;&#123;&#125;&quot;</span>,room.getValue());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Room</span>&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">increment</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span>(<span class="built_in">this</span>)&#123;</span><br><span class="line">            value++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">decrement</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span>(<span class="built_in">this</span>)&#123;</span><br><span class="line">            value--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getValue</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span>(<span class="built_in">this</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> value;															</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="方法上的synchronized"><a href="#方法上的synchronized" class="headerlink" title="方法上的synchronized"></a>方法上的synchronized</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//等价于</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span>(<span class="built_in">this</span>)&#123;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//等价于</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span>(Test.class)&#123;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="不加synchronized的方法"><a href="#不加synchronized的方法" class="headerlink" title="不加synchronized的方法"></a>不加synchronized的方法</h5><p>不加synchronized的方法就好比不遵守规则的人，不去老实排队。</p>
<h5 id="所谓的“线程八锁”"><a href="#所谓的“线程八锁”" class="headerlink" title="所谓的“线程八锁”"></a>所谓的“线程八锁”</h5><p>其实就是考察synchronized锁住的是哪个对象</p>
<p>情况1：12或21</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Number</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">a</span><span class="params">()</span>&#123;</span><br><span class="line">        log.debug(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">b</span><span class="params">()</span>&#123;</span><br><span class="line">        log.debug(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">    <span class="type">Number</span> <span class="variable">n1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Number</span>();</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">        n1.a();</span><br><span class="line">    &#125;).start();</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">        n1.b();</span><br><span class="line">    &#125;).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>情况2：一秒后，12或者2，一秒后1</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Number</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">a</span><span class="params">()</span>&#123;</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">        log.debug(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">b</span><span class="params">()</span>&#123;</span><br><span class="line">        log.debug(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">    <span class="type">Number</span> <span class="variable">n1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Number</span>();</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">        n1.a();</span><br><span class="line">    &#125;).start();</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">        n1.b();</span><br><span class="line">    &#125;).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>情况3：&#x2F;&#x2F;3 1秒后 12 或者 &#x2F;&#x2F;23 1秒后 1或者&#x2F;&#x2F;32 1秒后1</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Number</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">a</span><span class="params">()</span>&#123;</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">        log.debug(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">b</span><span class="params">()</span>&#123;</span><br><span class="line">        log.debug(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">c</span><span class="params">()</span>&#123;</span><br><span class="line">        log.debug(<span class="string">&quot;3&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">    <span class="type">Number</span> <span class="variable">n1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Number</span>();</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">        n1.a();</span><br><span class="line">    &#125;).start();</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">        n1.b();</span><br><span class="line">    &#125;).start();</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">        n1.c();</span><br><span class="line">    &#125;).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>情况4:2 -（1秒后）-1</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Number</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">a</span><span class="params">()</span>&#123;</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">        log.debug(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">b</span><span class="params">()</span>&#123;</span><br><span class="line">        log.debug(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">    <span class="type">Number</span> <span class="variable">n1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Number</span>()；</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">        n1.a();</span><br><span class="line">    &#125;).start();</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">        n1.b();</span><br><span class="line">    &#125;).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>情况5：2 -（1秒后）-1</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Number&#123;</span><br><span class="line">    public static synchronized void a()&#123;</span><br><span class="line">        sleep(1);</span><br><span class="line">        log.debug(&quot;1&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    public synchronized void b()&#123;</span><br><span class="line">        log.debug(&quot;2&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public static void main(String[] args)&#123;</span><br><span class="line">    Number n1 = new Number();</span><br><span class="line">    new Thread(()-&gt;&#123;</span><br><span class="line">        n1.a();</span><br><span class="line">    &#125;).start();</span><br><span class="line">    new Thread(()-&gt;&#123;</span><br><span class="line">        n1.b();</span><br><span class="line">    &#125;).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>情况6：1s后-12，或者2-1秒后-1</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Number</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">a</span><span class="params">()</span>&#123;</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">        log.debug(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">b</span><span class="params">()</span>&#123;</span><br><span class="line">        log.debug(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">    <span class="type">Number</span> <span class="variable">n1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Number</span>();</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">        n1.a();</span><br><span class="line">    &#125;).start();</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">        n1.b();</span><br><span class="line">    &#125;).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>情况7：2 -（1秒后）-1</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Number</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">a</span><span class="params">()</span>&#123;</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">        log.debug(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">b</span><span class="params">()</span>&#123;</span><br><span class="line">        log.debug(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">    <span class="type">Number</span> <span class="variable">n1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Number</span>();</span><br><span class="line">    <span class="type">Number</span> <span class="variable">n2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Number</span>();</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">        n1.a();</span><br><span class="line">    &#125;).start();</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">        n2.b();</span><br><span class="line">    &#125;).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>情况8：1s后-12，或者2-1秒后-1</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Number</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">a</span><span class="params">()</span>&#123;</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">        log.debug(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">b</span><span class="params">()</span>&#123;</span><br><span class="line">        log.debug(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">    <span class="type">Number</span> <span class="variable">n1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Number</span>();</span><br><span class="line">    <span class="type">Number</span> <span class="variable">n2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Number</span>();</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">        n1.a();</span><br><span class="line">    &#125;).start();</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">        n2.b();</span><br><span class="line">    &#125;).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="变量的线程安全分析"><a href="#变量的线程安全分析" class="headerlink" title="变量的线程安全分析"></a>变量的线程安全分析</h4><h5 id="成员变量和静态变量是否线程安全？"><a href="#成员变量和静态变量是否线程安全？" class="headerlink" title="成员变量和静态变量是否线程安全？"></a>成员变量和静态变量是否线程安全？</h5><ul>
<li>如果它们没有共享，则线程安全</li>
<li>如果它们被共享了，根据它们的状态是否能够改变，又分为两种情况<ul>
<li>如果只有读操作，则线程安全</li>
<li>如果有读写操作，则这段代码是临界区，需要考虑线程安全</li>
</ul>
</li>
</ul>
<h5 id="局部变量是否线程安全？"><a href="#局部变量是否线程安全？" class="headerlink" title="局部变量是否线程安全？"></a>局部变量是否线程安全？</h5><ul>
<li>局部变量是线程安全的</li>
<li>但局部变量引用的对象则未必<ul>
<li>如果该对象没有逃离方法的作用访问，它是线程安全的</li>
<li>如果该对象逃离方法的作用范围，需要考虑线程安全</li>
</ul>
</li>
</ul>
<h5 id="局部变量线程安全分析"><a href="#局部变量线程安全分析" class="headerlink" title="局部变量线程安全分析"></a>局部变量线程安全分析</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    i++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>每个线程调用test1()方法时局部变量i，会在每个线程的栈帧内存中被创建多份，因此不存在共享。</p>
<p><img src="G:/Blog/source/images/img56.PNG" alt="img56"></p>
<p><img src="G:/Blog/source/images/img57.PNG" alt="img57"></p>
<p>局部变量的引用稍有不同</p>
<p>成员变量的例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ThreadUnsafe</span>&#123;</span><br><span class="line">    ArrayList&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method1</span><span class="params">(<span class="type">int</span> loopNumber)</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; loopNumber;i++)&#123;</span><br><span class="line">            <span class="comment">//&#123;临界区，会产生竞态条件</span></span><br><span class="line">            method2();</span><br><span class="line">            method3();</span><br><span class="line">        <span class="comment">//&#125;临界区</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">method2</span><span class="params">()</span>&#123;</span><br><span class="line">        list.add(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">method3</span><span class="params">()</span>&#123;</span><br><span class="line">        list.remove(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">THREAD_NUMBER</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">LOOP_NUMBER</span> <span class="operator">=</span> <span class="number">200</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">ThreadUnsafe</span> <span class="variable">test</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadUnsafe</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; THREAD_NUMBER;i++)&#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">                test.method1(LOOP_NUMBER);</span><br><span class="line">            &#125;,<span class="string">&quot;Thread&quot;</span>+(i+<span class="number">1</span>)).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中一种情况是，如果线程2还未add，线程 1 remove就会报错：java.lang.IndexOutOfBoundsException</p>
<p>分析：</p>
<ul>
<li>无论哪个线程中的method2引用的都是同一个对象中的成员变量</li>
<li>method3与method2分析相同</li>
</ul>
<p><img src="G:/Blog/source/images/img58.PNG" alt="img58"></p>
<p>将list修改为局部变量</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ThreadSafe</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method1</span><span class="params">(<span class="type">int</span> loopNumber)</span>&#123;</span><br><span class="line">        ArrayList&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; loopNumber;i++)&#123;</span><br><span class="line">            <span class="comment">//&#123;临界区，会产生竞态条件</span></span><br><span class="line">            method2(list);</span><br><span class="line">            method3(list);</span><br><span class="line">        <span class="comment">//&#125;临界区</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">method2</span><span class="params">()</span>&#123;</span><br><span class="line">        list.add(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">method3</span><span class="params">()</span>&#123;</span><br><span class="line">        list.remove(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">THREAD_NUMBER</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">LOOP_NUMBER</span> <span class="operator">=</span> <span class="number">200</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">ThreadUnsafe</span> <span class="variable">test</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadUnsafe</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; THREAD_NUMBER;i++)&#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">                test.method1(LOOP_NUMBER);</span><br><span class="line">            &#125;,<span class="string">&quot;Thread&quot;</span>+(i+<span class="number">1</span>)).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>修改为局部变量就不会出现上述问题</p>
<p>分析：</p>
<ul>
<li>list是局部变量，每个线程调用时会创建其不同实例，没有共享</li>
<li>而method2的参数是从method1中传过来的，与method1中引用同一个对象</li>
<li>method3的参数分析与method2相同</li>
</ul>
<p><img src="G:/Blog/source/images/img59.PNG" alt="img59"></p>
<p>方法访问修饰符带来的思考，如果把method2和method3的方法修改为public会不会带来线程安全问题？</p>
<ul>
<li>情况1：有其它线程调用method2和method3</li>
<li>情况2：在情况1的基础上，为ThreadSafe类添加子类，子类覆盖method2或method3方法，即</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ThreadSafe</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">method1</span><span class="params">(<span class="type">int</span> loopNumber)</span>&#123;</span><br><span class="line">        ArrayList&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; loopNumber;i++)&#123;</span><br><span class="line">            <span class="comment">//&#123;临界区，会产生竞态条件</span></span><br><span class="line">            method2(list);</span><br><span class="line">            method3(list);</span><br><span class="line">        <span class="comment">//&#125;临界区</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">method2</span><span class="params">(ArrayList&lt;String&gt; list)</span>&#123;</span><br><span class="line">        list.add(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">method3</span><span class="params">(ArrayList&lt;String&gt; list)</span>&#123;</span><br><span class="line">        list.remove(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ThreadSafeSubClass</span> <span class="keyword">extends</span> <span class="title class_">ThreadSafe</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method3</span><span class="params">(ArrayList&lt;String&gt; list)</span>&#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            list.remove(<span class="number">0</span>);</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="常见线程安全类"><a href="#常见线程安全类" class="headerlink" title="常见线程安全类"></a>常见线程安全类</h5><ul>
<li>String</li>
<li>Integer</li>
<li>StringBuffer</li>
<li>Random</li>
<li>Vector</li>
<li>Hashtable</li>
<li>java.util.concurrent包下的类</li>
</ul>
<p>这里说它们是线程安全指的是，多个线程调用它们同一个实例的某个方法时，是线程安全的，也可以理解为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Hashtable</span> <span class="variable">table</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Hashtable</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">    table.put(<span class="string">&quot;key&quot;</span>,<span class="string">&quot;value1&quot;</span>);</span><br><span class="line">&#125;).start();</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">    table.put(<span class="string">&quot;key&quot;</span>,<span class="string">&quot;value2&quot;</span>);</span><br><span class="line">&#125;).start();</span><br></pre></td></tr></table></figure>

<ul>
<li>它们的每个方法是原子的</li>
<li>但注意它们多个方法的组合不是原子的。</li>
</ul>
<h6 id="线程安全类方法的组合"><a href="#线程安全类方法的组合" class="headerlink" title="线程安全类方法的组合"></a>线程安全类方法的组合</h6><p>分析下面代码是否安全？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Hashtable</span> <span class="variable">table</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Hashtable</span>();</span><br><span class="line"><span class="comment">//线程1，线程2</span></span><br><span class="line"><span class="keyword">if</span>(table.get(<span class="string">&quot;key&quot;</span>) == <span class="literal">null</span>)&#123;</span><br><span class="line">    table.put(<span class="string">&quot;key&quot;</span>,value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="G:/Blog/source/images/img60.PNG" alt="img60"></p>
<h6 id="不可变类线程安全性"><a href="#不可变类线程安全性" class="headerlink" title="不可变类线程安全性"></a>不可变类线程安全性</h6><p>String、Integer等都是不可变类，因为其内部的状态不可以改变，因此它们的方法是线程安全的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Immutable</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Immutable</span><span class="params">(<span class="type">int</span> value)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getValue</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="实例分析"><a href="#实例分析" class="headerlink" title="实例分析"></a>实例分析</h5><p>例1：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">publc <span class="keyword">class</span> <span class="title class_">MyServlet</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span>&#123;</span><br><span class="line">    <span class="comment">//是否线程安全？</span></span><br><span class="line">    Map&lt;String,Object&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">//是否线程安全？</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;...&quot;</span>;</span><br><span class="line">    <span class="comment">//是否线程安全？	</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;...&quot;</span>;</span><br><span class="line">    <span class="comment">//是否线程安全？</span></span><br><span class="line">    <span class="type">Date</span> <span class="variable">d1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">    <span class="comment">//是否线程安全？</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">Date</span> <span class="variable">d2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest request，HttpServletResponse response)</span>&#123;</span><br><span class="line">        <span class="comment">//使用上述变量</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>例2：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyServlet</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span>&#123;</span><br><span class="line">    <span class="comment">//是否线程安全</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">UserService</span> <span class="variable">userService</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserServiceImpl</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest request,HttpServletResponse response)</span>&#123;</span><br><span class="line">        userService.update(...);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">UserService</span>&#123;</span><br><span class="line">    <span class="comment">//记录调用次数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>例3：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyAspect</span>&#123;</span><br><span class="line">    <span class="comment">//是否线程安全</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> <span class="number">0L</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Before(&quot;execution(* *(..))&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">before</span><span class="params">()</span>&#123;</span><br><span class="line">        start = System.nanoTime();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@After(&quot;execution(* *(..))&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">after</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.nanoTime();</span><br><span class="line">        System.out.println(<span class="string">&quot;cost time:&quot;</span> + (end-start));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>例4：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyServlet</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span>&#123;</span><br><span class="line">    <span class="comment">//是否线程安全</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">UserService</span> <span class="variable">userService</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserServiceImpl</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest request,HttpServletResponse response)</span>&#123;</span><br><span class="line">        userService.update(...);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">UserService</span>&#123;</span><br><span class="line">    <span class="comment">//是否安全</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">UserDao</span> <span class="variable">userDao</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserDaoImpl</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">        userDao.update();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserDaoImpl</span> <span class="keyword">implements</span> <span class="title class_">UserDao</span>&#123;</span><br><span class="line">    publci <span class="keyword">void</span> <span class="title function_">update</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;update user set password = ? where username = ?&quot;</span>;</span><br><span class="line">        <span class="comment">//是否安全</span></span><br><span class="line">        <span class="keyword">try</span>(<span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> DriverManager.getConnection(<span class="string">&quot;&quot;</span>,<span class="string">&quot;&quot;</span>,<span class="string">&quot;&quot;</span>))&#123;</span><br><span class="line">            <span class="comment">//...</span></span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">            <span class="comment">//...</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>例5：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyServlet</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span>&#123;</span><br><span class="line">    <span class="comment">//是否线程安全</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">UserService</span> <span class="variable">userService</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserServiceImpl</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest request,HttpServletResponse response)</span>&#123;</span><br><span class="line">        userService.update(...);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">UserService</span>&#123;</span><br><span class="line">    <span class="comment">//是否安全</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">UserDao</span> <span class="variable">userDao</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserDaoImpl</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">        userDao.update();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserDaoImpl</span> <span class="keyword">implements</span> <span class="title class_">UserDao</span>&#123;</span><br><span class="line">    <span class="comment">//是否线程安全</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    publci <span class="keyword">void</span> <span class="title function_">update</span><span class="params">()</span><span class="keyword">throws</span> SQLException&#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;update user set password = ? where username = ?&quot;</span>;</span><br><span class="line">        conn = DriverManager.getConnection(<span class="string">&quot;&quot;</span>,<span class="string">&quot;&quot;</span>,<span class="string">&quot;&quot;</span>);</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">        conn.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>例6：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyServlet</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span>&#123;</span><br><span class="line">    <span class="comment">//是否线程安全</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">UserService</span> <span class="variable">userService</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserServiceImpl</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest request,HttpServletResponse response)</span>&#123;</span><br><span class="line">        userService.update(...);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">UserService</span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">        <span class="type">UserDao</span> <span class="variable">userDao</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserDaoImpl</span>();</span><br><span class="line">        userDao.update();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserDaoImpl</span> <span class="keyword">implements</span> <span class="title class_">UserDao</span>&#123;</span><br><span class="line">    <span class="comment">//是否线程安全</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    publci <span class="keyword">void</span> <span class="title function_">update</span><span class="params">()</span><span class="keyword">throws</span> SQLException&#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;update user set password = ? where username = ?&quot;</span>;</span><br><span class="line">        conn = DriverManager.getConnection(<span class="string">&quot;&quot;</span>,<span class="string">&quot;&quot;</span>,<span class="string">&quot;&quot;</span>);</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">        conn.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>例7：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">bar</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">SimpleDateFormate</span> <span class="variable">sdf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormate</span>(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);</span><br><span class="line">        foo(sdf);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="title function_">foo</span><span class="params">(SimpleDateFormate sdf)</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Test</span>().bar();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Monitor概念"><a href="#Monitor概念" class="headerlink" title="Monitor概念"></a>Monitor概念</h4><h5 id="Java对象头"><a href="#Java对象头" class="headerlink" title="Java对象头"></a>Java对象头</h5><p>以32位虚拟机为例</p>
<p>普通对象</p>
<p><img src="G:/Blog/source/images/img61.PNG" alt="img61"></p>
<p>数组对象</p>
<p><img src="G:/Blog/source/images/img62.PNG" alt="img62"></p>
<p>其中Mark World结构为</p>
<p><img src="G:/Blog/source/images/img64.PNG" alt="img64"></p>
<h5 id="Monitor（锁）"><a href="#Monitor（锁）" class="headerlink" title="Monitor（锁）"></a>Monitor（锁）</h5><p>Monitor被翻译为监视器或管程</p>
<p>每个java对象都可以关联一个Monitor对象，如果使用synchronized给对象锁（重量级）之后，该对象头的Mark Word中就被设置指向Monitor对象的指针。</p>
<p>Monitor结构如下：</p>
<p><img src="G:/Blog/source/images/img63.PNG" alt="img63"></p>
<ul>
<li>刚开始Monitor中Owner为null</li>
<li>当Thread-2执行synchronized（obj）就会将Monitor的所有者Owner置为Thread-2，Monitor中只能有一个Owner。</li>
<li>在Thread-2上锁过程中，如果Thread-3，Thread-4,Thread-5也来执行synchronized(obj)，就会进入EntryList BLOCKED.</li>
<li>Thread-2执行完同步代码块的内容，然后唤醒EntryList中等待的线程来竞争锁，竞争时是非公平的。</li>
<li>图中WaitSet中的Thread-0，Thread-1是之前获得过锁，但条件不满足进入WAITING状态的线程，后面讲wait-notify分析</li>
</ul>
<p>注意：</p>
<ul>
<li>synchronized必须是进入同一对象的monitor才有上述的效果</li>
<li>不加synchronized的对象不会关联监听器，不遵从以上规则。</li>
</ul>
<h5 id="synchronized原理进阶"><a href="#synchronized原理进阶" class="headerlink" title="synchronized原理进阶"></a>synchronized原理进阶</h5><h6 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h6><p>轻量级锁的使用场景：如果一个对象虽然有多线程访问，但多线程访问的时间是错开的（也就是没有竞争），那么可以使用轻量级锁来优化。</p>
<p>轻量级锁对使用者是透明的，即语法仍是synchronized</p>
<p>假设有两个方法同步块，利用同一对象加锁</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method1</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(obj)&#123;</span><br><span class="line">        <span class="comment">//同步块A</span></span><br><span class="line">        method2();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method2</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(obj)&#123;</span><br><span class="line">        <span class="comment">//同步块B</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>创建锁记录对象，每个线程的栈帧都会包含一个锁记录的结构，内部可以存储锁定对象的Mark Word。</li>
</ul>
<p><img src="G:/Blog/source/images/img65.PNG" alt="img65"></p>
<ul>
<li>让锁记录中Object Reference指向锁对象，并尝试用cas替换Object的Mark Word，将Mark Word的值存入锁记录。</li>
</ul>
<p><img src="G:/Blog/source/images/img66.PNG" alt="img66"></p>
<ul>
<li>如果cas替换成功，对象头中存储了锁记录地址和状态00，表示由该线程给对象加锁，这时图示如下：</li>
</ul>
<p><img src="G:/Blog/source/images/img67.PNG" alt="img67"></p>
<ul>
<li>如果cas失败，有两种情况<ul>
<li>如果其它线程已经持有了该Object的轻量级锁，这时表明有竞争，进入锁膨胀过程</li>
<li>如果是自己执行了synchronized锁重入，那么再添加一条Lock Record作为重入的计数</li>
</ul>
</li>
</ul>
<p><img src="G:/Blog/source/images/img68.PNG" alt="img68"></p>
<ul>
<li>当退出synchronized代码块（解锁时）如果有取值为null的锁新纪录，表示有重入，这时重置锁记录，表示重入计数减一。</li>
</ul>
<p><img src="G:/Blog/source/images/img69.PNG" alt="img69"></p>
<ul>
<li>当退出synchronized代码块（解锁时）锁记录的值不为null，这时使用cas将Mark Word的值恢复给对象头<ul>
<li>成功，则解锁成功</li>
<li>失败，说明轻量级锁进行了锁膨胀或已经升级为重量级锁，进入重量级锁解锁流程</li>
</ul>
</li>
</ul>
<h6 id="锁膨胀"><a href="#锁膨胀" class="headerlink" title="锁膨胀"></a>锁膨胀</h6><p>如果在尝试加轻量级锁的过程中，CAS操作无法成功，这时一种情况就是有其它线程为此对象加上了轻量级锁（有竞争），这时需要进行锁膨胀，将轻量级锁变为重量级锁。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method1</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(obj)&#123;</span><br><span class="line">        <span class="comment">//同步块</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>当Thread-1进行轻量级加锁时，Thread-0已经对该对象加了轻量级锁</li>
</ul>
<p><img src="G:/Blog/source/images/img70.PNG" alt="img70"></p>
<ul>
<li><p>这时Thread-1加轻量级锁失败，进入锁膨胀流程</p>
<ul>
<li>即为Object对象申请Monitor锁，让Object指向重量级锁地址</li>
<li>然后自己进入Monitor的EntryList Blocked</li>
</ul>
<p><img src="G:/Blog/source/images/img71.PNG" alt="img71"></p>
</li>
<li><p>当Thread-0退出同步块解锁时，使用cas将Mark Word的值恢复给对象头，失败。这时会进入重量级解锁流程，即按照Monitor地址找到Monitor对象，设置Owner为null，唤醒EntryList中Blocked线程。</p>
</li>
</ul>
<h6 id="自旋优化"><a href="#自旋优化" class="headerlink" title="自旋优化"></a>自旋优化</h6><p>重量级锁竞争时，还可以使用自旋来进行优化，如果当前线程自旋成功（即这个时候持锁线程已经退出了同步块，释放了锁），这时当前线程就可以避免阻塞。</p>
<p>自旋重试成功的情况：</p>
<p><img src="G:/Blog/source/images/img72.PNG" alt="img72"></p>
<p>自旋重试失败的情况：</p>
<p><img src="G:/Blog/source/images/img73.PNG" alt="img73"></p>
<ul>
<li>在java6之后自旋锁是自适应的，比如对象刚刚的一次自旋操作成功过，那么认为自旋成功的可能性会高，就多自旋几次；反之，就少自旋甚至不自旋。</li>
<li>自旋会占用CPU时间，单核CPU自旋就是浪费时间，多核CPU自旋才能发挥优势。</li>
<li>Java7之后不能控制是否开启自旋功能。</li>
</ul>
<h6 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h6><p>轻量级锁在没有竞争时（就自己这个进程），每次重入仍然需要执行CAS操作。</p>
<p>Java6中引入了偏向锁来做进一步优化：只有第一次使用CAS将线程ID设置到对象的Mark Word头，之后发现这个线程ID是自己的就表示没有竞争，不用重新CAS。以后只要不发生竞争，这个对象就归该线程所有。</p>
<p>例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">m1</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(obj)&#123;</span><br><span class="line">        <span class="comment">//同步块A</span></span><br><span class="line">        m2();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">m2</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(obj)&#123;</span><br><span class="line">        <span class="comment">//同步块B</span></span><br><span class="line">        m3();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">m3</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(obj)&#123;</span><br><span class="line">        <span class="comment">//同步块C</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>偏向状态</p>
<p><img src="G:/Blog/source/images/img74.PNG" alt="img74"></p>
<p>一个对象创建时：</p>
<ul>
<li>如果开启了偏向锁（默认开启），那么对象创建后，markword值为0x05即最后3位为101，这时它的thread，epoch，age都为0。</li>
<li>偏向锁是默认延迟的，不会再程序启动时立即生效，如果想避免延迟，可以加VM参数：-XX：BaisedLockingStarupDelay&#x3D;0来禁用延迟。</li>
<li>如果没有开启偏向锁，那么对象创建后，markword值为0x01即最后3位为001，这时hashcode、age都为0，第一次用到hashcode时才会赋值。</li>
</ul>
<h4 id="wait-x2F-notify"><a href="#wait-x2F-notify" class="headerlink" title="wait&#x2F;notify"></a>wait&#x2F;notify</h4><h5 id="原理之wait-x2F-notify"><a href="#原理之wait-x2F-notify" class="headerlink" title="原理之wait&#x2F;notify"></a>原理之wait&#x2F;notify</h5><p><img src="G:/Blog/source/images/img75.PNG" alt="img75"></p>
<ul>
<li>Owner线程发现条件不足，调用wait方法，即可进入WaitSet变为WAITING状态</li>
<li>BLOCKED和WAITING的线程都处于阻塞状态，不占用CPU时间片</li>
<li>BLOCKED线程会在Owner线程释放锁时唤醒</li>
<li>WAITING线程会在Owner线程调用notify或notifyAll时唤醒，但唤醒后并不意味着立刻获得锁，仍需进入EntryList重新竞争</li>
</ul>
<h5 id="API介绍"><a href="#API介绍" class="headerlink" title="API介绍"></a>API介绍</h5><ul>
<li>obj.wait()让进入object监视器的线程到waitSet等待</li>
<li>obj.notify()在object上正在waitSet等待的线程中挑一个唤醒</li>
<li>obj.notifyAll()让object上正在waitSet等待的线程全部唤醒</li>
</ul>
<p>它们都是线程之间进行协作的手段，都属于Object对象的方法。必须获得此对象的锁，才能调用这几个方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span>(lock)&#123;</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                lock.wait();</span><br><span class="line">            &#125;<span class="keyword">catch</span>(InterruptedException)&#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">        <span class="keyword">synchronized</span>(obj)&#123;</span><br><span class="line">            log.debug(<span class="string">&quot;执行.....&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                obj.wait();<span class="comment">//让线程在obj上一直等待下去</span></span><br><span class="line">            &#125;<span class="keyword">catch</span>(InterruptedException e)&#123;</span><br><span class="line">                e.prinStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            log.debug(<span class="string">&quot;其它代码....&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,<span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">        <span class="keyword">synchronized</span>(obj)&#123;</span><br><span class="line">            log.debug(<span class="string">&quot;执行.....&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                obj.wait();<span class="comment">//让线程在obj上一直等待下去</span></span><br><span class="line">            &#125;<span class="keyword">catch</span>(InterruptedException e)&#123;</span><br><span class="line">                e.prinStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            log.debug(<span class="string">&quot;其它代码....&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,<span class="string">&quot;t2&quot;</span>).start();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//主线程2秒后执行</span></span><br><span class="line">    sleep(<span class="number">2</span>);</span><br><span class="line">    log.debug(<span class="string">&quot;唤醒obj上其它线程&quot;</span>);</span><br><span class="line">    <span class="keyword">synchronized</span>(obj)&#123;</span><br><span class="line">        obj.notify();<span class="comment">//唤醒obj上一个线程</span></span><br><span class="line">        obj.notifyAll();<span class="comment">//唤醒obj上所有等待线程</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="wait-x2F-notify的正确姿势"><a href="#wait-x2F-notify的正确姿势" class="headerlink" title="wait&#x2F;notify的正确姿势"></a>wait&#x2F;notify的正确姿势</h5><h5 id="sleep（long-n）和wait（long-n）的区别"><a href="#sleep（long-n）和wait（long-n）的区别" class="headerlink" title="sleep（long n）和wait（long n）的区别"></a>sleep（long n）和wait（long n）的区别</h5><ul>
<li>sleep是Thread方法，而wait是Object方法</li>
<li>sleep不需要强制和synchronized配合使用，但wait需要和synchronized一起用</li>
<li>sleep在睡眠的同时，不会释放对象锁的，但wait在等待的时候会释放对象锁</li>
<li>它们状态TIMED_WAITING</li>
</ul>
<h5 id="step1"><a href="#step1" class="headerlink" title="step1"></a>step1</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">room</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"><span class="keyword">static</span> <span class="type">boolean</span> <span class="variable">hasCigarette</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="type">boolean</span> <span class="variable">hasTakeOut</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(room)&#123;</span><br><span class="line">        log.debug(<span class="string">&quot;有烟没？[&#123;&#125;]&quot;</span>,hasCigarette);</span><br><span class="line">        <span class="keyword">if</span>(!hasCigarette)&#123;</span><br><span class="line">            log.debug(<span class="string">&quot;没烟,先歇会！&quot;</span>);</span><br><span class="line">            sleep(<span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        log.debug(<span class="string">&quot;有烟没？[&#123;&#125;]&quot;</span>,hasCigarette);</span><br><span class="line">        <span class="keyword">if</span>(hasCigarette)&#123;</span><br><span class="line">            log.debug(<span class="string">&quot;可以开始干活了！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,<span class="string">&quot;小南&quot;</span>).start();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; <span class="number">5</span>;i++)&#123;</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">        <span class="keyword">synchronized</span>(room)&#123;</span><br><span class="line">            log.debug(<span class="string">&quot;可以开始干活了！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,<span class="string">&quot;其它人&quot;</span>).start();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sleep(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">    hasCigarette = <span class="literal">true</span>;</span><br><span class="line">    log.debug(<span class="string">&quot;烟到了哦！&quot;</span>);</span><br><span class="line">&#125;,<span class="string">&quot;送烟的&quot;</span>).start();</span><br></pre></td></tr></table></figure>

<p>缺点：</p>
<ul>
<li>其它干活的线程，都要一直阻塞，效率太低</li>
<li>小南线程必须睡足2s后才能醒来，就算烟提前送到，也无法立刻醒来</li>
<li>加了synchronized（room）后，就好比小南在里面反锁了门睡觉，烟根本没法送进门，main没加synchronized就好像main线程里翻窗户进来的</li>
<li>解决方法，使用wait-notify机制</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(room)&#123;</span><br><span class="line">        log.debug(<span class="string">&quot;有烟没？[&#123;&#125;]&quot;</span>,hasCigarette);</span><br><span class="line">        <span class="keyword">if</span>(!hasCigarette)&#123;</span><br><span class="line">            log.debug(<span class="string">&quot;没烟,先歇会！&quot;</span>);</span><br><span class="line">            <span class="comment">//sleep(2);</span></span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                room.wait();</span><br><span class="line">            &#125;<span class="keyword">catch</span>(InterruptedException e)&#123;</span><br><span class="line">                e.prinStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        log.debug(<span class="string">&quot;有烟没？[&#123;&#125;]&quot;</span>,hasCigarette);</span><br><span class="line">        <span class="keyword">if</span>(hasCigarette)&#123;</span><br><span class="line">            log.debug(<span class="string">&quot;可以开始干活了！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,<span class="string">&quot;小南&quot;</span>).start();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; <span class="number">5</span>;i++)&#123;</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">        <span class="keyword">synchronized</span>(room)&#123;</span><br><span class="line">            log.debug(<span class="string">&quot;可以开始干活了！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,<span class="string">&quot;其它人&quot;</span>).start();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sleep(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">    hasCigarette = <span class="literal">true</span>;</span><br><span class="line">    log.debug(<span class="string">&quot;烟到了哦！&quot;</span>);</span><br><span class="line">    room.notify();</span><br><span class="line">&#125;,<span class="string">&quot;送烟的&quot;</span>).start();</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(lock)&#123;</span><br><span class="line">    <span class="keyword">while</span>(条件不成立)&#123;</span><br><span class="line">        lock.wait();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//干活</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//另一个线程</span></span><br><span class="line"><span class="keyword">synchronized</span>(lock)&#123;</span><br><span class="line">    lock.notifyAll();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="同步模式之保护性暂停"><a href="#同步模式之保护性暂停" class="headerlink" title="同步模式之保护性暂停"></a>同步模式之保护性暂停</h4><p>即Guarded Suspension，用在一个线程等待另一个线程的执行结果</p>
<p>要点</p>
<ul>
<li>有一个结果需要从一个线程传递到另一个线程，让他们关联同一个GuardedObject</li>
<li>如果有结果不断从一个线程到另一个线程那么可以使用消息队列</li>
<li>JDK中，join的实现，Future的实现，采用的就是此模式</li>
<li>因为要等待另一方的结果，因此归纳到同步模式</li>
</ul>
<p><img src="G:/Blog/source/images/img76.PNG" alt="img76"></p>
<p>实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">    <span class="comment">//线程1等待线程2的下载结果</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">GuardedObject</span> <span class="variable">guardedObject</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GuardedObject</span>();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            <span class="comment">//等待结果</span></span><br><span class="line">            log.debug(<span class="string">&quot;等待结果&quot;</span>);</span><br><span class="line">            List&lt;String&gt; list = (List&lt;String&gt;)guardedObject.get();</span><br><span class="line">        &#125;,<span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            log.debug(<span class="string">&quot;执行下载&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                List&lt;String&gt;list = DownLoader.download();</span><br><span class="line">                guardedObject.complete(list);</span><br><span class="line">                log.debug(<span class="string">&quot;结果大小：&#123;&#125;&quot;</span>,list.size());</span><br><span class="line">            &#125;<span class="keyword">catch</span>(InterruptedException e)&#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;t2&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GuardedObject</span>&#123;</span><br><span class="line">    <span class="comment">//结果</span></span><br><span class="line">    <span class="keyword">private</span> Object response;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//获取结果</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">get</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span>(<span class="built_in">this</span>)&#123;</span><br><span class="line">            <span class="keyword">while</span>(response == <span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span>&#123;</span><br><span class="line">                    <span class="built_in">this</span>.wait();</span><br><span class="line">                &#125;<span class="keyword">catch</span>(InterruptedException e)&#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> response;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//产生结果</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">complete</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span>(<span class="built_in">this</span>)&#123;</span><br><span class="line">            <span class="built_in">this</span>.response = response;</span><br><span class="line">            <span class="built_in">this</span>.notifyAll();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="join原理"><a href="#join原理" class="headerlink" title="join原理"></a>join原理</h5><p>调用者轮询检查线程 alive 状态。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">t1.join();</span><br><span class="line"><span class="comment">//等价于下面的代码</span></span><br><span class="line"><span class="keyword">synchronized</span> (t1) &#123;</span><br><span class="line">	 <span class="comment">// 调用者线程进入 t1 的 waitSet 等待, 直到 t1 运行结束</span></span><br><span class="line"> 	<span class="keyword">while</span> (t1.isAlive()) &#123;</span><br><span class="line"> 		t1.wait(<span class="number">0</span>);</span><br><span class="line"> 	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="异步模式之生产者-x2F-消费者"><a href="#异步模式之生产者-x2F-消费者" class="headerlink" title="异步模式之生产者&#x2F;消费者"></a>异步模式之生产者&#x2F;消费者</h4><p>要点</p>
<ul>
<li>与前面的保护性暂停中的GuardObject不同，不需要产生结果和消费结果的线程一一对应</li>
<li>消费队列可以用来平衡生产和消费的线程资源</li>
<li>生产者仅仅负责产生结果数据，不关心数据该如何处理，而消费者专心处理结果数据</li>
<li>消息队列是由容量限制的，满时不会再加入数据，空时不会再消耗数据</li>
<li>JDK中各种阻塞队列，采用的就是这种模式</li>
</ul>
<p><img src="G:/Blog/source/images/img77.PNG" alt="img77"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">MessageQueue</span> <span class="variable">queue</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MessageQueue</span>(<span class="number">2</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; <span class="number">3</span>;i++)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">id</span> <span class="operator">=</span> i;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">                queue.put(<span class="keyword">new</span> <span class="title class_">Message</span>(i,<span class="string">&quot;值&quot;</span>+i));</span><br><span class="line">            &#125;,<span class="string">&quot;生产者&quot;</span> + i).start();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">                sleep(<span class="number">1</span>);</span><br><span class="line">                <span class="type">Message</span> <span class="variable">message</span> <span class="operator">=</span> queue.take();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;消费者&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//消息队列,java线程间通信</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MessageQueue</span>&#123;</span><br><span class="line">    <span class="comment">//消息的队列集合</span></span><br><span class="line">    <span class="keyword">private</span> LinkedList&lt;Message&gt; list = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">//队列容量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> capcity;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MessageQueue</span><span class="params">(<span class="type">int</span> capcity)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.capcity = capcity;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//获取消息</span></span><br><span class="line">    <span class="keyword">public</span> Message <span class="title function_">take</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//检查队列是否为空</span></span><br><span class="line">        <span class="keyword">synchronized</span>(list)&#123;</span><br><span class="line">            <span class="keyword">while</span>(list.isEmpty())&#123;</span><br><span class="line">                <span class="keyword">try</span>&#123;</span><br><span class="line">                    log.debug(<span class="string">&quot;队列为空，消费者线程等待&quot;</span>);</span><br><span class="line">                    list.wait();</span><br><span class="line">                &#125;<span class="keyword">catch</span>(InterruptedException e)&#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//从队列的头部获取消息并返回</span></span><br><span class="line">            <span class="type">Message</span> <span class="variable">message</span> <span class="operator">=</span> list.removeFirst();</span><br><span class="line">            log.debug(<span class="string">&quot;已消费消息&#123;&#125;&quot;</span>,message);</span><br><span class="line">            list.notifyAll();</span><br><span class="line">            <span class="keyword">return</span> message;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//存入消息</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(Message message)</span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span>(list)&#123;</span><br><span class="line">            <span class="comment">//检查队列是否已满</span></span><br><span class="line">            <span class="keyword">while</span>(list.size() == capcity)&#123;</span><br><span class="line">                <span class="keyword">try</span>&#123;</span><br><span class="line">                   log.debug(<span class="string">&quot;队列已满，生产者线程等待&quot;</span>);</span><br><span class="line">                   list.wait(); </span><br><span class="line">                &#125;<span class="keyword">catch</span>(InterruptedException e)&#123;</span><br><span class="line">                    e.prinStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//将消息加入队列尾部</span></span><br><span class="line">            list.addLast(message);</span><br><span class="line">            log.debug(<span class="string">&quot;已生产消息&#123;&#125;&quot;</span>,message);</span><br><span class="line">            list.notifyAll();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Message</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> Object value;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Message</span><span class="params">(<span class="type">int</span> id,Object value)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">        <span class="built_in">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getId</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">getValue</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Message&#123;&quot;</span> + </span><br><span class="line">            	<span class="string">&quot;id=&quot;</span> + id +</span><br><span class="line">            	<span class="string">&quot;,value=&quot;</span> + value +</span><br><span class="line">            	<span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="终止模式之两阶段终止模式"><a href="#终止模式之两阶段终止模式" class="headerlink" title="终止模式之两阶段终止模式"></a>终止模式之两阶段终止模式</h4><p>Two Phase Termination</p>
<p>在一个线程T1中如何优雅终止线程T2？这里优雅指的是给T2一个料理后事的机会。</p>
<h5 id="错误思路"><a href="#错误思路" class="headerlink" title="错误思路"></a>错误思路</h5><ul>
<li>使用线程对象的stop()方法停止线程<ul>
<li>stop方法会真正杀死线程，如果这时线程锁住了共享资源，那么当它被杀死后就再也没有机会释放锁，其它线程将永远无法获取锁</li>
</ul>
</li>
<li>使用System.exit(init)方法停止线程<ul>
<li>目的仅是停止一个线程，但这种做法会让整个程序都停止</li>
</ul>
</li>
</ul>
<h4 id="park-amp-upark"><a href="#park-amp-upark" class="headerlink" title="park&amp;upark"></a>park&amp;upark</h4><p>基本使用</p>
<p>它们是LockSupport类中的方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//暂停当前线程</span></span><br><span class="line">LockSupport.park();</span><br><span class="line"><span class="comment">//恢复某个线程的运行</span></span><br><span class="line">LockSupport.unpark(暂停线程对象);</span><br></pre></td></tr></table></figure>

<p>先park再unpark</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">   log.debug(<span class="string">&quot;start...&quot;</span>); </span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line">    log.debug(<span class="string">&quot;park...&quot;</span>);</span><br><span class="line">    LockSupport.park();</span><br><span class="line">    log.debug(<span class="string">&quot;resume...&quot;</span>);</span><br><span class="line">&#125;,<span class="string">&quot;t1&quot;</span>);</span><br><span class="line">t1.start();</span><br><span class="line"></span><br><span class="line">sleep(<span class="number">2</span>);</span><br><span class="line">log.debug(<span class="string">&quot;unpark...&quot;</span>);</span><br><span class="line">LockSupport.unpark(t1);</span><br></pre></td></tr></table></figure>

<p>特点</p>
<p>与Object的wait&amp;notify相比</p>
<ul>
<li>wait，notify和notifyAll必须配合Object Monitor一起使用，而park，unpark不必</li>
<li>park &amp; unpark是以线程为单位来阻塞和唤醒线程，而notify只能随机唤醒一个等待线程，notifyAll是唤醒所有等待线程，就不那么精确</li>
<li>park &amp; unpark可以先unpark，而wait &amp; notify不能先notify</li>
</ul>
<h5 id="原理之park-amp-unpark"><a href="#原理之park-amp-unpark" class="headerlink" title="原理之park &amp; unpark"></a>原理之park &amp; unpark</h5><p>每个线程都有自己的一个Parker对象，由三部分组成_counter,_cond和_mutex打个比喻</p>
<ul>
<li>线程就像一个旅人，Parker就像他随身携带的背包，条件变量就好比背包中的帐篷。_counter就好比背包中的备用干粮（0为耗尽，1为充足）</li>
<li>调用park就是要看需不需要停下来歇息<ul>
<li>如果备用干粮耗尽，那么钻进帐篷歇息</li>
<li>如果备用干粮充足，那么不需要停留，继续前进</li>
</ul>
</li>
<li>调用unpark，就好比令干粮充足<ul>
<li>如果这时线程还在帐篷，就唤醒让他继续前进</li>
<li>如果这时线程还在运行，那么下次他调用park时，仅是消耗备用干粮，不需要停留继续前进</li>
<li>因为背包空间有限，多次调用unpark仅会补充一份备用干粮</li>
</ul>
</li>
</ul>
<p><img src="G:/Blog/source/images/img78.PNG" alt="img78"></p>
<ol>
<li>当线程调用Unsafe.park()方法</li>
<li>检查_counter，本情况为0，这时，获得_mutex互斥锁</li>
<li>线程进入_cond条件变量阻塞</li>
<li>设置_counter &#x3D; 0</li>
</ol>
<p><img src="G:/Blog/source/images/img79.PNG" alt="img79"></p>
<ol>
<li>调用Unsafe.unpark(Thread_0)方法，设置_counter为1</li>
<li>唤醒_cond条件变量中的Thread_0</li>
<li>Thread_0恢复运行</li>
<li>设置_counter为0</li>
</ol>
<p><img src="G:/Blog/source/images/img80.PNG" alt="img80"></p>
<ol>
<li>调用Unsafe.unpark(Thread_0)方法，设置_counter为1</li>
<li>当前线程调用Unsafe.park()方法</li>
<li>检查_counter，本情况为1，这时线程无需阻塞，继续运行</li>
<li>设置_counter为0</li>
</ol>
<h4 id="重新理解线程状态转换"><a href="#重新理解线程状态转换" class="headerlink" title="重新理解线程状态转换"></a>重新理解线程状态转换</h4><p><img src="G:/Blog/source/images/img81.PNG" alt="img81">假设有线程Thread t</p>
<p><strong>情况1：NEW—&gt;RUNNABLE</strong></p>
<ul>
<li>当调用t.start()方法时，由NEW—&gt;RUNNABLE</li>
</ul>
<p><strong>情况2：RUNNABLE&lt;—&gt;WAITING</strong></p>
<p>t线程用synchronized（obj）获取了对象锁后</p>
<ul>
<li>调用obj.wait()方法时，t线程从RUNNABLE—&gt;WAITING</li>
<li>调用obj.notify()，obj.notifyAll()，t.interrupt()时<ul>
<li>竞争锁成功，t线程从WAITING—&gt;RUNNABLE</li>
<li>竞争锁失败，t线程从WAITING—&gt;BLOCKED</li>
</ul>
</li>
</ul>
<p><strong>情况3：RUNNABLE &lt;–&gt; WAITING</strong></p>
<ul>
<li>当前线程调用 t.join () 方法时，当前线程从 RUNNABLE –&gt; WAITING，注意是当前线程在 t 线程对象的监视器上等待。</li>
<li>t 线程运行结束，或调用了当前线程的 interrupt () 时，当前线程从 WAITING –&gt; RUNNABLE。</li>
</ul>
<p><strong>情况4：RUNNABLE &lt;–&gt; WAITING</strong></p>
<ul>
<li>当前线程调用 LockSupport.park () 方法会让当前线程从 RUNNABLE –&gt; WAITING。</li>
<li>调用 LockSupport.unpark (目标线程) 或调用了线程 的 interrupt () ，会让目标线程从 WAITING –&gt; RUNNABLE。</li>
</ul>
<p><strong>情况5：RUNNABLE &lt;–&gt; TIMED_WAITING</strong></p>
<ul>
<li>t 线程用 synchronized (obj) 获取了对象锁后，调用 obj.wait (long n) 方法时，t 线程从 RUNNABLE –&gt; TIMED_WAITING。</li>
<li>t 线程等待时间超过了 n 毫秒，或调用 obj.notify () ， obj.notifyAll () ， t.interrupt () 时：<ul>
<li>竞争锁成功，t 线程从 TIMED_WAITING –&gt; RUNNABLE</li>
<li>竞争锁失败，t 线程从 TIMED_WAITING –&gt; BLOCKED</li>
</ul>
</li>
</ul>
<p><strong>情况6：RUNNABLE &lt;–&gt; TIMED_WAITING</strong></p>
<p>当前线程调用 t.join (long n) 方法时，当前线程从 RUNNABLE –&gt; TIMED_WAITING。</p>
<p>当前线程等待时间超过了 n 毫秒，或 t 线程运行结束，或调用了当前线程的 interrupt () 时，当前线程从 TIMED_WAITING –&gt; RUNNABLE。</p>
<p><strong>情况7：RUNNABLE &lt;–&gt; TIMED_WAITING</strong></p>
<ul>
<li>当前线程调用 Thread.sleep (long n) ，当前线程从 RUNNABLE –&gt; TIMED_WAITING。</li>
<li>当前线程等待时间超过了 n 毫秒，当前线程从 TIMED_WAITING –&gt; RUNNABLE。</li>
</ul>
<p><strong>情况8：RUNNABLE &lt;–&gt; TIMED_WAITING</strong></p>
<ul>
<li>当前线程调用 LockSupport.parkNanos (long nanos) 或 LockSupport.parkUntil (long millis) 时，当前线 程从 RUNNABLE –&gt; TIMED_WAITING。</li>
<li>调用 LockSupport.unpark (目标线程) 或调用了线程 的 interrupt () ，或是等待超时，会让目标线程从 TIMED_WAITING–&gt; RUNNABLE。</li>
</ul>
<p><strong>情况9：RUNNABLE &lt;–&gt; BLOCKED</strong></p>
<ul>
<li>t 线程用 synchronized (obj) 获取了对象锁时如果竞争失败，从 RUNNABLE –&gt; BLOCKED。</li>
<li>持 obj 锁线程的同步代码块执行完毕，会唤醒该对象上所有 BLOCKED 的线程重新竞争，如果其中 t 线程竞争成功，从 BLOCKED –&gt; RUNNABLE ，其它失败的线程仍然 BLOCKED。</li>
</ul>
<p><strong>情况10：RUNNABLE &lt;–&gt; TERMINATED</strong></p>
<ul>
<li>当前线程所有代码运行完毕，进入 TERMINATED。</li>
</ul>
<h4 id="多把锁"><a href="#多把锁" class="headerlink" title="多把锁"></a>多把锁</h4><h5 id="多把不相干的锁"><a href="#多把不相干的锁" class="headerlink" title="多把不相干的锁"></a>多把不相干的锁</h5><p>一间大屋子有两个功能：睡觉、学习，互不相干。</p>
<p>现在小南要学习，小女要睡觉，但如果只用一间屋子（一个对象锁）的话，那么并发度很低</p>
<p>解决方法是准备多个房间（多个对象锁）</p>
<p>例如</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">    <span class="type">BigRoom</span> <span class="variable">bigRoom</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigRoom</span>();</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">        bigRoom.study();</span><br><span class="line">    &#125;,<span class="string">&quot;小南&quot;</span>).start();</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">        bigRoom.sleep();</span><br><span class="line">    &#125;,<span class="string">&quot;小女&quot;</span>).start();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BigRoom</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sleep</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span>(<span class="built_in">this</span>)&#123;</span><br><span class="line">            log.debug(<span class="string">&quot;sleeping 2 小时&quot;</span>);</span><br><span class="line">            Sleeper.sleep(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">study</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span>(<span class="built_in">this</span>)&#123;</span><br><span class="line">            log.debug(<span class="string">&quot;study 1 小时&quot;</span>);</span><br><span class="line">            Sleeper.sleep(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>改进：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">    <span class="type">BigRoom</span> <span class="variable">bigRoom</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigRoom</span>();</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">        bigRoom.study();</span><br><span class="line">    &#125;,<span class="string">&quot;小南&quot;</span>).start();</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">        bigRoom.sleep();</span><br><span class="line">    &#125;,<span class="string">&quot;小女&quot;</span>).start();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BigRoom</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">studyRoom</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">sleepRoom</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sleep</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span>(sleepRoom)&#123;</span><br><span class="line">            log.debug(<span class="string">&quot;sleeping 2 小时&quot;</span>);</span><br><span class="line">            Sleeper.sleep(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">study</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span>(studyRoom)&#123;</span><br><span class="line">            log.debug(<span class="string">&quot;study 1 小时&quot;</span>);</span><br><span class="line">            Sleeper.sleep(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将锁的粒度细分</p>
<ul>
<li>好处，可以增强并发度</li>
<li>坏处，如果一个线程需要同时获得多把锁，就容易发生死锁</li>
</ul>
<h4 id="活跃性"><a href="#活跃性" class="headerlink" title="活跃性"></a>活跃性</h4><h5 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h5><p>有这样情况：一个线程需要同时获取多把锁，这时就容易发生死锁</p>
<p>t1线程获得A对象锁，接下来想获取B对象的锁</p>
<p>t2线程获得B对象锁，接下来想获取A对象的锁</p>
<p>例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Object</span> <span class="variable">A</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"><span class="type">Object</span> <span class="variable">B</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"><span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(A)&#123;</span><br><span class="line">        log.debug(<span class="string">&quot;lock A&quot;</span>);</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">synchronized</span>(B)&#123;</span><br><span class="line">            log.debug(<span class="string">&quot;lock B&quot;</span>);</span><br><span class="line">            log.debug(<span class="string">&quot;操作...&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,<span class="string">&quot;t1&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(B)&#123;</span><br><span class="line">        log.debug(<span class="string">&quot;lock B&quot;</span>);</span><br><span class="line">        sleep(<span class="number">0.5</span>);</span><br><span class="line">        <span class="keyword">synchronized</span>(A)&#123;</span><br><span class="line">            log.debug(<span class="string">&quot;lock A&quot;</span>);</span><br><span class="line">            log.debug(<span class="string">&quot;操作...&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,<span class="string">&quot;t2&quot;</span>);</span><br><span class="line">t1.start();</span><br><span class="line">t2.start();</span><br></pre></td></tr></table></figure>

<h5 id="定位死锁"><a href="#定位死锁" class="headerlink" title="定位死锁"></a>定位死锁</h5><p>检测死锁可以使用jconsole工具，或者使用jps定位进程id，再用jstack定位死锁。</p>
<h5 id="哲学家就餐问题"><a href="#哲学家就餐问题" class="headerlink" title="哲学家就餐问题"></a>哲学家就餐问题</h5><p><img src="G:/Blog/source/images/img82.PNG" alt="img82"></p>
<p>有五位哲学家，围坐在圆桌旁</p>
<ul>
<li>他们只做两件事，思考和吃饭，思考一会吃口饭，吃完饭后接着思考</li>
<li>吃饭时要用两根筷子，桌上共有5根筷子，每位哲学家左右手边各有一根筷子</li>
<li>如果筷子被身边的人拿着，自己就得等待</li>
</ul>
<p>筷子类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestDeadLock</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">Chopstick</span> <span class="variable">c1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Chopstick</span>(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">        <span class="type">Chopstick</span> <span class="variable">c2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Chopstick</span>(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">        <span class="type">Chopstick</span> <span class="variable">c3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Chopstick</span>(<span class="string">&quot;3&quot;</span>);</span><br><span class="line">        <span class="type">Chopstick</span> <span class="variable">c4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Chopstick</span>(<span class="string">&quot;4&quot;</span>);</span><br><span class="line">        <span class="type">Chopstick</span> <span class="variable">c5</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Chopstick</span>(<span class="string">&quot;5&quot;</span>);</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Philosopher</span>(<span class="string">&quot;苏格拉底&quot;</span>，c1,c2).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Philosopher</span>(<span class="string">&quot;柏拉图&quot;</span>，c2,c3).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Philosopher</span>(<span class="string">&quot;亚里士多德&quot;</span>，c3,c4).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Philosopher</span>(<span class="string">&quot;赫拉克利特&quot;</span>，c4,c5).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Philosopher</span>(<span class="string">&quot;阿基米德&quot;</span>，c5,c1).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//哲学家类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Philosopher</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line">    Chopstick left;</span><br><span class="line">    Chopstick right;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Philosopher</span><span class="params">(String name,Chopstick left,Chopstick right)</span>&#123;</span><br><span class="line">        <span class="built_in">super</span>(name);</span><br><span class="line">        <span class="built_in">this</span>.left = left;</span><br><span class="line">        <span class="built_in">this</span>.right = right;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="comment">//尝试获得左手筷子</span></span><br><span class="line">            <span class="keyword">synchronized</span>(left)&#123;</span><br><span class="line">                <span class="comment">//尝试获得右手筷子</span></span><br><span class="line">                <span class="keyword">synchronized</span>(right)&#123;</span><br><span class="line">                    eat();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span>&#123;</span><br><span class="line">        log.debug(<span class="string">&quot;eating...&quot;</span>);</span><br><span class="line">        Sleeper.sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//筷子类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Chopstick</span>&#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Chopstick</span><span class="params">(String name)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;筷子&#123;&quot;</span> + name +<span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="活锁"><a href="#活锁" class="headerlink" title="活锁"></a>活锁</h5><p>活锁出现在两个线程互相改变对方的结束条件，最后谁也无法结束，例如</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestLiveLock</span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            <span class="comment">//期望减到0退出循环</span></span><br><span class="line">            <span class="keyword">while</span>(count &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                sleep(<span class="number">0.2</span>);</span><br><span class="line">                count--;</span><br><span class="line">                log.debug(<span class="string">&quot;count:&#123;&#125;&quot;</span>,count);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            <span class="comment">//期望超过20退出循环</span></span><br><span class="line">            <span class="keyword">while</span>(count &lt; <span class="number">20</span>)&#123;</span><br><span class="line">                sleep(<span class="number">0.2</span>);</span><br><span class="line">                count++;</span><br><span class="line">                log.debug(<span class="string">&quot;count:&#123;&#125;&quot;</span>,count);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;t2&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="饥饿"><a href="#饥饿" class="headerlink" title="饥饿"></a>饥饿</h5><p>很多教程把饥饿定义为，一个线程由于优先级太低，始终得不到CPU调度执行，也不能够结束，饥饿的情况不易演示，讲读写锁时会涉及到饥饿问题。</p>
<p>使用顺序加锁的方式解决之前的死锁问题</p>
<p><img src="G:/Blog/source/images/img83.PNG" alt="img83"></p>
<h4 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h4><p>相对于synchronized它具备如下特点</p>
<ul>
<li>可中断</li>
<li>可以设置超时时间</li>
<li>可以设置为公平锁</li>
<li>支持多个条件变量</li>
</ul>
<p>与synchronized一样，都支持可重入。</p>
<p>基本语法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//获取锁</span></span><br><span class="line">reentrantLock.lock();</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    <span class="comment">//临界区</span></span><br><span class="line">&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">    <span class="comment">//释放锁</span></span><br><span class="line">    reentrantLock.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="可重入"><a href="#可重入" class="headerlink" title="可重入"></a>可重入</h5><p>可重入是指同一个线程如果首次获得了这把锁，那么因为它是这把锁的拥有者，因此有权利再次获取这把锁</p>
<p>如果是不可重入，那么第二次获得锁时，自己也会被锁挡住</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">    method1();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method1</span><span class="params">()</span>&#123;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        log.debug(<span class="string">&quot;execute method1&quot;</span>);</span><br><span class="line">        method2();</span><br><span class="line">    &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method2</span><span class="params">()</span>&#123;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        log.debug(<span class="string">&quot;execute method2&quot;</span>);</span><br><span class="line">        method3();</span><br><span class="line">    &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method3</span><span class="params">()</span>&#123;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        log.debug(<span class="string">&quot;execute method2&quot;</span>);</span><br><span class="line">        method3();</span><br><span class="line">    &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="可打断"><a href="#可打断" class="headerlink" title="可打断"></a>可打断</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="comment">//如果没有竞争那么此方法就会获取lock对象锁</span></span><br><span class="line">            <span class="comment">//如果有竞争就进入阻塞队列，可以被其它线程用interrupt方法打断</span></span><br><span class="line">            log.debug(<span class="string">&quot;尝试获取锁&quot;</span>);</span><br><span class="line">            lock.lockInterruptibly();</span><br><span class="line">        &#125;<span class="keyword">catch</span>(InterruptedException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            log.debug(<span class="string">&quot;没有获得锁，返回&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            log.debug(<span class="string">&quot;获取锁&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,<span class="string">&quot;t1&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    lock.lock();</span><br><span class="line">    t1.start();</span><br><span class="line">    </span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line">    log.debug(<span class="string">&quot;打断t1&quot;</span>);</span><br><span class="line">    t1.interrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="锁超时"><a href="#锁超时" class="headerlink" title="锁超时"></a>锁超时</h5><p>立刻失效</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>(); </span><br><span class="line"><span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">    log.debug(<span class="string">&quot;启动...&quot;</span>);</span><br><span class="line">    <span class="comment">//尝试获得锁</span></span><br><span class="line">    <span class="keyword">if</span>(!lock.tryLock())&#123;</span><br><span class="line">        log.debug(<span class="string">&quot;获取立刻失败，返回&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        log.debug(<span class="string">&quot;获得锁&quot;</span>);</span><br><span class="line">    &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,<span class="string">&quot;t1&quot;</span>);</span><br><span class="line"></span><br><span class="line">lock.lock();</span><br><span class="line">log.debug(<span class="string">&quot;获得锁&quot;</span>);</span><br><span class="line">t1.start();</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    sleep(<span class="number">2</span>);</span><br><span class="line">&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">    lock.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="解决哲学家就餐"><a href="#解决哲学家就餐" class="headerlink" title="解决哲学家就餐"></a>解决哲学家就餐</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestDeadLock</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">Chopstick</span> <span class="variable">c1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Chopstick</span>(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">        <span class="type">Chopstick</span> <span class="variable">c2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Chopstick</span>(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">        <span class="type">Chopstick</span> <span class="variable">c3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Chopstick</span>(<span class="string">&quot;3&quot;</span>);</span><br><span class="line">        <span class="type">Chopstick</span> <span class="variable">c4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Chopstick</span>(<span class="string">&quot;4&quot;</span>);</span><br><span class="line">        <span class="type">Chopstick</span> <span class="variable">c5</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Chopstick</span>(<span class="string">&quot;5&quot;</span>);</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Philosopher</span>(<span class="string">&quot;苏格拉底&quot;</span>，c1,c2).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Philosopher</span>(<span class="string">&quot;柏拉图&quot;</span>，c2,c3).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Philosopher</span>(<span class="string">&quot;亚里士多德&quot;</span>，c3,c4).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Philosopher</span>(<span class="string">&quot;赫拉克利特&quot;</span>，c4,c5).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Philosopher</span>(<span class="string">&quot;阿基米德&quot;</span>，c5,c1).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//哲学家类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Philosopher</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line">    Chopstick left;</span><br><span class="line">    Chopstick right;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Philosopher</span><span class="params">(String name,Chopstick left,Chopstick right)</span>&#123;</span><br><span class="line">        <span class="built_in">super</span>(name);</span><br><span class="line">        <span class="built_in">this</span>.left = left;</span><br><span class="line">        <span class="built_in">this</span>.right = right;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="comment">//尝试获得左手筷子</span></span><br><span class="line">            <span class="keyword">if</span>(left.tryLock())</span><br><span class="line">                <span class="keyword">try</span>&#123;</span><br><span class="line">                   <span class="comment">//尝试获得右手筷子</span></span><br><span class="line">                    <span class="keyword">if</span>(right.tryLock())&#123;</span><br><span class="line">                        <span class="keyword">try</span>&#123;</span><br><span class="line">                            eat();</span><br><span class="line">                    &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">                        right.unlock();</span><br><span class="line">                    &#125;</span><br><span class="line">                  &#125;</span><br><span class="line">                &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">                    left.unlock();<span class="comment">//释放自己手里的筷子</span></span><br><span class="line">                &#125;</span><br><span class="line">        	&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span>&#123;</span><br><span class="line">        log.debug(<span class="string">&quot;eating...&quot;</span>);</span><br><span class="line">        Sleeper.sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//筷子类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Chopstick</span> <span class="keyword">extends</span> <span class="title class_">ReentrantLock</span>&#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Chopstick</span><span class="params">(String name)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;筷子&#123;&quot;</span> + name +<span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="公平锁"><a href="#公平锁" class="headerlink" title="公平锁"></a>公平锁</h5><p>ReentrantLock默认是不公平的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">lock.lock();</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; <span class="number">500</span>;i++)&#123;</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName + <span class="string">&quot;running...&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,<span class="string">&quot;t&quot;</span> + i).start();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//1秒之后去争夺锁</span></span><br><span class="line">Thread.sleep(<span class="number">1000</span>);</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">    System.out.println(Thread.currrentThread().getName() + <span class="string">&quot;start...&quot;</span>);</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;running...&quot;</span>);</span><br><span class="line">    &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,<span class="string">&quot;强行插入&quot;</span>).start();</span><br></pre></td></tr></table></figure>

<h5 id="条件变量"><a href="#条件变量" class="headerlink" title="条件变量"></a>条件变量</h5><p>synchronized中也有条件变量，就是我们讲原理时那个waitSet休息室，当条件不满足时进入waitSet等待</p>
<p>ReentrantLock的条件变量比synchronized强大之处在于，它是支持多个条件变量的，这就好比</p>
<ul>
<li>synchronized是那些不满足条件的线程都在一间休息室等消息</li>
<li>而ReentrantLock支持多间休息室，有专门等烟的休息室、专门等早餐的休息室，唤醒时，也是按休息室来唤醒</li>
</ul>
<p>使用流程</p>
<ul>
<li>await前需要获得锁</li>
<li>await执行后，会释放锁，进入conditionObject</li>
<li>await的线程被唤醒（或打断、或超时）取重新竞争lock锁</li>
<li>竞争lock锁成功后，从await后继续执行</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"><span class="keyword">static</span> <span class="type">Condition</span> <span class="variable">waitcigaretteQueue</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line"><span class="keyword">static</span> <span class="type">Condition</span> <span class="variable">waitbreakfastQueue</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">volatile</span> <span class="type">boolean</span> <span class="variable">hascigrette</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">volatile</span> <span class="type">boolean</span> <span class="variable">hasBreakfast</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            lock.lock();	</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="同步模式之顺序控制"><a href="#同步模式之顺序控制" class="headerlink" title="同步模式之顺序控制"></a>同步模式之顺序控制</h4><h5 id="固定顺序运行"><a href="#固定顺序运行" class="headerlink" title="固定顺序运行"></a>固定顺序运行</h5><p>wait &amp; notify版</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//用来同步的对象</span></span><br><span class="line"><span class="keyword">static</span> <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"><span class="comment">//t2运行标记，代表t2是否执行过</span></span><br><span class="line"><span class="keyword">static</span> <span class="type">boolean</span> <span class="variable">t2runed</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">        <span class="keyword">synchronized</span>(obj)&#123;</span><br><span class="line">            <span class="keyword">while</span>(!t2runed)&#123;</span><br><span class="line">                <span class="keyword">try</span>&#123;</span><br><span class="line">                    <span class="comment">//t1先等一会</span></span><br><span class="line">                    obj.wait();</span><br><span class="line">                &#125;<span class="keyword">catch</span>(InterruptedException e)&#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            log.debug(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,<span class="string">&quot;t1&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">        <span class="keyword">synchronized</span>(obj)&#123;</span><br><span class="line">           log.debug(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">            t2runed = <span class="literal">true</span>;</span><br><span class="line">            lock.notify();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,<span class="string">&quot;t2&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    t1.start();</span><br><span class="line">    t2.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>park &amp; unpark版</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            LockSupport.park();</span><br><span class="line">            log.debug(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">        &#125;,<span class="string">&quot;t1&quot;</span>);</span><br><span class="line">        t1.start();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            log.debug(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">            LockSupport.unpark(t1);</span><br><span class="line">        &#125;,<span class="string">&quot;t2&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="交替输出"><a href="#交替输出" class="headerlink" title="交替输出"></a>交替输出</h5><p>线程1输出a5次，线程2输出b5次，线程3输出c5次。现在要求输出abcabcabcabcabc。</p>
<p>wait &amp; notify版</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">WaitAndNotify</span> <span class="variable">waitAndNotify</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">WaitAndNotify</span>(<span class="number">1</span>, <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            waitAndNotify.run(<span class="string">&quot;a&quot;</span>, <span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">        &#125;).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            waitAndNotify.run(<span class="string">&quot;b&quot;</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">        &#125;).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            waitAndNotify.run(<span class="string">&quot;c&quot;</span>, <span class="number">3</span>, <span class="number">1</span>);</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WaitAndNotify</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">(String str, <span class="type">int</span> flag, <span class="type">int</span> nextFlag)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; loopNumber; i++) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span>(<span class="built_in">this</span>) &#123;</span><br><span class="line">                <span class="keyword">while</span> (flag != <span class="built_in">this</span>.flag) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="built_in">this</span>.wait();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.print(str);</span><br><span class="line">                <span class="comment">// 设置下一个运行的线程标记</span></span><br><span class="line">                <span class="built_in">this</span>.flag = nextFlag;</span><br><span class="line">                <span class="comment">// 唤醒所有线程</span></span><br><span class="line">                <span class="built_in">this</span>.notifyAll();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> flag;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> loopNumber;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">WaitAndNotify</span><span class="params">(<span class="type">int</span> flag, <span class="type">int</span> loopNumber)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.flag = flag;</span><br><span class="line">        <span class="built_in">this</span>.loopNumber = loopNumber;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>park &amp; unpark版</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Thread t1, t2, t3;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ParkAndUnPark</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ParkAndUnPark</span>(<span class="number">5</span>);</span><br><span class="line">        t1 = <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            obj.run(<span class="string">&quot;a&quot;</span>, t2);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        t2 = <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            obj.run(<span class="string">&quot;b&quot;</span>, t3);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        t3 = <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            obj.run(<span class="string">&quot;c&quot;</span>, t1);</span><br><span class="line">        &#125;);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        t3.start();</span><br><span class="line"></span><br><span class="line">        LockSupport.unpark(t1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ParkAndUnPark</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">(String str, Thread nextThread)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; loopNumber; i++) &#123;</span><br><span class="line">            LockSupport.park();</span><br><span class="line">            System.out.print(str);</span><br><span class="line">            LockSupport.unpark(nextThread);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> loopNumber;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ParkAndUnPark</span><span class="params">(<span class="type">int</span> loopNumber)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.loopNumber = loopNumber;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>await &amp; signal版</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">AwaitAndSignal</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AwaitAndSignal</span>(<span class="number">5</span>);</span><br><span class="line">        <span class="type">Condition</span> <span class="variable">a</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line">        <span class="type">Condition</span> <span class="variable">b</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line">        <span class="type">Condition</span> <span class="variable">c</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            lock.run(<span class="string">&quot;a&quot;</span>, a, b);</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            lock.run(<span class="string">&quot;b&quot;</span>, b, c);</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            lock.run(<span class="string">&quot;c&quot;</span>, c, a);</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            a.signal();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AwaitAndSignal</span> <span class="keyword">extends</span> <span class="title class_">ReentrantLock</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">(String str, Condition current, Condition nextCondition)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; loopNumber; i++) &#123;</span><br><span class="line">            lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                current.await();</span><br><span class="line">                System.out.print(str);</span><br><span class="line">                nextCondition.signal();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> loopNumber;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">AwaitAndSignal</span><span class="params">(<span class="type">int</span> loopNumber)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.loopNumber = loopNumber;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>多线程与高并发</category>
      </categories>
      <tags>
        <tag>多线程与高并发</tag>
      </tags>
  </entry>
  <entry>
    <title>JUC高并发编程-AQS、ReentrantLock、读写锁原理</title>
    <url>/2022/05/18/2022-05-18-JUC%E9%AB%98%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-AQS%E3%80%81ReentrantLock%E3%80%81%E8%AF%BB%E5%86%99%E9%94%81%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<h1 id="AQS、ReentrantLock、读写锁原理"><a href="#AQS、ReentrantLock、读写锁原理" class="headerlink" title="AQS、ReentrantLock、读写锁原理"></a>AQS、ReentrantLock、读写锁原理</h1><span id="more"></span>

<h4 id="AQS"><a href="#AQS" class="headerlink" title="AQS"></a>AQS</h4><h5 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h5><p>全称是 AbstractQueuedSynchronizer，是阻塞式锁和相关的同步器工具的框架。</p>
<h5 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h5><ul>
<li><p>用 state 属性来表示资源的状态（分独占模式和共享模式），子类需要定义如何维护这个状态，控制如何获取锁和释放锁：</p>
<ul>
<li>getState：获取 state 状态。</li>
<li>setState：设置 state 状态。</li>
<li>独占模式只有一个线程能够访问资源，而共享模式可以允许多个线程访问资源。</li>
</ul>
</li>
<li><p>提供了基于 FIFO 的等待队列，类似于 Monitor 的 EntryList。</p>
</li>
<li><p>条件变量来实现等待、唤醒机制，支持多个条件变量，类似于 Monitor 的 WaitSet。</p>
</li>
</ul>
<p>子类主要实现这样一些方法（默认抛出 UnsupportedOperationException）：</p>
<ul>
<li>tryAcquire</li>
<li>tryRelease</li>
<li>tryAcquireShared</li>
<li>tryReleaseShared</li>
<li>isHeldExclusively</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取锁的姿势</span></span><br><span class="line"><span class="comment">// 如果获取锁失败</span></span><br><span class="line"><span class="keyword">if</span> (!tryAcquire(arg)) &#123;</span><br><span class="line"> <span class="comment">// 入队, 可以选择阻塞当前线程 park unpark</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 释放锁的姿势</span></span><br><span class="line"><span class="comment">// 如果释放锁成功</span></span><br><span class="line"><span class="keyword">if</span> (tryRelease(arg)) &#123;</span><br><span class="line"> <span class="comment">// 让阻塞线程恢复运行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="自定义同步器"><a href="#自定义同步器" class="headerlink" title="自定义同步器"></a>自定义同步器</h5><p>下面实现一个不可重入的阻塞式锁：使用 AbstractQueuedSynchronizer 自定义一个同步器来实现自定义锁，代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UnRepeatLock</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">MyLock</span> <span class="variable">myLock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyLock</span>();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            myLock.lock();</span><br><span class="line">            log.info(<span class="string">&quot;lock ... &quot;</span>);</span><br><span class="line">            <span class="comment">// 测试是否不可重入</span></span><br><span class="line">            myLock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                log.info(<span class="string">&quot;starting...&quot;</span>);</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                log.info(<span class="string">&quot;unlock ... &quot;</span>);</span><br><span class="line">                myLock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyLock</span> <span class="keyword">implements</span> <span class="title class_">Lock</span> &#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">MySync</span> <span class="keyword">extends</span> <span class="title class_">AbstractQueuedSynchronizer</span> &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">tryAcquire</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>)) &#123;</span><br><span class="line">                setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">tryRelease</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (compareAndSetState(<span class="number">1</span>, <span class="number">0</span>)) &#123;</span><br><span class="line">                setExclusiveOwnerThread(<span class="literal">null</span>);</span><br><span class="line">                setState(<span class="number">0</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">isHeldExclusively</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> getState() == <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> Condition <span class="title function_">newCondition</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ConditionObject</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">MySync</span> <span class="variable">mySync</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MySync</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//加锁</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span> &#123;</span><br><span class="line">        mySync.acquire(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 可中断的锁</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lockInterruptibly</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        mySync.acquireInterruptibly(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 只会尝试一次加锁</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">tryLock</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> mySync.tryAcquire(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 带超时时间的</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">tryLock</span><span class="params">(<span class="type">long</span> time, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">return</span> mySync.tryAcquireNanos(<span class="number">1</span>,unit.toNanos(time));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解锁</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span> &#123;</span><br><span class="line">        mySync.release(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建条件变量</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Condition <span class="title function_">newCondition</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> mySync.newCondition();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">19</span>:<span class="number">35</span>:<span class="number">34.374</span> [t1] INFO com.heu.test.UnRepeatLock - lock ... </span><br><span class="line">一直等待。。。</span><br></pre></td></tr></table></figure>

<h5 id="AQS-目标"><a href="#AQS-目标" class="headerlink" title="AQS 目标"></a>AQS 目标</h5><p><strong>AQS 要实现的功能目标</strong></p>
<ul>
<li>阻塞版本获取锁 acquire 和非阻塞的版本尝试获取锁 tryAcquire</li>
<li>获取锁超时机制</li>
<li>通过打断取消机制</li>
<li>独占机制及共享机制</li>
<li>条件不满足时的等待机制</li>
</ul>
<p><strong>要实现的性能目标</strong></p>
<p>Instead, the primary performance goal here is scalability: to predictably maintain effiffifficiency even, orespecially, when synchronizers are contended.</p>
<h5 id="AQS设计"><a href="#AQS设计" class="headerlink" title="AQS设计"></a>AQS设计</h5><p><strong>获取锁的逻辑：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(state 状态不允许获取) &#123;</span><br><span class="line"> 	<span class="keyword">if</span>(队列中还没有此线程) &#123;</span><br><span class="line"> 	入队并阻塞</span><br><span class="line"> 	&#125;</span><br><span class="line">&#125;</span><br><span class="line">当前线程出队</span><br></pre></td></tr></table></figure>

<p><strong>释放锁的逻辑：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(state 状态允许了) &#123;</span><br><span class="line"> 	恢复阻塞的线程(s) </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p><strong>要点：</strong></p>
<ul>
<li>原子维护 state 状态</li>
<li>阻塞及恢复线程</li>
<li>维护队列</li>
</ul>
<p><strong>state 设计</strong></p>
<ul>
<li>state 使用 volatile 配合 cas 保证其修改时的原子性。</li>
<li>state 使用了 32bit int 来维护同步状态，因为当时使用 long 在很多平台下测试的结果并不理想。</li>
</ul>
<p><strong>阻塞恢复设计</strong></p>
<ul>
<li><p>早期的控制线程暂停和恢复的 api 有 suspend 和 resume，但它们是不可用的，因为如果先调用的 resume ，那么 suspend 将感知不到。</p>
</li>
<li><p>解决方法是使用 park &amp; unpark 来实现线程的暂停和恢复，具体原理在之前讲过了，先 unpark 再 park 也没问题。</p>
</li>
<li><p>park &amp; unpark 是针对线程的，而不是针对同步器的，因此控制粒度更为精细。</p>
</li>
<li><p>park 线程还可以通过 interrupt 打断。</p>
</li>
</ul>
<p> <strong>队列设计</strong></p>
<ul>
<li>使用了 FIFO 先入先出队列，并不支持优先级队列。</li>
<li>设计时借鉴了 CLH 队列，它是一种单向无锁队列。</li>
</ul>
<p>队列中有 head 和 tail 两个指针节点，都用 volatile 修饰配合 cas 使用，每个节点有 state 维护节点状态。</p>
<h5 id="主要用到-AQS的并发工具类"><a href="#主要用到-AQS的并发工具类" class="headerlink" title="主要用到 AQS的并发工具类"></a>主要用到 AQS的并发工具类</h5><h4 id="ReentrantLock-原理"><a href="#ReentrantLock-原理" class="headerlink" title="ReentrantLock 原理"></a>ReentrantLock 原理</h4><p>可以看到 ReentrantLock 提供了两个同步器，实现公平锁和非公平锁，默认是非公平锁！</p>
<h5 id="非公平锁实现原理"><a href="#非公平锁实现原理" class="headerlink" title="非公平锁实现原理"></a>非公平锁实现原理</h5><h6 id="加锁流程"><a href="#加锁流程" class="headerlink" title="加锁流程"></a>加锁流程</h6><p>先从构造器开始看，默认为非公平锁实现。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ReentrantLock</span><span class="params">()</span> &#123;</span><br><span class="line">        sync = <span class="keyword">new</span> <span class="title class_">NonfairSync</span>();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>NonfairSync 继承自 AQS，在没有线程竞争时：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="comment">// 没有竞争时, 直接加锁 (CAS)</span></span><br><span class="line">	<span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>))</span><br><span class="line">        <span class="comment">// 设置持有锁的线程</span></span><br><span class="line">        setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">// 有竞争, 会调用这个方法</span></span><br><span class="line">        acquire(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第一个竞争出现时：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">acquire</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">    <span class="comment">// 再次尝试加锁失败，则创建一个 Node 节点对象加入到等待队列中去.</span></span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Thread-1 执行了：</p>
<ul>
<li><p>lock方法中CAS，尝试将 state 由 0 改为 1，结果失败；</p>
</li>
<li><p>lock方法中进一步调用acquire方法，进入 tryAcquire 逻辑，这里认为此时 state 已经是1，结果仍然失败；</p>
</li>
<li><p>接下来进入 acquire方法的addWaiter 逻辑，构造 Node 队列：</p>
<ul>
<li>图中黄色三角表示该 Node 的 waitStatus 状态，其中 0 为默认正常状态；</li>
<li>Node 的创建是懒惰的；</li>
<li>其中第一个 Node 称为 Dummy（哑元）或哨兵，用来占位，并不关联线程。</li>
</ul>
</li>
</ul>
<p>之后当前线程进入acquire方法的 acquireQueued 逻辑：</p>
<ul>
<li><p>acquireQueued 会在一个死循环中不断尝试获得锁，失败后进入 park 阻塞;</p>
</li>
<li><p>如果自己是紧邻着 head（排第二位），那么再次 tryAcquire 尝试获取锁，这里设置此时 state 仍为 1，失败;</p>
</li>
<li><p>进入 shouldParkAfterFailedAcquire 逻辑，将前驱 node，即 head 的 waitStatus 改为 -1，这次返回 false；</p>
</li>
<li><p>shouldParkAfterFailedAcquire 执行完毕回到 acquireQueued ，再次 tryAcquire 尝试获取锁，当然这时 state 仍为 1，失败；</p>
</li>
<li><p>当再次进入 shouldParkAfterFailedAcquire 时，这时因为其前驱 node 的 waitStatus 已经是 -1，这次返回 true；</p>
</li>
<li><p>进入 parkAndCheckInterrupt， Thread-1 park（灰色表示已经阻塞）。</p>
</li>
</ul>
<p>如果再次有多个线程经历上述过程竞争失败，变成这个样子：</p>
<p><strong>加锁源码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Sync 继承自 AQS</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">NonfairSync</span> <span class="keyword">extends</span> <span class="title class_">Sync</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">7316153563782823691L</span>;</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 加锁实现</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 首先用 cas 尝试（仅尝试一次）将 state 从 0 改为 1, 如果成功表示获得了独占锁</span></span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>))</span><br><span class="line">            setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="comment">// 如果尝试失败，进入 ㈠</span></span><br><span class="line">            acquire(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ㈠ AQS 继承过来的方法, 方便阅读, 放在此处</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">acquire</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">        <span class="comment">// ㈡ tryAcquire</span></span><br><span class="line">        <span class="keyword">if</span> (</span><br><span class="line">            !tryAcquire(arg) &amp;&amp;</span><br><span class="line">            <span class="comment">// 当 tryAcquire 返回为 false 时, 先调用 addWaiter ㈣, 接着 acquireQueued ㈤</span></span><br><span class="line">            acquireQueued(addWaiter(Node.EXCLUSIVE), arg)</span><br><span class="line">        ) &#123;</span><br><span class="line">            selfInterrupt();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ㈡ 进入 ㈢</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">tryAcquire</span><span class="params">(<span class="type">int</span> acquires)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> nonfairTryAcquire(acquires);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ㈢ Sync 继承过来的方法, 方便阅读, 放在此处</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">nonfairTryAcquire</span><span class="params">(<span class="type">int</span> acquires)</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">Thread</span> <span class="variable">current</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> getState();</span><br><span class="line">        <span class="comment">// 如果还没有获得锁</span></span><br><span class="line">        <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 尝试用 cas 获得, 这里体现了非公平性: 不去检查 AQS 队列</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">                setExclusiveOwnerThread(current);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果已经获得了锁, 线程还是当前线程, 表示发生了锁重入</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">            <span class="comment">// state++</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">nextc</span> <span class="operator">=</span> c + acquires;</span><br><span class="line">            <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">            setState(nextc);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 获取失败, 回到调用处</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ㈣ AQS 继承过来的方法, 方便阅读, 放在此处</span></span><br><span class="line">    <span class="keyword">private</span> Node <span class="title function_">addWaiter</span><span class="params">(Node mode)</span> &#123;</span><br><span class="line">   <span class="comment">// 将当前线程关联到一个 Node 对象上, 模式为独占模式，新建的Node的waitstatus默认为0，因为waitstatus是成员变量，默认被初始化为0</span></span><br><span class="line">        <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(Thread.currentThread(), mode);</span><br><span class="line">        <span class="comment">// 如果 tail 不为 null, cas 尝试将 Node 对象加入 AQS 队列尾部</span></span><br><span class="line">        <span class="type">Node</span> <span class="variable">pred</span> <span class="operator">=</span> tail;</span><br><span class="line">        <span class="keyword">if</span> (pred != <span class="literal">null</span>) &#123;</span><br><span class="line">            node.prev = pred;</span><br><span class="line">            <span class="keyword">if</span> (compareAndSetTail(pred, node)) &#123;</span><br><span class="line">                <span class="comment">// 双向链表</span></span><br><span class="line">                pred.next = node;</span><br><span class="line">                <span class="keyword">return</span> node;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果tail为null，尝试将 Node 加入 AQS, 进入 ㈥</span></span><br><span class="line">        enq(node);</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ㈥ AQS 继承过来的方法, 方便阅读, 放在此处</span></span><br><span class="line">    <span class="keyword">private</span> Node <span class="title function_">enq</span><span class="params">(<span class="keyword">final</span> Node node)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="type">Node</span> <span class="variable">t</span> <span class="operator">=</span> tail;</span><br><span class="line">            <span class="keyword">if</span> (t == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 还没有, 设置 head 为哨兵节点（不对应线程，状态为 0）</span></span><br><span class="line">                <span class="keyword">if</span> (compareAndSetHead(<span class="keyword">new</span> <span class="title class_">Node</span>())) &#123;</span><br><span class="line">                    tail = head;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// cas 尝试将 Node 对象加入 AQS 队列尾部</span></span><br><span class="line">                node.prev = t;</span><br><span class="line">                <span class="keyword">if</span> (compareAndSetTail(t, node)) &#123;</span><br><span class="line">                    t.next = node;</span><br><span class="line">                    <span class="keyword">return</span> t;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ㈤ AQS 继承过来的方法, 方便阅读, 放在此处</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="type">int</span> arg)</span> &#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">failed</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">interrupted</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">p</span> <span class="operator">=</span> node.predecessor();</span><br><span class="line">                <span class="comment">// 上一个节点是 head, 表示轮到自己（当前线程对应的 node）了, 尝试获取</span></span><br><span class="line">                <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                    <span class="comment">// 获取成功, 设置自己（当前线程对应的 node）为 head</span></span><br><span class="line">                    setHead(node);</span><br><span class="line">                    <span class="comment">// 上一个节点 help GC</span></span><br><span class="line">                    p.next = <span class="literal">null</span>;</span><br><span class="line">                    failed = <span class="literal">false</span>;</span><br><span class="line">                    <span class="comment">// 返回中断标记 false</span></span><br><span class="line">                    <span class="keyword">return</span> interrupted;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (</span><br><span class="line">                    <span class="comment">// 判断是否应当 park, 进入 ㈦</span></span><br><span class="line">                    shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                    <span class="comment">// park 等待, 此时 Node 的状态被置为 Node.SIGNAL ㈧</span></span><br><span class="line">                    parkAndCheckInterrupt()</span><br><span class="line">                ) &#123;</span><br><span class="line">                    interrupted = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (failed)</span><br><span class="line">                cancelAcquire(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ㈦ AQS 继承过来的方法, 方便阅读, 放在此处</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">shouldParkAfterFailedAcquire</span><span class="params">(Node pred, Node node)</span> &#123;</span><br><span class="line">        <span class="comment">// 获取上一个节点的状态</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">ws</span> <span class="operator">=</span> pred.waitStatus;</span><br><span class="line">        <span class="keyword">if</span> (ws == Node.SIGNAL) &#123;</span><br><span class="line">            <span class="comment">// 上一个节点都在阻塞, 那么自己也阻塞好了</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// &gt; 0 表示取消状态</span></span><br><span class="line">        <span class="keyword">if</span> (ws &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 上一个节点取消, 那么重构删除前面所有取消的节点, 返回到外层循环重试</span></span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                node.prev = pred = pred.prev;</span><br><span class="line">            &#125; <span class="keyword">while</span> (pred.waitStatus &gt; <span class="number">0</span>);</span><br><span class="line">            pred.next = node;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 这次还没有阻塞</span></span><br><span class="line">            <span class="comment">// 但下次如果重试不成功, 则需要阻塞，这时需要设置上一个节点状态为 Node.SIGNAL</span></span><br><span class="line">            compareAndSetWaitStatus(pred, ws, Node.SIGNAL);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ㈧ 阻塞当前线程</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">parkAndCheckInterrupt</span><span class="params">()</span> &#123;</span><br><span class="line">        LockSupport.park(<span class="built_in">this</span>);</span><br><span class="line">        <span class="keyword">return</span> Thread.interrupted();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="解锁流程"><a href="#解锁流程" class="headerlink" title="解锁流程"></a>解锁流程</h6><p>Thread-0 释放锁，进入 tryRelease 流程，如果成功：</p>
<ul>
<li>设置 exclusiveOwnerThread 为 null</li>
<li>state &#x3D; 0</li>
</ul>
<p>如果当前队列不为 null，并且 head 的 waitStatus &#x3D; -1，进入 unparkSuccessor 流程：</p>
<p>unparkSuccessor 中会找到队列中离 head 最近的一个 Node（没取消的），unpark 恢复其运行，本例中即为 Thread-1.</p>
<p>回到 Thread-1 的 acquireQueued 流程：</p>
<p>如果加锁成功（没有竞争），会设置 （acquireQueued 方法中）：</p>
<ul>
<li>exclusiveOwnerThread 为 Thread-1，state &#x3D; 1；</li>
<li>head 指向刚刚 Thread-1 所在的 Node，该 Node 清空 Thread；</li>
<li>原本的 head 因为从链表断开，而可被垃圾回收。</li>
</ul>
<p>如果这时候有其它线程来竞争（非公平的体现），例如这时有 Thread-4 来了：</p>
<p>如果不巧又被 Thread-4 占了先：</p>
<ul>
<li>Thread-4 被设置为 exclusiveOwnerThread，state &#x3D; 1；</li>
<li>Thread-1 再次进入 acquireQueued 流程，获取锁失败，重新进入 park 阻塞。</li>
</ul>
<p><strong>解锁源码：</strong></p>
<p>&#x2F;&#x2F; Sync 继承自 AQS<br>static final class NonfairSync extends Sync {<br>    &#x2F;&#x2F; 解锁实现<br>    public void unlock() {<br>        sync.release(1);<br>    }</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// AQS 继承过来的方法, 方便阅读, 放在此处</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">release</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">    <span class="comment">// 尝试释放锁, 进入 ㈠</span></span><br><span class="line">    <span class="keyword">if</span> (tryRelease(arg)) &#123;</span><br><span class="line">        <span class="comment">// 队列头节点 unpark</span></span><br><span class="line">        <span class="type">Node</span> <span class="variable">h</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">if</span> (</span><br><span class="line">            <span class="comment">// 队列不为 null</span></span><br><span class="line">            h != <span class="literal">null</span> &amp;&amp;</span><br><span class="line">            <span class="comment">// waitStatus == Node.SIGNAL 才需要 unpark</span></span><br><span class="line">            h.waitStatus != <span class="number">0</span></span><br><span class="line">        ) &#123;</span><br><span class="line">            <span class="comment">// unpark AQS 中等待的线程, 进入 ㈡</span></span><br><span class="line">            unparkSuccessor(h);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ㈠ Sync 继承过来的方法, 方便阅读, 放在此处</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">tryRelease</span><span class="params">(<span class="type">int</span> releases)</span> &#123;</span><br><span class="line">    <span class="comment">// state--</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> getState() - releases;</span><br><span class="line">    <span class="keyword">if</span> (Thread.currentThread() != getExclusiveOwnerThread())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalMonitorStateException</span>();</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">free</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">// 支持锁重入, 只有 state 减为 0, 才释放成功</span></span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">        free = <span class="literal">true</span>;</span><br><span class="line">        setExclusiveOwnerThread(<span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    setState(c);</span><br><span class="line">    <span class="keyword">return</span> free;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ㈡ AQS 继承过来的方法, 方便阅读, 放在此处</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">unparkSuccessor</span><span class="params">(Node node)</span> &#123;</span><br><span class="line">    <span class="comment">// 如果状态为 Node.SIGNAL 尝试重置状态为 0, 如果线程获取到了锁那么后来头结点会被抛弃掉</span></span><br><span class="line">    <span class="comment">// 不成功也可以</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">ws</span> <span class="operator">=</span> node.waitStatus;</span><br><span class="line">    <span class="keyword">if</span> (ws &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        compareAndSetWaitStatus(node, ws, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 找到需要 unpark 的节点, 但本节点从 AQS 队列中脱离, 是由唤醒节点完成的</span></span><br><span class="line">    <span class="type">Node</span> <span class="variable">s</span> <span class="operator">=</span> node.next;</span><br><span class="line">    <span class="comment">// 不考虑已取消的节点, 从 AQS 队列从后至前找到队列最前面需要 unpark 的节点</span></span><br><span class="line">    <span class="keyword">if</span> (s == <span class="literal">null</span> || s.waitStatus &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        s = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">Node</span> <span class="variable">t</span> <span class="operator">=</span> tail; t != <span class="literal">null</span> &amp;&amp; t != node; t = t.prev)</span><br><span class="line">            <span class="keyword">if</span> (t.waitStatus &lt;= <span class="number">0</span>)</span><br><span class="line">                s = t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (s != <span class="literal">null</span>)</span><br><span class="line">        LockSupport.unpark(s.thread);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="锁重入原理"><a href="#锁重入原理" class="headerlink" title="锁重入原理"></a>锁重入原理</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">NonfairSync</span> <span class="keyword">extends</span> <span class="title class_">Sync</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Sync 继承过来的方法, 方便阅读, 放在此处</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">nonfairTryAcquire</span><span class="params">(<span class="type">int</span> acquires)</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">Thread</span> <span class="variable">current</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> getState();</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">                setExclusiveOwnerThread(current);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果已经获得了锁, 线程还是当前线程, 表示发生了锁重入</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">            <span class="comment">// state++</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">nextc</span> <span class="operator">=</span> c + acquires;</span><br><span class="line">            <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">            setState(nextc);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//解锁</span></span><br><span class="line">    <span class="comment">// Sync 继承过来的方法, 方便阅读, 放在此处</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">tryRelease</span><span class="params">(<span class="type">int</span> releases)</span> &#123;</span><br><span class="line">        <span class="comment">// state--</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> getState() - releases;</span><br><span class="line">        <span class="keyword">if</span> (Thread.currentThread() != getExclusiveOwnerThread())</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalMonitorStateException</span>();</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">free</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">// 支持锁重入, 只有 state 减为 0, 才释放成功</span></span><br><span class="line">        <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">            free = <span class="literal">true</span>;</span><br><span class="line">            setExclusiveOwnerThread(<span class="literal">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        setState(c);</span><br><span class="line">        <span class="keyword">return</span> free;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="可打断原理"><a href="#可打断原理" class="headerlink" title="可打断原理"></a>可打断原理</h5><p><strong>不可打断模式</strong>：在此模式下，即使它被打断，仍会驻留在 AQS 队列中，一直要等到获得锁后方能得知自己被打断了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Sync 继承自 AQS</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">NonfairSync</span> <span class="keyword">extends</span> <span class="title class_">Sync</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">parkAndCheckInterrupt</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 如果打断标记已经是 true, 则 park 会失效</span></span><br><span class="line">        LockSupport.park(<span class="built_in">this</span>);</span><br><span class="line">        <span class="comment">// interrupted 会清除打断标记</span></span><br><span class="line">        <span class="keyword">return</span> Thread.interrupted();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="type">int</span> arg)</span> &#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">failed</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">interrupted</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">p</span> <span class="operator">=</span> node.predecessor();</span><br><span class="line">                <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                    setHead(node);</span><br><span class="line">                    p.next = <span class="literal">null</span>;</span><br><span class="line">                    failed = <span class="literal">false</span>;</span><br><span class="line">                    <span class="comment">// 还是需要获得锁后, 才能返回打断状态</span></span><br><span class="line">                    <span class="keyword">return</span> interrupted;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                                parkAndCheckInterrupt()</span><br><span class="line">                ) &#123;</span><br><span class="line">                    <span class="comment">// 如果是因为 interrupt 被唤醒, 返回打断状态为 true</span></span><br><span class="line">                    interrupted = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      	<span class="keyword">finally</span> &#123;</span><br><span class="line">           	<span class="keyword">if</span> (failed)</span><br><span class="line">                cancelAcquire(node);</span><br><span class="line">        	&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">acquire</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">                        acquireQueued(addWaiter(Node.EXCLUSIVE), arg)</span><br><span class="line">        ) &#123;</span><br><span class="line">            <span class="comment">// 如果打断状态为 true</span></span><br><span class="line">            selfInterrupt();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">selfInterrupt</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 重新产生一次中断，这时候线程是如果正常运行的状态，那么不是出于sleep等状态，interrupt方法就不会报错</span></span><br><span class="line">        Thread.currentThread().interrupt();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>可打断模式：</strong></p>
<p>static final class NonfairSync extends Sync {<br>    public final void acquireInterruptibly(int arg) throws InterruptedException {<br>        if (Thread.interrupted())<br>            throw new InterruptedException();<br>        &#x2F;&#x2F; 如果没有获得到锁, 进入 ㈠<br>        if (!tryAcquire(arg))<br>            doAcquireInterruptibly(arg);<br>    }</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ㈠ 可打断的获取锁流程</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">doAcquireInterruptibly</span><span class="params">(<span class="type">int</span> arg)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> addWaiter(Node.EXCLUSIVE);</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">failed</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">p</span> <span class="operator">=</span> node.predecessor();</span><br><span class="line">            <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                setHead(node);</span><br><span class="line">                p.next = <span class="literal">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                failed = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                    parkAndCheckInterrupt()) &#123;</span><br><span class="line">                <span class="comment">// 在 park 过程中如果被 interrupt 会进入此</span></span><br><span class="line">                <span class="comment">// 这时候抛出异常, 而不会再次进入 for (;;)</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InterruptedException</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="公平锁原理"><a href="#公平锁原理" class="headerlink" title="公平锁原理"></a>公平锁原理</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">FairSync</span> <span class="keyword">extends</span> <span class="title class_">Sync</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> -<span class="number">3000897897090466540L</span>;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span> &#123;</span><br><span class="line">        acquire(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// AQS 继承过来的方法, 方便阅读, 放在此处</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">acquire</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (</span><br><span class="line">            !tryAcquire(arg) &amp;&amp;</span><br><span class="line">                acquireQueued(addWaiter(Node.EXCLUSIVE), arg)</span><br><span class="line">        ) &#123;</span><br><span class="line">            selfInterrupt();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 与非公平锁主要区别在于 tryAcquire 方法的实现</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">tryAcquire</span><span class="params">(<span class="type">int</span> acquires)</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">Thread</span> <span class="variable">current</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> getState();</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 先检查 AQS 队列中是否有前驱节点, 没有才去竞争</span></span><br><span class="line">            <span class="keyword">if</span> (!hasQueuedPredecessors() &amp;&amp;</span><br><span class="line">                    compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">                setExclusiveOwnerThread(current);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">nextc</span> <span class="operator">=</span> c + acquires;</span><br><span class="line">            <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">            setState(nextc);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ㈠ AQS 继承过来的方法, 方便阅读, 放在此处</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">hasQueuedPredecessors</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">t</span> <span class="operator">=</span> tail;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">h</span> <span class="operator">=</span> head;</span><br><span class="line">        Node s;</span><br><span class="line">        <span class="comment">// h != t 时表示队列中有 Node</span></span><br><span class="line">        <span class="keyword">return</span> h != t &amp;&amp;(</span><br><span class="line">                    <span class="comment">// (s = h.next) == null 表示队列中还有没有老二或者队列中老二线程不是此线程</span></span><br><span class="line">                    (s = h.next) == <span class="literal">null</span> || </span><br><span class="line">                    s.thread != Thread.currentThread()</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="条件变量实现原理"><a href="#条件变量实现原理" class="headerlink" title="条件变量实现原理"></a>条件变量实现原理</h5><p>每个条件变量其实就对应着一个等待队列，其实现类是 ConditionObject。</p>
<h6 id="await流程"><a href="#await流程" class="headerlink" title="await流程"></a>await流程</h6><p>开始时 Thread-0 持有锁，调用 await方法，进入 ConditionObject 的 addConditionWaiter 流程，创建新的 Node 节点，状态为-2（Node.CONDITION），关联 Thread-0，加入等待队列尾部。</p>
<p>接下来进入 AQS 的 fullyRelease 流程，释放同步器上的锁：</p>
<p>unpark AQS 队列中的下一个节点，竞争锁，假设没有其他竞争线程竞争，那么 Thread-1 竞争成功：</p>
<p>park 阻塞 Thread-0：</p>
<h6 id="signal-流程"><a href="#signal-流程" class="headerlink" title="signal 流程"></a>signal 流程</h6><p>假设 Thread-1 要来唤醒 Thread-0：</p>
<p>进入 ConditionObject 的 doSignal 流程，取得等待队列中第一个 Node，即 Thread-0 所在 Node：</p>
<p>执行 transferForSignal 流程，将该 Node 加入 AQS 队列尾部，将 Thread-0 的 waitStatus 改为 0，Thread-3 的waitStatus 改为 -1：</p>
<p>之后Thread-1 释放锁，进入 unlock 流程。</p>
<p><strong>源码分析：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConditionObject</span> <span class="keyword">implements</span> <span class="title class_">Condition</span>, java.io.Serializable &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">1173984872572414699L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第一个等待节点</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> Node firstWaiter;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 最后一个等待节点</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> Node lastWaiter;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ConditionObject</span><span class="params">()</span> &#123; &#125;</span><br><span class="line">    <span class="comment">// ㈠ 添加一个 Node 至等待队列</span></span><br><span class="line">    <span class="keyword">private</span> Node <span class="title function_">addConditionWaiter</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">t</span> <span class="operator">=</span> lastWaiter;</span><br><span class="line">        <span class="comment">// 所有已取消的 Node 从队列链表删除, 见 ㈡</span></span><br><span class="line">        <span class="keyword">if</span> (t != <span class="literal">null</span> &amp;&amp; t.waitStatus != Node.CONDITION) &#123;</span><br><span class="line">            unlinkCancelledWaiters();</span><br><span class="line">            t = lastWaiter;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 创建一个关联当前线程的新 Node, 添加至队列尾部</span></span><br><span class="line">        <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(Thread.currentThread(), Node.CONDITION);</span><br><span class="line">        <span class="keyword">if</span> (t == <span class="literal">null</span>)</span><br><span class="line">            firstWaiter = node;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            t.nextWaiter = node;</span><br><span class="line">        lastWaiter = node;</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 唤醒 - 将没取消的第一个节点转移至 AQS 队列</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">doSignal</span><span class="params">(Node first)</span> &#123;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="comment">// 已经是尾节点了</span></span><br><span class="line">            <span class="keyword">if</span> ( (firstWaiter = first.nextWaiter) == <span class="literal">null</span>) &#123;</span><br><span class="line">                lastWaiter = <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            first.nextWaiter = <span class="literal">null</span>;</span><br><span class="line">        &#125; <span class="keyword">while</span> (</span><br><span class="line">            <span class="comment">// 将等待队列中的 Node 转移至 AQS 队列, 不成功且还有节点则继续循环 ㈢</span></span><br><span class="line">                !transferForSignal(first) &amp;&amp;</span><br><span class="line">                        <span class="comment">// 队列还有节点</span></span><br><span class="line">                        (first = firstWaiter) != <span class="literal">null</span></span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 外部类方法, 方便阅读, 放在此处</span></span><br><span class="line">    <span class="comment">// ㈢ 如果节点状态是取消, 返回 false 表示转移失败, 否则转移成功</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">transferForSignal</span><span class="params">(Node node)</span> &#123;</span><br><span class="line">        <span class="comment">// 设置当前node状态为0（因为处在队列末尾），如果状态已经不是 Node.CONDITION, 说明被取消了</span></span><br><span class="line">        <span class="keyword">if</span> (!compareAndSetWaitStatus(node, Node.CONDITION, <span class="number">0</span>))</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">// 加入 AQS 队列尾部</span></span><br><span class="line">        <span class="type">Node</span> <span class="variable">p</span> <span class="operator">=</span> enq(node);</span><br><span class="line">        <span class="type">int</span> <span class="variable">ws</span> <span class="operator">=</span> p.waitStatus;</span><br><span class="line">        <span class="keyword">if</span> (</span><br><span class="line">            <span class="comment">// 插入节点的上一个节点被取消</span></span><br><span class="line">                ws &gt; <span class="number">0</span> ||</span><br><span class="line">                        <span class="comment">// 插入节点的上一个节点不能设置状态为 Node.SIGNAL</span></span><br><span class="line">                        !compareAndSetWaitStatus(p, ws, Node.SIGNAL)</span><br><span class="line">        ) &#123;</span><br><span class="line">            <span class="comment">// unpark 取消阻塞, 让线程重新同步状态</span></span><br><span class="line">            LockSupport.unpark(node.thread);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 全部唤醒 - 等待队列的所有节点转移至 AQS 队列</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">doSignalAll</span><span class="params">(Node first)</span> &#123;</span><br><span class="line">    lastWaiter = firstWaiter = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">next</span> <span class="operator">=</span> first.nextWaiter;</span><br><span class="line">        first.nextWaiter = <span class="literal">null</span>;</span><br><span class="line">        transferForSignal(first);</span><br><span class="line">        first = next;</span><br><span class="line">    &#125; <span class="keyword">while</span> (first != <span class="literal">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ㈡</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">unlinkCancelledWaiters</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 唤醒 - 必须持有锁才能唤醒, 因此 doSignal 内无需考虑加锁</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">signal</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 如果没有持有锁，会抛出异常</span></span><br><span class="line">        <span class="keyword">if</span> (!isHeldExclusively())</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalMonitorStateException</span>();</span><br><span class="line">        <span class="type">Node</span> <span class="variable">first</span> <span class="operator">=</span> firstWaiter;</span><br><span class="line">        <span class="keyword">if</span> (first != <span class="literal">null</span>)</span><br><span class="line">            doSignal(first);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 全部唤醒 - 必须持有锁才能唤醒, 因此 doSignalAll 内无需考虑加锁</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">signalAll</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!isHeldExclusively())</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalMonitorStateException</span>();</span><br><span class="line">        <span class="type">Node</span> <span class="variable">first</span> <span class="operator">=</span> firstWaiter;</span><br><span class="line">        <span class="keyword">if</span> (first != <span class="literal">null</span>)</span><br><span class="line">            doSignalAll(first);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 不可打断等待 - 直到被唤醒</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">awaitUninterruptibly</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 添加一个 Node 至等待队列, 见 ㈠</span></span><br><span class="line">        <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> addConditionWaiter();</span><br><span class="line">        <span class="comment">// 释放节点持有的锁, 见 ㈣</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">savedState</span> <span class="operator">=</span> fullyRelease(node);</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">interrupted</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">// 如果该节点还没有转移至 AQS 队列, 阻塞</span></span><br><span class="line">        <span class="keyword">while</span> (!isOnSyncQueue(node)) &#123;</span><br><span class="line">            <span class="comment">// park 阻塞</span></span><br><span class="line">            LockSupport.park(<span class="built_in">this</span>);</span><br><span class="line">            <span class="comment">// 如果被打断, 仅设置打断状态</span></span><br><span class="line">            <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">                interrupted = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 唤醒后, 尝试竞争锁, 如果失败进入 AQS 队列</span></span><br><span class="line">        <span class="keyword">if</span> (acquireQueued(node, savedState) || interrupted)</span><br><span class="line">            selfInterrupt();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 外部类方法, 方便阅读, 放在此处</span></span><br><span class="line">    <span class="comment">// ㈣ 因为某线程可能重入，需要将 state 全部释放，获取state，然后把它全部减掉，以全部释放</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">fullyRelease</span><span class="params">(Node node)</span> &#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">failed</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">savedState</span> <span class="operator">=</span> getState();</span><br><span class="line">            <span class="comment">// 唤醒等待队列队列中的下一个节点</span></span><br><span class="line">            <span class="keyword">if</span> (release(savedState)) &#123;</span><br><span class="line">                failed = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">return</span> savedState;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalMonitorStateException</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (failed)</span><br><span class="line">                node.waitStatus = Node.CANCELLED;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 打断模式 - 在退出等待时重新设置打断状态</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">REINTERRUPT</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 打断模式 - 在退出等待时抛出异常</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">THROW_IE</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 判断打断模式</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">checkInterruptWhileWaiting</span><span class="params">(Node node)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Thread.interrupted() ?</span><br><span class="line">                (transferAfterCancelledWait(node) ? THROW_IE : REINTERRUPT) :</span><br><span class="line">                <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ㈤ 应用打断模式</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">reportInterruptAfterWait</span><span class="params">(<span class="type">int</span> interruptMode)</span></span><br><span class="line">            <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">if</span> (interruptMode == THROW_IE)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InterruptedException</span>();</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (interruptMode == REINTERRUPT)</span><br><span class="line">            selfInterrupt();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 等待 - 直到被唤醒或打断</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">if</span> (Thread.interrupted()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InterruptedException</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 添加一个 Node 至等待队列, 见 ㈠</span></span><br><span class="line">        <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> addConditionWaiter();</span><br><span class="line">        <span class="comment">// 释放节点持有的锁</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">savedState</span> <span class="operator">=</span> fullyRelease(node);</span><br><span class="line">        <span class="type">int</span> <span class="variable">interruptMode</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 如果该节点还没有转移至 AQS 队列, 阻塞</span></span><br><span class="line">        <span class="keyword">while</span> (!isOnSyncQueue(node)) &#123;</span><br><span class="line">            <span class="comment">// park 阻塞              </span></span><br><span class="line">            LockSupport.park(<span class="built_in">this</span>);</span><br><span class="line">            <span class="comment">// 如果被打断, 退出等待队列</span></span><br><span class="line">            <span class="keyword">if</span> ((interruptMode = checkInterruptWhileWaiting(node)) != <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 退出等待队列后, 还需要获得 AQS 队列的锁</span></span><br><span class="line">        <span class="keyword">if</span> (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE)</span><br><span class="line">            interruptMode = REINTERRUPT;</span><br><span class="line">        <span class="comment">// 所有已取消的 Node 从队列链表删除, 见 ㈡</span></span><br><span class="line">        <span class="keyword">if</span> (node.nextWaiter != <span class="literal">null</span>)</span><br><span class="line">            unlinkCancelledWaiters();</span><br><span class="line">        <span class="comment">// 应用打断模式, 见 ㈤</span></span><br><span class="line">        <span class="keyword">if</span> (interruptMode != <span class="number">0</span>)</span><br><span class="line">            reportInterruptAfterWait(interruptMode);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 等待 - 直到被唤醒或打断或超时</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">long</span> <span class="title function_">awaitNanos</span><span class="params">(<span class="type">long</span> nanosTimeout)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">if</span> (Thread.interrupted()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InterruptedException</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 添加一个 Node 至等待队列, 见 ㈠</span></span><br><span class="line">        <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> addConditionWaiter();</span><br><span class="line">        <span class="comment">// 释放节点持有的锁</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">savedState</span> <span class="operator">=</span> fullyRelease(node);</span><br><span class="line">        <span class="comment">// 获得最后期限</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">long</span> <span class="variable">deadline</span> <span class="operator">=</span> System.nanoTime() + nanosTimeout;</span><br><span class="line">        <span class="type">int</span> <span class="variable">interruptMode</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 如果该节点还没有转移至 AQS 队列, 阻塞</span></span><br><span class="line">        <span class="keyword">while</span> (!isOnSyncQueue(node)) &#123;</span><br><span class="line">            <span class="comment">// 已超时, 退出等待队列</span></span><br><span class="line">            <span class="keyword">if</span> (nanosTimeout &lt;= <span class="number">0L</span>) &#123;</span><br><span class="line">                transferAfterCancelledWait(node);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// park 阻塞一定时间, spinForTimeoutThreshold 为 1000 ns</span></span><br><span class="line">            <span class="keyword">if</span> (nanosTimeout &gt;= spinForTimeoutThreshold)</span><br><span class="line">                LockSupport.parkNanos(<span class="built_in">this</span>, nanosTimeout);</span><br><span class="line">            <span class="comment">// 如果被打断, 退出等待队列</span></span><br><span class="line">            <span class="keyword">if</span> ((interruptMode = checkInterruptWhileWaiting(node)) != <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            nanosTimeout = deadline - System.nanoTime();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 退出等待队列后, 还需要获得 AQS 队列的锁</span></span><br><span class="line">        <span class="keyword">if</span> (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE)</span><br><span class="line">            interruptMode = REINTERRUPT;</span><br><span class="line">        <span class="comment">// 所有已取消的 Node 从队列链表删除, 见 ㈡</span></span><br><span class="line">        <span class="keyword">if</span> (node.nextWaiter != <span class="literal">null</span>)</span><br><span class="line">            unlinkCancelledWaiters();</span><br><span class="line">        <span class="comment">// 应用打断模式, 见 ㈤</span></span><br><span class="line">        <span class="keyword">if</span> (interruptMode != <span class="number">0</span>)</span><br><span class="line">            reportInterruptAfterWait(interruptMode);</span><br><span class="line">        <span class="keyword">return</span> deadline - System.nanoTime();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 等待 - 直到被唤醒或打断或超时, 逻辑类似于 awaitNanos</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">awaitUntil</span><span class="params">(Date deadline)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 等待 - 直到被唤醒或打断或超时, 逻辑类似于 awaitNanos</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">await</span><span class="params">(<span class="type">long</span> time, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 工具方法 省略 ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="读写锁原理"><a href="#读写锁原理" class="headerlink" title="读写锁原理"></a>读写锁原理</h4><h5 id="ReentrantReadWriteLock"><a href="#ReentrantReadWriteLock" class="headerlink" title="ReentrantReadWriteLock"></a>ReentrantReadWriteLock</h5><p>当读操作远远高于写操作时，这时候使用读写锁让读-读可以并发，提高性能。读-写，写-写都是相互互斥的！提供一个数据容器类，内部分别使用读锁保护数据的read()方法，写锁保护数据的write()方法 。实现代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReadWriteLockTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">DataContainer</span> <span class="variable">dataContainer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DataContainer</span>();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            dataContainer.read();</span><br><span class="line">            dataContainer.write();</span><br><span class="line">        &#125;,<span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            dataContainer.write();</span><br><span class="line">        &#125;,<span class="string">&quot;t2&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DataContainer</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Object</span> <span class="variable">object</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="type">ReentrantReadWriteLock</span> <span class="variable">readWriteLock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantReadWriteLock</span>();</span><br><span class="line">    <span class="keyword">private</span> ReentrantReadWriteLock.<span class="type">ReadLock</span> <span class="variable">readLock</span> <span class="operator">=</span> readWriteLock.readLock();</span><br><span class="line">    <span class="keyword">private</span> ReentrantReadWriteLock.<span class="type">WriteLock</span> <span class="variable">writeLock</span> <span class="operator">=</span> readWriteLock.writeLock();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">read</span><span class="params">()</span> &#123;</span><br><span class="line">        readLock.lock();</span><br><span class="line">        log.info(<span class="string">&quot;拿到读锁&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            log.info(<span class="string">&quot;读取操作&quot;</span>);</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            readLock.unlock();</span><br><span class="line">            log.info(<span class="string">&quot;释放读锁&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> object;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>  <span class="keyword">void</span> <span class="title function_">write</span><span class="params">()</span> &#123;</span><br><span class="line">        writeLock.lock();</span><br><span class="line">        log.info(<span class="string">&quot;拿到写锁&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            log.info(<span class="string">&quot;写操作&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            writeLock.unlock();</span><br><span class="line">            log.info(<span class="string">&quot;释放写锁&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：读读并发，读写阻塞</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">11</span>:<span class="number">01</span>:<span class="number">47.856</span> [t1] INFO com.heu.test.DataContainer - 拿到读锁</span><br><span class="line"><span class="number">11</span>:<span class="number">01</span>:<span class="number">47.865</span> [t1] INFO com.heu.test.DataContainer - 读取操作</span><br><span class="line"><span class="number">11</span>:<span class="number">01</span>:<span class="number">47.856</span> [t2] INFO com.heu.test.DataContainer - 拿到读锁</span><br><span class="line"><span class="number">11</span>:<span class="number">01</span>:<span class="number">47.867</span> [t2] INFO com.heu.test.DataContainer - 读取操作</span><br><span class="line"><span class="number">11</span>:<span class="number">01</span>:<span class="number">48.872</span> [t1] INFO com.heu.test.DataContainer - 释放读锁</span><br><span class="line"><span class="number">11</span>:<span class="number">01</span>:<span class="number">48.872</span> [t2] INFO com.heu.test.DataContainer - 释放读锁</span><br><span class="line"><span class="number">11</span>:<span class="number">01</span>:<span class="number">48.872</span> [t1] INFO com.heu.test.DataContainer - 拿到写锁</span><br><span class="line"><span class="number">11</span>:<span class="number">01</span>:<span class="number">48.872</span> [t1] INFO com.heu.test.DataContainer - 写操作</span><br><span class="line"><span class="number">11</span>:<span class="number">01</span>:<span class="number">48.872</span> [t1] INFO com.heu.test.DataContainer - 释放写锁</span><br></pre></td></tr></table></figure>

<p><strong>注意事项：</strong></p>
<ul>
<li>读锁不支持条件变量。</li>
<li>重入时升级不支持：即持有读锁的情况下去获取写锁，会导致获取写锁永久等待。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">r.lock();</span><br><span class="line">	 <span class="keyword">try</span> &#123;</span><br><span class="line">	     <span class="comment">// ...</span></span><br><span class="line">	     w.lock();</span><br><span class="line">	     <span class="keyword">try</span> &#123;</span><br><span class="line">	         <span class="comment">// ...</span></span><br><span class="line">	     &#125; <span class="keyword">finally</span>&#123;</span><br><span class="line">	         w.unlock();</span><br><span class="line">	     &#125;</span><br><span class="line">	 &#125; <span class="keyword">finally</span>&#123;</span><br><span class="line">	     r.unlock();</span><br><span class="line">	 &#125;</span><br><span class="line"><span class="comment">//写锁永久等待</span></span><br></pre></td></tr></table></figure>

<ul>
<li>重入时降级支持：即持有写锁的情况下去获取读锁：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CachedData</span> &#123;</span><br><span class="line">    Object data;</span><br><span class="line">    <span class="comment">// 是否有效，如果失效，需要重新计算 data</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">boolean</span> cacheValid;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">ReentrantReadWriteLock</span> <span class="variable">rwl</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantReadWriteLock</span>();</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">processCachedData</span><span class="params">()</span> &#123;</span><br><span class="line">        rwl.readLock().lock();</span><br><span class="line">        <span class="keyword">if</span> (!cacheValid) &#123;</span><br><span class="line">            <span class="comment">// 获取写锁前必须释放读锁</span></span><br><span class="line">            rwl.readLock().unlock();</span><br><span class="line">            rwl.writeLock().lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 判断是否有其它线程已经获取了写锁、更新了缓存, 避免重复更新</span></span><br><span class="line">                <span class="keyword">if</span> (!cacheValid) &#123;</span><br><span class="line">                    data = ...</span><br><span class="line">                    cacheValid = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 降级为读锁, 释放写锁, 这样能够让其它线程读取缓存</span></span><br><span class="line">                rwl.readLock().lock();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line"></span><br><span class="line">                rwl.writeLock().unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 自己用完数据, 释放读锁</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            use(data);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            rwl.readLock().unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="读写锁原理-1"><a href="#读写锁原理-1" class="headerlink" title="读写锁原理"></a>读写锁原理</h5><p>读写锁用的是同一个 Sync 同步器，因此等待队列、state 等也是同一个。</p>
<p>下面执行：t1 w.lock，t2 r.lock 情况：</p>
<ol>
<li><p>t1 成功上锁，流程与 ReentrantLock 加锁相比没有特殊之处，不同是写锁状态占了 state 的低 16 位，读锁使用的是 state 的高 16 位。</p>
</li>
<li><p>t2 执行 r.lock，这时进入读锁的 sync.acquireShared(1) 流程，首先会进入 tryAcquireShared 流程。如果有写锁占据，那么 tryAcquireShared 返回 -1 表示失败。tryAcquireShared 返回值表示：</p>
<ul>
<li>-1 表示失败。</li>
<li>0 表示成功，但后继节点不会继续唤醒。</li>
<li>正数表示成功，而且数值是还有几个后继节点需要唤醒，这里的读写锁返回 1。</li>
</ul>
</li>
<li><p>这时会进入 sync.doAcquireShared(1) 流程，首先也是调用 addWaiter 添加节点，不同之处在于节点被设置为 Node.SHARED 模式而非 Node.EXCLUSIVE 模式，注意此时 t2 仍处于活跃状态。</p>
</li>
<li><p>t2 会看看自己的节点是不是老二，如果是，还会再次调用 tryAcquireShared(1) 来尝试获取锁。</p>
</li>
<li><p>如果没有成功，在 doAcquireShared 内 for 循环一次，把前驱节点的 waitStatus 改为 -1，再 for 循环一 次尝试 tryAcquireShared(1) 如果还不成功，那么在 parkAndCheckInterrupt() 处 park。</p>
</li>
</ol>
<p>又继续执行 ：t3 r.lock，t4 w.lock。在这种状态下，假设又有 t3 加读锁和 t4 加写锁，这期间 t1 仍然持有锁，就变成了下面的样子：</p>
<p>继续执行 t1 w.unlock，这时会走到写锁的 sync.release(1) 流程，调用 sync.tryRelease(1) 成功，变成下面的样子：</p>
<p>接下来执行唤醒流程 sync.unparkSuccessor，即让老二恢复运行。这时 t2 在 doAcquireShared 内 parkAndCheckInterrupt() 处恢复运行，图中的t2从黑色变成了蓝色（注意这里只是恢复运行而已，并没有获取到锁！） 这回再来一次 for (;; ) 执行 tryAcquireShared 成功，让读锁计数加一。</p>
<p>这时 t2 已经恢复运行，接下来 t2 调用 setHeadAndPropagate(node, 1)，它原本所在节点被置为头节点。</p>
<p>事情还没完，在 setHeadAndPropagate 方法内还会检查下一个节点是否是 shared，如果是，则调用 doReleaseShared() 将 head 的状态从 -1 改为 0 并唤醒老二，这时 t3 在 doAcquireShared 内 parkAndCheckInterrupt() 处恢复运行。</p>
<p>这回再来一次 for (;; ) ，执行 tryAcquireShared 成功则让读锁计数加一。</p>
<p>这时 t3 已经恢复运行，接下来 t3 调用 setHeadAndPropagate(node, 1)，它原本所在节点被置为头节点。</p>
<p>再继续执行t2 r.unlock，t3 r.unlock t2，进入 sync.releaseShared(1) 中，调用 tryReleaseShared(1) 让计数减一。</p>
<p>但由于计数还不为零，t3 进入 sync.releaseShared(1) 中，调用 tryReleaseShared(1) 让计数减一，这回计数为零了，进入 doReleaseShared() 将头节点从 -1 改为 0 并唤醒老二，即：</p>
<p>之后 t4线程 在 acquireQueued 中 parkAndCheckInterrupt 处恢复运行，再次 执行for (;; )循环， 这次自己是老二，并且没有其他线程竞争，tryAcquire(1) 成功，修改头结点，流程结束。</p>
<h5 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h5><h6 id="写锁源码分析"><a href="#写锁源码分析" class="headerlink" title="写锁源码分析"></a>写锁源码分析</h6><p>写锁上锁流程：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">NonfairSync</span> <span class="keyword">extends</span> <span class="title class_">Sync</span> &#123;</span><br><span class="line">    <span class="comment">// ... 省略无关代码</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 外部类 WriteLock 方法, 方便阅读, 放在此处</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span> &#123;</span><br><span class="line">        sync.acquire(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// AQS 继承过来的方法, 方便阅读, 放在此处</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">acquire</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (</span><br><span class="line">            <span class="comment">// 尝试获得写锁失败</span></span><br><span class="line">                !tryAcquire(arg) &amp;&amp;</span><br><span class="line">                        <span class="comment">// 将当前线程关联到一个 Node 对象上, 模式为独占模式</span></span><br><span class="line">                        <span class="comment">// 进入 AQS 队列阻塞</span></span><br><span class="line">                        acquireQueued(addWaiter(Node.EXCLUSIVE), arg)</span><br><span class="line">        ) &#123;</span><br><span class="line">            selfInterrupt();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Sync 继承过来的方法, 方便阅读, 放在此处</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">tryAcquire</span><span class="params">(<span class="type">int</span> acquires)</span> &#123;</span><br><span class="line">        <span class="comment">// 获得低 16 位, 代表写锁的 state 计数</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">current</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> getState();</span><br><span class="line">        <span class="type">int</span> <span class="variable">w</span> <span class="operator">=</span> exclusiveCount(c);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (c != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (</span><br><span class="line">                <span class="comment">// c != 0 and w == 0 表示有读锁返回错误，读锁不支持锁升级, 或者</span></span><br><span class="line">                    w == <span class="number">0</span> ||</span><br><span class="line">                            <span class="comment">// c != 0 and w == 0 表示有写，如果 exclusiveOwnerThread 不是自己</span></span><br><span class="line">                            current != getExclusiveOwnerThread()</span><br><span class="line">            ) &#123;</span><br><span class="line">                <span class="comment">// 获得锁失败</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 写锁计数超过低 16 位, 报异常</span></span><br><span class="line">            <span class="keyword">if</span> (w + exclusiveCount(acquires) &gt; MAX_COUNT)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">            <span class="comment">// 写锁重入, 获得锁成功</span></span><br><span class="line">            setState(c + acquires);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (</span><br><span class="line">            <span class="comment">// 判断写锁是否该阻塞这里返回false, 或者</span></span><br><span class="line">                writerShouldBlock() ||</span><br><span class="line">                        <span class="comment">// 尝试更改计数失败</span></span><br><span class="line">                        !compareAndSetState(c, c + acquires)</span><br><span class="line">        ) &#123;</span><br><span class="line">            <span class="comment">// 获得锁失败</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 获得锁成功</span></span><br><span class="line">        setExclusiveOwnerThread(current);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 非公平锁 writerShouldBlock 总是返回 false, 无需阻塞</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">writerShouldBlock</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>写锁释放流程：</p>
<p>static final class NonfairSync extends Sync {<br>    &#x2F;&#x2F; … 省略无关代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// WriteLock 方法, 方便阅读, 放在此处</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span> &#123;</span><br><span class="line">    sync.release(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// AQS 继承过来的方法, 方便阅读, 放在此处</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">release</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">    <span class="comment">// 尝试释放写锁成功</span></span><br><span class="line">    <span class="keyword">if</span> (tryRelease(arg)) &#123;</span><br><span class="line">        <span class="comment">// unpark AQS 中等待的线程</span></span><br><span class="line">        <span class="type">Node</span> <span class="variable">h</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">if</span> (h != <span class="literal">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</span><br><span class="line">            unparkSuccessor(h);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Sync 继承过来的方法, 方便阅读, 放在此处</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">tryRelease</span><span class="params">(<span class="type">int</span> releases)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!isHeldExclusively())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalMonitorStateException</span>();</span><br><span class="line">    <span class="type">int</span> <span class="variable">nextc</span> <span class="operator">=</span> getState() - releases;</span><br><span class="line">    <span class="comment">// 因为可重入的原因, 写锁计数为 0, 才算释放成功</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">free</span> <span class="operator">=</span> exclusiveCount(nextc) == <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (free) &#123;</span><br><span class="line">        setExclusiveOwnerThread(<span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    setState(nextc);</span><br><span class="line">    <span class="keyword">return</span> free;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="读锁源码分析"><a href="#读锁源码分析" class="headerlink" title="读锁源码分析"></a>读锁源码分析</h6><p><strong>读锁上锁流程：</strong></p>
<p>static final class NonfairSync extends Sync {</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ReadLock 方法, 方便阅读, 放在此处</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span> &#123;</span><br><span class="line">    sync.acquireShared(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// AQS 继承过来的方法, 方便阅读, 放在此处</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">acquireShared</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">    <span class="comment">// tryAcquireShared 返回负数, 表示获取读锁失败</span></span><br><span class="line">    <span class="keyword">if</span> (tryAcquireShared(arg) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        doAcquireShared(arg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Sync 继承过来的方法, 方便阅读, 放在此处</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">tryAcquireShared</span><span class="params">(<span class="type">int</span> unused)</span> &#123;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">current</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">    <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> getState();</span><br><span class="line">    <span class="comment">// 如果是其它线程持有写锁, 获取读锁失败</span></span><br><span class="line">    <span class="keyword">if</span> (</span><br><span class="line">            exclusiveCount(c) != <span class="number">0</span> &amp;&amp;</span><br><span class="line">                    getExclusiveOwnerThread() != current</span><br><span class="line">    ) &#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> sharedCount(c);</span><br><span class="line">    <span class="keyword">if</span> (</span><br><span class="line">        <span class="comment">// 读锁不该阻塞(如果老二是写锁，读锁该阻塞), 并且</span></span><br><span class="line">            !readerShouldBlock() &amp;&amp;</span><br><span class="line">                    <span class="comment">// 小于读锁计数, 并且</span></span><br><span class="line">                    r &lt; MAX_COUNT &amp;&amp;</span><br><span class="line">                    <span class="comment">// 尝试增加计数成功</span></span><br><span class="line">                    compareAndSetState(c, c + SHARED_UNIT)</span><br><span class="line">    ) &#123;</span><br><span class="line">        <span class="comment">// ... 省略不重要的代码</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fullTryAcquireShared(current);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 非公平锁 readerShouldBlock 看 AQS 队列中第一个节点是否是写锁</span></span><br><span class="line"><span class="comment">// true 则该阻塞, false 则不阻塞</span></span><br><span class="line"><span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">readerShouldBlock</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> apparentlyFirstQueuedIsExclusive();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// AQS 继承过来的方法, 方便阅读, 放在此处</span></span><br><span class="line"><span class="comment">// 与 tryAcquireShared 功能类似, 但会不断尝试 for (;;) 获取读锁, 执行过程中无阻塞</span></span><br><span class="line"><span class="keyword">final</span> <span class="type">int</span> <span class="title function_">fullTryAcquireShared</span><span class="params">(Thread current)</span> &#123;</span><br><span class="line">    <span class="type">HoldCounter</span> <span class="variable">rh</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> getState();</span><br><span class="line">        <span class="keyword">if</span> (exclusiveCount(c) != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (getExclusiveOwnerThread() != current)</span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (readerShouldBlock()) &#123;</span><br><span class="line">            <span class="comment">// ... 省略不重要的代码</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (sharedCount(c) == MAX_COUNT)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(c, c + SHARED_UNIT)) &#123;</span><br><span class="line">            <span class="comment">// ... 省略不重要的代码</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// AQS 继承过来的方法, 方便阅读, 放在此处</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">doAcquireShared</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">    <span class="comment">// 将当前线程关联到一个 Node 对象上, 模式为共享模式</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> addWaiter(Node.SHARED);</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">failed</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">interrupted</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">p</span> <span class="operator">=</span> node.predecessor();</span><br><span class="line">            <span class="keyword">if</span> (p == head) &#123;</span><br><span class="line">                <span class="comment">// 再一次尝试获取读锁</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> tryAcquireShared(arg);</span><br><span class="line">                <span class="comment">// 成功</span></span><br><span class="line">                <span class="keyword">if</span> (r &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">// ㈠</span></span><br><span class="line">					<span class="comment">// r 表示可用资源数, 在这里总是 1 允许传播</span></span><br><span class="line">                    <span class="comment">//（唤醒 AQS 中下一个 Share 节点）</span></span><br><span class="line">                    setHeadAndPropagate(node, r);</span><br><span class="line">                    p.next = <span class="literal">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                    <span class="keyword">if</span> (interrupted)</span><br><span class="line">                        selfInterrupt();</span><br><span class="line">                    failed = <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (</span><br><span class="line">                <span class="comment">// 是否在获取读锁失败时阻塞（前一个阶段 waitStatus == Node.SIGNAL）</span></span><br><span class="line">                    shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                            <span class="comment">// park 当前线程</span></span><br><span class="line">                            parkAndCheckInterrupt()</span><br><span class="line">            ) &#123;</span><br><span class="line">                interrupted = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ㈠ AQS 继承过来的方法, 方便阅读, 放在此处</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">setHeadAndPropagate</span><span class="params">(Node node, <span class="type">int</span> propagate)</span> &#123;</span><br><span class="line">    <span class="type">Node</span> <span class="variable">h</span> <span class="operator">=</span> head; <span class="comment">// Record old head for check below</span></span><br><span class="line">    <span class="comment">// 设置自己为 head</span></span><br><span class="line">    setHead(node);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// propagate 表示有共享资源（例如共享读锁或信号量）</span></span><br><span class="line">    <span class="comment">// 原 head waitStatus == Node.SIGNAL 或 Node.PROPAGATE</span></span><br><span class="line">    <span class="comment">// 现在 head waitStatus == Node.SIGNAL 或 Node.PROPAGATE</span></span><br><span class="line">    <span class="keyword">if</span> (propagate &gt; <span class="number">0</span> || h == <span class="literal">null</span> || h.waitStatus &lt; <span class="number">0</span> ||</span><br><span class="line">            (h = head) == <span class="literal">null</span> || h.waitStatus &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">s</span> <span class="operator">=</span> node.next;</span><br><span class="line">        <span class="comment">// 如果是最后一个节点或者是等待共享读锁的节点</span></span><br><span class="line">        <span class="keyword">if</span> (s == <span class="literal">null</span> || s.isShared()) &#123;</span><br><span class="line">            <span class="comment">// 进入 ㈡</span></span><br><span class="line">            doReleaseShared();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ㈡ AQS 继承过来的方法, 方便阅读, 放在此处</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">doReleaseShared</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 如果 head.waitStatus == Node.SIGNAL ==&gt; 0 成功, 下一个节点 unpark</span></span><br><span class="line">    <span class="comment">// 如果 head.waitStatus == 0 ==&gt; Node.PROPAGATE</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">h</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="comment">// 队列还有节点</span></span><br><span class="line">        <span class="keyword">if</span> (h != <span class="literal">null</span> &amp;&amp; h != tail) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">ws</span> <span class="operator">=</span> h.waitStatus;</span><br><span class="line">            <span class="keyword">if</span> (ws == Node.SIGNAL) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!compareAndSetWaitStatus(h, Node.SIGNAL, <span class="number">0</span>))</span><br><span class="line">                    <span class="keyword">continue</span>; <span class="comment">// loop to recheck cases</span></span><br><span class="line">                <span class="comment">// 下一个节点 unpark 如果成功获取读锁</span></span><br><span class="line">                <span class="comment">// 并且下下个节点还是 shared, 继续 doReleaseShared</span></span><br><span class="line">                unparkSuccessor(h);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (ws == <span class="number">0</span> &amp;&amp;</span><br><span class="line">                    !compareAndSetWaitStatus(h, <span class="number">0</span>, Node.PROPAGATE))</span><br><span class="line">                <span class="keyword">continue</span>; <span class="comment">// loop on failed CAS</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (h == head) <span class="comment">// loop if head changed</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>读锁释放流程：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">NonfairSync</span> <span class="keyword">extends</span> <span class="title class_">Sync</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ReadLock 方法, 方便阅读, 放在此处</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span> &#123;</span><br><span class="line">        sync.releaseShared(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// AQS 继承过来的方法, 方便阅读, 放在此处</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">releaseShared</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (tryReleaseShared(arg)) &#123;</span><br><span class="line">            doReleaseShared();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Sync 继承过来的方法, 方便阅读, 放在此处</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">tryReleaseShared</span><span class="params">(<span class="type">int</span> unused)</span> &#123;</span><br><span class="line">        <span class="comment">// ... 省略不重要的代码</span></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> getState();</span><br><span class="line">            <span class="type">int</span> <span class="variable">nextc</span> <span class="operator">=</span> c - SHARED_UNIT;</span><br><span class="line">            <span class="keyword">if</span> (compareAndSetState(c, nextc)) &#123;</span><br><span class="line">                <span class="comment">// 读锁的计数不会影响其它获取读锁线程, 但会影响其它获取写锁线程</span></span><br><span class="line">                <span class="comment">// 计数为 0 才是真正释放</span></span><br><span class="line">                <span class="type">return</span> <span class="variable">nextc</span> <span class="operator">=</span>= <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// AQS 继承过来的方法, 方便阅读, 放在此处</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">doReleaseShared</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 如果 head.waitStatus == Node.SIGNAL ==&gt; 0 成功, 下一个节点 unpark</span></span><br><span class="line">        <span class="comment">// 如果 head.waitStatus == 0 ==&gt; Node.PROPAGATE</span></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="type">Node</span> <span class="variable">h</span> <span class="operator">=</span> head;</span><br><span class="line">            <span class="keyword">if</span> (h != <span class="literal">null</span> &amp;&amp; h != tail) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">ws</span> <span class="operator">=</span> h.waitStatus;</span><br><span class="line">                <span class="comment">// 如果有其它线程也在释放读锁，那么需要将 waitStatus 先改为 0</span></span><br><span class="line">                <span class="comment">// 防止 unparkSuccessor 被多次执行</span></span><br><span class="line">                <span class="keyword">if</span> (ws == Node.SIGNAL) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!compareAndSetWaitStatus(h, Node.SIGNAL, <span class="number">0</span>))</span><br><span class="line">                        <span class="keyword">continue</span>; <span class="comment">// loop to recheck cases</span></span><br><span class="line">                    unparkSuccessor(h);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 如果已经是 0 了，改为 -3，用来解决传播性，见后文信号量 bug 分析</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (ws == <span class="number">0</span> &amp;&amp;</span><br><span class="line">                        !compareAndSetWaitStatus(h, <span class="number">0</span>, Node.PROPAGATE))</span><br><span class="line">                    <span class="keyword">continue</span>; <span class="comment">// loop on failed CAS</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (h == head) <span class="comment">// loop if head changed</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="StampedLock"><a href="#StampedLock" class="headerlink" title="StampedLock"></a>StampedLock</h5><p>该类自 JDK 8 加入，是为了进一步优化读性能，它的特点是在使用读锁、写锁时都必须配合【戳】使用。</p>
<p><strong>加解读锁</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">long</span> <span class="variable">stamp</span> <span class="operator">=</span> lock.readLock();</span><br><span class="line">lock.unlockRead(stamp);</span><br></pre></td></tr></table></figure>

<p><strong>加解写锁</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">long</span> <span class="variable">stamp</span> <span class="operator">=</span> lock.writeLock();</span><br><span class="line">lock.unlockWrite(stamp);</span><br></pre></td></tr></table></figure>

<p>StampedLock 支持 tryOptimisticRead() 方法（乐观读），读取完毕后需要做一次戳校验，如果校验通过，表示这期间确实没有写操作，数据可以安全使用，如果校验没通过，需要重新获取读锁，保证数据安全。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">long</span> <span class="variable">stamp</span> <span class="operator">=</span> lock.tryOptimisticRead();</span><br><span class="line"><span class="comment">// 验戳</span></span><br><span class="line"><span class="keyword">if</span>(!lock.validate(stamp))&#123;</span><br><span class="line"> <span class="comment">// 锁升级</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>示例：提供一个数据容器类内部分别使用读锁保护数据的 read() 方法，写锁保护数据的 write() 方法。代码实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StampedLockTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">StampedLockDataContainer</span> <span class="variable">dataContainer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StampedLockDataContainer</span>(<span class="number">1</span>);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(dataContainer.read(<span class="number">1</span>));</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;t1&quot;</span>);</span><br><span class="line"></span><br><span class="line">        t1.start();</span><br><span class="line"></span><br><span class="line">        TimeUnit.MILLISECONDS.sleep(<span class="number">500</span>);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            dataContainer.write(<span class="number">10</span>);</span><br><span class="line">        &#125;, <span class="string">&quot;t2&quot;</span>);</span><br><span class="line"></span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">StampedLockDataContainer</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> data;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">StampedLock</span> <span class="variable">stampedLock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StampedLock</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">StampedLockDataContainer</span><span class="params">(<span class="type">int</span> data)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.data = data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">read</span><span class="params">(<span class="type">int</span> readTime)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">stamp</span> <span class="operator">=</span> stampedLock.tryOptimisticRead();</span><br><span class="line">        log.info(<span class="string">&quot;optimistic read locking ...&#123;&#125;&quot;</span>, stamp);</span><br><span class="line">        Thread.sleep(readTime * <span class="number">1000</span>);</span><br><span class="line">        <span class="keyword">if</span> (stampedLock.validate(stamp)) &#123;</span><br><span class="line">            log.info(<span class="string">&quot;read finish... &#123;&#125;&quot;</span>, stamp);</span><br><span class="line">            <span class="keyword">return</span> data;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 锁升级 - 读锁</span></span><br><span class="line">        log.info(<span class="string">&quot;update to read lock ...&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            stamp = stampedLock.readLock();</span><br><span class="line">            log.info(<span class="string">&quot;read lock &#123;&#125;&quot;</span>, stamp);</span><br><span class="line">            Thread.sleep(readTime * <span class="number">1000</span>);</span><br><span class="line">            log.info(<span class="string">&quot;read finish ... &#123;&#125;&quot;</span>, stamp);</span><br><span class="line">            <span class="keyword">return</span> data;</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            stampedLock.unlockRead(stamp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">write</span><span class="params">(<span class="type">int</span> newData)</span> &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">stamp</span> <span class="operator">=</span> stampedLock.writeLock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            log.info(<span class="string">&quot;write lock &#123;&#125;&quot;</span>, stamp);</span><br><span class="line">            <span class="built_in">this</span>.data = newData;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            log.info(<span class="string">&quot;write finish ... &#123;&#125;&quot;</span>, stamp);</span><br><span class="line">            log.info(<span class="string">&quot;write newData ... &#123;&#125;&quot;</span>, <span class="built_in">this</span>.data);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            stampedLock.unlockWrite(stamp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">16</span>:<span class="number">30</span>:<span class="number">13.011</span> [t1] INFO com.heu.test.StampedLockDataContainer - optimistic read locking ..<span class="number">.256</span></span><br><span class="line"><span class="number">16</span>:<span class="number">30</span>:<span class="number">13.519</span> [t2] INFO com.heu.test.StampedLockDataContainer - write lock <span class="number">384</span></span><br><span class="line"><span class="number">16</span>:<span class="number">30</span>:<span class="number">14.031</span> [t1] INFO com.heu.test.StampedLockDataContainer - update to read lock ...</span><br><span class="line"><span class="number">16</span>:<span class="number">30</span>:<span class="number">14.523</span> [t2] INFO com.heu.test.StampedLockDataContainer - write finish ... <span class="number">384</span></span><br><span class="line"><span class="number">16</span>:<span class="number">30</span>:<span class="number">14.524</span> [t2] INFO com.heu.test.StampedLockDataContainer - write newData ... <span class="number">10</span></span><br><span class="line"><span class="number">16</span>:<span class="number">30</span>:<span class="number">14.525</span> [t1] INFO com.heu.test.StampedLockDataContainer - read lock <span class="number">513</span></span><br><span class="line"><span class="number">16</span>:<span class="number">30</span>:<span class="number">15.533</span> [t1] INFO com.heu.test.StampedLockDataContainer - read finish ... <span class="number">513</span></span><br><span class="line"><span class="number">10</span></span><br></pre></td></tr></table></figure>

<p>注意：</p>
<ul>
<li>StampedLock 不支持条件变量</li>
<li>StampedLock 不支持可重入</li>
</ul>
<h4 id="Semaphore"><a href="#Semaphore" class="headerlink" title="Semaphore"></a>Semaphore</h4><h5 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h5><p>信号量，用来限制能同时访问共享资源的线程上限。示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SemaphoreTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//1.创建一个对象</span></span><br><span class="line">        <span class="type">Semaphore</span> <span class="variable">semaphore</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Semaphore</span>(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.开10个线程</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">                <span class="comment">//获取一个许可</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    semaphore.acquire();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    log.info(<span class="string">&quot;start...&quot;</span>);</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                    log.info(<span class="string">&quot;end...&quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                    semaphore.release();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,<span class="string">&quot;t&quot;</span>+(i+<span class="number">1</span>)).start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">16</span>:<span class="number">43</span>:<span class="number">36.143</span> [t2] INFO com.heu.test.SemaphoreTest - start...</span><br><span class="line"><span class="number">16</span>:<span class="number">43</span>:<span class="number">36.143</span> [t3] INFO com.heu.test.SemaphoreTest - start...</span><br><span class="line"><span class="number">16</span>:<span class="number">43</span>:<span class="number">36.143</span> [t1] INFO com.heu.test.SemaphoreTest - start...</span><br><span class="line"><span class="number">16</span>:<span class="number">43</span>:<span class="number">37.154</span> [t1] INFO com.heu.test.SemaphoreTest - end...</span><br><span class="line"><span class="number">16</span>:<span class="number">43</span>:<span class="number">37.154</span> [t3] INFO com.heu.test.SemaphoreTest - end...</span><br><span class="line"><span class="number">16</span>:<span class="number">43</span>:<span class="number">37.155</span> [t2] INFO com.heu.test.SemaphoreTest - end...</span><br><span class="line"><span class="number">16</span>:<span class="number">43</span>:<span class="number">37.156</span> [t4] INFO com.heu.test.SemaphoreTest - start...</span><br><span class="line"><span class="number">16</span>:<span class="number">43</span>:<span class="number">37.155</span> [t10] INFO com.heu.test.SemaphoreTest - start...</span><br><span class="line"><span class="number">16</span>:<span class="number">43</span>:<span class="number">37.156</span> [t6] INFO com.heu.test.SemaphoreTest - start...</span><br><span class="line"><span class="number">16</span>:<span class="number">43</span>:<span class="number">38.162</span> [t4] INFO com.heu.test.SemaphoreTest - end...</span><br><span class="line"><span class="number">16</span>:<span class="number">43</span>:<span class="number">38.162</span> [t6] INFO com.heu.test.SemaphoreTest - end...</span><br><span class="line"><span class="number">16</span>:<span class="number">43</span>:<span class="number">38.162</span> [t10] INFO com.heu.test.SemaphoreTest - end...</span><br><span class="line"><span class="number">16</span>:<span class="number">43</span>:<span class="number">38.162</span> [t9] INFO com.heu.test.SemaphoreTest - start...</span><br><span class="line"><span class="number">16</span>:<span class="number">43</span>:<span class="number">38.163</span> [t7] INFO com.heu.test.SemaphoreTest - start...</span><br><span class="line"><span class="number">16</span>:<span class="number">43</span>:<span class="number">38.163</span> [t8] INFO com.heu.test.SemaphoreTest - start...</span><br><span class="line"><span class="number">16</span>:<span class="number">43</span>:<span class="number">39.174</span> [t9] INFO com.heu.test.SemaphoreTest - end...</span><br><span class="line"><span class="number">16</span>:<span class="number">43</span>:<span class="number">39.174</span> [t7] INFO com.heu.test.SemaphoreTest - end...</span><br><span class="line"><span class="number">16</span>:<span class="number">43</span>:<span class="number">39.174</span> [t5] INFO com.heu.test.SemaphoreTest - start...</span><br><span class="line"><span class="number">16</span>:<span class="number">43</span>:<span class="number">39.174</span> [t8] INFO com.heu.test.SemaphoreTest - end...</span><br><span class="line"><span class="number">16</span>:<span class="number">43</span>:<span class="number">40.181</span> [t5] INFO com.heu.test.SemaphoreTest - end...</span><br></pre></td></tr></table></figure>

<h5 id="Semaphore原理"><a href="#Semaphore原理" class="headerlink" title="Semaphore原理"></a>Semaphore原理</h5><p>Semaphore 有点像一个停车场，permits 就好像停车位数量，当线程获得了 permits 就像是获得了停车位，然后停车场显示空余车位减一。如下示例：刚开始 permits（state）为 3，这时 5 个线程来获取资源：</p>
<p>假设其中 Thread-1，Thread-2，Thread-4 cas 竞争成功，而 Thread-0 和 Thread-3 竞争失败，进入 AQS 队列park 阻塞。</p>
<p>这时 Thread-4 释放了 permits，状态如下：</p>
<p>接下来 Thread-0 竞争成功，permits 再次设置为 0，设置自己为 head 节点，断开原来的 head 节点，unpark 接下来的 Thread-3 节点，但由于 permits 是 0，因此 Thread-3 在尝试不成功后再次进入 park 状态。</p>
<h5 id="源码分析-1"><a href="#源码分析-1" class="headerlink" title="源码分析"></a><strong>源码分析</strong></h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">NonfairSync</span> <span class="keyword">extends</span> <span class="title class_">Sync</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> -<span class="number">2694183684443567898L</span>;</span><br><span class="line">    NonfairSync(<span class="type">int</span> permits) &#123;</span><br><span class="line">        <span class="comment">// permits 即 state</span></span><br><span class="line">        <span class="built_in">super</span>(permits);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Semaphore 方法, 方便阅读, 放在此处</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">acquire</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        sync.acquireSharedInterruptibly(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// AQS 继承过来的方法, 方便阅读, 放在此处</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">acquireSharedInterruptibly</span><span class="params">(<span class="type">int</span> arg)</span></span><br><span class="line">            <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InterruptedException</span>();</span><br><span class="line">        <span class="keyword">if</span> (tryAcquireShared(arg) &lt; <span class="number">0</span>)</span><br><span class="line">            doAcquireSharedInterruptibly(arg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 尝试获得共享锁</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="type">int</span> <span class="title function_">tryAcquireShared</span><span class="params">(<span class="type">int</span> acquires)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> nonfairTryAcquireShared(acquires);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Sync 继承过来的方法, 方便阅读, 放在此处</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">nonfairTryAcquireShared</span><span class="params">(<span class="type">int</span> acquires)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">available</span> <span class="operator">=</span> getState();</span><br><span class="line">            <span class="type">int</span> <span class="variable">remaining</span> <span class="operator">=</span> available - acquires;</span><br><span class="line">            <span class="keyword">if</span> (</span><br><span class="line">                   <span class="comment">// 如果许可已经用完, 返回负数, 表示获取失败, 进入 doAcquireSharedInterruptibly</span></span><br><span class="line">                    remaining &lt; <span class="number">0</span> ||</span><br><span class="line">                            <span class="comment">// 如果 cas 重试成功, 返回正数, 表示获取成功</span></span><br><span class="line">                            compareAndSetState(available, remaining)</span><br><span class="line">            ) &#123;</span><br><span class="line">                <span class="keyword">return</span> remaining;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// AQS 继承过来的方法, 方便阅读, 放在此处</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">doAcquireSharedInterruptibly</span><span class="params">(<span class="type">int</span> arg)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> addWaiter(Node.SHARED);</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">failed</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">p</span> <span class="operator">=</span> node.predecessor();</span><br><span class="line">                <span class="keyword">if</span> (p == head) &#123;</span><br><span class="line">                    <span class="comment">// 再次尝试获取许可</span></span><br><span class="line">                    <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> tryAcquireShared(arg);</span><br><span class="line">                    <span class="keyword">if</span> (r &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="comment">// 成功后本线程出队（AQS）, 所在 Node设置为 head</span></span><br><span class="line">                        <span class="comment">// 如果 head.waitStatus == Node.SIGNAL ==&gt; 0 成功, 下一个节点 unpark</span></span><br><span class="line">                        <span class="comment">// 如果 head.waitStatus == 0 ==&gt; Node.PROPAGATE</span></span><br><span class="line">					  <span class="comment">// r 表示可用资源数, 为 0 则不会继续传播</span></span><br><span class="line">                        setHeadAndPropagate(node, r);</span><br><span class="line">                        p.next = <span class="literal">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                        failed = <span class="literal">false</span>;</span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 不成功, 设置上一个节点 waitStatus = Node.SIGNAL, 下轮进入 park 阻塞</span></span><br><span class="line">                <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                        parkAndCheckInterrupt())</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InterruptedException</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (failed)</span><br><span class="line">                cancelAcquire(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Semaphore 方法, 方便阅读, 放在此处</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">release</span><span class="params">()</span> &#123;</span><br><span class="line">        sync.releaseShared(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// AQS 继承过来的方法, 方便阅读, 放在此处</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">releaseShared</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (tryReleaseShared(arg)) &#123;</span><br><span class="line">            doReleaseShared();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Sync 继承过来的方法, 方便阅读, 放在此处</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">tryReleaseShared</span><span class="params">(<span class="type">int</span> releases)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">current</span> <span class="operator">=</span> getState();</span><br><span class="line">            <span class="type">int</span> <span class="variable">next</span> <span class="operator">=</span> current + releases;</span><br><span class="line">            <span class="keyword">if</span> (next &lt; current) <span class="comment">// overflow</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;Maximum permit count exceeded&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span> (compareAndSetState(current, next))</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>method1 输出：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">17</span>:<span class="number">18</span>:<span class="number">12.575</span> [main] INFO com.heu.test.CountDownLatchTest - main wait ...</span><br><span class="line"><span class="number">17</span>:<span class="number">18</span>:<span class="number">12.575</span> [t2] INFO com.heu.test.CountDownLatchTest - t2 start ...</span><br><span class="line"><span class="number">17</span>:<span class="number">18</span>:<span class="number">12.575</span> [t1] INFO com.heu.test.CountDownLatchTest - t1 start ...</span><br><span class="line"><span class="number">17</span>:<span class="number">18</span>:<span class="number">12.575</span> [t3] INFO com.heu.test.CountDownLatchTest - t3 start ...</span><br><span class="line"><span class="number">17</span>:<span class="number">18</span>:<span class="number">13.592</span> [t1] INFO com.heu.test.CountDownLatchTest - t1 end ...</span><br><span class="line"><span class="number">17</span>:<span class="number">18</span>:<span class="number">14.098</span> [t3] INFO com.heu.test.CountDownLatchTest - t3 end ...</span><br><span class="line"><span class="number">17</span>:<span class="number">18</span>:<span class="number">14.590</span> [t2] INFO com.heu.test.CountDownLatchTest - t2 end ...</span><br><span class="line"><span class="number">17</span>:<span class="number">18</span>:<span class="number">14.590</span> [main] INFO com.heu.test.CountDownLatchTest - main wait end ...</span><br></pre></td></tr></table></figure>

<p>method2 输出：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">17</span>:<span class="number">23</span>:<span class="number">07.829</span> [pool-<span class="number">1</span>-thread-<span class="number">4</span>] INFO com.heu.test.CountDownLatchTest - main wait...</span><br><span class="line"><span class="number">17</span>:<span class="number">23</span>:<span class="number">07.829</span> [pool-<span class="number">1</span>-thread-<span class="number">2</span>] INFO com.heu.test.CountDownLatchTest - t2 start ...</span><br><span class="line"><span class="number">17</span>:<span class="number">23</span>:<span class="number">07.829</span> [pool-<span class="number">1</span>-thread-<span class="number">3</span>] INFO com.heu.test.CountDownLatchTest - t3 start ...</span><br><span class="line"><span class="number">17</span>:<span class="number">23</span>:<span class="number">07.829</span> [pool-<span class="number">1</span>-thread-<span class="number">1</span>] INFO com.heu.test.CountDownLatchTest - t1 start ...</span><br><span class="line"><span class="number">17</span>:<span class="number">23</span>:<span class="number">08.854</span> [pool-<span class="number">1</span>-thread-<span class="number">1</span>] INFO com.heu.test.CountDownLatchTest - t1 end ..<span class="number">.2</span></span><br><span class="line"><span class="number">17</span>:<span class="number">23</span>:<span class="number">09.344</span> [pool-<span class="number">1</span>-thread-<span class="number">3</span>] INFO com.heu.test.CountDownLatchTest - t3 end ..<span class="number">.2</span></span><br><span class="line"><span class="number">17</span>:<span class="number">23</span>:<span class="number">09.851</span> [pool-<span class="number">1</span>-thread-<span class="number">2</span>] INFO com.heu.test.CountDownLatchTest - t2 end ..<span class="number">.1</span></span><br><span class="line"><span class="number">17</span>:<span class="number">23</span>:<span class="number">09.851</span> [pool-<span class="number">1</span>-thread-<span class="number">4</span>] INFO com.heu.test.CountDownLatchTest - main wait end ...</span><br></pre></td></tr></table></figure>

<p>method3 输出：当所有线程全部加载完毕，输出游戏开始，类似王者荣耀！</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">[<span class="number">100</span>%, <span class="number">100</span>%, <span class="number">100</span>%, <span class="number">100</span>%, <span class="number">100</span>%, <span class="number">100</span>%, <span class="number">100</span>%, <span class="number">100</span>%, <span class="number">100</span>%, <span class="number">100</span>%]</span><br><span class="line">游戏开始</span><br></pre></td></tr></table></figure>

<h4 id="CyclicBarrier"><a href="#CyclicBarrier" class="headerlink" title="CyclicBarrier"></a>CyclicBarrier</h4><p>CyclicBarri[ˈsaɪklɪk ˈbæriɚ]：循环栅栏，用来进行线程协作，等待线程满足某个计数。构造时设置『计数个数』，每个线程执行到某个需要“同步”的时刻调用 await() 方法进行等待，当等待的线程数满足『计数个数』时，继续执行。跟 CountdownLatch 一样，但这个可以重用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">       <span class="type">ExecutorService</span> <span class="variable">executorService</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">2</span>);</span><br><span class="line">       <span class="type">CyclicBarrier</span> <span class="variable">cyclicBarrier</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CyclicBarrier</span>(<span class="number">2</span>, () -&gt; &#123;</span><br><span class="line">           log.info(<span class="string">&quot;task2 finish ...&quot;</span>);</span><br><span class="line">       &#125;);</span><br><span class="line"></span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">           executorService.submit(() -&gt; &#123;</span><br><span class="line">               log.info(<span class="string">&quot;task1 begin ...&quot;</span>);</span><br><span class="line">               <span class="keyword">try</span> &#123;</span><br><span class="line">                   Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                   cyclicBarrier.await();</span><br><span class="line">               &#125; <span class="keyword">catch</span> (InterruptedException | BrokenBarrierException e) &#123;</span><br><span class="line">                   e.printStackTrace();</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;);</span><br><span class="line">           executorService.submit(() -&gt; &#123;</span><br><span class="line">               log.info(<span class="string">&quot;task2 begin ...&quot;</span>);</span><br><span class="line">               <span class="keyword">try</span> &#123;</span><br><span class="line">                   Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">                   cyclicBarrier.await();</span><br><span class="line">               &#125; <span class="keyword">catch</span> (InterruptedException | BrokenBarrierException e) &#123;</span><br><span class="line">                   e.printStackTrace();</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;);</span><br><span class="line">       &#125;</span><br><span class="line">       executorService.shutdown();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>多线程与高并发</category>
      </categories>
      <tags>
        <tag>多线程与高并发</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis</title>
    <url>/2021/05/02/Redis/</url>
    <content><![CDATA[<h1 id="Redis小试牛刀"><a href="#Redis小试牛刀" class="headerlink" title="Redis小试牛刀"></a>Redis小试牛刀</h1><span id="more"></span>

<h2 id="Redis概述"><a href="#Redis概述" class="headerlink" title="Redis概述"></a>Redis概述</h2><h3 id="Redis介绍"><a href="#Redis介绍" class="headerlink" title="Redis介绍"></a>Redis介绍</h3><ul>
<li>Redis是一个开源的key-value存储系统。</li>
<li>和Memcached类似，它支持存储的value类型相对更多，包括string(字符串)、list(链表)、set(集合)、zset(sorted set –有序集合)和hash（哈希类型）。</li>
<li>这些数据类型都支持push&#x2F;pop、add&#x2F;remove及取交集并集和差集及更丰富的操作，而且这些操作都是原子性的。</li>
<li>在此基础上，Redis支持各种不同方式的排序。</li>
<li>与memcached一样，为了保证效率，数据都是缓存在内存中。</li>
<li>区别的是Redis会周期性的把更新的数据写入磁盘或者把修改操作写入追加的记录文件。</li>
<li>并且在此基础上实现了master-slave(主从)同步。</li>
</ul>
<h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><p><strong>配合关系型数据库做高速缓存</strong></p>
<ul>
<li><p>高频次，热门访问的数据，降低数据库IO。</p>
</li>
<li><p>分布式架构，做session共享。</p>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210618160003509.png" alt="image-20210618160003509"></p>
<p><strong>多样的数据结构存储持久化数据</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210618160101040.png" alt="image-20210618160101040"></p>
<h3 id="相关技术"><a href="#相关技术" class="headerlink" title="相关技术"></a>相关技术</h3><p><strong>Redis使用的是单线程+多路IO复用技术：</strong></p>
<p>多路复用是指使用一个线程来检查多个文件描述符（Socket）的就绪状态，比如调用select和poll函数，传入多个文件描述符，如果有一个文件描述符就绪，则返回，否则阻塞直到超时。得到就绪状态后进行真正的操作可以在同一个线程里执行，也可以启动线程执行（比如使用线程池）。</p>
<p>**串行  vs  多线程+锁（memcached） vs  单线程+多路IO复用(Redis)**（与Memcache三点不同: 支持多数据类型，支持持久化，单线程+多路IO复用） 。</p>
<h2 id="Redis数据类型"><a href="#Redis数据类型" class="headerlink" title="Redis数据类型"></a>Redis数据类型</h2><h3 id="Redis字符串-String"><a href="#Redis字符串-String" class="headerlink" title="Redis字符串(String)"></a><strong>Redis</strong>字符串(String)</h3><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><ol>
<li><p>String是Redis最基本的类型，你可以理解成与Memcached一模一样的类型，一个key对应一个value。</p>
</li>
<li><p>String类型是二进制安全的。意味着Redis的string可以包含任何数据。比如jpg图片或者序列化的对象。</p>
</li>
<li><p>String类型是Redis最基本的数据类型，一个Redis中字符串value最多可以是512M。</p>
</li>
</ol>
<h4 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h4><p>String的数据结构为简单动态字符串(Simple Dynamic String,缩写SDS)，是可以修改的字符串，内部结构实现上类似于Java的ArrayList，采用预分配冗余空间的方式来减少内存的频繁分配.</p>
<img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210618162745983.png" alt="image-20210618162745983" style="zoom:120%;">

<p>如图中所示，内部为当前字符串实际分配的空间capacity一般要高于实际字符串长度len。当字符串长度小于1M时，扩容都是加倍现有的空间，如果超过1M，扩容时一次只会多扩1M的空间。需要注意的是字符串最大长度为512M。</p>
<h3 id="Redis列表（List"><a href="#Redis列表（List" class="headerlink" title="Redis列表（List)"></a>Redis列表（List)</h3><h4 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h4><p>单键多值：Redis 列表是简单的字符串列表，按照插入顺序排序。你可以添加一个元素到列表的头部（左边）或者尾部（右边）。它的底</p>
<p>层实际是个<strong>双向链表</strong>，对两端的操作性能很高，通过索引下标的操作中间的节点性能会较差。</p>
<img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210618163018649.png" alt="image-20210618163018649" style="zoom:120%;">

<h4 id="数据结构-1"><a href="#数据结构-1" class="headerlink" title="数据结构"></a>数据结构</h4><ul>
<li>List的数据结构为快速链表quickList。</li>
<li>首先在列表元素较少的情况下会使用一块连续的内存存储，这个结构是ziplist，也即是压缩列表。它将所有的元素紧挨着一起存储，分配的是一块连续的内存。</li>
<li>当数据量比较多的时候才会改成quicklist。因为普通的链表需要的附加指针空间太大，会比较浪费空间。比如这个列表里存的只是int类型的数据，结构上还需要两个额外的指针prev和next。</li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210618164459005.png" alt="image-20210618164459005" style="zoom:120%;">

<ul>
<li>Redis将链表和ziplist结合起来组成了quicklist。也就是将多个ziplist使用双向指针串起来使用。这样既满足了快速的插入删除性能，又不会出现太大的空间冗余。</li>
</ul>
<h3 id="Redis集合（Set）"><a href="#Redis集合（Set）" class="headerlink" title="Redis集合（Set）"></a>Redis集合（Set）</h3><h4 id="概述-2"><a href="#概述-2" class="headerlink" title="概述"></a>概述</h4><ul>
<li><p>Redis set对外提供的功能与list类似，是一个列表的功能，特殊之处在于set是可以<strong>自动排重</strong>的，当你需要存储一个列表数据，又不希望出现重复数据时，set是一个很好的选择，并且set提供了判断某个成员是否在一个set集合内的重要接口，这个也是list所不能提供的。</p>
</li>
<li><p>Redis的Set是string类型的无序集合。它底层其实是一个value为null的hash表，所以添加，删除，查找的**复杂度都是O(1)**。</p>
</li>
<li><p>一个算法，随着数据的增加，执行时间的长短，如果是O(1)，数据增加，查找数据的时间不变。</p>
</li>
</ul>
<h4 id="数据结构-2"><a href="#数据结构-2" class="headerlink" title="数据结构"></a>数据结构</h4><ul>
<li>Set数据结构是dict字典，字典是用哈希表实现的。</li>
<li>Java中HashSet的内部实现使用的是HashMap，只不过所有的value都指向同一个对象。Redis的set结构也是一样，它的内部也使用hash结构，所有的value都指向同一个内部值。</li>
</ul>
<h3 id="Redis哈希（Hash）"><a href="#Redis哈希（Hash）" class="headerlink" title="Redis哈希（Hash）"></a>Redis哈希（Hash）</h3><h4 id="概述-3"><a href="#概述-3" class="headerlink" title="概述"></a>概述</h4><ul>
<li><p>Redis hash 是一个键值对集合。</p>
</li>
<li><p>Redis hash是一个string类型的field和value的映射表，hash特别适合用于存储对象。</p>
</li>
<li><p>类似Java里面的Map&lt;String,Object&gt;。</p>
</li>
<li><p>用户ID为查找的key，存储的value用户对象包含姓名，年龄，生日等信息，如果用普通的key&#x2F;value结构来存储，主要有以下2种存储方式：</p>
<p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210618203434868.png" alt="image-20210618203434868" style="zoom:120%;">                    <img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210618203449210.png" alt="image-20210618203449210" style="zoom:120%;"></p>
<p>方法一：每次修改用户的某个属性需要，先反序列化改好后再序列化回去。开销较大。</p>
<p>方法二：用户ID数据冗余。</p>
</li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210618203718979.png" alt="image-20210618203718979" style="zoom:120%;">

<p>通过 key(用户ID) + field(属性标签) 就可以操作对应属性数据了，既不需要重复存储数据，也不会带来序列化和并发修改控制的问题。</p>
<h4 id="数据结构-3"><a href="#数据结构-3" class="headerlink" title="数据结构"></a>数据结构</h4><p>Hash类型对应的数据结构是两种：ziplist（压缩列表），hashtable（哈希表）。当field-value长度较短且个数较少时，使用ziplist，否则使用hashtable。</p>
<h3 id="Redis有序集合Zset（Sorted-set）"><a href="#Redis有序集合Zset（Sorted-set）" class="headerlink" title="Redis有序集合Zset（Sorted set）"></a>Redis有序集合Zset（Sorted set）</h3><h4 id="概述-4"><a href="#概述-4" class="headerlink" title="概述"></a>概述</h4><ul>
<li><p>Redis有序集合zset与普通集合set非常相似，是一个没有重复元素的字符串集合。</p>
</li>
<li><p>不同之处是有序集合的每个成员都关联了一个<strong>评分（</strong>score），这个评分（score）被用来按照从最低分到最高分的方式排序集合中的成员。集合的成员是唯一的，但是评分可以是重复了 。</p>
</li>
<li><p>因为元素是有序的，所以你也可以很快的根据评分（score）或者次序（position）来获取一个范围的元素。</p>
</li>
<li><p>访问有序集合的中间元素也是非常快的，因此你能够使用有序集合作为一个没有重复成员的智能列表。</p>
</li>
</ul>
<h4 id="数据结构-4"><a href="#数据结构-4" class="headerlink" title="数据结构"></a>数据结构</h4><p>SortedSet(zset)是Redis提供的一个非常特别的数据结构，一方面它等价于Java的数据结构Map&lt;String, Double&gt;，可以给每一个元素value赋予一个权重score，另一方面它又类似于TreeSet，内部的元素会按照权重score进行排序，可以得到每个元素的名次，还可以通过score的范围来获取元素的列表。</p>
<p>zset底层使用了两个数据结构：</p>
<ol>
<li><p>hash，hash的作用就是关联元素value和权重score，保障元素value的唯一性，可以通过元素value找到相应的score值。</p>
</li>
<li><p>跳跃表，跳跃表的目的在于给元素value排序，根据score的范围获取元素列表。</p>
</li>
</ol>
<h4 id="跳跃表"><a href="#跳跃表" class="headerlink" title="跳跃表"></a>跳跃表</h4><p><strong>简介</strong></p>
<p>有序集合在生活中比较常见，例如根据成绩对学生排名，根据得分对玩家排名等。对于有序集合的底层实现，可以用数组、平衡树、链表等。数组不便元素的插入、删除；平衡树或红黑树虽然效率高但结构复杂；链表查询需要遍历所有效率低。Redis采用的是跳跃表，跳跃表效率堪比红黑树，实现远比红黑树简单。</p>
<p><strong>实例</strong></p>
<p>对比有序链表和跳跃表，从链表中查询出51：</p>
<ol>
<li>有序链表</li>
</ol>
<img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210618205641992.png" alt="image-20210618205641992" style="zoom:120%;">

<p>​       要查找值为51的元素，需要从第一个元素开始依次查找、比较才能找到。共需要6次比较。</p>
<ol start="2">
<li>跳跃表</li>
</ol>
<img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210618205920332.png" alt="image-20210618205920332" style="zoom:120%;">

<ul>
<li><p>从第2层开始，1节点比51节点小，向后比较；</p>
</li>
<li><p>21节点比51节点小，继续向后比较，后面就是NULL了，所以从21节点向下到第1层；</p>
</li>
<li><p>在第1层，41节点比51节点小，继续向后，61节点比51节点大，所以从41向下；</p>
</li>
<li><p>在第0层，51节点为要查找的节点，节点被找到，共查找4次。</p>
</li>
</ul>
<p>从此可以看出跳跃表比有序链表效率要高。</p>
<h3 id="Redis-Bitmaps"><a href="#Redis-Bitmaps" class="headerlink" title="Redis Bitmaps"></a>Redis Bitmaps</h3><h4 id="概述-5"><a href="#概述-5" class="headerlink" title="概述"></a>概述</h4><p>Redis提供了Bitmaps这个“数据类型”可以实现对位的操作：</p>
<ul>
<li><p>Bitmaps本身不是一种数据类型， 实际上它就是字符串（key-value） ， 但是它可以对字符串的位进行操作。</p>
</li>
<li><p>Bitmaps单独提供了一套命令， 所以在Redis中使用Bitmaps和使用字符串的方法不太相同。 可以把Bitmaps想象成一个以位为单位的数组， 数组的每个单元只能存储0和1， 数组的下标在Bitmaps中叫做偏移量。</p>
 <img src="/.io//image-20210618212534639.png" alt="image-20210618212534639" style="zoom:120%;"></li>
</ul>
<h4 id="Bitmaps与set对比"><a href="#Bitmaps与set对比" class="headerlink" title="Bitmaps与set对比"></a><strong>Bitmaps</strong>与set对比</h4><p>假设网站有1亿用户， 每天独立访问的用户有5千万， 如果每天用集合类型和Bitmaps分别存储活跃用户可以得到表：</p>
<table>
<thead>
<tr>
<th>set和Bitmaps存储一天活跃用户对比</th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>数据类型</td>
<td>每个用户id占用空间</td>
<td>需要存储的用户量</td>
<td>全部内存量</td>
</tr>
<tr>
<td>集合</td>
<td>64位</td>
<td>50000000</td>
<td>64位*50000000 &#x3D; 400MB</td>
</tr>
<tr>
<td>Bitmaps</td>
<td>1位</td>
<td>100000000</td>
<td>1位*100000000 &#x3D; 12.5MB</td>
</tr>
</tbody></table>
<p>很明显， 这种情况下使用Bitmaps能节省很多的内存空间， 尤其是随着时间推移节省的内存还是非常可观的。</p>
<table>
<thead>
<tr>
<th>set和Bitmaps存储独立用户空间对比</th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>数据类型</td>
<td>一天</td>
<td>一个月</td>
<td>一年</td>
</tr>
<tr>
<td>集合</td>
<td>400MB</td>
<td>12GB</td>
<td>144GB</td>
</tr>
<tr>
<td>Bitmaps</td>
<td>12.5MB</td>
<td>375MB</td>
<td>4.5GB</td>
</tr>
</tbody></table>
<p>但Bitmaps并不是万金油， 假如该网站每天的独立访问用户很少， 例如只有10万（大量的僵尸用户） ， 那么两者的对比如下表所示， 很显然， 这时候使用Bitmaps就不太合适了， 因为基本上大部分位都是0。</p>
<table>
<thead>
<tr>
<th>set和Bitmaps存储一天活跃用户对比（用户比较少）</th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>数据类型</td>
<td>每个userid占用空间</td>
<td>需要存储的用户量</td>
<td>全部内存量</td>
</tr>
<tr>
<td>集合</td>
<td>64位</td>
<td>100000</td>
<td>64位*100000 &#x3D; 800KB</td>
</tr>
<tr>
<td>Bitmaps</td>
<td>1位</td>
<td>100000000</td>
<td>1位*100000000 &#x3D; 12.5MB</td>
</tr>
</tbody></table>
<h3 id="HyperLogLog"><a href="#HyperLogLog" class="headerlink" title="HyperLogLog"></a><strong>HyperLogLog</strong></h3><p> 在工作当中，我们经常会遇到与统计相关的功能需求，比如统计网站PV（PageView页面访问量），可以使用Redis的incr、incrby轻松实现。但像UV（UniqueVisitor独立访客）、独立IP数、搜索记录数等需要去重和计数的问题如何解决？这种求集合中不重复元素个数的问题称为基数问题。</p>
<p>解决基数问题有很多种方案：</p>
<ol>
<li><p>数据存储在MySQL表中，使用distinct count计算不重复个数。</p>
</li>
<li><p>使用Redis提供的hash、set、bitmaps等数据结构来处理。</p>
</li>
</ol>
<p>以上的方案结果精确，但随着数据不断增加，导致占用空间越来越大，对于非常大的数据集是不切实际的。能否能够降低一定的精度来平衡存储空间？Redis推出了HyperLogLog。</p>
<ul>
<li><p>Redis HyperLogLog 是用来做基数统计的算法，HyperLogLog 的优点是：在输入元素的数量或者体积非常非常大时，计算基数所需的空间总是固定的、并且是很小的。</p>
</li>
<li><p>在 Redis 里面，每个 HyperLogLog 键只需要花费 12 KB 内存，就可以计算接近 2^64 个不同元素的基数。这和计算基数时，元素越多耗费内存就越多的集合形成鲜明对比。</p>
</li>
<li><p>但是，因为 HyperLogLog 只会根据输入元素来计算基数，而不会储存输入元素本身，所以 HyperLogLog 不能像集合那样，返回输入的各个元素。</p>
</li>
</ul>
<p>什么是基数?</p>
<p>比如数据集 {1, 3, 5, 7, 5, 7, 8}，那么这个数据集的基数集为 {1, 3, 5 ,7, 8}，基数(不重复元素)为5。 基数估计就是在误差可接受的范围内，快速计算基数。</p>
<h3 id="Geospatial"><a href="#Geospatial" class="headerlink" title="Geospatial"></a><strong>Geospatial</strong></h3><p>Redis 3.2 中增加了对GEO类型的支持。GEO，Geographic，地理信息的缩写。该类型，就是元素的2维坐标，在地图上就是经纬度。redis基于该类型，提供了经纬度设置，查询，范围查询，距离查询，经纬度Hash等常见操作。</p>
<h2 id="Redis的发布和订阅"><a href="#Redis的发布和订阅" class="headerlink" title="Redis的发布和订阅"></a>Redis的发布和订阅</h2><h3 id="什么是发布和订阅"><a href="#什么是发布和订阅" class="headerlink" title="什么是发布和订阅"></a>什么是发布和订阅</h3><ul>
<li><p>Redis 发布订阅 (pub&#x2F;sub) 是一种消息通信模式：发送者 (pub) 发送消息，订阅者 (sub) 接收消息。</p>
</li>
<li><p>Redis 客户端可以订阅任意数量的频道。</p>
</li>
</ul>
<h3 id="Redis的发布和订阅-1"><a href="#Redis的发布和订阅-1" class="headerlink" title="Redis的发布和订阅"></a><strong>Redis</strong>的发布和订阅</h3><ol>
<li>客户端可以订阅频道如下图：</li>
</ol>
<img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210618211300027.png" alt="image-20210618211300027" style="zoom:150%;">

<ol start="2">
<li>当给这个频道发布消息后，消息就会发送给订阅的客户端：</li>
</ol>
<img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210618211401669.png" alt="image-20210618211401669" style="zoom:150%;">

<h3 id="发布订阅命令行实现"><a href="#发布订阅命令行实现" class="headerlink" title="发布订阅命令行实现"></a><strong>发布订阅命令行实现</strong></h3><ol>
<li><p>打开一个客户端订阅channel1：</p>
  <img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210618211907299.png" alt="image-20210618211907299" style="zoom: 60%;">
</li>
<li><p>打开另一个客户端，给channel1发布消息hello：</p>
  <img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210618212029799.png" alt="image-20210618212029799" style="zoom:50%;">
</li>
<li><p>打开第一个客户端可以看到发送的消息：</p>
</li>
</ol>
 <img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210618211941020.png" alt="image-20210618211941020" style="zoom: 55%;">



<h2 id="Redis事务、锁机制秒杀"><a href="#Redis事务、锁机制秒杀" class="headerlink" title="Redis事务、锁机制秒杀"></a>Redis事务、锁机制秒杀</h2><h3 id="Redis事务定义"><a href="#Redis事务定义" class="headerlink" title="Redis事务定义"></a>Redis事务定义</h3><p>Redis事务是一个单独的隔离操作：事务中的所有命令都会序列化、按顺序地执行。事务在执行的过程中，不会被其他客户端发送来的命令请求所打断。</p>
<p>Redis事务的主要作用就是<strong>串联多个命令</strong>防止别的命令插队。</p>
<h3 id="Multi、Exec、discard"><a href="#Multi、Exec、discard" class="headerlink" title="Multi、Exec、discard"></a>Multi、Exec、discard</h3><p>Redis事务中有Multi、Exec和discard三个指令，在Redis中，从输入Multi命令开始，输入的命令都会依次进入命令队列中，但不会执行，直到输入Exec后，Redis会将之前的命令队列中的命令依次执行。而组队的过程中可以通过discard来放弃组队。</p>
 <img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210619093306171.png" alt="image-20210619093306171" style="zoom:120%;">

<p>案例说明：</p>
 <img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210619093617872.png" alt="image-20210619093617872" style="zoom: 50%;">

<p>组队成功，提交成功。</p>
 <img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210619093741383.png" alt="image-20210619093741383" style="zoom: 50%;">

<p>组队阶段报错，提交失败。</p>
 <img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210619093941172.png" alt="image-20210619093941172" style="zoom:50%;">

<p>组队成功，提交有成功有失败情况。</p>
<h3 id="事务的错误处理"><a href="#事务的错误处理" class="headerlink" title="事务的错误处理"></a>事务的错误处理</h3><p>组队中某个命令出现了报告错误，执行时整个的所有队列都会被取消。</p>
 <img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210619094058710.png" alt="image-20210619094058710" style="zoom:130%;">

<p>如果执行阶段某个命令报出了错误，则只有报错的命令不会被执行，而其他的命令都会执行，不会回滚。</p>
 <img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210619094201203.png" alt="image-20210619094201203" style="zoom:130%;">

<h3 id="为什么要做成事务"><a href="#为什么要做成事务" class="headerlink" title="为什么要做成事务"></a><strong>为什么要做成事务</strong></h3><p>想想一个场景：有很多人有你的账户，同时去参加双十一抢购。</p>
<h3 id="事务冲突的问题"><a href="#事务冲突的问题" class="headerlink" title="事务冲突的问题"></a><strong>事务冲突的问题</strong></h3><p><strong>例子</strong></p>
<ul>
<li><p>一个请求想给金额减8000；</p>
</li>
<li><p>一个请求想给金额减5000；</p>
</li>
<li><p>一个请求想给金额减1000。</p>
<p>最终我们可以发现，总共金额是10000，如果请求全部执行，那最后的金额变为-4000，很明显不合理。</p>
</li>
</ul>
 <img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210619094341090.png" alt="image-20210619094341090" style="zoom:130%;">

<p><strong>悲观锁</strong></p>
 <img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210619094633896.png" alt="image-20210619094633896" style="zoom:130%;">

<p><strong>悲观锁(Pessimistic Lock)<strong>，顾名思义，就是很悲观，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会block直到它拿到锁。</strong>传统的关系型数据库里边就用到了很多这种锁机制</strong>，比如<strong>行锁</strong>，<strong>表锁</strong>等，<strong>读锁</strong>，<strong>写锁</strong>等，都是在做操作之前先上锁。</p>
<p><strong>乐观锁</strong></p>
 <img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210619094741479.png" alt="image-20210619094741479" style="zoom:130%;">

<p><strong>乐观锁(Optimistic Lock)<strong>，顾名思义，就是很乐观，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号等机制。</strong>乐观锁适用于多读的应用类型，这样可以提高吞吐量</strong>。Redis就是利用这种<strong>check-and-set机制</strong>实现事务的。</p>
<p><strong>WATCH</strong> <strong>key</strong> <strong>[key …]</strong></p>
<p>在执行multi之前，先执行watch key1 [key2]，可以监视一个(或多个) key ，如果在事务<strong>执行之前这个(或这些) key被其他命令所改动，那么事务将被打断。</strong></p>
 <img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210619095200164.png" alt="image-20210619095200164" style="zoom: 50%;">



<p> <strong>unwatch</strong></p>
<p>取消 WATCH 命令对所有 key 的监视。如果在执行 WATCH 命令之后，EXEC 命令或DISCARD 命令先被执行了的话，那么就不需要再执行UNWATCH 了。</p>
<h3 id="Redis事务三特性"><a href="#Redis事务三特性" class="headerlink" title="Redis事务三特性"></a>Redis事务三特性</h3><ul>
<li><p>单独的隔离操作 ：事务中的所有命令都会序列化、按顺序地执行。事务在执行的过程中，不会被其他客户端发送来的命令请求所打断。 </p>
</li>
<li><p>没有隔离级别的概念 ：队列中的命令没有提交之前都不会实际被执行，因为事务提交前任何指令都不会被实际执行。</p>
</li>
<li><p>不保证原子性 ：事务中如果有一条命令执行失败，其后的命令仍然会被执行，没有回滚 。</p>
</li>
</ul>
<h2 id="Redis-事务秒杀案例"><a href="#Redis-事务秒杀案例" class="headerlink" title="Redis_事务秒杀案例"></a>Redis_事务秒杀案例</h2><h3 id="解决计数器和人员记录的事务操作"><a href="#解决计数器和人员记录的事务操作" class="headerlink" title="解决计数器和人员记录的事务操作"></a><strong>解决计数器和人员记录的事务操作</strong></h3><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210619095633057.png" alt="image-20210619095633057" style="zoom:130%;">

<h3 id="Redis事务—秒杀并发模拟"><a href="#Redis事务—秒杀并发模拟" class="headerlink" title="Redis事务—秒杀并发模拟"></a>Redis事务—秒杀并发模拟</h3><blockquote>
<p><strong>使用工具ab模拟测试：</strong></p>
<ul>
<li><p>CentOS6 默认安装</p>
</li>
<li><p>CentOS7需要手动安装</p>
</li>
</ul>
</blockquote>
<p><strong>通过ab测试</strong></p>
<p>im postfile 模拟表单提交参数， 以&amp;符号结尾，存放当前目录。</p>
<p>内容：prodid&#x3D;0101&amp;</p>
<p>执行：ab -n 2000 -c 200 -k -p ~&#x2F;postfile -T application&#x2F;x-www-form-urlencoded</p>
<p>访问：<a href="http://192.168.2.115:8081/Seckill/doseckill">http://192.168.2.115:8081/Seckill/doseckill</a></p>
<p><strong>超卖</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210619100129431.png" alt="image-20210619100129431" style="zoom:120%;"><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210619100138313.png" alt="image-20210619100138313" style="zoom:120%;"></p>
<h3 id="超卖问题"><a href="#超卖问题" class="headerlink" title="超卖问题"></a>超卖问题</h3><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210619100303067.png" alt="image-20210619100303067" style="zoom:130%;">

<p><strong>利用乐观锁淘汰用户，解决超卖问题。</strong></p>
<img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210619100339429.png" alt="image-20210619100339429" style="zoom:130%;">

<p><strong>主要代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SecKill_redis</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="type">Jedis</span> <span class="variable">jedis</span> <span class="operator">=</span><span class="keyword">new</span> <span class="title class_">Jedis</span>(<span class="string">&quot;192.168.44.168&quot;</span>,<span class="number">6379</span>);</span><br><span class="line">		System.out.println(jedis.ping());</span><br><span class="line">		jedis.close();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//秒杀过程</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">doSecKill</span><span class="params">(String uid,String prodid)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">		<span class="comment">//1 uid和prodid非空判断</span></span><br><span class="line">		<span class="keyword">if</span>(uid == <span class="literal">null</span> || prodid == <span class="literal">null</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//2 连接redis</span></span><br><span class="line">		<span class="comment">//Jedis jedis = new Jedis(&quot;192.168.44.168&quot;,6379);</span></span><br><span class="line">		<span class="comment">//通过连接池得到jedis对象</span></span><br><span class="line">		<span class="type">JedisPool</span> <span class="variable">jedisPoolInstance</span> <span class="operator">=</span> JedisPoolUtil.getJedisPoolInstance();</span><br><span class="line">		<span class="type">Jedis</span> <span class="variable">jedis</span> <span class="operator">=</span> jedisPoolInstance.getResource();</span><br><span class="line"></span><br><span class="line">		<span class="comment">//3 拼接key</span></span><br><span class="line">		<span class="comment">// 3.1 库存key</span></span><br><span class="line">		<span class="type">String</span> <span class="variable">kcKey</span> <span class="operator">=</span> <span class="string">&quot;sk:&quot;</span>+prodid+<span class="string">&quot;:qt&quot;</span>;</span><br><span class="line">		<span class="comment">// 3.2 秒杀成功用户key</span></span><br><span class="line">		<span class="type">String</span> <span class="variable">userKey</span> <span class="operator">=</span> <span class="string">&quot;sk:&quot;</span>+prodid+<span class="string">&quot;:user&quot;</span>;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//监视库存</span></span><br><span class="line">		jedis.watch(kcKey);</span><br><span class="line"></span><br><span class="line">		<span class="comment">//4 获取库存，如果库存null，秒杀还没有开始</span></span><br><span class="line">		<span class="type">String</span> <span class="variable">kc</span> <span class="operator">=</span> jedis.get(kcKey);</span><br><span class="line">		<span class="keyword">if</span>(kc == <span class="literal">null</span>) &#123;</span><br><span class="line">			System.out.println(<span class="string">&quot;秒杀还没有开始，请等待&quot;</span>);</span><br><span class="line">			jedis.close();</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 5 判断用户是否重复秒杀操作</span></span><br><span class="line">		<span class="keyword">if</span>(jedis.sismember(userKey, uid)) &#123;</span><br><span class="line">			System.out.println(<span class="string">&quot;已经秒杀成功了，不能重复秒杀&quot;</span>);</span><br><span class="line">			jedis.close();</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//6 判断如果商品数量，库存数量小于1，秒杀结束</span></span><br><span class="line">		<span class="keyword">if</span>(Integer.parseInt(kc)&lt;=<span class="number">0</span>) &#123;</span><br><span class="line">			System.out.println(<span class="string">&quot;秒杀已经结束了&quot;</span>);</span><br><span class="line">			jedis.close();</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//7 秒杀过程</span></span><br><span class="line">		<span class="comment">//使用事务</span></span><br><span class="line">		<span class="type">Transaction</span> <span class="variable">multi</span> <span class="operator">=</span> jedis.multi();</span><br><span class="line"></span><br><span class="line">		<span class="comment">//组队操作</span></span><br><span class="line">		multi.decr(kcKey);</span><br><span class="line">		multi.sadd(userKey,uid);</span><br><span class="line"></span><br><span class="line">		<span class="comment">//执行</span></span><br><span class="line">		List&lt;Object&gt; results = multi.exec();</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span>(results == <span class="literal">null</span> || results.size()==<span class="number">0</span>) &#123;</span><br><span class="line">			System.out.println(<span class="string">&quot;秒杀失败了....&quot;</span>);</span><br><span class="line">			jedis.close();</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//7.1 库存-1</span></span><br><span class="line">		<span class="comment">//jedis.decr(kcKey);</span></span><br><span class="line">		<span class="comment">//7.2 把秒杀成功用户添加清单里面</span></span><br><span class="line">		<span class="comment">//jedis.sadd(userKey,uid);</span></span><br><span class="line"></span><br><span class="line">		System.out.println(<span class="string">&quot;秒杀成功了..&quot;</span>);</span><br><span class="line">		jedis.close();</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> <img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210619100941862.png" alt="image-20210619100941862" style="zoom:100%;"><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210619101004992.png" alt="image-20210619101004992"></p>
<h3 id="继续增加并发测试"><a href="#继续增加并发测试" class="headerlink" title="继续增加并发测试"></a>继续增加并发测试</h3><p> <strong>连接有限制</strong></p>
<p>增加-r参数，-r  Don’t exit on socket receive errors。</p>
<p> <strong>已经秒光，可是还有库存</strong></p>
<p>已经秒光，可是还有库存。原因：乐观锁导致很多请求都失败。先点的没秒到，后点的可能秒到了。</p>
 <img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210619101322601.png" alt="image-20210619101322601" style="zoom:150%;">

<p><strong>连接超时，通过连接池解决</strong></p>
<p>节省每次连接redis服务带来的消耗，把连接好的实例反复利用。通过参数管理连接的行为，代码见项目中：</p>
<p>连接池参数：</p>
<ul>
<li><p>MaxTotal：控制一个pool可分配多少个jedis实例，通过pool.getResource()来获取；如果赋值为-1，则表示不限制；如果pool已经分配了MaxTotal个jedis实例，则此时pool的状态为exhausted。</p>
</li>
<li><p>maxIdle：控制一个pool最多有多少个状态为idle(空闲)的jedis实例；</p>
</li>
<li><p>MaxWaitMillis：表示当borrow一个jedis实例时，最大的等待毫秒数，如果超过等待时间，则直接抛JedisConnectionException；</p>
</li>
<li><p>testOnBorrow：获得一个jedis实例的时候是否检查连接可用性（ping()）；如果为true，则得到的jedis实例均是可用的。</p>
</li>
</ul>
<h3 id="解决库存遗留问题"><a href="#解决库存遗留问题" class="headerlink" title="解决库存遗留问题"></a><strong>解决库存遗留问题</strong></h3><p><strong>LUA脚本在Redis中的优势</strong></p>
<ul>
<li><p>将复杂的或者多步的redis操作，写为一个脚本，一次提交给redis执行，减少反复连接redis的次数，提升性能。</p>
</li>
<li><p>LUA脚本是类似redis事务，有一定的原子性，不会被其他命令插队，可以完成一些redis事务性的操作。</p>
</li>
<li><p>但是注意redis的lua脚本功能，只有在Redis 2.6以上的版本才可以使用。</p>
</li>
<li><p>利用lua脚本淘汰用户，解决超卖问题，redis 2.6版本以后，通过lua脚本解决<strong>争抢问题</strong>，实际上是<strong>redis</strong> <strong>利用其单线程的特性，用任务队列的方式解决多任务并发问题</strong>。</p>
</li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210619101853376.png" alt="image-20210619101853376" style="zoom:130%;">

<h2 id="Redis持久化之RDB"><a href="#Redis持久化之RDB" class="headerlink" title="Redis持久化之RDB"></a><strong>Redis</strong>持久化之RDB</h2><h3 id="总体介绍"><a href="#总体介绍" class="headerlink" title="总体介绍"></a><strong>总体介绍</strong></h3><blockquote>
<p>官网介绍：<a href="http://www.redis.io/">http://www.redis.io</a></p>
</blockquote>
<p>Redis 提供了2个不同形式的持久化方式：</p>
<ul>
<li><p>RDB（Redis DataBase）</p>
</li>
<li><p>AOF（Append Of File）</p>
</li>
</ul>
<h3 id="RDB"><a href="#RDB" class="headerlink" title="RDB"></a><strong>RDB</strong></h3><h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a><strong>简介</strong></h4><p>在指定的时间间隔内将内存中的数据集快照写入磁盘， 也就是行话讲的Snapshot快照，它恢复时是将快照文件直接读到内存里。</p>
<h4 id="备份是如何执行的"><a href="#备份是如何执行的" class="headerlink" title="备份是如何执行的"></a><strong>备份是如何执行的</strong></h4><p>Redis会单独创建（fork）一个子进程来进行持久化，首先会将数据写入到一个临时文件中，待持久化过程都结束了，再用这个临时文件替换上次持久化好的文件。整个过程中，主进程是不进行任何IO操作的，这就确保了极高的性能。如果需要进行大规模数据的恢复，且对于数据恢复的完整性不是非常敏感，那RDB方式要比AOF方式更加的高效。<strong>RDB的缺点是最后一次持久化后的数据可能丢失</strong>。</p>
<h4 id="Fork"><a href="#Fork" class="headerlink" title="Fork"></a>Fork</h4><ul>
<li><p>Fork的作用是复制一个与当前进程一样的进程。新进程的所有数据（变量、环境变量、程序计数器等） 数值都和原进程一致，但是是一个全新的进程，并作为原进程的子进程。</p>
</li>
<li><p>在Linux程序中，fork()会产生一个和父进程完全相同的子进程，但子进程在此后多会exec系统调用，出于效率考虑，Linux中引入了“<strong>写时复制技术</strong>”。</p>
</li>
<li><p><strong>一般情况父进程和子进程会共用同一段物理内存</strong>，只有进程空间的各段的内容要发生变化时，才会将父进程的内容复制一份给子进程。</p>
</li>
</ul>
<h4 id="RDB持久化流程"><a href="#RDB持久化流程" class="headerlink" title="RDB持久化流程"></a><strong>RDB</strong>持久化流程</h4><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210619103155712.png" alt="image-20210619103155712" style="zoom:150%;">

<h4 id="dump-rdb文件"><a href="#dump-rdb文件" class="headerlink" title="dump.rdb文件"></a><strong>dump.rdb</strong>文件</h4><p>在redis.conf中配置文件名称，默认为dump.rdb。</p>
<p>rdb文件的保存路径，也可以修改。默认为Redis启动时命令行所在的目录下 “dir  .&#x2F;”</p>
<h4 id="如何触发RDB快照；保持策略"><a href="#如何触发RDB快照；保持策略" class="headerlink" title="如何触发RDB快照；保持策略"></a><strong>如何触发RDB快照；保持策略</strong></h4><p><strong>配置文件中默认的快照配置</strong></p>
<img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210619103558260.png" alt="image-20210619103558260" style="zoom:130%;">

<p><strong>命令save VS bgsave</strong></p>
<ul>
<li><p>save ：save时只管保存，其它不管，全部阻塞。手动保存，不建议。</p>
</li>
<li><p><strong>bgsave：Redis会在后台异步进行快照操作，</strong> <strong>快照同时还可以响应客户端请求。</strong></p>
</li>
<li><p>可以通过lastsave 命令获取最后一次成功执行快照的时间。</p>
</li>
</ul>
<p><strong>flushall命令</strong></p>
<p>执行flushall命令，也会产生dump.rdb文件，但里面是空的，无意义。</p>
<h4 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h4><ul>
<li><p>适合大规模的数据恢复</p>
</li>
<li><p>对数据完整性和一致性要求不高更适合使用</p>
</li>
<li><p>节省磁盘空间</p>
</li>
<li><p>恢复速度快</p>
</li>
</ul>
<p> <img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210619104039665.png" alt="image-20210619104039665"></p>
<h4 id="劣势"><a href="#劣势" class="headerlink" title="劣势"></a>劣势</h4><ul>
<li><p>Fork的时候，内存中的数据被克隆了一份，大致2倍的膨胀性需要考虑。</p>
</li>
<li><p>虽然Redis在fork时使用了<strong>写时拷贝技术</strong>，但是如果数据庞大时还是比较消耗性能。</p>
</li>
<li><p>在备份周期在一定间隔时间做一次备份，所以如果Redis意外down掉的话，就会丢失最后一次快照后的所有修改。</p>
</li>
</ul>
<h4 id="如何停止"><a href="#如何停止" class="headerlink" title="如何停止"></a>如何停止</h4><p>动态停止RDB：redis-cli config set save “”#save后给空值，表示禁用保存策略。</p>
<h4 id="小总结"><a href="#小总结" class="headerlink" title="小总结"></a>小总结</h4><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210619104309571.png" alt="image-20210619104309571" style="zoom:130%;">



<h2 id="Redis持久化之AOF"><a href="#Redis持久化之AOF" class="headerlink" title="Redis持久化之AOF"></a>Redis持久化之AOF</h2><h3 id="AOF（Append-Only-File）"><a href="#AOF（Append-Only-File）" class="headerlink" title="AOF（Append Only File）"></a>AOF<strong>（Append Only File）</strong></h3><p>以<strong>日志</strong>的形式来记录每个写操作（增量保存），将Redis执行过的所有写指令记录下来(<strong>读操作不记录</strong>)， <strong>只许追加文件但不可以改写文件</strong>，redis启动之初会读取该文件重新构建数据，换言之，redis 重启的话就根据日志文件的内容将写指令从前到后执行一次以完成数据的恢复工作。</p>
<h4 id="AOF持久化流程"><a href="#AOF持久化流程" class="headerlink" title="AOF持久化流程"></a><strong>AOF</strong>持久化流程</h4><ol>
<li><p>客户端的请求写命令会被append追加到AOF缓冲区内；</p>
</li>
<li><p>AOF缓冲区根据AOF持久化策略[always,everysec,no]将操作sync同步到磁盘的AOF文件中；</p>
</li>
<li><p>AOF文件大小超过重写策略或手动重写时，会对AOF文件rewrite重写，压缩AOF文件容量；</p>
</li>
<li><p>Redis服务重启时，会重新load加载AOF文件中的写操作达到数据恢复的目的。</p>
</li>
</ol>
<img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210619104813563.png" alt="image-20210619104813563" style="zoom:130%;">

<h4 id="AOF默认不开启"><a href="#AOF默认不开启" class="headerlink" title="AOF默认不开启"></a><strong>AOF</strong>默认不开启</h4><p>可以在redis.conf中配置文件名称默认为 appendonly.aof文件中开启，AOF文件的保存路径，同RDB的路径一致。</p>
<h4 id="AOF和RDB同时开启，redis听谁的？"><a href="#AOF和RDB同时开启，redis听谁的？" class="headerlink" title="AOF和RDB同时开启，redis听谁的？"></a>AOF和RDB同时开启，redis听谁的？</h4><p>AOF和RDB同时开启，系统默认取AOF的数据（数据不会存在丢失）。</p>
<h4 id="AOF启动、修复、恢复"><a href="#AOF启动、修复、恢复" class="headerlink" title="AOF启动、修复、恢复"></a><strong>AOF</strong>启动、修复、恢复</h4><ul>
<li><p>AOF的备份机制和性能虽然和RDB不同，但是备份和恢复的操作同RDB一样，都是拷贝备份文件，需要恢复时再拷贝到Redis工作目录下，启动系统即加载。</p>
</li>
<li><p>正常恢复</p>
<ul>
<li>修改默认的appendonly no，改为yes。</li>
<li>将有数据的aof文件复制一份保存到对应目录(查看目录：config get dir)。</li>
<li>恢复：重启redis然后重新加载。</li>
</ul>
</li>
<li><p>异常恢复</p>
<ul>
<li>修改默认的appendonly no，改为yes。</li>
<li>如遇到<strong>AOF文件损坏</strong>，通过&#x2F;usr&#x2F;local&#x2F;bin&#x2F;<strong>redis-check-aof–fix appendonly.aof</strong>进行恢复。</li>
<li>备份被写坏的AOF文件。</li>
<li>恢复：重启redis，然后重新加载。</li>
</ul>
</li>
</ul>
<h4 id="AOF同步频率设置"><a href="#AOF同步频率设置" class="headerlink" title="AOF同步频率设置"></a>AOF同步频率设置</h4><ul>
<li><p>appendfsync always：始终同步，每次Redis的写入都会立刻记入日志；性能较差但数据完整性比较好。</p>
</li>
<li><p>appendfsync everysec：每秒同步，每秒记入日志一次，如果宕机，本秒的数据可能丢失。</p>
</li>
<li><p>appendfsync no：redis不主动进行同步，把同步时机交给操作系统。</p>
</li>
</ul>
<h4 id="Rewrite压缩"><a href="#Rewrite压缩" class="headerlink" title="Rewrite压缩"></a><strong>Rewrite</strong>压缩</h4><p><strong>Rewrite压缩是什么</strong></p>
<p>AOF采用文件追加方式，文件会越来越大为避免出现此种情况，新增了重写机制，当AOF文件的大小超过所设定的阈值时，Redis就会启动AOF文件的内容压缩，只保留可以恢复数据的最小指令集，可以使用命令bgrewriteaof。</p>
<p><strong>重写原理，如何实现重写</strong></p>
<p>AOF文件持续增长而过大时，会fork出一条新进程来将文件重写(也是先写临时文件最后再rename)，redis4.0版本后的重写，是指把rdb 的快照，以二进制的形式附在新的aof头部，作为已有的历史数据，替换掉原来的流水账操作。</p>
<p><strong>no-appendfsync-on-rewrite：</strong></p>
<ul>
<li><p>如果 no-appendfsync-on-rewrite&#x3D;yes ，不写入aof文件只写入缓存，用户请求不会阻塞，但是在这段时间如果宕机会丢失这段时间的缓存数据。（降低数据安全性，提高性能）</p>
</li>
<li><p>如果 no-appendfsync-on-rewrite&#x3D;no，还是会把数据往磁盘里刷，但是遇到重写操作，可能会发生阻塞。（数据安全，但是性能降低）</p>
</li>
</ul>
<p><strong>触发机制，何时重写</strong></p>
<p>Redis会记录上次重写时的AOF大小，默认配置是当AOF文件大小是上次rewrite后大小的一倍且文件大于64M时触发。</p>
<p>重写虽然可以节约大量磁盘空间，减少恢复时间。但是每次重写还是有一定的负担的，因此设定Redis要满足一定条件才会进行重写。 </p>
<ul>
<li><p>auto-aof-rewrite-percentage：设置重写的基准值，文件达到100%时开始重写（文件是原来重写后文件的2倍时触发）。</p>
</li>
<li><p>auto-aof-rewrite-min-size：设置重写的基准值，最小文件64MB。达到这个值开始重写。</p>
</li>
<li><p>系统载入时或者上次重写完毕时，Redis会记录此时AOF大小，设为base_size,</p>
</li>
<li><p>如果Redis的AOF当前大小&gt;&#x3D; base_size +base_size*100% (默认)且当前大小&gt;&#x3D;64mb(默认)的情况下，Redis会对AOF进行重写。 </p>
</li>
<li><p>例如：文件达到70MB开始重写，降到50MB，下次什么时候开始重写？100MB</p>
</li>
</ul>
<p><strong>重写流程</strong></p>
<ol>
<li><p>bgrewriteaof触发重写，判断是否当前有bgsave或bgrewriteaof在运行，如果有，则等待该命令结束后再继续执行；</p>
</li>
<li><p>主进程fork出子进程执行重写操作，保证主进程不会阻塞；</p>
</li>
<li><p>子进程遍历redis内存中数据到临时文件，客户端的写请求同时写入aof_buf缓冲区和aof_rewrite_buf重写缓冲区，保证原AOF文件完整以及新AOF文件生成期间的新的数据修改动作不会丢失；</p>
</li>
<li><p>子进程写完新的AOF文件后，向主进程发信号，父进程更新统计信息。主进程把aof_rewrite_buf中的数据写入到新的AOF文件；</p>
</li>
<li><p>使用新的AOF文件覆盖旧的AOF文件，完成AOF重写。</p>
</li>
</ol>
<img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210619110418254.png" alt="image-20210619110418254" style="zoom:120%;">

<h4 id="优势-1"><a href="#优势-1" class="headerlink" title="优势"></a>优势</h4><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210619110452361.png" alt="image-20210619110452361" style="zoom:120%;">

<ul>
<li><p>备份机制更稳健，丢失数据概率更低。</p>
</li>
<li><p>可读的日志文本，通过操作AOF稳健，可以处理误操作。</p>
</li>
</ul>
<h4 id="劣势-1"><a href="#劣势-1" class="headerlink" title="劣势"></a>劣势</h4><ul>
<li><p>比起RDB占用更多的磁盘空间。</p>
</li>
<li><p>恢复备份速度要慢。</p>
</li>
<li><p>每次读写都同步的话，有一定的性能压力。</p>
</li>
<li><p>存在个别Bug，造成恢复不能。</p>
</li>
</ul>
<h4 id="小总结-1"><a href="#小总结-1" class="headerlink" title="小总结"></a>小总结</h4><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210619110629704.png" alt="image-20210619110629704" style="zoom:120%;">

<h3 id="总结-Which-one"><a href="#总结-Which-one" class="headerlink" title="总结(Which one)"></a><strong>总结</strong>(Which one)</h3><h4 id="用哪个好"><a href="#用哪个好" class="headerlink" title="用哪个好"></a><strong>用哪个好</strong></h4><p>官方推荐两个都启用：</p>
<ul>
<li><p>如果对数据不敏感，可以选单独用RDB。</p>
</li>
<li><p>不建议单独用 AOF，因为可能会出现Bug。</p>
</li>
<li><p>如果只是做纯内存缓存，可以都不用。</p>
</li>
</ul>
<h4 id="官网建议"><a href="#官网建议" class="headerlink" title="官网建议"></a>官网建议</h4><ul>
<li><p>RDB持久化方式能够在指定的时间间隔能对你的数据进行快照存储。</p>
</li>
<li><p>AOF持久化方式记录每次对服务器写的操作，当服务器重启的时候会重新执行这些命令来恢复原始的数据，AOF命令以redis协议追加保存每次写的操作到文件末尾。 </p>
</li>
<li><p>Redis还能对AOF文件进行后台重写，使得AOF文件的体积不至于过大。</p>
</li>
<li><p>只做缓存：如果你只希望你的数据在服务器运行的时候存在，你也可以不使用任何持久化方式。</p>
</li>
<li><p>同时开启两种持久化方式：在这种情况下，当redis重启的时候会优先载入AOF文件来恢复原始的数据，因为在通常情况下AOF文件保存的数据集要比RDB文件保存的数据集要完整。</p>
</li>
<li><p>RDB的数据不实时，同时使用两者时服务器重启也只会找AOF文件。那要不要只使用AOF呢？ </p>
</li>
<li><p>建议不要，因为RDB更适合用于备份数据库(AOF在不断变化不好备份)，快速重启，而且不会有AOF可能潜在的bug，留着作为一个万一的手段。</p>
</li>
<li><p>性能建议：</p>
<ul>
<li>因为RDB文件只用作后备用途，建议只在Slave上持久化RDB文件，而且只要15分钟备份一次就够了，只保留save 9001这条规则。    </li>
<li>如果使用AOF，好处是在最恶劣情况下也只会丢失不超过两秒数据，启动脚本较简单，只load自己的AOF文件就可以了。</li>
<li>aof代价：一是带来了持续的IO，二是AOF rewrite的最后，将rewrite过程中产生的新数据写到新文件造成的阻塞几乎是不可避免的。  </li>
<li>只要硬盘许可，应该尽量减少AOF  rewrite的频率，AOF重写的基础大小默认值64M太小了，可以设到5G以上。默认超过原大小100%大小时重写可以改到适当的数值。</li>
</ul>
</li>
</ul>
<h2 id="Redis主从复制"><a href="#Redis主从复制" class="headerlink" title="Redis主从复制"></a>Redis主从复制</h2><p>主机数据更新后根据配置和策略， 自动同步到备机的master&#x2F;slaver机制，<strong>Master以写为主，Slave以读为主</strong>，主从复制节点间数据是全量的。</p>
<p>作用：</p>
<ul>
<li><p>读写分离，性能扩展</p>
</li>
<li><p>容灾快速恢复</p>
</li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210619111652745.png" alt="image-20210619111652745" style="zoom:150%;">

<h3 id="复制原理"><a href="#复制原理" class="headerlink" title="复制原理"></a><strong>复制原理</strong></h3><ul>
<li><p>Slave启动成功连接到master后会发送一个sync命令；</p>
</li>
<li><p>Master接到命令启动后台的存盘进程，同时收集所有接收到的用于修改数据集命令，在后台进程执行完毕之后，master将传送整个数据文件到slave，以完成一次完全同步。</p>
</li>
<li><p>全量复制：slave服务器在接收到数据库文件数据后，将其存盘并加载到内存中。</p>
</li>
<li><p>增量复制：Master继续将新的所有收集到的修改命令依次传给slave，完成同步。</p>
</li>
<li><p>但是只要是重新连接master，一次完全同步（全量复制)将被自动执行。</p>
</li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210619112440704.png" alt="image-20210619112440704" style="zoom:150%;">

<h3 id="哨兵模式-sentinel"><a href="#哨兵模式-sentinel" class="headerlink" title="哨兵模式(sentinel)"></a><strong>哨兵模式</strong>(sentinel)</h3><p>反客为主：当一个master宕机后，后面的slave可以立刻升为master，其后面的slave不用做任何修改。用 slaveof no one 指令将从机变为主机。而哨兵模式是<strong>反客为主的自动版</strong>，能够后台监控主机是否故障，如果故障了根据投票数自动将从库转换为主库。</p>
<img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210619154258222.png" alt="image-20210619154258222" style="zoom:130%;">

<p> <strong>当主机挂掉，从机选举产生新的主机</strong></p>
<ul>
<li><p>哪个从机会被选举为主机呢？根据优先级别：slave-priority 。</p>
</li>
<li><p>原主机重启后会变为从机。</p>
</li>
</ul>
<p><strong>复制延时</strong></p>
<p>由于所有的写操作都是先在Master上操作，然后同步更新到Slave上，所以从Master同步到Slave机器有一定的延迟，当系统很繁忙的时</p>
<p>候，延迟问题会更加严重，Slave机器数量的增加也会使这个问题更加严重。</p>
<p><strong>故障恢复</strong></p>
<img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210619154850009.png" alt="image-20210619154850009" style="zoom:130%;">

<p>优先级：在redis.conf中默认 slave-priority 100，值越小优先级越高。</p>
<p>偏移量：指获得原主机数据最全的概率。</p>
<p>runid：每个redis实例启动后都会随机生成一个40位的runid。</p>
<h2 id="Redis集群（cluster模式）"><a href="#Redis集群（cluster模式）" class="headerlink" title="Redis集群（cluster模式）"></a>Redis集群（cluster模式）</h2><p>Redis 集群（包括很多小集群）实现了对Redis的水平扩容，即启动N个redis节点，将整个数据库分布存储在这N个节点中，每个节点存储总数据的1&#x2F;N，即一个小集群存储1&#x2F;N的数据，每个小集群里面维护好自己的1&#x2F;N的数据。</p>
<p>Redis 集群通过分区（partition）来提供一定程度的可用性（availability）： 即使集群中有一部分节点失效或者无法进行通讯， 集群也可以继续处理命令请求。</p>
<p>该模式的redis集群特点是：分治、分片。</p>
<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><ol>
<li><p>容量不够，redis如何进行扩容？</p>
</li>
<li><p>并发写操作， redis如何分摊？</p>
</li>
<li><p>另外，主从模式，薪火相传模式，主机宕机，导致ip地址发生变化，应用程序中配置需要修改对应的主机地址、端口等信息。</p>
</li>
<li><p>之前通过代理主机来解决，但是redis3.0中提供了解决方案。就是无中心化集群配置。</p>
</li>
</ol>
<h3 id="集群连接"><a href="#集群连接" class="headerlink" title="集群连接"></a>集群连接</h3><p>普通方式登录：可能直接进入读主机，存储数据时，会出现MOVED重定向操作，所以，应该以集群方式登录。</p>
 <img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210619162020586.png" alt="image-20210619162020586" style="zoom:150%;">

<p>集群登录：redis-cli -c -p 6379  采用集群策略连接，设置数据会自动切换到相应的写主机.</p>
<h3 id="redis-cluster-如何分配这六个节点"><a href="#redis-cluster-如何分配这六个节点" class="headerlink" title="redis cluster 如何分配这六个节点?"></a><strong>redis cluster</strong> <strong>如何分配这六个节点?</strong></h3><ul>
<li>一个集群至少要有三个主节点。</li>
<li>选项 –cluster-replicas 1 ：表示我们希望为集群中的每个主节点创建一个从节点。</li>
<li>分配原则尽量保证每个主数据库运行在不同的IP地址，每个从库和主库不在一个IP地址上。</li>
</ul>
<h3 id="什么是slots"><a href="#什么是slots" class="headerlink" title="什么是slots"></a>什么是slots</h3><p>一个 Redis 集群包含 16384 个插槽（hash slot），数据库中的每个键都属于这 16384 个插槽的其中一个。集群使用公式 CRC16(key) % 16384 来计算键 key 属于哪个槽， 其中 CRC16(key) 语句用于计算键 key 的 CRC16 校验和 。</p>
<p>集群中的每个节点负责处理一部分插槽。 举个例子， 如果一个集群可以有主节点， 其中：</p>
<ul>
<li>节点 A 负责处理 0 号至 5460 号插槽。</li>
<li>节点 B 负责处理 5461 号至 10922 号插槽。</li>
<li>节点 C 负责处理 10923 号至 16383 号插槽。</li>
</ul>
<h3 id="在集群中录入值"><a href="#在集群中录入值" class="headerlink" title="在集群中录入值"></a><strong>在集群中录入值</strong></h3><p>在redis-cli每次录入、查询键值，redis都会计算出该key应该送往的插槽，如果不是该客户端对应服务器的插槽，redis会报错，并告知应前往的redis实例地址和端口。</p>
<p>redis-cli客户端提供了 –c 参数实现自动重定向。如 redis-cli -c –p 6379 登入后，再录入、查询键值对可以自动重定向。不在一个slot下的键值，是不能使用mget,mset等多键操作。</p>
<h3 id="故障恢复"><a href="#故障恢复" class="headerlink" title="故障恢复"></a><strong>故障恢复</strong></h3><ul>
<li><p>如果主节点下线？从节点能否自动升为主节点？注意：<strong>15</strong>秒超时</p>
</li>
<li><p>主节点恢复后，主从关系会如何？主节点回来变成从机。</p>
</li>
</ul>
<p>如果所有某一段插槽的主从节点都宕掉，redis服务是否还能继续?</p>
<ul>
<li><p>如果某一段插槽的主从都挂掉，而cluster-require-full-coverage 为yes ，那么整个集群都挂掉。</p>
</li>
<li><p>如果某一段插槽的主从都挂掉，而cluster-require-full-coverage 为no ，那么，该插槽数据全都不能使用，也无法存储。</p>
</li>
</ul>
<h3 id="Redis-集群优点"><a href="#Redis-集群优点" class="headerlink" title="Redis 集群优点"></a><strong>Redis</strong> <strong>集群优点</strong></h3><ul>
<li><p>实现扩容</p>
</li>
<li><p>分摊压力</p>
</li>
<li><p>无中心配置相对简单</p>
</li>
</ul>
<h3 id="Redis-集群不足"><a href="#Redis-集群不足" class="headerlink" title="Redis 集群不足"></a><strong>Redis</strong> <strong>集群不足</strong></h3><ul>
<li><p>多键操作是不被支持的。</p>
</li>
<li><p>多键的Redis事务是不被支持的，lua脚本不被支持。</p>
</li>
<li><p>由于集群方案出现较晚，很多公司已经采用了其他的集群方案，而代理或者客户端分片的方案想要迁移至redis cluster，需要整体迁移而不是逐步过渡，复杂度较大。</p>
</li>
</ul>
<h2 id="Redis应用问题解决"><a href="#Redis应用问题解决" class="headerlink" title="Redis应用问题解决"></a>Redis应用问题解决</h2><h3 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h3><h4 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h4><p>key对应的数据在数据源并不存在，每次针对此key的请求从缓存获取不到，请求都会压到数据源（数据库），从而可能压垮数据源。比如</p>
<p>用一个不存在的用户id获取用户信息，不论缓存还是数据库都没有，若黑客利用此漏洞进行攻击可能压垮数据库。</p>
<p>缓存穿透发生的条件：</p>
<ol>
<li>应用服务器压力变大</li>
<li>redis命中率降低</li>
<li>一直查询数据库，使得数据库压力太大而压垮</li>
</ol>
<p>其实redis在这个过程中一直平稳运行，崩溃的是我们的数据库（如MySQL）。</p>
<p>缓存穿透发生的原因：黑客或者其他非正常用户频繁进行很多非正常的url访问，使得redis查询不到数据库。</p>
<img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210619163643698.png" alt="image-20210619163643698" style="zoom:120%;">

<h4 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h4><ol>
<li><p><strong>对空值缓存：</strong>如果一个查询返回的数据为空（不管是数据是否不存在），我们仍然把这个空结果（null）进行缓存，设置空结果的过期时间会很短，最长不超过五分钟。</p>
</li>
<li><p><strong>设置可访问的名单（白名单）：</strong>使用bitmaps类型定义一个可以访问的名单，名单id作为bitmaps的偏移量，每次访问和bitmap里面的id进行比较，如果访问id不在bitmaps里面，进行拦截，不允许访问。</p>
</li>
<li><p><strong>采用布隆过滤器</strong>：布隆过滤器（Bloom Filter）是1970年由布隆提出的。它实际上是一个很长的二进制向量(位图)和一系列随机映射函数（哈希函数）。布隆过滤器可以用于检索一个元素是否在一个集合中。它的优点是空间效率和查询时间都远远超过一般的算法，缺点是有一定的误识别率和删除困难。</p>
</li>
<li><p><strong>进行实时监控：</strong>当发现Redis的命中率开始急速降低，需要排查访问对象和访问的数据，和运维人员配合，可以设置黑名单限制服务。</p>
</li>
</ol>
<h3 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h3><h4 id="问题描述-1"><a href="#问题描述-1" class="headerlink" title="问题描述"></a>问题描述</h4><p>key对应的数据存在，但在redis中过期，此时若有大量并发请求过来，这些请求发现缓存过期一般都会从后端数据库加载数据并回设到缓存，这个时候大并发的请求可能会瞬间把后端数据库压垮。</p>
<p>缓存击穿的现象：</p>
<ol>
<li>数据库访问压力瞬时增加，数据库崩溃</li>
<li>redis里面没有出现大量key过期</li>
<li>redis正常运行</li>
</ol>
<p>缓存击穿发生的原因：redis某个key过期了，大量访问使用这个key（热门key）。</p>
<img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210619165201337.png" alt="image-20210619165201337" style="zoom:120%;">

<h4 id="解决方案-1"><a href="#解决方案-1" class="headerlink" title="解决方案"></a>解决方案</h4><p>key可能会在某些时间点被超高并发地访问，是一种非常“热点”的数据。</p>
<ol>
<li><p><strong>预先设置热门数据：</strong>在redis高峰访问之前，把一些热门数据提前存入到redis里面，加大这些热门数据key的时长。</p>
</li>
<li><p><strong>实时调整：</strong>现场监控哪些数据热门，实时调整key的过期时长。</p>
</li>
<li><p><strong>使用锁：</strong></p>
<ol>
<li>就是在缓存失效的时候（判断拿出来的值为空），不是立即去load db。</li>
<li>先使用缓存工具的某些带成功操作返回值的操作（比如Redis的SETNX）去set一个mutex key。</li>
<li>当操作返回成功时，再进行load db的操作，并回设缓存，最后删除mutex key；</li>
<li>当操作返回失败，证明有线程在load db，当前线程睡眠一段时间再重试整个get缓存的方法。</li>
</ol>
</li>
</ol>
<img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210619165505113.png" alt="image-20210619165505113" style="zoom:120%;">

<h3 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h3><h4 id="问题描述-2"><a href="#问题描述-2" class="headerlink" title="问题描述"></a>问题描述</h4><p>key对应的数据存在，但在redis中过期，此时若有大量并发请求过来，这些请求发现缓存过期一般都会从后端数据库加载数据并回设到缓存，这个时候大并发的请求可能会瞬间把后端数据库压垮。</p>
<p>缓存雪崩与缓存击穿的区别在于这里针对很多key缓存，前者则是某一个key正常访问。</p>
<img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210619170416116.png" alt="image-20210619170416116" style="zoom:120%;">

<p><strong>缓存失效瞬间：</strong></p>
<img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210619170456227.png" alt="image-20210619170456227" style="zoom:120%;">

<h4 id="解决方案-2"><a href="#解决方案-2" class="headerlink" title="解决方案"></a>解决方案</h4><ol>
<li><p><strong>构建多级缓存架构：</strong>nginx缓存 + redis缓存 +其他缓存（ehcache等）。</p>
</li>
<li><p><strong>使用锁或队列：</strong>用加锁或者队列的方式来保证不会有大量的线程对数据库一次性进行读写，从而避免失效时大量的并发请求落到底层存储系统上，该方法不适用高并发情况。</p>
</li>
<li><p><strong>设置过期标志更新缓存：</strong>记录缓存数据是否过期（设置提前量），如果过期会触发通知另外的线程在后台去更新实际key的缓存。</p>
</li>
<li><p><strong>将缓存失效时间分散开：</strong>比如可以在原有的失效时间基础上增加一个随机值，比如1-5分钟随机，这样每一个缓存的过期时间的重复率就会降低，就很难引发集体失效的事件。</p>
</li>
</ol>
<h3 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h3><h4 id="问题描述-3"><a href="#问题描述-3" class="headerlink" title="问题描述"></a>问题描述</h4><p>随着业务发展的需要，原单体单机部署的系统被演化成分布式集群系统后，由于分布式系统多线程的特点以及分布在不同机器上，这将使原单机部署情况下的并发控制锁策略失效，单纯的Java API并不能提供分布式锁的能力。为了解决这个问题就需要一种跨JVM的互斥机制来控制共享资源的访问，这就是分布式锁要解决的问题！</p>
<p>分布式锁主流的实现方案：</p>
<ol>
<li><p>基于数据库实现分布式锁</p>
</li>
<li><p>基于缓存（Redis等）</p>
</li>
<li><p>基于Zookeeper</p>
</li>
</ol>
<p>根据实现方式，分布式锁还可以分为类CAS自旋式分布式锁以及event事件类型分布式锁：</p>
<ul>
<li>类CAS自旋式分布式锁：询问的方式，类似java并发编程中的线程获询问的方式尝试加锁，如mysql、redis。</li>
<li>另外一类是event事件通知进程后续锁的变化，轮询向外的过程，如zookeeper、etcd。</li>
</ul>
<p>每一种分布式锁解决方案都有各自的优缺点：</p>
<ol>
<li><p>性能：redis最高</p>
</li>
<li><p>可靠性：zookeeper最高</p>
</li>
</ol>
<h4 id="解决方案：使用redis实现分布式锁"><a href="#解决方案：使用redis实现分布式锁" class="headerlink" title="解决方案：使用redis实现分布式锁"></a><strong>解决方案：使用redis实现分布式锁</strong></h4><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210619213926122.png" alt="image-20210619213926122" style="zoom:120%;">

<p>setnx：通过该命令尝试获得锁，没有获得锁的线程会不断等待尝试。</p>
<p>set key ex 3000nx：设置过期时间，自动释放锁，解决当某一个业务异常而导致锁无法释放的问题。但是当业务运行超过过期时间时，开辟监控线程增加该业务的运行时间，直到运行结束，释放锁。</p>
<p>uuid：设置uuid，释放前获取这个值，判断是否自己的锁，防止误删锁，造成没锁的情况。</p>
<h3 id="RedLock"><a href="#RedLock" class="headerlink" title="RedLock"></a>RedLock</h3><p>Redlock是一种算法，Redlock也就是 Redis Distributed Lock，可用实现多节点redis的分布式锁。RedLock官方推荐，Redisson完成了对Redlock算法封装。</p>
<p>此种方式具有以下特性：</p>
<ul>
<li>互斥访问：即永远只有一个 client 能拿到锁。</li>
<li>避免死锁：最终 client 都可能拿到锁，不会出现死锁的情况，即使锁定资源的服务崩溃或者分区，仍然能释放锁。</li>
<li>容错性：只要大部分 Redis 节点存活（一半以上），就可以正常提供服务</li>
</ul>
<p>RedLock原理（了解）</p>
<ol>
<li>获取当前Unix时间，以毫秒为单位。</li>
<li>依次尝试从N个实例，使用相同的key和随机值获取锁。在步骤2，当向Redis设置锁时，客户端应该设置一个网络连接和响应超时时间，这个超时时间应该小于锁的失效时间。例如你的锁自动失效时间为10秒，则超时时间应该在5-50毫秒之间。这样可以避免服务器端Redis已经挂掉的情况下，客户端还在死死地等待响应结果。如果服务器端没有在规定时间内响应，客户端应该尽快尝试另外一个Redis实例。</li>
<li>客户端使用当前时间减去开始获取锁时间（步骤1记录的时间）就得到获取锁使用的时间。当且仅当从大多数（这里是3个节点）的Redis节点都取到锁，并且使用的时间小于锁失效时间时，锁才算获取成功。</li>
<li>如果取到了锁，key的真正有效时间等于有效时间减去获取锁所使用的时间（步骤3计算的结果）。</li>
<li>如果因为某些原因，获取锁失败（没有在至少N&#x2F;2+1个Redis实例取到锁或者取锁时间已经超过了有效时间），客户端应该在所有的Redis实例上进行解锁（即便某些Redis实例根本就没有加锁成功）。</li>
</ol>
<h2 id="Redis-IO多线程"><a href="#Redis-IO多线程" class="headerlink" title="Redis IO多线程"></a>Redis IO多线程</h2><h3 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h3><p>Redis6终于支撑多线程了，告别单线程了吗？</p>
<p>IO多线程其实指<strong>客户端交互部分</strong>的<strong>网络IO</strong>交互处理模块<strong>多线程</strong>，而非<strong>执行命令多线程</strong>。Redis6执行命令依然是单线程。</p>
<h3 id="原理架构"><a href="#原理架构" class="headerlink" title="原理架构"></a><strong>原理架构</strong></h3><p>Redis 6 加入多线程，但跟 Memcached 这种从 IO处理到数据访问多线程的实现模式有些差异。Redis 的多线程部分只是用来处理网络数据的读写和协议解析，执行命令仍然是单线程。之所以这么设计是不想因为多线程而变得复杂，需要去控制 key、lua、事务，LPUSH&#x2F;LPOP 等等的并发问题。整体的设计大体如下:</p>
<img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210619215600452.png" alt="image-20210619215600452" style="zoom:120%;">

<p>另外，多线程IO默认也是不开启的，需要再配置文件中配置：</p>
<ul>
<li><p>io-threads-do-reads yes </p>
</li>
<li><p>io-threads 4</p>
</li>
</ul>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>消息中间件-RabbitMQ</title>
    <url>/2022/03/15/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6-RabbitMQ/</url>
    <content><![CDATA[<h3 id="消息中间件-RabbitMQ"><a href="#消息中间件-RabbitMQ" class="headerlink" title="消息中间件-RabbitMQ"></a>消息中间件-RabbitMQ</h3><p><strong>RabbitMQ</strong>是实现了高级消息队列协议（AMQP）的开源消息代理软件（亦称面向消息的中间件）。RabbitMQ服务器是用<a href="https://baike.baidu.com/item/Erlang">Erlang</a>语言编写的，而集群和故障转移是构建在<a href="https://baike.baidu.com/item/%E5%BC%80%E6%94%BE%E7%94%B5%E4%BF%A1%E5%B9%B3%E5%8F%B0">开放电信平台</a>框架上的。所有主要的<a href="https://baike.baidu.com/item/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/9845131">编程语言</a>均有与代理接口通讯的<a href="https://baike.baidu.com/item/%E5%AE%A2%E6%88%B7%E7%AB%AF/101081">客户端</a>库。</p>
<span id="more"></span>

<h3 id="1、什么是MQ？"><a href="#1、什么是MQ？" class="headerlink" title="1、什么是MQ？"></a>1、什么是MQ？</h3><p>MQ（message queue），从字面意思上看，本质是个队列，FIFO先入先出，只不过队列中存放的内容是message而已，还是一种跨进程的通信机制，用于上下游传递信息。在互联网架构中，MQ是一种非常常见的上下游“逻辑解耦+物理解耦”的消息通信服务。使用了MQ之后，消息发送上游只需要依赖MQ，不用依赖其他服务。</p>
<h3 id="2、为什么要用MQ？"><a href="#2、为什么要用MQ？" class="headerlink" title="2、为什么要用MQ？"></a>2、为什么要用MQ？</h3><p>流量消峰（优点：防止系统宕机；缺点：访问速率偏慢）</p>
<p><img src="/../images/31.PNG" alt="31"></p>
<p>应用解耦（如果订单系统出现故障，就会造成任意一个子系统出现下单异常；使用MQ,即使是出现异常，在MQ已经缓存完成，依然可以正常进行下单）</p>
<p><img src="/../images/32.PNG" alt="32"></p>
<p>异步处理</p>
<p><img src="/../images/33.PNG" alt="33"></p>
<p>分类</p>
<ul>
<li><p><input disabled type="checkbox"> 
ActiveMQ</p>
<p>优点：单机吞吐量万级，时效性ms级，可用性高，基于主从架构实现高可用性，消息可靠性较低的概率丢失数据</p>
<p>缺点：维护越来越少，高吞吐量场景较少使用。</p>
</li>
<li><p><input disabled type="checkbox"> 
Kafka</p>
<p>优点：吞吐量高，分布式，一个数据多个副本，少数机器宕机，不会丢失数据，日志采集。</p>
<p>缺点：社区更新较慢。消费失败不支持重试。</p>
</li>
<li><p><input disabled type="checkbox"> 
RocketMQ</p>
<p>优点：单机吞吐量十万级，分布式架构，消息0丢失。java语言实现的。</p>
<p>缺点：支持的客户端语言不多。</p>
</li>
<li><p><input disabled type="checkbox"> 
RabbitMQ</p>
<p>优点：高并发的特性，性能较好，支持多语言。</p>
<p>缺点：商业版需要收费，学习成本比较高。</p>
</li>
</ul>
<p>选择</p>
<ul>
<li><input disabled type="checkbox"> Kafka：大型公司，并且有日志采集功能。</li>
<li><input disabled type="checkbox"> RocketMQ：金融互联网，适合高并发场景。</li>
<li><input disabled type="checkbox"> RabbitMQ：中小型公司。</li>
</ul>
<h3 id="3、RabbitMQ"><a href="#3、RabbitMQ" class="headerlink" title="3、RabbitMQ"></a>3、RabbitMQ</h3><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><p>RabbitMQ是一个消息中间件，它接受并转发消息。可以当做一个快递站点，dangni要发送包裹时，把包裹方法哦站点，最后包裹会通过快递员送到指定地方，按照这种逻辑，RabbitMQ是一个快递站点，一个快递员帮你传递快件。RabbitMQ与快递站的主要区别在于，它不处理快件而是接收，存储和转发消息数据。</p>
<h4 id="四大核心组件（生产者、交换机、队列、消费者）"><a href="#四大核心组件（生产者、交换机、队列、消费者）" class="headerlink" title="四大核心组件（生产者、交换机、队列、消费者）"></a>四大核心组件（生产者、交换机、队列、消费者）</h4><p><img src="/../images/34.PNG" alt="34"></p>
<h4 id="RabbitMQ核心部分"><a href="#RabbitMQ核心部分" class="headerlink" title="RabbitMQ核心部分"></a>RabbitMQ核心部分</h4><p><img src="/../images/35.PNG" alt="35"></p>
<h4 id="RabbitMQ的工作原理"><a href="#RabbitMQ的工作原理" class="headerlink" title="RabbitMQ的工作原理"></a>RabbitMQ的工作原理</h4><p><img src="/../images/36.PNG" alt="36"></p>
<p>Broker：接收和分发消息的应用，，RabbitMQ server就是Message Broker。</p>
<p>Virtual host：出于多租户和安全因素设计的，把AMQP的基本组件划分到一个虚拟的分组中，类似于网络中的namespace概念。</p>
<p>Connection：publisher&#x2F;consumer和broker之间的TCP连接。</p>
<p>Channel：作为轻量级的Connection极大减少了操作系统建立TCP connection的开销。</p>
<p>Exchange：message到达broker的第一站，根据分发规则，匹配查询表中的routing key，分发消息到queue中去。常用的类型有：direct（point-to-point）、topic（publish-subscribe）和 fanout（multicast）。</p>
<h3 id="4、案例"><a href="#4、案例" class="headerlink" title="4、案例"></a>4、案例</h3><ul>
<li><input disabled type="checkbox"> 新建Producer.class；</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.tzd;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Channel;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Connection;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.ConnectionFactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeoutException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> tianzedeng</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2022/3/15 - 16:13</span></span><br><span class="line"><span class="comment"> * 生产者：发送消息</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Producer</span> &#123;</span><br><span class="line">    <span class="comment">//队列名称</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">QUEUE_NAME</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//发消息</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException &#123;</span><br><span class="line">        <span class="comment">//创建工厂</span></span><br><span class="line">        <span class="type">ConnectionFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConnectionFactory</span>();</span><br><span class="line">        <span class="comment">//工厂IP 连接RabbitMQ的队列</span></span><br><span class="line">        factory.setHost(<span class="string">&quot;本地ip&quot;</span>);</span><br><span class="line">        <span class="comment">//用户名</span></span><br><span class="line">        factory.setUsername(<span class="string">&quot;username&quot;</span>);</span><br><span class="line">        <span class="comment">//密码</span></span><br><span class="line">        factory.setPassword(<span class="string">&quot;password&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建连接</span></span><br><span class="line">        <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> factory.newConnection();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//通过连接获取信道</span></span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> connection.createChannel();</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 生成一个队列</span></span><br><span class="line"><span class="comment">         * 1.队列名称</span></span><br><span class="line"><span class="comment">         * 2.队列里面的消息是否持久化（磁盘） 默认情况消息存储在内存中</span></span><br><span class="line"><span class="comment">         * 3.该队列是否只供一个消费者进行消费 是否进行消息共享，</span></span><br><span class="line"><span class="comment">         * 4.是否自动删除 最后一个消费者端开连接后 该队列是否自动删除</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        channel.queueDeclare(QUEUE_NAME,<span class="literal">true</span>,<span class="literal">false</span>,<span class="literal">false</span>,<span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//发消息</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        * 1.发送到哪个交换机</span></span><br><span class="line"><span class="comment">        * 2.路由的key是哪个</span></span><br><span class="line"><span class="comment">        * 3.其它参数信息</span></span><br><span class="line"><span class="comment">        * 4.发送消息的消息体</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        channel.basicPublish(<span class="string">&quot;&quot;</span>,QUEUE_NAME,<span class="literal">null</span>,message.getBytes());</span><br><span class="line">        System.out.println(<span class="string">&quot;消息发送完毕&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">SLF4J: Failed to load class <span class="string">&quot;org.slf4j.impl.StaticLoggerBinder&quot;</span>.</span><br><span class="line">SLF4J: Defaulting to no-operation (NOP) logger implementation</span><br><span class="line">SLF4J: See http:<span class="comment">//www.slf4j.org/codes.html#StaticLoggerBinder for further details.</span></span><br><span class="line">消息发送完毕</span><br></pre></td></tr></table></figure>

<ul>
<li><input disabled type="checkbox"> 新建Consumer.class</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.tzd;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeoutException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> tianzedeng</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2022/3/15 - 16:36</span></span><br><span class="line"><span class="comment"> * 消费者:接收消息</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Consumer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//队列的名称</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">QUEUE_NAME</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//接收消息</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建连接工厂</span></span><br><span class="line">        <span class="type">ConnectionFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConnectionFactory</span>();</span><br><span class="line">        factory.setHost(<span class="string">&quot;本地IP&quot;</span>);</span><br><span class="line">        factory.setUsername(<span class="string">&quot;username&quot;</span>);</span><br><span class="line">        factory.setPassword(<span class="string">&quot;password&quot;</span>);</span><br><span class="line">        <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> factory.newConnection();</span><br><span class="line"></span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> connection.createChannel();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//声明 接收消息</span></span><br><span class="line">        <span class="type">DeliverCallback</span> <span class="variable">deliverCallback</span> <span class="operator">=</span> (consumerTag,message)-&gt;&#123;</span><br><span class="line">            System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(message.getBody()));</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">//取消消息时的回调</span></span><br><span class="line">        <span class="type">CancelCallback</span> <span class="variable">cancelCallback</span> <span class="operator">=</span> consumerTag -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;消息消费被中断&quot;</span>);</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        * 消费者接收消息</span></span><br><span class="line"><span class="comment">        * */</span></span><br><span class="line">        channel.basicConsume(QUEUE_NAME,<span class="literal">true</span>,deliverCallback,cancelCallback);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">SLF4J: Failed to load class <span class="string">&quot;org.slf4j.impl.StaticLoggerBinder&quot;</span>.</span><br><span class="line">SLF4J: Defaulting to no-operation (NOP) logger implementation</span><br><span class="line">SLF4J: See http:<span class="comment">//www.slf4j.org/codes.html#StaticLoggerBinder for further details.</span></span><br><span class="line">hello world</span><br></pre></td></tr></table></figure>

<p>后台控制器如图：</p>
<p><img src="/../images/37.PNG" alt="37"></p>
<h3 id="5、工作队列原理"><a href="#5、工作队列原理" class="headerlink" title="5、工作队列原理"></a>5、工作队列原理</h3><p><img src="/../images/38.PNG" alt="38"></p>
<p>重复的连接工厂方法用工具类封装RabbitMqUtils.class</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.tzd.rabbitmq.util;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Connection;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.ConnectionFactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Channel;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> tianzedeng</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2022/3/15 - 18:27</span></span><br><span class="line"><span class="comment"> * 工具类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RabbitMqUtils</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//得到一个连接的channel</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Channel <span class="title function_">getChannel</span><span class="params">()</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="comment">//创建一个连接工厂</span></span><br><span class="line">        <span class="type">ConnectionFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConnectionFactory</span>();</span><br><span class="line">        factory.setHost(<span class="string">&quot;本地IP&quot;</span>);</span><br><span class="line">        factory.setUsername(<span class="string">&quot;username&quot;</span>);</span><br><span class="line">        factory.setPassword(<span class="string">&quot;password&quot;</span>);</span><br><span class="line">        <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> factory.newConnection();</span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> connection.createChannel();</span><br><span class="line">        <span class="keyword">return</span> channel;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>新建工作线程类Work01.class</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.tzd.rabbitmq.demo2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.CancelCallback;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Channel;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.DeliverCallback;</span><br><span class="line"><span class="keyword">import</span> com.tzd.rabbitmq.util.RabbitMqUtils;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> tianzedeng</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2022/3/15 - 18:38</span></span><br><span class="line"><span class="comment"> * 这是一个工作线程，相当于消费者</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Worker01</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//队列名称</span></span><br><span class="line">    <span class="keyword">public</span>  <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">QUEUE_NAME</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//接收消息</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> RabbitMqUtils.getChannel();</span><br><span class="line"></span><br><span class="line">        <span class="type">DeliverCallback</span> <span class="variable">deliverCallback</span> <span class="operator">=</span> (consumerTag,message)-&gt;&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;接收到的消息：&quot;</span>+<span class="keyword">new</span> <span class="title class_">String</span>(message.getBody()));</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="type">CancelCallback</span> <span class="variable">cancelCallback</span> <span class="operator">=</span> (consumerTag)-&gt;&#123;</span><br><span class="line">            System.out.println(consumerTag+<span class="string">&quot;消费者取消消费者接口回调逻辑&quot;</span>);</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">//消息的接收</span></span><br><span class="line">        System.out.println(<span class="string">&quot;C2等待接收消息。。。。。&quot;</span>);</span><br><span class="line">        channel.basicConsume(QUEUE_NAME,<span class="literal">true</span>,deliverCallback,cancelCallback);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>新建生产者类Task01.class</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.tzd.rabbitmq.demo2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Channel;</span><br><span class="line"><span class="keyword">import</span> com.tzd.rabbitmq.util.RabbitMqUtils;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> tianzedeng</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2022/3/15 - 18:55</span></span><br><span class="line"><span class="comment"> * 生产者发送大量的消息</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Task01</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//队列名称</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">QUEUE_NAME</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> RabbitMqUtils.getChannel();</span><br><span class="line"></span><br><span class="line">        channel.queueDeclare(QUEUE_NAME,<span class="literal">true</span>,<span class="literal">false</span>,<span class="literal">false</span>,<span class="literal">null</span>);</span><br><span class="line">        <span class="comment">//从控制台接收信息</span></span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (scanner.hasNext())&#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> scanner.next();</span><br><span class="line">            channel.basicPublish(<span class="string">&quot;&quot;</span>,QUEUE_NAME,<span class="literal">null</span>,message.getBytes());</span><br><span class="line">            System.out.println(<span class="string">&quot;发送消息完成&quot;</span>+message);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<p>Task01：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">SLF4J: Failed to load class <span class="string">&quot;org.slf4j.impl.StaticLoggerBinder&quot;</span>.</span><br><span class="line">SLF4J: Defaulting to no-operation (NOP) logger implementation</span><br><span class="line">SLF4J: See http:<span class="comment">//www.slf4j.org/codes.html#StaticLoggerBinder for further details.</span></span><br><span class="line">AA</span><br><span class="line">发送消息完成AA</span><br><span class="line">BB</span><br><span class="line">发送消息完成BB</span><br><span class="line">CC</span><br><span class="line">发送消息完成CC</span><br><span class="line">DD</span><br><span class="line">发送消息完成DD</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>Work01：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">SLF4J: Failed to load class <span class="string">&quot;org.slf4j.impl.StaticLoggerBinder&quot;</span>.</span><br><span class="line">SLF4J: Defaulting to no-operation (NOP) logger implementation</span><br><span class="line">SLF4J: See http:<span class="comment">//www.slf4j.org/codes.html#StaticLoggerBinder for further details.</span></span><br><span class="line">C1等待接收消息。。。。。</span><br><span class="line">接收到的消息：AA</span><br><span class="line">接收到的消息：CC</span><br></pre></td></tr></table></figure>

<p>Work01：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">SLF4J: Failed to load class <span class="string">&quot;org.slf4j.impl.StaticLoggerBinder&quot;</span>.</span><br><span class="line">SLF4J: Defaulting to no-operation (NOP) logger implementation</span><br><span class="line">SLF4J: See http:<span class="comment">//www.slf4j.org/codes.html#StaticLoggerBinder for further details.</span></span><br><span class="line">C2等待接收消息。。。。。</span><br><span class="line">接收到的消息：BB</span><br><span class="line">接收到的消息：DD</span><br></pre></td></tr></table></figure>

<h3 id="6、消息应答"><a href="#6、消息应答" class="headerlink" title="6、消息应答"></a>6、消息应答</h3><p>为了保证消息在发送过程中不丢失，RabbitMQ引入消息应答机制，消息应答就是：消费者在接收到消息并且处理该消息之后，告诉RabbitMQ已经处理完毕，RabbitMQ可以删除该消息了。</p>
<ul>
<li><p><input disabled type="checkbox"> 
自动应答</p>
<p>仅适用在消费者可以高效并以某种速率能够处理这些消息的情况下使用。</p>
</li>
<li><p><input disabled type="checkbox"> 
手动应答</p>
<ul>
<li><p>Channel.basicAck（用于肯定确认）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">basicAck</span><span class="params">(<span class="type">long</span> deliveryTag,</span></span><br><span class="line"><span class="params">                              <span class="type">boolean</span> multiple)</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>Channel.basicNack（用于否定确认）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">basicNack</span><span class="params">(<span class="type">long</span> deliveryTag,</span></span><br><span class="line"><span class="params">                               <span class="type">boolean</span> multiple,</span></span><br><span class="line"><span class="params">                               <span class="type">boolean</span> requeue)</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>Channel.basicReject（用于否定确认）与Channel.basicNack相比少了一个参数，不处理该消息直接拒绝，可以将其丢弃。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">basicReject</span><span class="params">(<span class="type">long</span> deliveryTag,</span></span><br><span class="line"><span class="params">                                 <span class="type">boolean</span> requeue)</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><input disabled type="checkbox"> 
Multiple的解释</p>
<p>手动应答的好处是可以批量应答并且减少网络拥堵。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">channel.basicAck(deliverTag,<span class="literal">true</span>)</span><br></pre></td></tr></table></figure>

<p>true表示应答一次，就会应答所有进程里面的消息。</p>
<p>false表示只会应答当前的消息。</p>
<p><img src="/../images/39.PNG" alt="39"></p>
</li>
</ul>
</li>
</ul>
<h4 id="消息应答重新入队"><a href="#消息应答重新入队" class="headerlink" title="消息应答重新入队"></a>消息应答重新入队</h4><p><img src="/../images/40.PNG" alt="40"></p>
<p>新建Task.class</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.tzd.rabbitmq.demo3;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Channel;</span><br><span class="line"><span class="keyword">import</span> com.tzd.rabbitmq.util.RabbitMqUtils;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> tianzedeng</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2022/3/15 - 20:18</span></span><br><span class="line"><span class="comment"> * 消息在手动应答时是不丢失的，放回队列中重新消费</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">task2</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">TASK_QUEUE_NAME</span> <span class="operator">=</span> <span class="string">&quot;ack_queue&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> RabbitMqUtils.getChannel();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//声明队列</span></span><br><span class="line">        channel.queueDeclare(TASK_QUEUE_NAME,<span class="literal">false</span>,<span class="literal">false</span>,<span class="literal">false</span>,<span class="literal">null</span>);</span><br><span class="line">        <span class="comment">//从控制台输入信息</span></span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="keyword">while</span> (scanner.hasNext())&#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> scanner.next();</span><br><span class="line">            channel.basicPublish(<span class="string">&quot;&quot;</span>,TASK_QUEUE_NAME,<span class="literal">null</span>,message.getBytes(<span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">            System.out.println(<span class="string">&quot;生产者发出消息：&quot;</span>+message);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>新建Work03.class</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.tzd.rabbitmq.demo3;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Channel;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.DeliverCallback;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Delivery;</span><br><span class="line"><span class="keyword">import</span> com.tzd.rabbitmq.util.RabbitMqUtils;</span><br><span class="line"><span class="keyword">import</span> com.tzd.rabbitmq.util.SleepUtils;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> tianzedeng</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2022/3/15 - 20:26</span></span><br><span class="line"><span class="comment"> * 消息在手动应答时不允许丢失，放回队列中重新消费</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Work03</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">TASK_QUEUE_NAME</span> <span class="operator">=</span> <span class="string">&quot;ack_queue&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> RabbitMqUtils.getChannel();</span><br><span class="line">        System.out.println(<span class="string">&quot;C1等待接收消息处理时间较短&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">DeliverCallback</span> <span class="variable">deliverCallback</span> <span class="operator">=</span> (consumerTag,message)-&gt;&#123;</span><br><span class="line">            <span class="comment">//沉睡1秒</span></span><br><span class="line">            SleepUtils.sleep(<span class="number">1</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;接收到的消息：&quot;</span>+<span class="keyword">new</span> <span class="title class_">String</span>(message.getBody(),<span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">            <span class="comment">//手动应答</span></span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">            * 1.消息的标记 tag</span></span><br><span class="line"><span class="comment">            * 2.是否批量应答</span></span><br><span class="line"><span class="comment">            * */</span></span><br><span class="line">                    channel.basicAck(message.getEnvelope().getDeliveryTag(),<span class="literal">false</span>);</span><br><span class="line">                    &#125;;</span><br><span class="line">                    <span class="comment">//采用手动应答</span></span><br><span class="line">                    <span class="type">boolean</span> <span class="variable">autoAck</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">                    channel.basicConsume(TASK_QUEUE_NAME,autoAck,deliverCallback,(consumerTag -&gt; &#123;</span><br><span class="line">                    System.out.println(consumerTag+<span class="string">&quot;消费者取消消费接口回调逻辑&quot;</span>);</span><br><span class="line">                    &#125;));</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>新建Work04.class</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.tzd.rabbitmq.demo3;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Channel;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.DeliverCallback;</span><br><span class="line"><span class="keyword">import</span> com.tzd.rabbitmq.util.RabbitMqUtils;</span><br><span class="line"><span class="keyword">import</span> com.tzd.rabbitmq.util.SleepUtils;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> tianzedeng</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2022/3/15 - 20:26</span></span><br><span class="line"><span class="comment"> * 消息在手动应答时不允许丢失，放回队列中重新消费</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Work04</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">TASK_QUEUE_NAME</span> <span class="operator">=</span> <span class="string">&quot;ack_queue&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> RabbitMqUtils.getChannel();</span><br><span class="line">        System.out.println(<span class="string">&quot;C2等待接收消息处理时间较长&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">DeliverCallback</span> <span class="variable">deliverCallback</span> <span class="operator">=</span> (consumerTag,message)-&gt;&#123;</span><br><span class="line">            <span class="comment">//沉睡1秒</span></span><br><span class="line">            SleepUtils.sleep(<span class="number">30</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;接收到的消息：&quot;</span>+<span class="keyword">new</span> <span class="title class_">String</span>(message.getBody(),<span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">            <span class="comment">//手动应答</span></span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">            * 1.消息的标记 tag</span></span><br><span class="line"><span class="comment">            * 2.是否批量应答</span></span><br><span class="line"><span class="comment">            * */</span></span><br><span class="line">            channel.basicAck(message.getEnvelope().getDeliveryTag(),<span class="literal">false</span>);</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">//采用手动应答</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">autoAck</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        channel.basicConsume(TASK_QUEUE_NAME,autoAck,deliverCallback,(consumerTag -&gt; &#123;</span><br><span class="line">            System.out.println(consumerTag+<span class="string">&quot;消费者取消消费接口回调逻辑&quot;</span>);</span><br><span class="line">        &#125;));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>封装睡眠工具类SleepUtils.class</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.tzd.rabbitmq.util;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> tianzedeng</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2022/3/15 - 20:34</span></span><br><span class="line"><span class="comment"> * 睡眠工具类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SleepUtils</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sleep</span><span class="params">(<span class="type">int</span> second)</span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>*second);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (InterruptedException _ignored)&#123;</span><br><span class="line">            Thread.currentThread().interrupt();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<p>Task2：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">SLF4J: Failed to load class <span class="string">&quot;org.slf4j.impl.StaticLoggerBinder&quot;</span>.</span><br><span class="line">SLF4J: Defaulting to no-operation (NOP) logger implementation</span><br><span class="line">SLF4J: See http:<span class="comment">//www.slf4j.org/codes.html#StaticLoggerBinder for further details.</span></span><br><span class="line">aa</span><br><span class="line">生产者发出消息：aa</span><br><span class="line">bb</span><br><span class="line">生产者发出消息：bb</span><br><span class="line">cc</span><br><span class="line">生产者发出消息：cc</span><br><span class="line">dd</span><br><span class="line">生产者发出消息：dd</span><br></pre></td></tr></table></figure>

<p>Work03：在Work04没有接受到消息之前，手动打断Work04时，消息不会丢失，会回调到Work3重新消费。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">SLF4J: Failed to load class <span class="string">&quot;org.slf4j.impl.StaticLoggerBinder&quot;</span>.</span><br><span class="line">SLF4J: Defaulting to no-operation (NOP) logger implementation</span><br><span class="line">SLF4J: See http:<span class="comment">//www.slf4j.org/codes.html#StaticLoggerBinder for further details.</span></span><br><span class="line">C1等待接收消息处理时间较短</span><br><span class="line">接收到的消息：aa</span><br><span class="line">接收到的消息：cc</span><br><span class="line">接收到的消息：dd</span><br></pre></td></tr></table></figure>

<p>Work04：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">SLF4J: Failed to load class <span class="string">&quot;org.slf4j.impl.StaticLoggerBinder&quot;</span>.</span><br><span class="line">SLF4J: Defaulting to no-operation (NOP) logger implementation</span><br><span class="line">SLF4J: See http:<span class="comment">//www.slf4j.org/codes.html#StaticLoggerBinder for further details.</span></span><br><span class="line">C2等待接收消息处理时间较长</span><br><span class="line">接收到的消息：bb</span><br><span class="line"></span><br><span class="line">Process finished with exit code -<span class="number">1</span></span><br></pre></td></tr></table></figure>

<h3 id="7、RabbitMQ持久化"><a href="#7、RabbitMQ持久化" class="headerlink" title="7、RabbitMQ持久化"></a>7、RabbitMQ持久化</h3><h4 id="队列持久化（生产者告知）"><a href="#队列持久化（生产者告知）" class="headerlink" title="队列持久化（生产者告知）"></a>队列持久化（生产者告知）</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//让消息队列持久化</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">durable</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">channel.queueDeclare(ACK_QUEUE_NAME,durable,<span class="literal">false</span>,<span class="literal">false</span>,<span class="literal">null</span>);</span><br></pre></td></tr></table></figure>

<p><img src="/../images/41.PNG" alt="41"></p>
<h4 id="消息持久化（生产者就得提前告知队列要实行消息持久化，即要求保存在磁盘中）"><a href="#消息持久化（生产者就得提前告知队列要实行消息持久化，即要求保存在磁盘中）" class="headerlink" title="消息持久化（生产者就得提前告知队列要实行消息持久化，即要求保存在磁盘中）"></a>消息持久化（生产者就得提前告知队列要实行消息持久化，即要求保存在磁盘中）</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">channel.basicPublish(<span class="string">&quot;&quot;</span>,TASK_QUEUE_NAME,<span class="literal">null</span>,message.getBytes(<span class="string">&quot;UTF-8&quot;</span>));</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//当durable为true时</span></span><br><span class="line">channel.basicPublish(<span class="string">&quot;&quot;</span>,TASK_QUEUE_NAME,MessageProperties.PERSISTENT_TEXT_PLAIN,message.getBytes(<span class="string">&quot;UTF-8&quot;</span>));</span><br></pre></td></tr></table></figure>

<h3 id="8、不公平分发"><a href="#8、不公平分发" class="headerlink" title="8、不公平分发"></a>8、不公平分发</h3><p>设置参数channel.basicQos(1);</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">prefetchCount</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">channel.basicQos(prefetchCount);</span><br></pre></td></tr></table></figure>

<h3 id="9、预期值"><a href="#9、预期值" class="headerlink" title="9、预期值"></a>9、预期值</h3><p><img src="/../images/42.PNG" alt="42"></p>
<h3 id="10、发布确认"><a href="#10、发布确认" class="headerlink" title="10、发布确认"></a>10、发布确认</h3><p><img src="/../images/43.PNG" alt="43"></p>
<h4 id="开启发布确认"><a href="#开启发布确认" class="headerlink" title="开启发布确认"></a>开启发布确认</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> connection.createChannel();</span><br><span class="line">channel.confirmSelect();</span><br></pre></td></tr></table></figure>

<h4 id="单个确认发布"><a href="#单个确认发布" class="headerlink" title="单个确认发布"></a>单个确认发布</h4><p>同步确认发布方式，一手交钱一手交货。但是发布速度慢，容易阻塞。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.tzd.rabbitmq.demo4;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Channel;</span><br><span class="line"><span class="keyword">import</span> com.tzd.rabbitmq.util.RabbitMqUtils;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.awt.*;</span><br><span class="line"><span class="keyword">import</span> java.util.UUID;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> tianzedeng</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2022/3/16 - 15:01</span></span><br><span class="line"><span class="comment"> * 验证发布确认模式：</span></span><br><span class="line"><span class="comment"> * 使用的时间比较哪种确认方式最好</span></span><br><span class="line"><span class="comment"> *      1.单个确认</span></span><br><span class="line"><span class="comment"> *      2.批量确认</span></span><br><span class="line"><span class="comment"> *      3.异步批量确认</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConfirmMessage</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//批量发消息的个数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MESSAGE_COUNT</span>  <span class="operator">=</span> <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//1.单个确认</span></span><br><span class="line">        ConfirmMessage.publishMessageIndividually();<span class="comment">//发布1000个单独确认消息896ms</span></span><br><span class="line">        <span class="comment">//2.批量确认</span></span><br><span class="line">        ConfirmMessage.publishMessageBatch();<span class="comment">//发布1000个批量确认消息，耗时195ms</span></span><br><span class="line">        <span class="comment">//3.异步批量确认</span></span><br><span class="line">		ConfirmMessage.publishMessageAsync();<span class="comment">//发布1000个异步确认消息，耗时76ms</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//单个确认</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">publishMessageIndividually</span><span class="params">()</span><span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> RabbitMqUtils.getChannel();</span><br><span class="line">        <span class="comment">//队列的声明</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">queueName</span> <span class="operator">=</span> UUID.randomUUID().toString();</span><br><span class="line">        channel.queueDeclare(queueName,<span class="literal">true</span>,<span class="literal">false</span>,<span class="literal">false</span>,<span class="literal">null</span>);</span><br><span class="line">        <span class="comment">//开启发布确认</span></span><br><span class="line">        channel.confirmSelect();</span><br><span class="line">        <span class="comment">//开始时间</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">begin</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//批量发消息</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; MESSAGE_COUNT;i++)&#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> i + <span class="string">&quot;&quot;</span>;</span><br><span class="line">            channel.basicPublish(<span class="string">&quot;&quot;</span>,queueName,<span class="literal">null</span>,message.getBytes());</span><br><span class="line">            <span class="comment">//单个消息马上确认</span></span><br><span class="line">            <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> channel.waitForConfirms();</span><br><span class="line">            <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;消息发送成功&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//结束时间</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;发布&quot;</span> + MESSAGE_COUNT +<span class="string">&quot;个单独确认消息&quot;</span>+(end - begin)+<span class="string">&quot;ms&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="批量确认发布"><a href="#批量确认发布" class="headerlink" title="批量确认发布"></a>批量确认发布</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//批量确认消息的大小</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">batchSize</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">        <span class="comment">//批量发送消息 并且批量确认消息</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; MESSAGE_COUNT;i++)&#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> i + <span class="string">&quot;&quot;</span>;</span><br><span class="line">            channel.basicPublish(<span class="string">&quot;&quot;</span>,queueName,<span class="literal">null</span>,message.getBytes());</span><br><span class="line"></span><br><span class="line">            <span class="comment">//判断达到100条消息 批量确认一次</span></span><br><span class="line">            <span class="keyword">if</span> ((i+<span class="number">1</span>)%batchSize == <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="comment">//发布确认</span></span><br><span class="line">                channel.waitForConfirms();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>



<h4 id="异步确认发布"><a href="#异步确认发布" class="headerlink" title="异步确认发布"></a>异步确认发布</h4><p><img src="/../images/44.PNG" alt="44"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">        1.deliveryTag:消息的标记</span></span><br><span class="line"><span class="comment">        2.multiple：是否为批量确认</span></span><br><span class="line"><span class="comment">        * */</span></span><br><span class="line">        <span class="comment">//消息确认成功 回调函数</span></span><br><span class="line">        <span class="type">ConfirmCallback</span> <span class="variable">ackCallback</span> <span class="operator">=</span> (deliveryTag,multiple)-&gt;&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;确认的消息：&quot;</span>+ deliveryTag );</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">//消息确认失败 回调函数</span></span><br><span class="line">        <span class="type">ConfirmCallback</span> <span class="variable">nackCallback</span> <span class="operator">=</span> (deliveryTag,multiple)-&gt;&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;未确认的消息：&quot;</span>+ deliveryTag );</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">//准备消息的监听器 哪些消息成功 哪些消息失败</span></span><br><span class="line">        channel.addConfirmListener(ackCallback,nackCallback);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//批量发送消息</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; MESSAGE_COUNT; i++) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> i + <span class="string">&quot;&quot;</span>;</span><br><span class="line">            channel.basicPublish(<span class="string">&quot;&quot;</span>,queueName,<span class="literal">null</span>,message.getBytes());</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<h4 id="如何处理异步未确认消息"><a href="#如何处理异步未确认消息" class="headerlink" title="如何处理异步未确认消息"></a>如何处理异步未确认消息</h4><p>最好的解决方法就是把未确认的消息放到一个基于内存的能被发布线程访问的队列，比如说用ConcurrentLinkedQueue这个队列在confirm callbacks与发布线程之间进行消息的传递。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">       * 线程安全有序的一个哈希表 适用于高并发的情况</span></span><br><span class="line"><span class="comment">       * 1.轻松的将序号与消息进行关联</span></span><br><span class="line"><span class="comment">       * 2.可以批量删除条目 只要给到序号即可</span></span><br><span class="line"><span class="comment">       * 3.支持高并发</span></span><br><span class="line"><span class="comment">       * */</span></span><br><span class="line">       ConcurrentSkipListMap&lt;Long,String&gt; outstandingConfirms =</span><br><span class="line">               <span class="keyword">new</span> <span class="title class_">ConcurrentSkipListMap</span>&lt;&gt;();</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//消息确认成功 回调函数</span></span><br><span class="line">        <span class="type">ConfirmCallback</span> <span class="variable">ackCallback</span> <span class="operator">=</span> (deliveryTag,multiple)-&gt;&#123;</span><br><span class="line">            <span class="keyword">if</span> (multiple)&#123;</span><br><span class="line">                <span class="comment">//2.删除已经确认的消息 剩下就是未确认的消息</span></span><br><span class="line">                ConcurrentNavigableMap&lt;Long, String&gt; longStringConcurrentNavigableMap =</span><br><span class="line">                        outstandingConfirms.headMap(deliveryTag);</span><br><span class="line">                longStringConcurrentNavigableMap.clear();</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                outstandingConfirms.remove(deliveryTag);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;确认的消息：&quot;</span>+ deliveryTag );</span><br><span class="line">        &#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//消息确认失败 回调函数</span></span><br><span class="line">        <span class="type">ConfirmCallback</span> <span class="variable">nackCallback</span> <span class="operator">=</span> (deliveryTag,multiple)-&gt;&#123;</span><br><span class="line">            <span class="comment">//3.打印一下未确认的消息都有哪些</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> outstandingConfirms.get(deliveryTag);</span><br><span class="line">            System.out.println(<span class="string">&quot;未确认的消息：&quot;</span>+message+<span class="string">&quot;::::::未确认的消息tag：&quot;</span>+ deliveryTag );</span><br><span class="line">        &#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//批量发送消息</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; MESSAGE_COUNT; i++) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> i + <span class="string">&quot;&quot;</span>;</span><br><span class="line">            channel.basicPublish(<span class="string">&quot;&quot;</span>,queueName,<span class="literal">null</span>,message.getBytes());</span><br><span class="line">            <span class="comment">//1.记录所有要发送到的消息 消息的总和</span></span><br><span class="line">            outstandingConfirms.put(channel.getNextPublishSeqNo(),message);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<h3 id="11、交换机"><a href="#11、交换机" class="headerlink" title="11、交换机"></a>11、交换机</h3><p><img src="/../images/45.PNG" alt="45"></p>
<p>RabbitMQ消息传递模型的核心思想：生产者的消息从不会直接发送到队列。实际上，通常生产者甚至都不知道这些消息传递到了哪个队列。</p>
<p>相反，生产者只能将消息发送到交换机。交换机工作的内容很简单，一方面它接收来自生产者的消息，另一方变将它们推入队列。交换机必须确切知道如何处理收到的消息。是应该把消息放到特定队列还是说把他们放到许多队列中还是说应该丢弃它们。这就是交换机来决定的。</p>
<p><img src="/../images/46.PNG" alt="46"></p>
<h4 id="Exchanges的类型"><a href="#Exchanges的类型" class="headerlink" title="Exchanges的类型"></a>Exchanges的类型</h4><p>直接（direct）、主题（topic）、标题（header）、扇出（fanout）。</p>
<h4 id="创建临时队列"><a href="#创建临时队列" class="headerlink" title="创建临时队列"></a>创建临时队列</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">queueName</span> <span class="operator">=</span> channel.queueDeclare().getQueue();</span><br></pre></td></tr></table></figure>

<h4 id="绑定（binding）"><a href="#绑定（binding）" class="headerlink" title="绑定（binding）"></a>绑定（binding）</h4><p>绑定就是exchange和queue之间的桥梁，它告诉我们exchange和哪个队列进行绑定关系。x与Q1和Q2进行绑定。</p>
<p><img src="/../images/47.PNG" alt="47"></p>
<h4 id="扇出（Fanout）—-发布订阅模式"><a href="#扇出（Fanout）—-发布订阅模式" class="headerlink" title="扇出（Fanout）—-发布订阅模式"></a>扇出（Fanout）—-发布订阅模式</h4><p>它将接收到的消息广播到它知道的所有队列中。</p>
<p>新建消息的接收类：ReceiveLogs01和ReceiveLogs02</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.tzd.rabbitmq.demo5;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Channel;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.DeliverCallback;</span><br><span class="line"><span class="keyword">import</span> com.tzd.rabbitmq.util.RabbitMqUtils;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> tianzedeng</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2022/3/16 - 19:27</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReceiveLogs01</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">EXCHANGE_NAME</span> <span class="operator">=</span> <span class="string">&quot;logs&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> RabbitMqUtils.getChannel();</span><br><span class="line">        <span class="comment">//声明交换机</span></span><br><span class="line">        channel.exchangeDeclare(EXCHANGE_NAME ,<span class="string">&quot;fanout&quot;</span>);</span><br><span class="line">        <span class="comment">//声明一个队列 临时队列</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">queueName</span> <span class="operator">=</span> channel.queueDeclare().getQueue();</span><br><span class="line">        <span class="comment">//绑定交换机与队列</span></span><br><span class="line">        channel.queueBind(queueName,EXCHANGE_NAME,<span class="string">&quot;&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;等待接收消息，把接收到的消息打印在屏幕上......&quot;</span>);</span><br><span class="line">        <span class="comment">//接收消息</span></span><br><span class="line">        <span class="type">DeliverCallback</span> <span class="variable">deliverCallback</span> <span class="operator">=</span> (consumeTag, message)-&gt;&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;ReceiveLogs01控制台打印接收到的消息：&quot;</span>+<span class="keyword">new</span> <span class="title class_">String</span>(message.getBody(),<span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">//消费者取消消息时回调接口</span></span><br><span class="line">        channel.basicConsume(queueName,<span class="literal">true</span>,deliverCallback,consumerTag -&gt;&#123;&#125; );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>新建生产者类：EmitLog</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.tzd.rabbitmq.demo5;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Channel;</span><br><span class="line"><span class="keyword">import</span> com.tzd.rabbitmq.util.RabbitMqUtils;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> tianzedeng</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2022/3/16 - 19:46</span></span><br><span class="line"><span class="comment"> * 发消息给交换机</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EmitLog</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">EXCHANGE_NAME</span> <span class="operator">=</span> <span class="string">&quot;logs&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> RabbitMqUtils.getChannel();</span><br><span class="line">        channel.exchangeDeclare(EXCHANGE_NAME,<span class="string">&quot;fanout&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (scanner.hasNext())&#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> scanner.next();</span><br><span class="line">            channel.basicPublish(EXCHANGE_NAME,<span class="string">&quot;&quot;</span>,<span class="literal">null</span>,message.getBytes(<span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">            System.out.println(<span class="string">&quot;生产者发出消息：&quot;</span>+message);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<p><img src="/../images/48.PNG" alt="48"></p>
<p><img src="/../images/49.PNG" alt="49"></p>
<p><img src="/../images/50.PNG" alt="50"></p>
<h4 id="Direct-Exchange—–路由模式"><a href="#Direct-Exchange—–路由模式" class="headerlink" title="Direct Exchange—–路由模式"></a>Direct Exchange—–路由模式</h4><p>Routing key不相同。</p>
<p><img src="/../images/51.PNG" alt="51"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">channel.queueBind(<span class="string">&quot;console&quot;</span>,EXCHANGE_NAME,<span class="string">&quot;info&quot;</span>);</span><br><span class="line">channel.queueBind(<span class="string">&quot;console&quot;</span>,EXCHANGE_NAME,<span class="string">&quot;warning&quot;</span>);</span><br><span class="line"></span><br><span class="line">channel.queueBind(<span class="string">&quot;disk&quot;</span>,EXCHANGE_NAME,<span class="string">&quot;error&quot;</span>);</span><br><span class="line"></span><br><span class="line">channel.basicPublish(EXCHANGE_NAME,<span class="string">&quot;error/info/warning&quot;</span>,<span class="literal">null</span>,message.getBytes(<span class="string">&quot;UTF-8&quot;</span>));</span><br></pre></td></tr></table></figure>

<h3 id="12、Topics"><a href="#12、Topics" class="headerlink" title="12、Topics"></a>12、Topics</h3><p>当想接收不同类型的日志时，可以使用topic类型。</p>
<p><img src="/../images/52.PNG" alt="52"></p>
<p><img src="/../images/53.PNG" alt="53"></p>
<p><img src="/../images/54.PNG" alt="53"></p>
<p>注意事项：</p>
<p>当一个队列绑定键是#，那么这个队列将接收所有数据，跟fanout类似。</p>
<p>如果队列绑定键当中没有#和*出现，那么该队列绑定类型就是direct。</p>
<p>新建ReceiveLogsTopic01和ReceiveLogsTopic02类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.tzd.rabbitmq.demo7;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.BuiltinExchangeType;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Channel;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.DeliverCallback;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Delivery;</span><br><span class="line"><span class="keyword">import</span> com.tzd.rabbitmq.util.RabbitMqUtils;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> tianzedeng</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2022/3/16 - 21:02</span></span><br><span class="line"><span class="comment"> * 声明主题交换机及相关队列</span></span><br><span class="line"><span class="comment"> * 消费者C1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReceiveLogsTopic01</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//交换机的名称</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">EXCHANGE_NAME</span> <span class="operator">=</span> <span class="string">&quot;topic_logs&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//创建信道</span></span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> RabbitMqUtils.getChannel();</span><br><span class="line">        <span class="comment">//声明交换机</span></span><br><span class="line">        channel.exchangeDeclare(EXCHANGE_NAME, BuiltinExchangeType.TOPIC);</span><br><span class="line">        <span class="comment">//声明队列</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">queueName</span> <span class="operator">=</span> <span class="string">&quot;Q1&quot;</span>;</span><br><span class="line">        channel.queueDeclare(queueName,<span class="literal">false</span>,<span class="literal">false</span>,<span class="literal">false</span>,<span class="literal">null</span>);</span><br><span class="line">        channel.queueBind(queueName,EXCHANGE_NAME,<span class="string">&quot;*.orange.*&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;等待接收消息......&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">DeliverCallback</span> <span class="variable">deliverCallback</span> <span class="operator">=</span> (consumerTag,message)-&gt;&#123;</span><br><span class="line">            System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(message.getBody(),<span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">            System.out.println(<span class="string">&quot;接收队列：&quot;</span>+queueName+<span class="string">&quot;绑定键&quot;</span>+message.getEnvelope().getRoutingKey());</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">//接收消息</span></span><br><span class="line">        channel.basicConsume(queueName,<span class="literal">true</span>,deliverCallback,consumerTag -&gt; &#123;&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>新建生产者类EmitLogTopic：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.tzd.rabbitmq.demo7;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Channel;</span><br><span class="line"><span class="keyword">import</span> com.tzd.rabbitmq.util.RabbitMqUtils;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> tianzedeng</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2022/3/16 - 21:17</span></span><br><span class="line"><span class="comment"> * 生产者</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EmiLogTopic</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//交换机的名称</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">EXCHANGE_NAME</span> <span class="operator">=</span> <span class="string">&quot;topic_logs&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//创建信道</span></span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> RabbitMqUtils.getChannel();</span><br><span class="line">        <span class="comment">//发送消息</span></span><br><span class="line">        Map&lt;String,String&gt; bindingMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        bindingMap.put(<span class="string">&quot;quick.orange.rabbit&quot;</span>,<span class="string">&quot;被队列Q1Q2接收&quot;</span>);</span><br><span class="line">        bindingMap.put(<span class="string">&quot;lazy.orange.elephant&quot;</span>,<span class="string">&quot;被队列Q1Q2接收&quot;</span>);</span><br><span class="line">        bindingMap.put(<span class="string">&quot;quick.orange.fox&quot;</span>,<span class="string">&quot;被队列Q1接收&quot;</span>);</span><br><span class="line">        bindingMap.put(<span class="string">&quot;lazy.brown.fox&quot;</span>,<span class="string">&quot;被队列Q2接收&quot;</span>);</span><br><span class="line">        bindingMap.put(<span class="string">&quot;lazy.pink.rabbit&quot;</span>,<span class="string">&quot;虽然满足两个绑定但只被Q2接收&quot;</span>);</span><br><span class="line">        bindingMap.put(<span class="string">&quot;quick.brown.fox&quot;</span>,<span class="string">&quot;不匹配任何绑定不会被任何队列接收到会被丢弃&quot;</span>);</span><br><span class="line">        bindingMap.put(<span class="string">&quot;quick.orange.male.rabbit&quot;</span>,<span class="string">&quot;是四个单词不匹配任何绑定会被丢弃&quot;</span>);</span><br><span class="line">        bindingMap.put(<span class="string">&quot;lazy.orange.male.rabbit&quot;</span>,<span class="string">&quot;是四个单词但匹配Q2&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;String, String&gt; bindingKeyEntry : bindingMap.entrySet()) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">routingKey</span> <span class="operator">=</span> bindingKeyEntry.getKey();</span><br><span class="line">            <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> bindingKeyEntry.getValue();</span><br><span class="line">            channel.basicPublish(EXCHANGE_NAME,routingKey,<span class="literal">null</span>,message.getBytes(<span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">            System.out.println(<span class="string">&quot;生产者发出消息:&quot;</span>+message);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<p><img src="/../images/55.PNG" alt="55"></p>
<p><img src="/../images/56.PNG" alt="56"></p>
<p><img src="/../images/57.PNG" alt="57"></p>
<h3 id="13、死信队列"><a href="#13、死信队列" class="headerlink" title="13、死信队列"></a>13、死信队列</h3><h4 id="死信的概念"><a href="#死信的概念" class="headerlink" title="死信的概念"></a>死信的概念</h4><p>无法被消费的消息叫死信。一般来说，producer将消息投递到broker或者直接到queue，consumer从queue取出消息进行消费，但某些时候由于特定的原因导致queue中的某些消息无法消费，这样的消息如果没有后续的处理，就变成死信，有死信就自然有了死信队列。</p>
<p>应用场景：为了保证订单业务的消息数据不丢失，需要使用到RabbitMQ的死信队列机制，当消息消费发生异常时，将消息投入死信队列中，还有比如说：用户在商城下单成功并点击去支付后在指定时间未支付时自动失效。</p>
<h4 id="死信的来源"><a href="#死信的来源" class="headerlink" title="死信的来源"></a>死信的来源</h4><ul>
<li>消息TTL过期</li>
<li>队列达到最大限度</li>
<li>消息被拒绝（basic.reject或basic.nack）并且requeue&#x3D;false</li>
</ul>
<p><img src="/../images/58.PNG" alt="58"></p>
<p>新建Consumer01类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.tzd.rabbitmq.demo8;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.BuiltinExchangeType;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Channel;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.DeliverCallback;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Delivery;</span><br><span class="line"><span class="keyword">import</span> com.tzd.rabbitmq.util.RabbitMqUtils;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> tianzedeng</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2022/3/17 - 14:38</span></span><br><span class="line"><span class="comment"> * 死信队列</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 消费者1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Consumer01</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//普通交换机名称</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">NORMAL_EXCHANGE</span> <span class="operator">=</span> <span class="string">&quot;normal_exchange&quot;</span>;</span><br><span class="line">    <span class="comment">//死信交换机名称</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">DEAD_EXCHANGE</span> <span class="operator">=</span> <span class="string">&quot;dead_exchange&quot;</span>;</span><br><span class="line">    <span class="comment">//普通队列名称</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">NORMAL_QUEUE</span> <span class="operator">=</span> <span class="string">&quot; normal_queue&quot;</span>;</span><br><span class="line">    <span class="comment">//死信队列名称</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">DEAD_QUEUE</span> <span class="operator">=</span> <span class="string">&quot; dead_queue&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> RabbitMqUtils.getChannel();</span><br><span class="line">        <span class="comment">//声明死信交换机和普通交换机 类型为direct</span></span><br><span class="line">        channel.exchangeDeclare(NORMAL_EXCHANGE, BuiltinExchangeType.DIRECT);</span><br><span class="line">        channel.exchangeDeclare(DEAD_EXCHANGE,BuiltinExchangeType.DIRECT);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//声明普通队列</span></span><br><span class="line">        Map&lt;String, Object&gt; arguments = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">//过期时间</span></span><br><span class="line">        <span class="comment">//arguments.put(&quot;x-message-ttl&quot;,10000);</span></span><br><span class="line">        <span class="comment">//正常队列设置死信交换机</span></span><br><span class="line">        arguments.put(<span class="string">&quot;x-dead-letter-exchange&quot;</span>,DEAD_EXCHANGE);</span><br><span class="line">        <span class="comment">//设置死信routing key</span></span><br><span class="line">        arguments.put(<span class="string">&quot;x-dead-letter-routing-key&quot;</span>,<span class="string">&quot;lisi&quot;</span>);</span><br><span class="line">        channel.queueDeclare(NORMAL_QUEUE,<span class="literal">false</span>,<span class="literal">false</span>,<span class="literal">false</span>,arguments);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//声明死信队列</span></span><br><span class="line">        channel.queueDeclare(DEAD_QUEUE,<span class="literal">false</span>,<span class="literal">false</span>,<span class="literal">false</span>,<span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//绑定普通交换机与普通队列</span></span><br><span class="line">        channel.queueBind(NORMAL_QUEUE,NORMAL_EXCHANGE,<span class="string">&quot;zhangsan&quot;</span>);</span><br><span class="line">        <span class="comment">//绑定死信交换机与死信队列</span></span><br><span class="line">        channel.queueBind(DEAD_QUEUE,DEAD_EXCHANGE,<span class="string">&quot;lisi&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;等待接收消息......&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">DeliverCallback</span> <span class="variable">deliverCallback</span> <span class="operator">=</span> ( consumerTag,  message)-&gt;&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Consumer01接收的消息是：&quot;</span>+<span class="keyword">new</span> <span class="title class_">String</span>(message.getBody(),<span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">        &#125;;</span><br><span class="line">        channel.basicConsume(NORMAL_QUEUE,<span class="literal">true</span>,deliverCallback,consumerTag -&gt; &#123;&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>新建Consumer02类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.tzd.rabbitmq.demo8;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.BuiltinExchangeType;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Channel;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.DeliverCallback;</span><br><span class="line"><span class="keyword">import</span> com.tzd.rabbitmq.util.RabbitMqUtils;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> tianzedeng</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2022/3/17 - 14:38</span></span><br><span class="line"><span class="comment"> * 死信队列</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 消费者2</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Consumer02</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//死信队列名称</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">DEAD_QUEUE</span> <span class="operator">=</span> <span class="string">&quot; dead_queue&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> RabbitMqUtils.getChannel();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;等待接收消息......&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">DeliverCallback</span> <span class="variable">deliverCallback</span> <span class="operator">=</span> ( consumerTag,  message)-&gt;&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Consumer02接收的消息是：&quot;</span>+<span class="keyword">new</span> <span class="title class_">String</span>(message.getBody(),<span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">        &#125;;</span><br><span class="line">        channel.basicConsume(DEAD_QUEUE,<span class="literal">true</span>,deliverCallback,consumerTag -&gt; &#123;&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>新建Producer类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.tzd.rabbitmq.demo8;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.AMQP;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Channel;</span><br><span class="line"><span class="keyword">import</span> com.tzd.rabbitmq.util.RabbitMqUtils;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> tianzedeng</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2022/3/17 - 15:08</span></span><br><span class="line"><span class="comment"> * 死信队列----生产者</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Producer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">NORMAL_EXCHANGE</span> <span class="operator">=</span> <span class="string">&quot;normal_exchange&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> RabbitMqUtils.getChannel();</span><br><span class="line">        <span class="comment">//死信消息 设置TTL时间（time to live） 单位是ms</span></span><br><span class="line">        AMQP.<span class="type">BasicProperties</span> <span class="variable">properties</span> <span class="operator">=</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">AMQP</span>.BasicProperties()</span><br><span class="line">                .builder().expiration(<span class="string">&quot;10000&quot;</span>).build();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;i &lt; <span class="number">11</span>;i++)&#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="string">&quot;info&quot;</span>+i;</span><br><span class="line">            channel.basicPublish(NORMAL_EXCHANGE,<span class="string">&quot;zhangsan&quot;</span>,<span class="literal">null</span>,message.getBytes());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<p><img src="/../images/59.PNG" alt="59"></p>
<h3 id="14、延迟队列"><a href="#14、延迟队列" class="headerlink" title="14、延迟队列"></a>14、延迟队列</h3><p>延时队列内部是有序的。最重要的特性就体现在它的延时属性上，延时队列中的元素是希望在指定时间到了以后或之前取出和处理，简单来说，延时队列就是用来存放需要在指定时间被处理的元素的队列。</p>
<p>使用场景</p>
<ul>
<li><input checked disabled type="checkbox"> 订单在十分钟之内未支付则自动取消</li>
<li><input checked disabled type="checkbox"> 新创建的店铺，如果在十天之内都没有上传过商品，则自动发送消息提醒</li>
<li><input checked disabled type="checkbox"> 用户注册成功后，如果三天内没有登录则进行短信提醒</li>
<li><input checked disabled type="checkbox"> 用户发起退款，如果三天内没有得到处理则通知相关运营人员</li>
<li><input checked disabled type="checkbox"> 预订会议后，需要在预订的时间点前十分钟通知各个与会人员参加会议</li>
</ul>
<h3 id="15、整合SpringBoot"><a href="#15、整合SpringBoot" class="headerlink" title="15、整合SpringBoot"></a>15、整合SpringBoot</h3><p>配置类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.tzd.rabbitmq.springboot_rabbitmq.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> springfox.documentation.builders.ApiInfoBuilder;</span><br><span class="line"><span class="keyword">import</span> springfox.documentation.service.ApiInfo;</span><br><span class="line"><span class="keyword">import</span> springfox.documentation.service.Contact;</span><br><span class="line"><span class="keyword">import</span> springfox.documentation.spi.DocumentationType;</span><br><span class="line"><span class="keyword">import</span> springfox.documentation.spring.web.plugins.Docket;</span><br><span class="line"><span class="keyword">import</span> springfox.documentation.swagger2.annotations.EnableSwagger2;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> tianzedeng</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2022/3/17 - 18:33</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableSwagger2</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SwaggerConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Docket <span class="title function_">webApiConfig</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Docket</span>(DocumentationType.SWAGGER_2)</span><br><span class="line">                .groupName(<span class="string">&quot;webApi&quot;</span>)</span><br><span class="line">                .apiInfo(webApiInfo())</span><br><span class="line">                .select()</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ApiInfo <span class="title function_">webApiInfo</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ApiInfoBuilder</span>()</span><br><span class="line">                .title(<span class="string">&quot;rabbitmq接口文档&quot;</span>)</span><br><span class="line">                .description(<span class="string">&quot;本文描述了rabbitmq微服务接口定义&quot;</span>)</span><br><span class="line">                .version(<span class="string">&quot;1.0&quot;</span>)</span><br><span class="line">                .contact(<span class="keyword">new</span> <span class="title class_">Contact</span>(<span class="string">&quot;enjoy6288&quot;</span>,<span class="string">&quot;http://atguigu.com&quot;</span>,<span class="string">&quot;1129783206@qq.com&quot;</span>))</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>添加依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-amqp<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>fastjson<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.47<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.springfox<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>springfox-swagger2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.9.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.springfox<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>springfox-swagger-ui<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.9.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.amqp<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-rabbit-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>修改配置</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring.rabbitmq.host</span>=<span class="string">本地ip</span></span><br><span class="line"><span class="attr">spring.rabbitmq.port</span>=<span class="string">5672</span></span><br><span class="line"><span class="attr">spring.rabbitmq.username</span>=<span class="string">username</span></span><br><span class="line"><span class="attr">spring.rabbitmq.password</span>=<span class="string">password</span></span><br></pre></td></tr></table></figure>

<h3 id="16、队列TTL"><a href="#16、队列TTL" class="headerlink" title="16、队列TTL"></a>16、队列TTL</h3><p><img src="/../images/60.PNG" alt="60"></p>
<p>在pom.xml中添加依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--RabbitMQ 依赖--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-amqp<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>fastjson<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.47<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--swagger--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.springfox<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>springfox-swagger2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.0.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.springfox<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>springfox-swagger-ui<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.0.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--RabbitMQ 测试依赖--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.amqp<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-rabbit-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>新建配置文件类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.tzd.rabbitmq.springboot_rabbitmq.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.core.*;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Qualifier;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> tianzedeng</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2022/3/17 - 18:59</span></span><br><span class="line"><span class="comment"> * ttl----配置文件类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TtlQueueConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//普通交换机的名称</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">X_EXCHANGE</span> <span class="operator">=</span> <span class="string">&quot;X&quot;</span>;</span><br><span class="line">    <span class="comment">//死信交换机的名称</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">Y_DEAD_LETTER_EXCHANGE</span> <span class="operator">=</span> <span class="string">&quot;Y&quot;</span>;</span><br><span class="line">    <span class="comment">//普通队列的名称</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">QUEUE_A</span> <span class="operator">=</span> <span class="string">&quot;QA&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">QUEUE_B</span> <span class="operator">=</span> <span class="string">&quot;QB&quot;</span>;</span><br><span class="line">    <span class="comment">//死信队列的名称</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">DEAD_LETTER_QUEUE</span> <span class="operator">=</span> <span class="string">&quot;QD&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//声明xExchange 别名</span></span><br><span class="line">    <span class="meta">@Bean(&quot;xExchange&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> DirectExchange <span class="title function_">xExchange</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DirectExchange</span>(X_EXCHANGE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//声明yExchange 别名</span></span><br><span class="line">    <span class="meta">@Bean(&quot;yExchange&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> DirectExchange <span class="title function_">yExchange</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DirectExchange</span>(Y_DEAD_LETTER_EXCHANGE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//声明普通队列 TTL为10s</span></span><br><span class="line">    <span class="meta">@Bean(&quot;queueA&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">queueA</span><span class="params">()</span>&#123;</span><br><span class="line">        Map&lt;String, Object&gt; arguments = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(<span class="number">3</span>);</span><br><span class="line">        <span class="comment">//设置死信交换机</span></span><br><span class="line">        arguments.put(<span class="string">&quot;x-dead-letter-exchange&quot;</span>,Y_DEAD_LETTER_EXCHANGE);</span><br><span class="line">        <span class="comment">//设置死信routing-key</span></span><br><span class="line">        arguments.put(<span class="string">&quot;x-dead-letter-routing-key&quot;</span>,<span class="string">&quot;YD&quot;</span>);</span><br><span class="line">        <span class="comment">//设置TTL</span></span><br><span class="line">        arguments.put(<span class="string">&quot;x-message-ttl&quot;</span>,<span class="number">10000</span>);</span><br><span class="line">        <span class="keyword">return</span> QueueBuilder.durable(QUEUE_A).withArguments(arguments).build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//声明普通队列 TTL为40s</span></span><br><span class="line">    <span class="meta">@Bean(&quot;queueB&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">queueB</span><span class="params">()</span>&#123;</span><br><span class="line">        Map&lt;String, Object&gt; arguments = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(<span class="number">3</span>);</span><br><span class="line">        <span class="comment">//设置死信交换机</span></span><br><span class="line">        arguments.put(<span class="string">&quot;x-dead-letter-exchange&quot;</span>,Y_DEAD_LETTER_EXCHANGE);</span><br><span class="line">        <span class="comment">//设置死信routing-key</span></span><br><span class="line">        arguments.put(<span class="string">&quot;x-dead-letter-routing-key&quot;</span>,<span class="string">&quot;YD&quot;</span>);</span><br><span class="line">        <span class="comment">//设置TTL</span></span><br><span class="line">        arguments.put(<span class="string">&quot;x-message-ttl&quot;</span>,<span class="number">40000</span>);</span><br><span class="line">        <span class="keyword">return</span> QueueBuilder.durable(QUEUE_A).withArguments(arguments).build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//声明死信队列</span></span><br><span class="line">    <span class="meta">@Bean(&quot;queueD&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">queueD</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> QueueBuilder.durable(DEAD_LETTER_QUEUE).build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//绑定</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Binding <span class="title function_">queueABindingX</span><span class="params">(<span class="meta">@Qualifier(&quot;queueA&quot;)</span> Queue queueA,</span></span><br><span class="line"><span class="params">                                  <span class="meta">@Qualifier(&quot;xExchange&quot;)</span> DirectExchange xExchange)</span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(queueA).to(xExchange).with(<span class="string">&quot;XA&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Binding <span class="title function_">queueBBindingX</span><span class="params">(<span class="meta">@Qualifier(&quot;queueB&quot;)</span> Queue queueB,</span></span><br><span class="line"><span class="params">                                  <span class="meta">@Qualifier(&quot;xExchange&quot;)</span> DirectExchange xExchange)</span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(queueB).to(xExchange).with(<span class="string">&quot;XB&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Binding <span class="title function_">queueDBindingY</span><span class="params">(<span class="meta">@Qualifier(&quot;queueD&quot;)</span> Queue queueD,</span></span><br><span class="line"><span class="params">                                  <span class="meta">@Qualifier(&quot;yExchange&quot;)</span> DirectExchange yExchange)</span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(queueD).to(yExchange).with(<span class="string">&quot;YD&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>新建消费者类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.tzd.rabbitmq.springboot_rabbitmq.consumer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Channel;</span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.core.Message;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.rabbit.annotation.RabbitListener;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> tianzedeng</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2022/3/17 - 19:37</span></span><br><span class="line"><span class="comment"> * 队列TTL 消费者</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DeadLetterQueueConsumer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//接收消息</span></span><br><span class="line">    <span class="meta">@RabbitListener(queues = &quot;QD&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">receiveD</span><span class="params">(Message message, Channel channel)</span>&#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(message.getBody());</span><br><span class="line">        log.info(<span class="string">&quot;当前时间:&#123;&#125;,收到死信队列的消息:&#123;&#125;&quot;</span>,<span class="keyword">new</span> <span class="title class_">Date</span>().toString(),msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>新建转发请求类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.tzd.rabbitmq.springboot_rabbitmq.controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.rabbit.core.RabbitTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.PathVariable;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> tianzedeng</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2022/3/17 - 19:28</span></span><br><span class="line"><span class="comment"> * 发送延迟消息</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/ttl&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SendMsgController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RabbitTemplate rabbitTemplate;</span><br><span class="line">    <span class="comment">//开始发消息</span></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/sendMsg/&#123;message&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">senMsg</span><span class="params">(<span class="meta">@PathVariable</span> String message)</span>&#123;</span><br><span class="line">        log.info(<span class="string">&quot;当前时间:&#123;&#125;,发送一条信息给两个TTL队列:&#123;&#125;&quot;</span>,<span class="keyword">new</span> <span class="title class_">Date</span>().toString(),message);</span><br><span class="line"></span><br><span class="line">        rabbitTemplate.convertAndSend(<span class="string">&quot;X&quot;</span>,<span class="string">&quot;XA&quot;</span>,<span class="string">&quot;消息来自ttl为10s：&quot;</span>+message);</span><br><span class="line">        rabbitTemplate.convertAndSend(<span class="string">&quot;X&quot;</span>,<span class="string">&quot;XB&quot;</span>,<span class="string">&quot;消息来自ttl为40s：&quot;</span>+message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：<a href="http://localhost:8080/ttl/sendMsg/%E4%BD%A0%E5%A5%BD">http://localhost:8080/ttl/sendMsg/你好</a></p>
<h3 id="17、发布确认高级"><a href="#17、发布确认高级" class="headerlink" title="17、发布确认高级"></a>17、发布确认高级</h3><p>在生产环境中由于一些不明原因，导致 RabbitMQ 重启，在 RabbitMQ 重启期间生产者消息投递失败， 导致消息丢失，需要手动处理和恢复。于是，我们开始思考，如何才能进行 RabbitMQ 的消息可靠投递呢？</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring.rabbitmq.publisher-confirm-type</span>=<span class="string">correlated</span></span><br></pre></td></tr></table></figure>

<ul>
<li>NONE：是禁用发布确认模式，是默认值</li>
<li>CORRELATED： 是发布消息成功到交换器后会触发回调方法。</li>
<li>SIMPLE ：经测试有两种效果，其一效果和 CORRELATED 值一样会触发回调方法，其二在发布消息成功后使用 rabbitTemplate 调用 waitForConfirms 或 waitForConfirmsOrDie 方法等待 broker 节点返回发送结果，根据返回结果来判定下一步的逻辑，要注意的点是 waitForConfirmsOrDie 方法如果返回 false 则会关闭 channel，则接下来无法发送消息到 broker。</li>
</ul>
<p>添加配置类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConfirmConfig</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">CONFIRM_EXCHANGE_NAME</span> <span class="operator">=</span> <span class="string">&quot;confirm.exchange&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">CONFIRM_QUEUE_NAME</span> <span class="operator">=</span> <span class="string">&quot;confirm.queue&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//声明业务 Exchange</span></span><br><span class="line">    <span class="meta">@Bean(&quot;confirmExchange&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> DirectExchange <span class="title function_">confirmExchange</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DirectExchange</span>(CONFIRM_EXCHANGE_NAME);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 声明确认队列</span></span><br><span class="line">    <span class="meta">@Bean(&quot;confirmQueue&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">confirmQueue</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> QueueBuilder.durable(CONFIRM_QUEUE_NAME).build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 声明确认队列绑定关系</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Binding <span class="title function_">queueBinding</span><span class="params">(<span class="meta">@Qualifier(&quot;confirmQueue&quot;)</span> Queue queue,</span></span><br><span class="line"><span class="params">                                <span class="meta">@Qualifier(&quot;confirmExchange&quot;)</span> DirectExchange exchange)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(queue).to(exchange).with(<span class="string">&quot;key1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>消息生产者回调接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyCallBack</span> <span class="keyword">implements</span> <span class="title class_">RabbitTemplate</span>.ConfirmCallback &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 交换机不管是否收到消息的一个回调方法</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> correlationData 消息相关数据</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ack             交换机是否收到消息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> cause           为收到消息的原因</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">confirm</span><span class="params">(CorrelationData correlationData, <span class="type">boolean</span> ack, String cause)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">id</span> <span class="operator">=</span> correlationData != <span class="literal">null</span> ? correlationData.getId() : <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">if</span> (ack) &#123;</span><br><span class="line">            log.info(<span class="string">&quot;交换机已经收到 id 为:&#123;&#125;的消息&quot;</span>, id);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            log.info(<span class="string">&quot;交换机还未收到 id 为:&#123;&#125;消息，原因:&#123;&#125;&quot;</span>, id, cause);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>消息生产者</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/confirm&quot;)</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProducerController</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">CONFIRM_EXCHANGE_NAME</span> <span class="operator">=</span> <span class="string">&quot;confirm.exchange&quot;</span>;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RabbitTemplate rabbitTemplate;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> MyCallBack myCallBack;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//依赖注入 rabbitTemplate 之后再设置它的回调对象</span></span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> &#123;</span><br><span class="line">        rabbitTemplate.setConfirmCallback(myCallBack);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 消息回调和退回</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> message</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@GetMapping(&quot;sendMessage/&#123;message&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendMessage</span><span class="params">(<span class="meta">@PathVariable</span> String message)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//指定消息 id 为 1</span></span><br><span class="line">        <span class="type">CorrelationData</span> <span class="variable">correlationData1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CorrelationData</span>(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">routingKey</span> <span class="operator">=</span> <span class="string">&quot;key1&quot;</span>;</span><br><span class="line">        rabbitTemplate.convertAndSend(CONFIRM_EXCHANGE_NAME, routingKey, message + routingKey, correlationData1);</span><br><span class="line">        log.info(routingKey + <span class="string">&quot;发送消息内容:&#123;&#125;&quot;</span>, message + routingKey);</span><br><span class="line"></span><br><span class="line">        <span class="type">CorrelationData</span> <span class="variable">correlationData2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CorrelationData</span>(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">        routingKey = <span class="string">&quot;key2&quot;</span>;</span><br><span class="line">        rabbitTemplate.convertAndSend(CONFIRM_EXCHANGE_NAME, routingKey, message + routingKey, correlationData2);</span><br><span class="line">        log.info(routingKey + <span class="string">&quot;发送消息内容:&#123;&#125;&quot;</span>, message + routingKey);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>消息消费者</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConfirmConsumer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">CONFIRM_QUEUE_NAME</span> <span class="operator">=</span> <span class="string">&quot;confirm.queue&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RabbitListener(queues = CONFIRM_QUEUE_NAME)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">receiveMsg</span><span class="params">(Message message)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(message.getBody());</span><br><span class="line">        log.info(<span class="string">&quot;接受到队列 confirm.queue 消息:&#123;&#125;&quot;</span>, msg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>访问：<a href="http://localhost:8080/confirm/sendMessage/">http://localhost:8080/confirm/sendMessage/</a></p>
<h3 id="18、幂等性"><a href="#18、幂等性" class="headerlink" title="18、幂等性"></a>18、幂等性</h3><h4 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h4><p>用户对于同一操作发起的一次请求或者多次请求的结果是一致的，不会因为多次点击而产生了副作用。 举个最简单的例子，那就是支付，用户购买商品后支付，支付扣款成功，但是返回结果的时候网络异常， 此时钱已经扣了，用户再次点击按钮，此时会进行第二次扣款，返回结果成功，用户查询余额发现多扣钱 了，流水记录也变成了两条。在以前的单应用系统中，我们只需要把数据操作放入事务中即可，发生错误立即回滚，但是再响应客户端的时候也有可能出现网络中断或者异常等等.</p>
<h4 id="消息重复消费"><a href="#消息重复消费" class="headerlink" title="消息重复消费"></a>消息重复消费</h4><p>消费者在消费 MQ 中的消息时，MQ 已把消息发送给消费者，消费者在给 MQ 返回 ack 时网络中断， 故 MQ 未收到确认信息，该条消息会重新发给其他的消费者，或者在网络重连后再次发送给该消费者，但实际上该消费者已成功消费了该条消息，造成消费者消费了重复的消息。</p>
<h4 id="解决思路"><a href="#解决思路" class="headerlink" title="解决思路"></a>解决思路</h4><p>消费者在消费 MQ 中的消息时，MQ 已把消息发送给消费者，消费者在给 MQ 返回 ack 时网络中断， 故 MQ 未收到确认信息，该条消息会重新发给其他的消费者，或者在网络重连后再次发送给该消费者，但实际上该消费者已成功消费了该条消息，造成消费者消费了重复的消息。</p>
<h4 id="消费端的幂等性保障"><a href="#消费端的幂等性保障" class="headerlink" title="消费端的幂等性保障"></a>消费端的幂等性保障</h4><p>在海量订单生成的业务高峰期，生产端有可能就会重复发生了消息，这时候消费端就要实现幂等性， 这就意味着我们的消息永远不会被消费多次，即使我们收到了一样的消息。</p>
<p>业界主流的幂等性有两种操作:</p>
<p>·唯一 ID+指纹码机制，用数据库主键去重；<br>·利用 redis 的原子性去实现。<br>·唯一ID+指纹码机制</p>
<p>指纹码：我们的一些规则或者时间戳加别的服务给到的唯一信息码，它并不一定是我们系统生成的，基本都是由我们的业务规则拼接而来，但是一定要保证唯一性，然后就利用查询语句进行判断这个 id 是否存在数据库中，优势就是实现简单就一个拼接，然后查询判断是否重复；劣势就是在高并发时，如果是单个数据库就会有写入性能瓶颈当然也可以采用分库分表提升性能，但也不是我们最推荐的方式。</p>
<h3 id="19、优先级队列"><a href="#19、优先级队列" class="headerlink" title="19、优先级队列"></a>19、优先级队列</h3><p>使用场景</p>
<p>在我们系统中有一个订单催付的场景，我们的客户在天猫下的订单，淘宝会及时将订单推送给我们，如果在用户设定的时间内未付款那么就会给用户推送一条短信提醒，很简单的一个功能对吧。</p>
<p>但是，天猫商家对我们来说，肯定是要分大客户和小客户的对吧，比如像苹果、小米这样大商家一年起码能给我们创造很大的利润，所以理应当然，他们的订单必须得到优先处理，而曾经我们的后端系统是使用 redis 来存放的定时轮询，大家都知道 redis 只能用 List 做一个简简单单的消息队列，并不能实现一个优先级的场景，所以订单量大了后采用 RabbitMQ 进行改造和优化，如果发现是大客户的订单给一个相对比较高的优先级， 否则就是默认优先级。</p>
<p>队列中添加优先级</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map&lt;String, Object&gt; params = <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">params.put(<span class="string">&quot;x-max-priority&quot;</span>, <span class="number">10</span>);</span><br><span class="line">channel.queueDeclare(<span class="string">&quot;hello&quot;</span>, <span class="literal">true</span>, <span class="literal">false</span>, <span class="literal">false</span>, params);</span><br></pre></td></tr></table></figure>

<p>消息中添加优先级</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">AMQP.<span class="type">BasicProperties</span> <span class="variable">properties</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AMQP</span>.BasicProperties().builder().priority(<span class="number">10</span>).build();</span><br></pre></td></tr></table></figure>

<h4 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a>注意事项：</h4><p>要让队列实现优先级需要做的事情有如下事情：队列需要设置为优先级队列，消息需要设置消息的优先级，消费者需要等待消息已经发送到队列中才去消费因为，这样才有机会对消息进行排序。</p>
<p>生产者</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PriorityProducer</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">QUEUE_NAME</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> RabbitMqUtils.getChannel();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//给消息赋予一个 priority 属性</span></span><br><span class="line">        AMQP.<span class="type">BasicProperties</span> <span class="variable">properties</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AMQP</span>.BasicProperties().builder().priority(<span class="number">10</span>).build();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; <span class="number">11</span>; i++) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="string">&quot;info&quot;</span> + i;</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">5</span>) &#123;</span><br><span class="line">                channel.basicPublish(<span class="string">&quot;&quot;</span>, QUEUE_NAME, properties, message.getBytes());</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                channel.basicPublish(<span class="string">&quot;&quot;</span>, QUEUE_NAME, <span class="literal">null</span>, message.getBytes());</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;发送消息完成:&quot;</span> + message);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>消费者</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PriorityConsumer</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">QUEUE_NAME</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> RabbitMqUtils.getChannel();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//设置队列的最大优先级 最大可以设置到 255 官网推荐 1-10 如果设置太高比较吃内存和 CPU</span></span><br><span class="line">        Map&lt;String, Object&gt; params = <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">        params.put(<span class="string">&quot;x-max-priority&quot;</span>, <span class="number">10</span>);</span><br><span class="line">        channel.queueDeclare(QUEUE_NAME, <span class="literal">true</span>, <span class="literal">false</span>, <span class="literal">false</span>, params);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//推送的消息如何进行消费的接口回调</span></span><br><span class="line">        <span class="type">DeliverCallback</span> <span class="variable">deliverCallback</span> <span class="operator">=</span> (consumerTag, delivery) -&gt; &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(delivery.getBody());</span><br><span class="line">            System.out.println(message);</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">//取消消费的一个回调接口 如在消费的时候队列被删除掉了</span></span><br><span class="line">        <span class="type">CancelCallback</span> <span class="variable">cancelCallback</span> <span class="operator">=</span> (consumerTag) -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;消息消费被中断&quot;</span>);</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        channel.basicConsume(QUEUE_NAME, <span class="literal">true</span>, deliverCallback, cancelCallback);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="20、惰性队列"><a href="#20、惰性队列" class="headerlink" title="20、惰性队列"></a>20、惰性队列</h3><h4 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h4><p>RabbitMQ 从 3.6.0 版本开始引入了惰性队列的概念。惰性队列会尽可能的将消息存入磁盘中，而在消费者消费到相应的消息时才会被加载到内存中，它的一个重要的设计目标是能够支持更长的队列，即支持更多的消息存储。当消费者由于各种各样的原因(比如消费者下线、宕机亦或者是由于维护而关闭等)而致使长时间内不能消费消息造成堆积时，惰性队列就很有必要了。</p>
<p>默认情况下，当生产者将消息发送到 RabbitMQ 的时候，队列中的消息会尽可能的存储在内存之中， 这样可以更加快速的将消息发送给消费者。即使是持久化的消息，在被写入磁盘的同时也会在内存中驻留一份备份。当RabbitMQ 需要释放内存的时候，会将内存中的消息换页至磁盘中，这个操作会耗费较长的时间，也会阻塞队列的操作，进而无法接收新的消息。虽然 RabbitMQ 的开发者们一直在升级相关的算法， 但是效果始终不太理想，尤其是在消息量特别大的时候。</p>
<h4 id="两种模式"><a href="#两种模式" class="headerlink" title="两种模式"></a>两种模式</h4><p>队列具备两种模式：default 和 lazy。默认的为default 模式，在3.6.0 之前的版本无需做任何变更。lazy 模式即为惰性队列的模式，可以通过调用 channel.queueDeclare 方法的时候在参数中设置，也可以通过 Policy 的方式设置，如果一个队列同时使用这两种方式设置的话，那么 Policy 的方式具备更高的优先级。 如果要通过声明的方式改变已有队列的模式的话，那么只能先删除队列，然后再重新声明一个新的。</p>
<p>在队列声明的时候可以通过“x-queue-mode”参数来设置队列的模式，取值为“default”和“lazy”。下面示例中演示了一个惰性队列的声明细节：</p>
<h4 id="Map-lt-String-Object-gt-args-x3D-new-HashMap-lt-String-Object-gt"><a href="#Map-lt-String-Object-gt-args-x3D-new-HashMap-lt-String-Object-gt" class="headerlink" title="Map&lt;String, Object&gt; args &#x3D; new HashMap&lt;String, Object&gt;();"></a>Map&lt;String, Object&gt; args &#x3D; new HashMap&lt;String, Object&gt;();</h4><p>args.put(“x-queue-mode”, “lazy”);<br>channel.queueDeclare(“myqueue”, false, false, false, args);</p>
]]></content>
      <categories>
        <category>RabbitMQ</category>
      </categories>
      <tags>
        <tag>RabbitMQ</tag>
      </tags>
  </entry>
  <entry>
    <title>java-IO模式（AIO/BIO/NIO） - ArrayList源码解析</title>
    <url>/2022/05/19/2022-05-19-java-IO%E6%A8%A1%E5%BC%8F%EF%BC%88AIOBIONIO%EF%BC%89/</url>
    <content><![CDATA[<h1 id="IO模式（AIO-x2F-BIO-x2F-NIO）"><a href="#IO模式（AIO-x2F-BIO-x2F-NIO）" class="headerlink" title="IO模式（AIO&#x2F;BIO&#x2F;NIO）"></a>IO模式（AIO&#x2F;BIO&#x2F;NIO）</h1><span id="more"></span>

<h4 id="Java的I-x2F-O演进之路"><a href="#Java的I-x2F-O演进之路" class="headerlink" title="Java的I&#x2F;O演进之路"></a>Java的I&#x2F;O演进之路</h4><h5 id="I-x2F-O模型基本说明"><a href="#I-x2F-O模型基本说明" class="headerlink" title="I&#x2F;O模型基本说明"></a>I&#x2F;O模型基本说明</h5><p>I&#x2F;O模型：就是用什么样的通道或者说是通信模式和架构进行数据的传输和接收，很大程度上决定了程序通信的性能，java共支持三种网络编程的I&#x2F;O模型：BIO、NIO、AIO。</p>
<p>实际通信需求下，要根据不同的业务场景和性能需求决定选择不同的I&#x2F;O模型。</p>
<h5 id="I-x2F-O模型"><a href="#I-x2F-O模型" class="headerlink" title="I&#x2F;O模型"></a>I&#x2F;O模型</h5><p><strong>Java BIO</strong></p>
<p>同步并阻塞（传统阻塞型），服务器实现模式为一个连接一个线程，即客户端有连接请求时服务器端就需要启动一个线程进行处理，如果这个连接不做任何事情会造成不必要的线程开销。</p>
<p><img src="/../images/img99.PNG" alt="img99"></p>
<p><strong>Java NIO</strong></p>
<p>同步非阻塞，服务器实现模式为一个线程处理多个请求（连接），即客户端发送的请求都会注册到多路复用上，多路复用轮询到连接有I&#x2F;O请求就进行处理。</p>
<p><img src="/../images/img100.PNG" alt="img100"></p>
<p><strong>Java AIO</strong></p>
<p>异步非阻塞，服务器实现模式为一个有效请求一个线程，客户端的I&#x2F;O请求都是由OS先完成了再通知服务器应用去启动线程进行处理，一般适用于连接数较多且连接时间较长的应用。</p>
<h4 id="BIO、NIO、AIO适用场景分析"><a href="#BIO、NIO、AIO适用场景分析" class="headerlink" title="BIO、NIO、AIO适用场景分析"></a>BIO、NIO、AIO适用场景分析</h4><ol>
<li>BIO方式适用于连接数目比较小且固定的架构，这种方式对服务器资源要求比较高，并发局限于应用中，JDK1.4以前的唯一选择，但程序简单易理解。</li>
<li>NIO方式适用于连接数目多且比较短（轻操作）的架构，比如聊天服务器，弹幕系统，服务器间通讯等。编程比较复杂，JDK1.4开始支持。</li>
<li>AIO方式适用于连接数目多且连接比较长（重操作）的架构，比如相册服务器，充分调用OS参与并发操作，变成比较复杂，JDK7开始支持。</li>
</ol>
<h4 id="JAVA-BIO深入剖析"><a href="#JAVA-BIO深入剖析" class="headerlink" title="JAVA BIO深入剖析"></a>JAVA BIO深入剖析</h4><h5 id="JAVA-BIO基本介绍"><a href="#JAVA-BIO基本介绍" class="headerlink" title="JAVA BIO基本介绍"></a>JAVA BIO基本介绍</h5><ul>
<li>JAVA BIO就是传统的Java io编程，其相关的类和接口在java.io</li>
<li>BIO（Blocking I&#x2F;O）：同步阻塞，服务器实现模式为一个连接一个线程，即客户端有连接请求时服务器端就需要启动一个线程进行处理，如果这个连接不做任何事情会造成不必要的线程开销，可以通过线程池机制改善（实现多个客户连接服务器）。</li>
</ul>
<h5 id="JAVA-BIO工作机制"><a href="#JAVA-BIO工作机制" class="headerlink" title="JAVA BIO工作机制"></a>JAVA BIO工作机制</h5><p><img src="/../images/a1.PNG" alt="a1"></p>
<h5 id="传统的BIO编程实例回顾"><a href="#传统的BIO编程实例回顾" class="headerlink" title="传统的BIO编程实例回顾"></a>传统的BIO编程实例回顾</h5><p>网络编程的基本模型是Client&#x2F;Server模型，也就是两个进程之间进行相互通信，其中，服务端提供位置信（绑定ip地址和端口），客户端通过连接操作向服务端监听的端口地址发起连接请求，基于TCP协议下进行三次握手连接，连接成功后，双方通过网络套接字（Socket）进行通信。</p>
<p>传统的同步阻塞模型开发中，服务端ServerSocket负责绑定ip地址，启动监听端口；客户端Socket负责发起连接操作，连接成功后，双方通过输入和输出流进行同步阻塞式通信。</p>
<p>基于BIO模式下的通信，客户端-服务端是完全同步的，完全耦合的。</p>
<h6 id="服务端案例如下"><a href="#服务端案例如下" class="headerlink" title="服务端案例如下"></a>服务端案例如下</h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">	目标：客户端发送消息，服务端接收消息</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Server</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;=====服务端启动=======&quot;</span>);</span><br><span class="line">            <span class="comment">//1.定义一个ServerSocket对象进行服务端的端口注册</span></span><br><span class="line">            <span class="type">ServerSocket</span> <span class="variable">ss</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerSocket</span>(<span class="number">9999</span>);</span><br><span class="line">            <span class="comment">//2.监听客户端的Socket连接请求</span></span><br><span class="line">            <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> ss.accept();</span><br><span class="line">            <span class="comment">//3.从socket管道中得到一个字节输入流对象</span></span><br><span class="line">            <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> socket.getInputStream();</span><br><span class="line">            <span class="comment">//4.把字节输入流包装成一个缓冲字符输入流</span></span><br><span class="line">            <span class="type">BufferedReader</span> <span class="variable">br</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(is));</span><br><span class="line">            String msg;</span><br><span class="line">            <span class="keyword">while</span>((msg = br.readLine()) != <span class="literal">null</span>)&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;服务端接收到：&quot;</span>+msg);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="客户端案例如下"><a href="#客户端案例如下" class="headerlink" title="客户端案例如下"></a>客户端案例如下</h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">	客户端</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="comment">//1.创建Socke对象请求服务端的连接</span></span><br><span class="line">        	<span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Socket</span>(<span class="string">&quot;127.0.0.1&quot;</span>,<span class="number">9999</span>);</span><br><span class="line">            <span class="comment">//2.从Socket对象中获得字节输出流</span></span><br><span class="line">            <span class="type">OutputStream</span> <span class="variable">os</span> <span class="operator">=</span> socket.getOutputStream();</span><br><span class="line">            <span class="comment">//3.把字节输出流包装成一个打印流</span></span><br><span class="line">            <span class="type">PrintStream</span> <span class="variable">ps</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PrintStream</span>(os);</span><br><span class="line">            ps.println(<span class="string">&quot;hello world!服务端你好！&quot;</span>);</span><br><span class="line">            ps.flush();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h6><ul>
<li>在以上通信中，服务端会一直等待客户端的消息，如果客户端没有进行消息的发送，服务端将一直进入阻塞状态。</li>
<li>同时服务器是按照行获取消息，这意味着客户端也必须按照行进行消息的发送，否则服务端将进入等待消息的阻塞状态。</li>
</ul>
<h5 id="BIO模式下多发和多收消息"><a href="#BIO模式下多发和多收消息" class="headerlink" title="BIO模式下多发和多收消息"></a>BIO模式下多发和多收消息</h5><p>在上面的案例中，只能实现客户端发送消息，服务端接收消息，并不能实现反复的收消息和反复的发消息，我们只需要在客户端案例中，加上反复按照行发送消息的逻辑即可！</p>
<h6 id="服务端代码如下"><a href="#服务端代码如下" class="headerlink" title="服务端代码如下"></a>服务端代码如下</h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">	目标：服务端可以反复的接收消息，客户端可以反复的发送消息</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Server</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;=====服务端启动=======&quot;</span>);</span><br><span class="line">            <span class="comment">//1.定义一个ServerSocket对象进行服务端的端口注册</span></span><br><span class="line">            <span class="type">ServerSocket</span> <span class="variable">ss</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerSocket</span>(<span class="number">9999</span>);</span><br><span class="line">            <span class="comment">//2.监听客户端的Socket连接请求</span></span><br><span class="line">            <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> ss.accept();</span><br><span class="line">            <span class="comment">//3.从socket管道中得到一个字节输入流对象</span></span><br><span class="line">            <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> socket.getInputStream();</span><br><span class="line">            <span class="comment">//4.把字节输入流包装成一个缓冲字符输入流</span></span><br><span class="line">            <span class="type">BufferedReader</span> <span class="variable">br</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(is));</span><br><span class="line">            String msg;</span><br><span class="line">            <span class="keyword">while</span>((msg = br.readLine()) != <span class="literal">null</span>)&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;服务端接收到：&quot;</span>+msg);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="客户端代码如下"><a href="#客户端代码如下" class="headerlink" title="客户端代码如下"></a>客户端代码如下</h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="comment">//1.创建Socke对象请求服务端的连接</span></span><br><span class="line">        	<span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Socket</span>(<span class="string">&quot;127.0.0.1&quot;</span>,<span class="number">9999</span>);</span><br><span class="line">            <span class="comment">//2.从Socket对象中获得字节输出流</span></span><br><span class="line">            <span class="type">OutputStream</span> <span class="variable">os</span> <span class="operator">=</span> socket.getOutputStream();</span><br><span class="line">            <span class="comment">//3.把字节输出流包装成一个打印流</span></span><br><span class="line">            <span class="type">PrintStream</span> <span class="variable">ps</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PrintStream</span>(os);</span><br><span class="line">            <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">            <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;请说：&quot;</span>);</span><br><span class="line">                <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> sc.nextLine();</span><br><span class="line">                ps.println(msg);</span><br><span class="line">           	 	ps.flush();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="BIO模式下接收多个客户端"><a href="#BIO模式下接收多个客户端" class="headerlink" title="BIO模式下接收多个客户端"></a>BIO模式下接收多个客户端</h5><h6 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h6><p>在上述案例中，一个服务端只能接收一个客户端的通信请求，那么如果服务端需要处理很多个客户端的消息通信请求应该如何处理呢，此时我们需要在服务端引入线程，也就是说，客户端每次发起一个请求，服务端就创建一个新的线程来处理这个客户端的请求，这样就实现了一个客户端一个线程的模型。</p>
<h6 id="服务端代码如下-1"><a href="#服务端代码如下-1" class="headerlink" title="服务端代码如下"></a>服务端代码如下</h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">	目标：实现服务端可以同时接收多个客户端的Socket通信需求</span></span><br><span class="line"><span class="comment">	思路：服务器每接收到一个客户端socket请求对象后都交给一个独立的线程来处理客户端的数据交互需求</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Server</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="comment">//1.注册端口</span></span><br><span class="line">        	<span class="type">ServerSocket</span> <span class="variable">ss</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerSocket</span>(<span class="number">9999</span>);</span><br><span class="line">            <span class="comment">//2.定义一个死循环，负责不断的接收客户端的Socket连接请求</span></span><br><span class="line">            <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">                <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> ss.accept();</span><br><span class="line">                <span class="comment">//3.创建一个独立的线程来处理与这个客户端的socket通信需求</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ServerThreadReader</span>(socket).start();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="服务端读线程代码如下"><a href="#服务端读线程代码如下" class="headerlink" title="服务端读线程代码如下"></a>服务端读线程代码如下</h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServerThreadReader</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> Socket socket;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ServerThreadReader</span><span class="params">(Socket socket)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.socket = socket;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="comment">//从socket对象中得到一个字节输入流</span></span><br><span class="line">        	<span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> socket.getInputStream();</span><br><span class="line">            <span class="comment">//使用缓冲字符输入流包装字节输入流</span></span><br><span class="line">            <span class="type">BufferedReader</span> <span class="variable">br</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(is));</span><br><span class="line">            String msg;</span><br><span class="line">            <span class="keyword">while</span>((msg = br.readLine()) != <span class="literal">null</span>)&#123;</span><br><span class="line">                System.out.println(msg);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="客户端代码如下-1"><a href="#客户端代码如下-1" class="headerlink" title="客户端代码如下"></a>客户端代码如下</h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="comment">//1.请求与服务器的Socket对象连接</span></span><br><span class="line">            <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Socket</span>(<span class="string">&quot;127.0.0.1&quot;</span>,<span class="number">9999</span>);</span><br><span class="line">            <span class="comment">//2.得到一个打印流</span></span><br><span class="line">            <span class="type">PrintStream</span> <span class="variable">ps</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PrintStream</span>(socket.getOutputStream());</span><br><span class="line">            <span class="comment">//3.使用循环不断的发送消息给服务端接收</span></span><br><span class="line">            <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">            <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">                System.out.print(<span class="string">&quot;请说：&quot;</span>);</span><br><span class="line">                <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> sc.nextLine();</span><br><span class="line">                ps.println(msg);</span><br><span class="line">                ps.flush();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span>(IOException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h6><ol>
<li>每个Socket接收到，都会创建一个线程，线程的竞争、切换上下文影响性能；</li>
<li>每个线程都会占用栈空间和cpu资源；</li>
<li>并不是每个socket都进行IO操作，无意义的线程处理；</li>
<li>客户端的并发访问量增加时。服务端将呈现1:1的线程开销，访问量越大，系统将发生线程溢出，线程创建失败，最终导致进程宕机或者僵死，从而不能对外提供服务。</li>
</ol>
<h5 id="伪异步I-x2F-O编程"><a href="#伪异步I-x2F-O编程" class="headerlink" title="伪异步I&#x2F;O编程"></a>伪异步I&#x2F;O编程</h5><h6 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h6><p>采用线程次和任务队列实现，当客户端节接入时，将客户端的Socket封装成一个Task（该任务实现java.lang.Runnable线程任务接口）交给后端的线程池中进行处理。JDK的线程池维护一个消息队列和N个活跃的线程，对消息队列中Socket任务进行处理，由于线程池可以设置消息队列的大小和最大线程数，因此，它的资源占用是可控的，无论多少个客户端并发访问，都不会导致资源的耗尽和宕机。</p>
<p>图示如下：</p>
<p><img src="/../images/b.PNG" alt="b"></p>
<h6 id="服务端源码分析"><a href="#服务端源码分析" class="headerlink" title="服务端源码分析"></a>服务端源码分析</h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">	开发实现伪异步通信架构</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Server</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="comment">//1.注册端口</span></span><br><span class="line">            <span class="type">ServerSocket</span> <span class="variable">ss</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerSocket</span>(<span class="number">9999</span>);</span><br><span class="line">            <span class="comment">//2.定义一个循环接收客户端的Socket连接请求</span></span><br><span class="line">            <span class="comment">//初始化一个线程池对象</span></span><br><span class="line">            <span class="type">HandlerSocketServerPool</span> <span class="variable">pool</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HandlerSocketPool</span>(<span class="number">6</span>,<span class="number">10</span>);</span><br><span class="line">            <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">                <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> ss.accept();</span><br><span class="line">                <span class="comment">//3.把socket对象交给一个线程池进行处理</span></span><br><span class="line">                <span class="comment">//把socket封装成一个任务对象交给线程池处理</span></span><br><span class="line">                <span class="type">Runnable</span> <span class="variable">target</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerRunnableTarget</span>(socket);</span><br><span class="line">                pool.execute(target);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span>(IOException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="线程池类"><a href="#线程池类" class="headerlink" title="线程池类"></a>线程池类</h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HandlerSocketServerPool</span>&#123;</span><br><span class="line">    <span class="comment">//1.创建一个线程池的成员变量存储一个线程池对象</span></span><br><span class="line">    <span class="keyword">private</span> ExecutorService executorServcice;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//2.创建这个类的对象的时候就需要初始化线程池对象</span></span><br><span class="line">    <span class="comment">//public ThreadPoolExecutor(int corePoolSize,int maximumPoolSize,long keepAliveTime,TimeUnit unit,BlockingQueueRunnable workQueue)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">HandlerSocketServerPool</span><span class="params">(<span class="type">int</span> maxThreadNum,<span class="type">int</span> queueSize)</span>&#123;</span><br><span class="line">        executorServcice = <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">3</span>,maxThreadNum,<span class="number">120</span>,TimeUnit.SECONDS,<span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>&lt;Runnable&gt;(queueSize));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//3.提供一个方法来提交任务给线程池的任务队列来暂存，等着线程池来处理</span></span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">(Runnable target)</span>&#123;</span><br><span class="line">        executorServcice.execute(target);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServerRunanableTarget</span> <span class="keyword">implements</span> <span class="title class_">Runanble</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Socket socket;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ServerRunnableTarget</span><span class="params">(Socket socket)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.socket = socket;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;=====服务端启动=======&quot;</span>);</span><br><span class="line">            <span class="comment">//1.监听客户端的Socket连接请求</span></span><br><span class="line">            <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> ss.accept();</span><br><span class="line">            <span class="comment">//2.从socket管道中得到一个字节输入流对象</span></span><br><span class="line">            <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> socket.getInputStream();</span><br><span class="line">            <span class="comment">//3.把字节输入流包装成一个缓冲字符输入流</span></span><br><span class="line">            <span class="type">BufferedReader</span> <span class="variable">br</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(is));</span><br><span class="line">            String msg;</span><br><span class="line">            <span class="keyword">while</span>((msg = br.readLine()) != <span class="literal">null</span>)&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;服务端接收到：&quot;</span>+msg);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;	</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="comment">//1.请求与服务器的Socket对象连接</span></span><br><span class="line">            <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Socket</span>(<span class="string">&quot;127.0.0.1&quot;</span>,<span class="number">9999</span>);</span><br><span class="line">            <span class="comment">//2.得到一个打印流</span></span><br><span class="line">            <span class="type">PrintStream</span> <span class="variable">ps</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PrintStream</span>(socket.getOutputStream());</span><br><span class="line">            <span class="comment">//3.使用循环不断的发送消息给服务端接收</span></span><br><span class="line">            <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">            <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">                System.out.print(<span class="string">&quot;请说：&quot;</span>);</span><br><span class="line">                <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> sc.nextLine();</span><br><span class="line">                ps.println(msg);</span><br><span class="line">                ps.flush();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span>(IOException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h6><ul>
<li>伪异步I&#x2F;O采用了线程池实现，因此避免了为每个请求创建一个独立线程造成线程资源耗尽的问题，但由于底层依然是采用的同步阻塞模型，因此无法从根本上解决问题。</li>
<li>如果单个消息处理缓慢，或者服务器线程池中的全部线程都被阻塞，那么后续socket的I&#x2F;o消息都将在队列中排队。新的Socket请求将被拒绝，客户端发生大量连接超时。</li>
</ul>
<h5 id="基于BIO形式下的文件上传"><a href="#基于BIO形式下的文件上传" class="headerlink" title="基于BIO形式下的文件上传"></a>基于BIO形式下的文件上传</h5><h6 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h6><p>支持任意类型文件形式的上传</p>
<h6 id="客户端-1"><a href="#客户端-1" class="headerlink" title="客户端"></a>客户端</h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">	目标：实现客户端上传任意类型的文件数据给服务端保存起来</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">           <span class="comment">//1.请求与服务器的Socket连接</span></span><br><span class="line">            <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Socket</span>(<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>,<span class="number">9999</span>);</span><br><span class="line">           <span class="comment">//2.把字节输出流包装成一个数据输出流</span></span><br><span class="line">            <span class="type">DataOutputStream</span> <span class="variable">dos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DataOutputStream</span>(socket.getOutputStream());</span><br><span class="line">            <span class="comment">//3.发送上传文件的后缀给服务端</span></span><br><span class="line">            dos.write(<span class="string">&quot;.png&quot;</span>);</span><br><span class="line">            <span class="comment">//4.把文件数据发送给服务端进行接收</span></span><br><span class="line">            <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;文件路径&quot;</span>);</span><br><span class="line">            <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">            <span class="type">int</span> len;</span><br><span class="line">            <span class="keyword">while</span>(len = is.read(buffer) &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                dos.write(buffer,<span class="number">0</span>,len);</span><br><span class="line">            &#125;</span><br><span class="line">            dos.flush();</span><br><span class="line">            socket.shutdownOutput();<span class="comment">//通知服务端这边的数据发送完毕了</span></span><br><span class="line">        &#125;<span class="keyword">catch</span>(IOException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">	目标：服务端开发，可以实现接收客户端的任意类型文件，并保存到服务端磁盘</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Sever</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="type">ServerSocket</span> <span class="variable">ss</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerSocket</span>(<span class="number">9999</span>);</span><br><span class="line">            <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">                <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> ss.accept();</span><br><span class="line">                <span class="comment">//交给独立的线程来处理与这个客户端的文件通信需求</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ServerReaderThread</span>(socket).start();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="线程类"><a href="#线程类" class="headerlink" title="线程类"></a>线程类</h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServerReaderThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Socket socket;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ServerReaderThread</span><span class="params">(Socket socket)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.socket = socket;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="comment">//1.得到一个数据输入流读取客户端发送过来的数据</span></span><br><span class="line">            <span class="type">DataInputStream</span> <span class="variable">dis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DataInputStream</span>(socket.getInputStream());</span><br><span class="line">            <span class="comment">//2.读取客户端发送过来的文件类型</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">suffix</span> <span class="operator">=</span> dis.readUTF();</span><br><span class="line">            System.out.prinln(<span class="string">&quot;服务端已经成功接收到了文件类型：&quot;</span> + suffix);</span><br><span class="line">            <span class="comment">//3.定义一个字节输出管道负责把客户端发来的文件数据写出去</span></span><br><span class="line">            <span class="type">OutputStream</span> <span class="variable">os</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;文件路径&quot;</span>+UUID.randomUUID().toString() + suffix);</span><br><span class="line">            <span class="comment">//4.从数据输入流读取文件数据，写到字节输出流中</span></span><br><span class="line">            <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">            <span class="type">int</span> len;</span><br><span class="line">            <span class="keyword">while</span>(len = dis.read(buffer) &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                os.write(buffer,<span class="number">0</span>,len);</span><br><span class="line">            &#125;</span><br><span class="line">            os.close();</span><br><span class="line">            System.out.println(<span class="string">&quot;服务端接收文件保存成功！&quot;</span>);	</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="Java-BIO模式下的端口转发思想"><a href="#Java-BIO模式下的端口转发思想" class="headerlink" title="Java BIO模式下的端口转发思想"></a>Java BIO模式下的端口转发思想</h5><p>需求：需要实现一个客户端的消息可以发送给所有的客户端去接收。（群聊实现）</p>
<p><img src="/../images/c.PNG" alt="c"></p>
<h6 id="服务端开发"><a href="#服务端开发" class="headerlink" title="服务端开发"></a>服务端开发</h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">	目标：BIO模式下的端口转发思想-服务端实现</span></span><br><span class="line"><span class="comment">	服务端实现的需求：</span></span><br><span class="line"><span class="comment">	1.注册端口</span></span><br><span class="line"><span class="comment">	2.接收客户端的socket连接，交给独立的线程处理。</span></span><br><span class="line"><span class="comment">	3.需要把当前连接的客户端socket存到一个所谓的在线socket集合中保存</span></span><br><span class="line"><span class="comment">	4.接收客户端消息，然后推送给当前所有在线的socket接收</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Server</span>&#123;</span><br><span class="line">    <span class="comment">//定义静态集合</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> List&lt;Socket&gt; allSocketOnLine = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="type">ServerSocket</span> <span class="variable">ss</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerSocket</span>(<span class="number">9999</span>);</span><br><span class="line">            <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">                <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> ss.accept();</span><br><span class="line">                <span class="comment">//把登录的客户端存到在线的集合中</span></span><br><span class="line">                allSocketOnLine.add(socket);</span><br><span class="line">                <span class="comment">//为当前登录成功的socket分配一个独立的线程来处理与之通信</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ServerRreaderThread</span>(socket).start();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="线程类-1"><a href="#线程类-1" class="headerlink" title="线程类"></a>线程类</h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServerReaderThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Socket socket;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ServerReaderThread</span><span class="params">(Socket socket)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.socket = socket;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="comment">//1.从socket中获取当前客户端的输入流</span></span><br><span class="line">            <span class="type">BufferedReader</span> <span class="variable">br</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(socket.getInputStream()));</span><br><span class="line">            String msg;</span><br><span class="line">            <span class="keyword">while</span>((msg = br.readLine()) != <span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="comment">//2.服务端接收到客户端的消息后，需要推送给当前所有的在线socket</span></span><br><span class="line">                sendMsgToAllClient(msg);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;当前有人下线！&quot;</span>);</span><br><span class="line">            <span class="comment">//从在线socket集合中移除本socket</span></span><br><span class="line">            Server.allSocketOnLine.remove(socket);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendMsgToAllClient</span><span class="params">(String msg)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="keyword">for</span>(Socket sk:Server.allSocketOnLine)&#123;</span><br><span class="line">            <span class="type">PrintStream</span> <span class="variable">ps</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PrintStream</span>(sk.getOutputStream());</span><br><span class="line">            ps.print(msg);</span><br><span class="line">            ps.flush();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="基于BIO模式下的即时通讯"><a href="#基于BIO模式下的即时通讯" class="headerlink" title="基于BIO模式下的即时通讯"></a>基于BIO模式下的即时通讯</h5><p>基于BIO模式下的即时通讯，我们需要解决客户端到客户端的通信，也就是需要实现客户端与客户端的端口消息转发逻辑。</p>
<h6 id="项目功能演示"><a href="#项目功能演示" class="headerlink" title="项目功能演示"></a>项目功能演示</h6><p><strong>功能清单简要说明</strong></p>
<ol>
<li>客户端登录功能</li>
<li>在线人数实时更新</li>
<li>离线人数更新</li>
<li>群聊</li>
<li>私聊</li>
<li>@消息</li>
<li>消息用户和消息时间点</li>
</ol>
<h6 id="服务端设计"><a href="#服务端设计" class="headerlink" title="服务端设计"></a>服务端设计</h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServerChat</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Map&lt;Socket,String&gt; onLineSockets = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="type">ServerSocket</span> <span class="variable">ss</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerSocket</span>(Constans.PORT);</span><br><span class="line">            <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">                <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> ss.accept();</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ServerReader</span>(socket).start();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServerReader</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Socket socket;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ServerReader</span><span class="params">(Socket socket)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.socket = socket;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">DataInputStream</span> <span class="variable">dis</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            dis = <span class="keyword">new</span> <span class="title class_">DataInputStream</span>(socket.getInputStream());</span><br><span class="line">            <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">flag</span> <span class="operator">=</span> dis.readInt();</span><br><span class="line">                <span class="keyword">if</span>(flag == <span class="number">1</span>)&#123;</span><br><span class="line">                    <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> dis.readUTF();</span><br><span class="line">                    System.out.println(name+<span class="string">&quot;------&gt;&quot;</span>+socket.getRemoteSocketAddress());</span><br><span class="line">                    ServerChat.onLineSockets.put(socket,name);</span><br><span class="line">                &#125;</span><br><span class="line">                writeMsg(flag,dis);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;有人下线了！&quot;</span>);</span><br><span class="line">            ServerChat.onLineSockets.remove(socket);</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                writeMsg(<span class="number">1</span>,dis);</span><br><span class="line">            &#125;<span class="keyword">catch</span>(Exception e1)&#123;</span><br><span class="line">                e1.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">writeMsg</span><span class="params">(<span class="type">int</span> flag,DataInputStream dis)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">if</span>(flag == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="type">StringBuffer</span> <span class="variable">rs</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();</span><br><span class="line">            Collection&lt;String&gt; onlineNames = ServerChat.onLineSockets.values();</span><br><span class="line">            <span class="keyword">if</span>(onlinNames != <span class="literal">null</span> &amp;&amp; onlineNames.size() &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">for</span>(String name : onlineNames)&#123;</span><br><span class="line">                    rs.append(name + Constants.SPILIT);</span><br><span class="line">                &#125;</span><br><span class="line">                msg = rs.substring(<span class="number">0</span>,rs.lastIndexOf(Constants.SPILIT));</span><br><span class="line">                sendMsgToAll(flag,msg);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(flag == <span class="number">2</span> || flag == <span class="number">3</span>)&#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">newMsg</span> <span class="operator">=</span> dis.readUTF();</span><br><span class="line">            <span class="type">String</span> <span class="variable">sendName</span> <span class="operator">=</span> ServerChat.onLineSockets.get(socket); </span><br><span class="line">            </span><br><span class="line">            <span class="type">StringBuilder</span> <span class="variable">msgFinal</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">            </span><br><span class="line">            <span class="type">SimpleDateFormat</span> <span class="variable">sdf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd HH:mm:ss EEE&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span>(flag == <span class="number">2</span>)&#123;</span><br><span class="line">                msgFinal.append(sendName).append(<span class="string">&quot; &quot;</span>).append(sdf.format(System.currentTimeMills()*<span class="number">2</span>)).append(<span class="string">&quot;\r\n&quot;</span>);</span><br><span class="line">                msgFinal().append(<span class="string">&quot; &quot;</span>).append(newMsg).append(<span class="string">&quot;\r\n&quot;</span>);</span><br><span class="line">                sendMsgToAll(flag,msgFinal.toString());</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(flag == <span class="number">3</span>)&#123;</span><br><span class="line">                msgFinal.append(sendName).append(<span class="string">&quot; &quot;</span>).append(sdf.format(System.currentTimeMills()*<span class="number">2</span>)).append(<span class="string">&quot;\r\n&quot;</span>);</span><br><span class="line">                msgFinal().append(<span class="string">&quot; &quot;</span>).append(newMsg).append(<span class="string">&quot;\r\n&quot;</span>);</span><br><span class="line">                <span class="type">String</span> <span class="variable">destName</span> <span class="operator">=</span> dis.readUTF();</span><br><span class="line">                sendMsgToOne(destName,msgFinal.toString());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">sendMsgToONe</span><span class="params">(String destName,String msg)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        Set&lt;Socket&gt; allOnLineSockets = ServerChat.onLineSockets.keySet();</span><br><span class="line">        <span class="keyword">for</span>(Socket sk : allOnLineSockets)&#123;</span><br><span class="line">            <span class="keyword">if</span>(ServerChat.onLineSockets.get(sk).trim().equals(destName))&#123;</span><br><span class="line">            <span class="type">DataOutputStream</span> <span class="variable">dos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DataOutputStream</span>(sk.getOutputStream());</span><br><span class="line">            dos.writeInt(<span class="number">2</span>);</span><br><span class="line">            dos.writeUTF(msg);</span><br><span class="line">            dos.flush();   </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">sendMsgToAll</span><span class="params">(<span class="type">int</span> flag,String msg)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        Set&lt;Socket&gt; allOnLineSockets = ServerChat.onLineSockets.keySet();</span><br><span class="line">        <span class="keyword">for</span>(Socket sk : allOnLineSockets)&#123;</span><br><span class="line">            <span class="type">DataOutputStream</span> <span class="variable">dos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DataOutputStream</span>(sk.getOutputStream());</span><br><span class="line">            dos.writeInt(flag);</span><br><span class="line">            dos.writeUTF(msg);</span><br><span class="line">            dos.flush();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Constants</span>&#123;</span><br><span class="line">    <span class="comment">//常量</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">PORT</span> <span class="operator">=</span> <span class="number">7778</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//协议分隔符</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">SPILIT</span> <span class="operator">=</span> <span class="string">&quot;003197xxxxx&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="客户端设计"><a href="#客户端设计" class="headerlink" title="客户端设计"></a>客户端设计</h6><p>客户端主体代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClientChat</span> <span class="keyword">implements</span> <span class="title class_">ActionListener</span> &#123;</span><br><span class="line">   <span class="comment">/** 1.设计界面  */</span></span><br><span class="line">   <span class="keyword">private</span> <span class="type">JFrame</span> <span class="variable">win</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JFrame</span>();</span><br><span class="line">   <span class="comment">/** 2.消息内容框架 */</span></span><br><span class="line">   <span class="keyword">public</span> <span class="type">JTextArea</span> <span class="variable">smsContent</span> <span class="operator">=</span><span class="keyword">new</span> <span class="title class_">JTextArea</span>(<span class="number">23</span> , <span class="number">50</span>);</span><br><span class="line">   <span class="comment">/** 3.发送消息的框  */</span></span><br><span class="line">   <span class="keyword">private</span> <span class="type">JTextArea</span> <span class="variable">smsSend</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JTextArea</span>(<span class="number">4</span>,<span class="number">40</span>);</span><br><span class="line">   <span class="comment">/** 4.在线人数的区域  */</span></span><br><span class="line">   <span class="comment">/** 存放人的数据 */</span></span><br><span class="line">   <span class="comment">/** 展示在线人数的窗口 */</span></span><br><span class="line">   <span class="keyword">public</span> JList&lt;String&gt; onLineUsers = <span class="keyword">new</span> <span class="title class_">JList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 是否私聊按钮</span></span><br><span class="line">   <span class="keyword">private</span> <span class="type">JCheckBox</span> <span class="variable">isPrivateBn</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JCheckBox</span>(<span class="string">&quot;私聊&quot;</span>);</span><br><span class="line">   <span class="comment">// 消息按钮</span></span><br><span class="line">   <span class="keyword">private</span> <span class="type">JButton</span> <span class="variable">sendBn</span>  <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JButton</span>(<span class="string">&quot;发送&quot;</span>);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 登录界面</span></span><br><span class="line">   <span class="keyword">private</span> JFrame loginView;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> JTextField ipEt , nameEt , idEt;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> Socket socket ;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">      <span class="keyword">new</span> <span class="title class_">ClientChat</span>().initView();</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">initView</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="comment">/** 初始化聊天窗口的界面 */</span></span><br><span class="line">      win.setSize(<span class="number">650</span>, <span class="number">600</span>);</span><br><span class="line"></span><br><span class="line">      <span class="comment">/** 展示登录界面  */</span></span><br><span class="line">      displayLoginView();</span><br><span class="line"></span><br><span class="line">      <span class="comment">/** 展示聊天界面 */</span></span><br><span class="line">      <span class="comment">//displayChatView();</span></span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">displayChatView</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">      <span class="type">JPanel</span> <span class="variable">bottomPanel</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JPanel</span>(<span class="keyword">new</span> <span class="title class_">BorderLayout</span>());</span><br><span class="line">      <span class="comment">//-----------------------------------------------</span></span><br><span class="line">      <span class="comment">// 将消息框和按钮 添加到窗口的底端</span></span><br><span class="line">      win.add(bottomPanel, BorderLayout.SOUTH);</span><br><span class="line">      bottomPanel.add(smsSend);</span><br><span class="line">      <span class="type">JPanel</span> <span class="variable">btns</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JPanel</span>(<span class="keyword">new</span> <span class="title class_">FlowLayout</span>(FlowLayout.LEFT));</span><br><span class="line">      btns.add(sendBn);</span><br><span class="line">      btns.add(isPrivateBn);</span><br><span class="line">      bottomPanel.add(btns, BorderLayout.EAST);</span><br><span class="line">      <span class="comment">//-----------------------------------------------</span></span><br><span class="line">      <span class="comment">// 给发送消息按钮绑定点击事件监听器</span></span><br><span class="line">      <span class="comment">// 将展示消息区centerPanel添加到窗口的中间</span></span><br><span class="line">      smsContent.setBackground(<span class="keyword">new</span> <span class="title class_">Color</span>(<span class="number">0xdd</span>,<span class="number">0xdd</span>,<span class="number">0xdd</span>));</span><br><span class="line">      <span class="comment">// 让展示消息区可以滚动。</span></span><br><span class="line">      win.add(<span class="keyword">new</span> <span class="title class_">JScrollPane</span>(smsContent), BorderLayout.CENTER);</span><br><span class="line">      smsContent.setEditable(<span class="literal">false</span>);</span><br><span class="line">      <span class="comment">//-----------------------------------------------</span></span><br><span class="line">      <span class="comment">// 用户列表和是否私聊放到窗口的最右边</span></span><br><span class="line">      <span class="type">Box</span> <span class="variable">rightBox</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Box</span>(BoxLayout.Y_AXIS);</span><br><span class="line">      onLineUsers.setFixedCellWidth(<span class="number">120</span>);</span><br><span class="line">      onLineUsers.setVisibleRowCount(<span class="number">13</span>);</span><br><span class="line">      rightBox.add(<span class="keyword">new</span> <span class="title class_">JScrollPane</span>(onLineUsers));</span><br><span class="line">      win.add(rightBox, BorderLayout.EAST);</span><br><span class="line">      <span class="comment">//-----------------------------------------------</span></span><br><span class="line">      <span class="comment">// 关闭窗口退出当前程序</span></span><br><span class="line">      win.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);</span><br><span class="line">      win.pack();  <span class="comment">// swing 加上这句 就可以拥有关闭窗口的功能</span></span><br><span class="line">      <span class="comment">/** 设置窗口居中,显示出来  */</span></span><br><span class="line">      setWindowCenter(win,<span class="number">650</span>,<span class="number">600</span>,<span class="literal">true</span>);</span><br><span class="line">      <span class="comment">// 发送按钮绑定点击事件</span></span><br><span class="line">      sendBn.addActionListener(<span class="built_in">this</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">displayLoginView</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/** 先让用户进行登录</span></span><br><span class="line"><span class="comment">       *  服务端ip</span></span><br><span class="line"><span class="comment">       *  用户名</span></span><br><span class="line"><span class="comment">       *  id</span></span><br><span class="line"><span class="comment">       *  */</span></span><br><span class="line">      <span class="comment">/** 显示一个qq的登录框     */</span></span><br><span class="line">      loginView = <span class="keyword">new</span> <span class="title class_">JFrame</span>(<span class="string">&quot;登录&quot;</span>);</span><br><span class="line">      loginView.setLayout(<span class="keyword">new</span> <span class="title class_">GridLayout</span>(<span class="number">3</span>, <span class="number">1</span>));</span><br><span class="line">      loginView.setSize(<span class="number">400</span>, <span class="number">230</span>);</span><br><span class="line"></span><br><span class="line">      <span class="type">JPanel</span> <span class="variable">ip</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JPanel</span>();</span><br><span class="line">      <span class="type">JLabel</span> <span class="variable">label</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JLabel</span>(<span class="string">&quot;   IP:&quot;</span>);</span><br><span class="line">      ip.add(label);</span><br><span class="line">      ipEt = <span class="keyword">new</span> <span class="title class_">JTextField</span>(<span class="number">20</span>);</span><br><span class="line">      ip.add(ipEt);</span><br><span class="line">      loginView.add(ip);</span><br><span class="line"></span><br><span class="line">      <span class="type">JPanel</span> <span class="variable">name</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JPanel</span>();</span><br><span class="line">      <span class="type">JLabel</span> <span class="variable">label1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JLabel</span>(<span class="string">&quot;姓名:&quot;</span>);</span><br><span class="line">      name.add(label1);</span><br><span class="line">      nameEt = <span class="keyword">new</span> <span class="title class_">JTextField</span>(<span class="number">20</span>);</span><br><span class="line">      name.add(nameEt);</span><br><span class="line">      loginView.add(name);</span><br><span class="line"></span><br><span class="line">      <span class="type">JPanel</span> <span class="variable">btnView</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JPanel</span>();</span><br><span class="line">      <span class="type">JButton</span> <span class="variable">login</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JButton</span>(<span class="string">&quot;登陆&quot;</span>);</span><br><span class="line">      btnView.add(login);</span><br><span class="line">      <span class="type">JButton</span> <span class="variable">cancle</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JButton</span>(<span class="string">&quot;取消&quot;</span>);</span><br><span class="line">      btnView.add(cancle);</span><br><span class="line">      loginView.add(btnView);</span><br><span class="line">      <span class="comment">// 关闭窗口退出当前程序</span></span><br><span class="line">      loginView.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);</span><br><span class="line">      setWindowCenter(loginView,<span class="number">400</span>,<span class="number">260</span>,<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">      <span class="comment">/** 给登录和取消绑定点击事件 */</span></span><br><span class="line">      login.addActionListener(<span class="built_in">this</span>);</span><br><span class="line">      cancle.addActionListener(<span class="built_in">this</span>);</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">setWindowCenter</span><span class="params">(JFrame frame, <span class="type">int</span> width , <span class="type">int</span> height, <span class="type">boolean</span> flag)</span> &#123;</span><br><span class="line">      <span class="comment">/** 得到所在系统所在屏幕的宽高 */</span></span><br><span class="line">      <span class="type">Dimension</span> <span class="variable">ds</span> <span class="operator">=</span> frame.getToolkit().getScreenSize();</span><br><span class="line"></span><br><span class="line">      <span class="comment">/** 拿到电脑的宽 */</span></span><br><span class="line">      <span class="type">int</span> <span class="variable">width1</span> <span class="operator">=</span> ds.width;</span><br><span class="line">      <span class="comment">/** 高 */</span></span><br><span class="line">      <span class="type">int</span> <span class="variable">height1</span> <span class="operator">=</span> ds.height ;</span><br><span class="line"></span><br><span class="line">      System.out.println(width1 +<span class="string">&quot;*&quot;</span> + height1);</span><br><span class="line">      <span class="comment">/** 设置窗口的左上角坐标 */</span></span><br><span class="line">      frame.setLocation(width1/<span class="number">2</span> - width/<span class="number">2</span>, height1/<span class="number">2</span> -height/<span class="number">2</span>);</span><br><span class="line">      frame.setVisible(flag);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">actionPerformed</span><span class="params">(ActionEvent e)</span> &#123;</span><br><span class="line">      <span class="comment">/** 得到点击的事件源 */</span></span><br><span class="line">      <span class="type">JButton</span> <span class="variable">btn</span> <span class="operator">=</span> (JButton) e.getSource();</span><br><span class="line">      <span class="keyword">switch</span>(btn.getText())&#123;</span><br><span class="line">         <span class="keyword">case</span> <span class="string">&quot;登陆&quot;</span>:</span><br><span class="line">            <span class="type">String</span> <span class="variable">ip</span> <span class="operator">=</span> ipEt.getText().toString();</span><br><span class="line">            <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> nameEt.getText().toString();</span><br><span class="line">            <span class="comment">// 校验参数是否为空</span></span><br><span class="line">            <span class="comment">// 错误提示</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span> ;</span><br><span class="line">            <span class="comment">// 12.1.2.0</span></span><br><span class="line">            <span class="comment">// \d&#123;1,3&#125;\.\d&#123;1,3&#125;\.\d&#123;1,3&#125;\.\d&#123;1,3&#125;\</span></span><br><span class="line">            <span class="keyword">if</span>(ip==<span class="literal">null</span> || !ip.matches(<span class="string">&quot;\\d&#123;1,3&#125;\\.\\d&#123;1,3&#125;\\.\\d&#123;1,3&#125;\\.\\d&#123;1,3&#125;&quot;</span>))&#123;</span><br><span class="line">               msg = <span class="string">&quot;请输入合法的服务端ip地址&quot;</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(name==<span class="literal">null</span> || !name.matches(<span class="string">&quot;\\S&#123;1,&#125;&quot;</span>))&#123;</span><br><span class="line">               msg = <span class="string">&quot;姓名必须1个字符以上&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(!msg.equals(<span class="string">&quot;&quot;</span>))&#123;</span><br><span class="line">               <span class="comment">/** msg有内容说明参数有为空 */</span></span><br><span class="line">               <span class="comment">// 参数一：弹出放到哪个窗口里面</span></span><br><span class="line">               JOptionPane.showMessageDialog(loginView, msg);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">               <span class="keyword">try</span> &#123;</span><br><span class="line">                  <span class="comment">// 参数都合法了</span></span><br><span class="line">                  <span class="comment">// 当前登录的用户,去服务端登陆</span></span><br><span class="line">                  <span class="comment">/** 先把当前用户的名称展示到界面 */</span></span><br><span class="line">                  win.setTitle(name);</span><br><span class="line">                  <span class="comment">// 去服务端登陆连接一个socket管道</span></span><br><span class="line">                  socket = <span class="keyword">new</span> <span class="title class_">Socket</span>(ip, Constants.PORT);</span><br><span class="line"></span><br><span class="line">                  <span class="comment">//为客户端的socket分配一个线程 专门负责收消息</span></span><br><span class="line">                  <span class="keyword">new</span> <span class="title class_">ClientReader</span>(<span class="built_in">this</span>,socket).start();</span><br><span class="line"></span><br><span class="line">                  <span class="comment">// 带上用户信息过去</span></span><br><span class="line">                  <span class="type">DataOutputStream</span> <span class="variable">dos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DataOutputStream</span>(socket.getOutputStream());</span><br><span class="line">                  dos.writeInt(<span class="number">1</span>); <span class="comment">// 登录消息</span></span><br><span class="line">                  dos.writeUTF(name.trim());</span><br><span class="line">                  dos.flush();</span><br><span class="line"></span><br><span class="line">                  <span class="comment">// 关系当前窗口 弹出聊天界面</span></span><br><span class="line">                  loginView.dispose(); <span class="comment">// 登录窗口销毁</span></span><br><span class="line">                  displayChatView(); <span class="comment">// 展示了聊天窗口了</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">               &#125; <span class="keyword">catch</span> (Exception e1) &#123;</span><br><span class="line">                  e1.printStackTrace();</span><br><span class="line">               &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">         <span class="keyword">case</span> <span class="string">&quot;取消&quot;</span>:</span><br><span class="line">            <span class="comment">/** 退出系统 */</span></span><br><span class="line">            System.exit(<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">         <span class="keyword">case</span> <span class="string">&quot;发送&quot;</span>:</span><br><span class="line">            <span class="comment">// 得到发送消息的内容</span></span><br><span class="line">				<span class="type">String</span> <span class="variable">msgSend</span> <span class="operator">=</span> smsSend.getText().toString();</span><br><span class="line">				<span class="keyword">if</span>(!msgSend.trim().equals(<span class="string">&quot;&quot;</span>))&#123;</span><br><span class="line">					<span class="comment">/** 发消息给服务端 */</span></span><br><span class="line">					<span class="keyword">try</span> &#123;</span><br><span class="line">						<span class="comment">// 判断是否对谁发消息</span></span><br><span class="line">						<span class="type">String</span> <span class="variable">selectName</span> <span class="operator">=</span> onLineUsers.getSelectedValue();</span><br><span class="line">						<span class="type">int</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="number">2</span> ;<span class="comment">// 群发 @消息</span></span><br><span class="line">						<span class="keyword">if</span>(selectName!=<span class="literal">null</span>&amp;&amp;!selectName.equals(<span class="string">&quot;&quot;</span>))&#123;</span><br><span class="line">							msgSend =(<span class="string">&quot;@&quot;</span>+selectName+<span class="string">&quot;,&quot;</span>+msgSend);</span><br><span class="line">							<span class="comment">/** 判断是否选中了私法 */</span></span><br><span class="line">							<span class="keyword">if</span>(isPrivateBn.isSelected())&#123;</span><br><span class="line">								<span class="comment">/** 私法 */</span></span><br><span class="line">								flag = <span class="number">3</span> ;<span class="comment">//私发消息</span></span><br><span class="line">							&#125;</span><br><span class="line"></span><br><span class="line">						&#125;</span><br><span class="line">						<span class="type">DataOutputStream</span> <span class="variable">dos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DataOutputStream</span>(socket.getOutputStream());</span><br><span class="line">						dos.writeInt(flag); <span class="comment">// 群发消息  发送给所有人</span></span><br><span class="line">						dos.writeUTF(msgSend);</span><br><span class="line">						<span class="keyword">if</span>(flag == <span class="number">3</span>)&#123;</span><br><span class="line">							<span class="comment">// 告诉服务端我对谁私发</span></span><br><span class="line">							dos.writeUTF(selectName.trim());</span><br><span class="line">						&#125;</span><br><span class="line">						dos.flush();</span><br><span class="line"></span><br><span class="line">					&#125; <span class="keyword">catch</span> (Exception e1) &#123;</span><br><span class="line">						e1.printStackTrace();</span><br><span class="line">					&#125;</span><br><span class="line"></span><br><span class="line">				&#125;</span><br><span class="line">				smsSend.setText(<span class="literal">null</span>);</span><br><span class="line">            	<span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line">&#125;	</span><br></pre></td></tr></table></figure>

<p>客户端socket处理线程</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ClientReader</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> Socket socket;</span><br><span class="line">	<span class="keyword">private</span> ClientChat clientChat ;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">ClientReader</span><span class="params">(ClientChat clientChat, Socket socket)</span> &#123;</span><br><span class="line">		<span class="built_in">this</span>.clientChat = clientChat;</span><br><span class="line">		<span class="built_in">this</span>.socket = socket;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="type">DataInputStream</span> <span class="variable">dis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DataInputStream</span>(socket.getInputStream());</span><br><span class="line">			<span class="comment">/** 循环一直等待客户端的消息 */</span></span><br><span class="line">			<span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">				<span class="comment">/** 读取当前的消息类型 ：登录,群发,私聊 , @消息 */</span></span><br><span class="line">				<span class="type">int</span> <span class="variable">flag</span> <span class="operator">=</span> dis.readInt();</span><br><span class="line">				<span class="keyword">if</span>(flag == <span class="number">1</span>)&#123;</span><br><span class="line">					<span class="comment">// 在线人数消息回来了</span></span><br><span class="line">					<span class="type">String</span> <span class="variable">nameDatas</span> <span class="operator">=</span> dis.readUTF();</span><br><span class="line">					<span class="comment">// 展示到在线人数的界面</span></span><br><span class="line">					String[] names = nameDatas.split(Constants.SPILIT);</span><br><span class="line"></span><br><span class="line">					clientChat.onLineUsers.setListData(names);</span><br><span class="line">				&#125;<span class="keyword">else</span> <span class="keyword">if</span>(flag == <span class="number">2</span>)&#123;</span><br><span class="line">					<span class="comment">//群发,私聊 , @消息 都是直接显示的。</span></span><br><span class="line">					<span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> dis.readUTF() ;</span><br><span class="line">					clientChat.smsContent.append(msg);</span><br><span class="line">					<span class="comment">// 让消息界面滾動到底端</span></span><br><span class="line">					clientChat.smsContent.setCaretPosition(clientChat.smsContent.getText().length());</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="JAVA-NIO深入剖析"><a href="#JAVA-NIO深入剖析" class="headerlink" title="JAVA NIO深入剖析"></a>JAVA NIO深入剖析</h4><h5 id="java-NIO基本介绍"><a href="#java-NIO基本介绍" class="headerlink" title="java NIO基本介绍"></a>java NIO基本介绍</h5><ul>
<li><p>Java NIO（New IO）也有人称之为 java non-blocking IO是从Java 1.4版本开始引入的一个新的IO API，可以替代标准的Java IO API。NIO与原来的IO有同样的作用和目的，但是使用的方式完全不同，NIO支持面向缓冲区的、基于通道的IO操作。NIO将以更加高效的方式进行文件的读写操作。NIO可以理解为非阻塞IO,传统的IO的read和write只能阻塞执行，线程在读写IO期间不能干其他事情，比如调用socket.read()时，如果服务器一直没有数据传输过来，线程就一直阻塞，而NIO中可以配置socket为非阻塞模式。</p>
</li>
<li><p>NIO 相关类都被放在 java.nio 包及子包下，并且对原 java.io 包中的很多类进行改写。</p>
</li>
<li><p>NIO 有三大核心部分：Channel( 通道) ，Buffer( 缓冲区), Selector( 选择器)</p>
</li>
<li><p>Java NIO 的非阻塞模式，使一个线程从某通道发送请求或者读取数据，但是它仅能得到目前可用的数据，如<br>果目前没有数据可用时，就什么都不会获取，而不是保持线程阻塞，所以直至数据变的可以读取之前，该线程<br>可以继续做其他的事情。 非阻塞写也是如此，一个线程请求写入一些数据到某通道，但不需要等待它完全写<br>入，这个线程同时可以去做别的事情。</p>
</li>
<li><p>通俗理解：NIO 是可以做到用一个线程来处理多个操作的。假设有 1000 个请求过来,根据实际情况，可以分<br>配20 或者 80个线程来处理。不像之前的阻塞 IO 那样，非得分配 1000 个。</p>
</li>
</ul>
<h5 id="NIO和BIO比较"><a href="#NIO和BIO比较" class="headerlink" title="NIO和BIO比较"></a>NIO和BIO比较</h5><ul>
<li><p>BIO 以流的方式处理数据,而 NIO 以块的方式处理数据,块 I&#x2F;O 的效率比流 I&#x2F;O 高很多</p>
</li>
<li><p>BIO 是阻塞的，NIO 则是非阻塞的</p>
</li>
<li><p>BIO 基于字节流和字符流进行操作，而 NIO 基于 Channel(通道)和Buffer(缓冲区)进行操作，数据总是从通道读取到缓冲区中，或者从缓冲区写入到通道中。Selector(选择器)用于监听多个通道的事件（比如：连接请求，数据到达等），因此使用单个线程就可以监听多个客户端通道</p>
</li>
</ul>
<table>
<thead>
<tr>
<th align="center">NIO</th>
<th align="center">BIO</th>
</tr>
</thead>
<tbody><tr>
<td align="center">面向缓冲区（Buffer）</td>
<td align="center">面向流（Stream）</td>
</tr>
<tr>
<td align="center">非阻塞（Non-Blocking IO）</td>
<td align="center">阻塞IO（Blocking IO）</td>
</tr>
<tr>
<td align="center">选择器（Selectors）</td>
<td align="center"></td>
</tr>
</tbody></table>
<h5 id="NIO三大核心原理示意图"><a href="#NIO三大核心原理示意图" class="headerlink" title="NIO三大核心原理示意图"></a>NIO三大核心原理示意图</h5><p>NIO 有三大核心部分：Channel( 通道) ，Buffer( 缓冲区), Selector( 选择器)</p>
<p><strong>Buffer缓冲区</strong><br>缓冲区本质上是一块可以写入数据，然后可以从中读取数据的内存。这块内存被包装成NIO Buffer对象，并提供<br>了一组方法，用来方便的访问该块内存。相比较直接对数组的操作，Buffer API更加容易操作和管理。</p>
<p><strong>Channel（通道）</strong><br>Java NIO的通道类似流，但又有些不同：既可以从通道中读取数据，又可以写数据到通道。但流的（input或output)读写通常是单向的。 通道可以非阻塞读取和写入通道，通道可以支持读取或写入缓冲区，也支持异步地读写。</p>
<p><strong>Selector选择器</strong><br>Selector是 一个Java NIO组件，可以能够检查一个或多个 NIO 通道，并确定哪些通道已经准备好进行读<br>取或写入。这样，一个单独的线程可以管理多个channel，从而管理多个网络连接，提高效率</p>
<p><img src="/../images/d.PNG" alt="d"></p>
<ul>
<li>每个 channel 都会对应一个 Buffer</li>
<li>一个线程对应Selector ， 一个Selector对应多个 channel(连接)</li>
<li>程序切换到哪个 channel 是由事件决定的</li>
<li>Selector 会根据不同的事件，在各个通道上切换</li>
<li>Buffer 就是一个内存块 ， 底层是一个数组</li>
<li>数据的读取写入是通过 Buffer完成的 , BIO 中要么是输入流，或<br>者是输出流, 不能双向，但是 NIO 的 Buffer 是可以读也可以写。</li>
<li>Java NIO系统的核心在于：通道(Channel)和缓冲区 (Buffer)。<br>通道表示打开到 IO 设备(例如：文件、 套接字)的连接。若需<br>要使用 NIO 系统，需要获取 用于连接 IO 设备的通道以及<br>用于容纳数据的缓冲 区。然后操作缓冲区，对数据进<br>行处理。简而言之，Channel 负责传输， Buffer 负责<br>存取数据</li>
</ul>
<h5 id="NIO核心一：缓冲区（Buffer）"><a href="#NIO核心一：缓冲区（Buffer）" class="headerlink" title="NIO核心一：缓冲区（Buffer）"></a>NIO核心一：缓冲区（Buffer）</h5><p>缓冲区（Buffer）一个用于特定基本数据类型的容器。由 java.nio 包定义的，所有缓冲区 都是 Buffer 抽象类的子类。Java NIO 中的 Buffer 主要用于与 NIO 通道进行 交互，数据是从通道读入缓冲区，从缓冲区写入通道中的。</p>
<p><img src="/../images/e.png" alt="e"></p>
<p><strong>Buffer及其子类</strong></p>
<p>Buffer就像一个数组，可以保存多个相同类型的数据。根据数据类型不同 ，有以下 Buffer 常用子类：</p>
<ul>
<li>ByteBuffer </li>
<li>CharBuffer </li>
<li>ShortBuffer </li>
<li>IntBuffer </li>
<li>LongBuffer </li>
<li>FloatBuffer </li>
<li>DoubleBuffer</li>
</ul>
<p>上述 Buffer 类他们都采用相似的方法进行管理数据，只是各自 管理的数据类型不同而已。都是通过如下方法获<br>取一个 Buffer 对象：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> XxxBuffer <span class="title function_">allocate</span><span class="params">(<span class="type">int</span> capacity)</span> : 创建</span><br><span class="line">一个容量为capacity 的 XxxBuffer 对象</span><br></pre></td></tr></table></figure>

<p><strong>缓冲区的基本属性</strong></p>
<p>Buffer 中的重要概念： </p>
<ul>
<li><p><strong>容量 (capacity)</strong> ：作为一个内存块，Buffer具有一定的固定大小，<br>也称为”容量”，缓冲区容量不能为负，并且创建后不能更改。 </p>
</li>
<li><p>**限制 (limit)**：表示缓冲区中可以操作数据的大小<br>（limit 后数据不能进行读写）。缓冲区的限制不能<br>为负，并且不能大于其容量。 写入模式，限制等于<br>buffer的容量。读取模式下，limit等于写入的数据量。</p>
</li>
<li><p>**位置 (position)**：下一个要读取或写入的数据的索引。<br>缓冲区的位置不能为 负，并且不能大于其限制 </p>
</li>
<li><p>**标记 (mark)与重置 (reset)**：标记是一个索引，<br>通过 Buffer 中的 mark() 方法 指定 Buffer 中一个<br>特定的 position，之后可以通过调用 reset() 方法恢<br>复到这 个 position.<br><strong>标记、位置、限制、容量遵守以下不变式：</strong><br>0 &lt;&#x3D; mark &lt;&#x3D; position &lt;&#x3D; limit &lt;&#x3D; capacity</p>
</li>
</ul>
<p><img src="/../images/f.png" alt="f"></p>
<p><strong>Buffer常见方法</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Buffer <span class="title function_">clear</span><span class="params">()</span> <span class="comment">//清空缓冲区并返回对缓冲区的引用</span></span><br><span class="line">Buffer <span class="title function_">flip</span><span class="params">()</span>  <span class="comment">//将缓冲区的界限设置为当前位置，并将当前位置充值为 0</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">capacity</span><span class="params">()</span> <span class="comment">//返回 Buffer 的 capacity 大小</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">hasRemaining</span><span class="params">()</span> <span class="comment">//判断缓冲区中是否还有元素</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">limit</span><span class="params">()</span> <span class="comment">//返回 Buffer 的界限(limit) 的位置</span></span><br><span class="line">Buffer <span class="title function_">limit</span><span class="params">(<span class="type">int</span> n)</span> <span class="comment">//将设置缓冲区界限为 n,并返回一个具有新 limit 的缓冲区对象</span></span><br><span class="line">Buffer <span class="title function_">mark</span><span class="params">()</span> <span class="comment">//对缓冲区设置标记</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">position</span><span class="params">()</span> <span class="comment">//返回缓冲区的当前位置 position</span></span><br><span class="line">Buffer <span class="title function_">position</span><span class="params">(<span class="type">int</span> n)</span> <span class="comment">//将设置缓冲区的当前位置为 n，并返回修改后的 Buffer 对象</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">remaining</span><span class="params">()</span> <span class="comment">//返回 position 和 limit 之间的元素个数</span></span><br><span class="line">Buffer <span class="title function_">reset</span><span class="params">()</span> <span class="comment">//将位置 position 转到以前设置的mark所在的位置</span></span><br><span class="line">Buffer <span class="title function_">rewind</span><span class="params">()</span> <span class="comment">//将位置设为为 0， 取消设置的 mark</span></span><br></pre></td></tr></table></figure>

<p><strong>缓冲区的数据操作</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Buffer 所有子类提供了两个用于数据操作的方法 <span class="comment">//get()put() 方法取获取 Buffer中的数据</span></span><br><span class="line">get() <span class="comment">//读取单个字节</span></span><br><span class="line">get(<span class="type">byte</span>[] dst)<span class="comment">//批量读取多个字节到 dst 中</span></span><br><span class="line">get(<span class="type">int</span> index)<span class="comment">//读取指定索引位置的字节(不会移动 position)</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">//放到入数据到Buffer</span></span><br><span class="line">put(<span class="type">byte</span> b)<span class="comment">//将给定单个字节写入缓冲区的当前位置</span></span><br><span class="line">put(<span class="type">byte</span>[] src)<span class="comment">//将 src 中的字节写入缓冲区的当前位置</span></span><br><span class="line">put(<span class="type">int</span> index, <span class="type">byte</span> b)<span class="comment">//将指定字节写入缓冲区的索引位置(不会移动 position)</span></span><br></pre></td></tr></table></figure>

<p>使用Buffer读写数据一般遵循以下四个步骤：</p>
<ul>
<li>写入数据到Buffer</li>
<li>调用flip()方法，转换为读取模式</li>
<li>从Buffer中读取数据</li>
<li>调用buffer.clear()方法或者buffer.compact()方<br>法清除缓冲区</li>
</ul>
<p>代码演示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestBuffer</span> &#123;</span><br><span class="line">   <span class="meta">@Test</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test3</span><span class="params">()</span>&#123;</span><br><span class="line">      <span class="comment">//分配直接缓冲区</span></span><br><span class="line">      <span class="type">ByteBuffer</span> <span class="variable">buf</span> <span class="operator">=</span> ByteBuffer.allocateDirect(<span class="number">1024</span>);</span><br><span class="line">      System.out.println(buf.isDirect());</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="meta">@Test</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span>&#123;</span><br><span class="line">      <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;itheima&quot;</span>;</span><br><span class="line">      </span><br><span class="line">      <span class="type">ByteBuffer</span> <span class="variable">buf</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">      </span><br><span class="line">      buf.put(str.getBytes());</span><br><span class="line">      </span><br><span class="line">      buf.flip();</span><br><span class="line">      </span><br><span class="line">      <span class="type">byte</span>[] dst = <span class="keyword">new</span> <span class="title class_">byte</span>[buf.limit()];</span><br><span class="line">      buf.get(dst, <span class="number">0</span>, <span class="number">2</span>);</span><br><span class="line">      System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(dst, <span class="number">0</span>, <span class="number">2</span>));</span><br><span class="line">      System.out.println(buf.position());</span><br><span class="line">      </span><br><span class="line">      <span class="comment">//mark() : 标记</span></span><br><span class="line">      buf.mark();</span><br><span class="line">      </span><br><span class="line">      buf.get(dst, <span class="number">2</span>, <span class="number">2</span>);</span><br><span class="line">      System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(dst, <span class="number">2</span>, <span class="number">2</span>));</span><br><span class="line">      System.out.println(buf.position());</span><br><span class="line">      </span><br><span class="line">      <span class="comment">//reset() : 恢复到 mark 的位置</span></span><br><span class="line">      buf.reset();</span><br><span class="line">      System.out.println(buf.position());</span><br><span class="line">      </span><br><span class="line">      <span class="comment">//判断缓冲区中是否还有剩余数据</span></span><br><span class="line">      <span class="keyword">if</span>(buf.hasRemaining())&#123;</span><br><span class="line">         <span class="comment">//获取缓冲区中可以操作的数量</span></span><br><span class="line">         System.out.println(buf.remaining());</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">    </span><br><span class="line">   <span class="meta">@Test</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span>&#123;</span><br><span class="line">      <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;itheima&quot;</span>;</span><br><span class="line">      <span class="comment">//1. 分配一个指定大小的缓冲区</span></span><br><span class="line">      <span class="type">ByteBuffer</span> <span class="variable">buf</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">      System.out.println(<span class="string">&quot;-----------------allocate()----------------&quot;</span>);</span><br><span class="line">      System.out.println(buf.position());<span class="comment">// 7</span></span><br><span class="line">      System.out.println(buf.limit());<span class="comment">// 10</span></span><br><span class="line">      System.out.println(buf.capacity());<span class="comment">// 10</span></span><br><span class="line">      </span><br><span class="line">      <span class="comment">//2. 利用 put() 存入数据到缓冲区中</span></span><br><span class="line">      buf.put(str.getBytes());</span><br><span class="line">      System.out.println(<span class="string">&quot;-----------------put()----------------&quot;</span>);</span><br><span class="line">      System.out.println(buf.position());<span class="comment">// 0</span></span><br><span class="line">      System.out.println(buf.limit());<span class="comment">// 7</span></span><br><span class="line">      System.out.println(buf.capacity());<span class="comment">// 10</span></span><br><span class="line">      </span><br><span class="line">      <span class="comment">//3. 切换读取数据模式</span></span><br><span class="line">      buf.flip();</span><br><span class="line">      System.out.println(<span class="string">&quot;-----------------flip()----------------&quot;</span>);</span><br><span class="line">      System.out.println(buf.position());<span class="comment">// 7</span></span><br><span class="line">      System.out.println(buf.limit());<span class="comment">// 10</span></span><br><span class="line">      System.out.println(buf.capacity());<span class="comment">// 10</span></span><br><span class="line">      </span><br><span class="line">      <span class="comment">//4. 利用 get() 读取缓冲区中的数据</span></span><br><span class="line">      <span class="type">byte</span>[] dst = <span class="keyword">new</span> <span class="title class_">byte</span>[buf.limit()];</span><br><span class="line">      buf.get(dst);</span><br><span class="line">      System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(dst, <span class="number">0</span>, dst.length));</span><br><span class="line"></span><br><span class="line">      System.out.println(<span class="string">&quot;-----------------get()----------------&quot;</span>);</span><br><span class="line">      System.out.println(buf.position());<span class="comment">// 0</span></span><br><span class="line">      System.out.println(buf.limit());<span class="comment">// 7</span></span><br><span class="line">      System.out.println(buf.capacity());<span class="comment">// 10</span></span><br><span class="line">       </span><br><span class="line">      <span class="comment">//5. rewind() : 可重复读</span></span><br><span class="line">      buf.rewind();</span><br><span class="line">      System.out.println(<span class="string">&quot;-----------------rewind()----------------&quot;</span>);</span><br><span class="line">      System.out.println(buf.position());</span><br><span class="line">      System.out.println(buf.limit());</span><br><span class="line">      System.out.println(buf.capacity());</span><br><span class="line">      </span><br><span class="line">      <span class="comment">//6. clear() : 清空缓冲区. 但是缓冲区中的数据依然存在，但是处于“被遗忘”状态</span></span><br><span class="line">      buf.clear();</span><br><span class="line">      System.out.println(<span class="string">&quot;-----------------clear()----------------&quot;</span>);</span><br><span class="line">      System.out.println(buf.position());</span><br><span class="line">      System.out.println(buf.limit());</span><br><span class="line">      System.out.println(buf.capacity());</span><br><span class="line">      System.out.println((<span class="type">char</span>)buf.get());</span><br><span class="line">      </span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="直接与非直接缓冲区"><a href="#直接与非直接缓冲区" class="headerlink" title="直接与非直接缓冲区"></a>直接与非直接缓冲区</h5><p>什么是直接内存与非直接内存？</p>
<p>根据官方文档的描述：</p>
<p>byte byffer可以是两种类型，一种是基于直接内存（也就是非堆内存）；另一种是非直接内存（也就是堆内存）。对于直接内存来说，JVM将会在IO操作上具有更高的性能，因为它直接作用于本地系统的IO操作。而非直接内存，也就是堆内存中的数据，如果要作IO操作，会先从本进程内存复制到直接内存，再利用本地IO处理。</p>
<p>从数据流的角度，非直接内存是下面这样的作用链：本地IO–&gt;直接内存–&gt;非直接内存–&gt;直接内存–&gt;本地IO</p>
<p>而直接内存是：本地IO–&gt;直接内存–&gt;本地IO</p>
<p>很明显，在做IO处理时，比如网络发送大量数据时，直接内存会具有更高的效率。直接内存使用allocateDirect创建，但是它比申请普通的堆内存需要耗费更高的性能。不过，这部分的数据是在JVM之外的，因此它不会占用应用的内存。所以呢，当你有很大的数据要缓存，并且它的生命周期又很长，那么就比较适合使用直接内存。只是一般<br>来说，如果不是能带来很明显的性能提升，还是推荐直接使用堆内存。字节缓冲区是直接缓冲区还是非直接缓冲<br>区可通过调用其 isDirect()  方法来确定。</p>
<p>使用场景</p>
<ol>
<li>有很大的数据需要存储，它的生命周期又很长</li>
<li>适合频繁的IO操作，比如网络并发场景</li>
</ol>
<h5 id="NIO核心二：通道（channel）"><a href="#NIO核心二：通道（channel）" class="headerlink" title="NIO核心二：通道（channel）"></a>NIO核心二：通道（channel）</h5><p><strong>通道Channe概述</strong></p>
<p>通道（Channel）：由 java.nio.channels 包定义 的。Channel 表示 IO 源与目标打开的连接。 Channel 类似于传统的“流”。只不过 Channel 本身不能直接访问数据，Channel 只能与 Buffer 进行交互。</p>
<p>NIO 的通道类似于流，但有些区别如下：</p>
<ul>
<li>通道可以同时进行读写，而流只能读或者只能写</li>
<li>通道可以实现异步读写数据</li>
<li>通道可以从缓冲读数据，也可以写数据到缓冲:</li>
</ul>
<p>BIO 中的 stream 是单向的，例如 FileInputStream 对象只能进行读取数据的操作，而 NIO 中的通道(Channel)是双向的，可以读操作，也可以写操作。</p>
<p>Channel 在 NIO 中是一个接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Channel</span> <span class="keyword">extends</span> <span class="title class_">Closeable</span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<p><strong>常用的Channel实现类</strong></p>
<ul>
<li>FileChannel：用于读取、写入、映射和操作文件的通道。</li>
<li>DatagramChannel：通过 UDP 读写网络中的数据通道。</li>
<li>SocketChannel：通过 TCP 读写网络中的数据。</li>
<li>ServerSocketChannel：可以监听新进来的 TCP 连接，对每一个新进来的连接都会创建一个 SocketChannel。 </li>
<li>【ServerSocketChanne 类似 ServerSocket , SocketChannel 类似 Socket】</li>
</ul>
<p><strong>FileChannel类</strong></p>
<p>获取通道的一种方式是对支持通道的对象调用getChannel() 方法。支持通道的类如下：</p>
<ul>
<li><p>FileInputStream</p>
</li>
<li><p>FileOutputStream</p>
</li>
<li><p>RandomAccessFile</p>
</li>
<li><p>DatagramSocket</p>
</li>
<li><p>Socket</p>
</li>
<li><p>ServerSocket</p>
<p>获取通道的其他方式是使用 Files 类的静态方法 newByteChannel() 获取字节通道。或者通过通道的静态<br>方法 open() 打开并返回指定通道。</p>
</li>
</ul>
<p><strong>FileChannel的常用方法</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">read</span><span class="params">(ByteBuffer dst)</span> <span class="comment">//从Channel到中读取数据到ByteBuffer</span></span><br><span class="line"><span class="type">long</span>  <span class="title function_">read</span><span class="params">(ByteBuffer[] dsts)</span> <span class="comment">//将Channel到中的数据“分散”到ByteBuffer[]</span></span><br><span class="line"><span class="type">int</span>  <span class="title function_">write</span><span class="params">(ByteBuffer src)</span><span class="comment">//将ByteBuffer到中的数据写入到Channel</span></span><br><span class="line"><span class="type">long</span> <span class="title function_">write</span><span class="params">(ByteBuffer[] srcs)</span><span class="comment">//将ByteBuffer[]到中的数据“聚集”到Channel</span></span><br><span class="line"><span class="type">long</span> <span class="title function_">position</span><span class="params">()</span> <span class="comment">//返回此通道的文件位置</span></span><br><span class="line">FileChannel <span class="title function_">position</span><span class="params">(<span class="type">long</span> p)</span> <span class="comment">//设置此通道的文件位置</span></span><br><span class="line"><span class="type">long</span> <span class="title function_">size</span><span class="params">()</span> <span class="comment">//返回此通道的文件的当前大小</span></span><br><span class="line">FileChannel <span class="title function_">truncate</span><span class="params">(<span class="type">long</span> s)</span> <span class="comment">//将此通道的文件截取为给定大小</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">force</span><span class="params">(<span class="type">boolean</span> metaData)</span> <span class="comment">//强制将所有对此通道的文件更新写入到存储设备中</span></span><br></pre></td></tr></table></figure>

<p><strong>案例1-本地文件写数据</strong></p>
<p>需求：使用前面学习后的 ByteBuffer(缓冲) 和 FileChannel(通道)， 将 “hello,黑马Java程序员！” 写入到 data.txt 中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ChannelTest</span> &#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">write</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 1、字节输出流通向目标文件</span></span><br><span class="line">            <span class="type">FileOutputStream</span> <span class="variable">fos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;data01.txt&quot;</span>);</span><br><span class="line">            <span class="comment">// 2、得到字节输出流对应的通道Channel</span></span><br><span class="line">            <span class="type">FileChannel</span> <span class="variable">channel</span> <span class="operator">=</span> fos.getChannel();</span><br><span class="line">            <span class="comment">// 3、分配缓冲区</span></span><br><span class="line">            <span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">            buffer.put(<span class="string">&quot;hello,黑马Java程序员！&quot;</span>.getBytes());</span><br><span class="line">            <span class="comment">// 4、把缓冲区切换成写出模式</span></span><br><span class="line">            buffer.flip();</span><br><span class="line">            channel.write(buffer);</span><br><span class="line">            channel.close();</span><br><span class="line">            System.out.println(<span class="string">&quot;写数据到文件中！&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>案例2-本地文件读数据</strong></p>
<p>需求：使用前面学习后的 ByteBuffer(缓冲) 和 FileChannel(通道)，将data01.txt 中的数据读入到程序，并显示在控制台屏幕。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ChannelTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">read</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 1、定义一个文件字节输入流与源文件接通</span></span><br><span class="line">        <span class="type">FileInputStream</span> <span class="variable">is</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;data01.txt&quot;</span>);</span><br><span class="line">        <span class="comment">// 2、需要得到文件字节输入流的文件通道</span></span><br><span class="line">        <span class="type">FileChannel</span> <span class="variable">channel</span> <span class="operator">=</span> is.getChannel();</span><br><span class="line">        <span class="comment">// 3、定义一个缓冲区</span></span><br><span class="line">        <span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">        <span class="comment">// 4、读取数据到缓冲区</span></span><br><span class="line">        channel.read(buffer);</span><br><span class="line">        buffer.flip();</span><br><span class="line">        <span class="comment">// 5、读取出缓冲区中的数据并输出即可</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">rs</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(buffer.array(),<span class="number">0</span>,buffer.remaining());</span><br><span class="line">        System.out.println(rs);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><strong>案例3-使用Buffer完成文件复制</strong></p>
<p>使用 FileChannel(通道) ，完成文件的拷贝。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">copy</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="comment">// 源文件</span></span><br><span class="line">    <span class="type">File</span> <span class="variable">srcFile</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;C:\\Users\\dlei\\Desktop\\BIO,NIO,AIO\\文件\\壁纸.jpg&quot;</span>);</span><br><span class="line">    <span class="type">File</span> <span class="variable">destFile</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;C:\\Users\\dlei\\Desktop\\BIO,NIO,AIO\\文件\\壁纸new.jpg&quot;</span>);</span><br><span class="line">    <span class="comment">// 得到一个字节字节输入流</span></span><br><span class="line">    <span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(srcFile);</span><br><span class="line">    <span class="comment">// 得到一个字节输出流</span></span><br><span class="line">    <span class="type">FileOutputStream</span> <span class="variable">fos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(destFile);</span><br><span class="line">    <span class="comment">// 得到的是文件通道</span></span><br><span class="line">    <span class="type">FileChannel</span> <span class="variable">isChannel</span> <span class="operator">=</span> fis.getChannel();</span><br><span class="line">    <span class="type">FileChannel</span> <span class="variable">osChannel</span> <span class="operator">=</span> fos.getChannel();</span><br><span class="line">    <span class="comment">// 分配缓冲区</span></span><br><span class="line">    <span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">        <span class="comment">// 必须先清空缓冲然后再写入数据到缓冲区</span></span><br><span class="line">        buffer.clear();</span><br><span class="line">        <span class="comment">// 开始读取一次数据</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">flag</span> <span class="operator">=</span> isChannel.read(buffer);</span><br><span class="line">        <span class="keyword">if</span>(flag == -<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 已经读取了数据 ，把缓冲区的模式切换成可读模式</span></span><br><span class="line">        buffer.flip();</span><br><span class="line">        <span class="comment">// 把数据写出到</span></span><br><span class="line">        osChannel.write(buffer);</span><br><span class="line">    &#125;</span><br><span class="line">    isChannel.close();</span><br><span class="line">    osChannel.close();</span><br><span class="line">    System.out.println(<span class="string">&quot;复制完成！&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>案例4-分散（Scatter）和聚集（Gather）</p>
<p>分散读取（Scatter ）:是指把Channel通道的数据读入到多个缓冲区中去。</p>
<p>聚集写入（Gathering ）：是指将多个 Buffer 中的数据“聚集”到 Channel。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//分散和聚集</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> <span class="keyword">throws</span> IOException&#123;</span><br><span class="line">		<span class="type">RandomAccessFile</span> <span class="variable">raf1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RandomAccessFile</span>(<span class="string">&quot;1.txt&quot;</span>, <span class="string">&quot;rw&quot;</span>);</span><br><span class="line">	<span class="comment">//1. 获取通道</span></span><br><span class="line">	<span class="type">FileChannel</span> <span class="variable">channel1</span> <span class="operator">=</span> raf1.getChannel();</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//2. 分配指定大小的缓冲区</span></span><br><span class="line">	<span class="type">ByteBuffer</span> <span class="variable">buf1</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">100</span>);</span><br><span class="line">	<span class="type">ByteBuffer</span> <span class="variable">buf2</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//3. 分散读取</span></span><br><span class="line">	ByteBuffer[] bufs = &#123;buf1, buf2&#125;;</span><br><span class="line">	channel1.read(bufs);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span> (ByteBuffer byteBuffer : bufs) &#123;</span><br><span class="line">		byteBuffer.flip();</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(bufs[<span class="number">0</span>].array(), <span class="number">0</span>, bufs[<span class="number">0</span>].limit()));</span><br><span class="line">	System.out.println(<span class="string">&quot;-----------------&quot;</span>);</span><br><span class="line">	System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(bufs[<span class="number">1</span>].array(), <span class="number">0</span>, bufs[<span class="number">1</span>].limit()));</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//4. 聚集写入</span></span><br><span class="line">	<span class="type">RandomAccessFile</span> <span class="variable">raf2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RandomAccessFile</span>(<span class="string">&quot;2.txt&quot;</span>, <span class="string">&quot;rw&quot;</span>);</span><br><span class="line">	<span class="type">FileChannel</span> <span class="variable">channel2</span> <span class="operator">=</span> raf2.getChannel();</span><br><span class="line">	</span><br><span class="line">	channel2.write(bufs);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>案例5-transForm()</strong></p>
<p>从目标通道中去复制原通道数据</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test02</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="comment">// 1、字节输入管道</span></span><br><span class="line">    <span class="type">FileInputStream</span> <span class="variable">is</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;data01.txt&quot;</span>);</span><br><span class="line">    <span class="type">FileChannel</span> <span class="variable">isChannel</span> <span class="operator">=</span> is.getChannel();</span><br><span class="line">    <span class="comment">// 2、字节输出流管道</span></span><br><span class="line">    <span class="type">FileOutputStream</span> <span class="variable">fos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;data03.txt&quot;</span>);</span><br><span class="line">    <span class="type">FileChannel</span> <span class="variable">osChannel</span> <span class="operator">=</span> fos.getChannel();</span><br><span class="line">    <span class="comment">// 3、复制</span></span><br><span class="line">    osChannel.transferFrom(isChannel,isChannel.position(),isChannel.size());</span><br><span class="line">    isChannel.close();</span><br><span class="line">    osChannel.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>案例6-transferTo()</strong></p>
<p>把原通道数据复制到目标通道</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test02</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="comment">// 1、字节输入管道</span></span><br><span class="line">    <span class="type">FileInputStream</span> <span class="variable">is</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;data01.txt&quot;</span>);</span><br><span class="line">    <span class="type">FileChannel</span> <span class="variable">isChannel</span> <span class="operator">=</span> is.getChannel();</span><br><span class="line">    <span class="comment">// 2、字节输出流管道</span></span><br><span class="line">    <span class="type">FileOutputStream</span> <span class="variable">fos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;data04.txt&quot;</span>);</span><br><span class="line">    <span class="type">FileChannel</span> <span class="variable">osChannel</span> <span class="operator">=</span> fos.getChannel();</span><br><span class="line">    <span class="comment">// 3、复制</span></span><br><span class="line">    isChannel.transferTo(isChannel.position() , isChannel.size() , osChannel);</span><br><span class="line">    isChannel.close();</span><br><span class="line">    osChannel.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="NIO核心三：选择器（Selector）"><a href="#NIO核心三：选择器（Selector）" class="headerlink" title="NIO核心三：选择器（Selector）"></a>NIO核心三：选择器（Selector）</h5><p><strong>选择器概述</strong></p>
<p>选择器（Selector） 是 SelectableChannle 对象的多路复用器，Selector 可以同时监控多个 SelectableChannel 的 IO 状况，也就是说，利用 Selector可使一个单独的线程管理多个 Channel。Selector 是非阻塞 IO 的核心。</p>
<p>Java 的 NIO，用非阻塞的 IO 方式。可以用一个线程，处理多个的客户端连接，就会使用到 Selector(选择器)Selector 能够检测多个注册的通道上是否有事件发生(注意:多个 Channel 以事件的方式可以注册到同一个<br>Selector)，如果有事件发生，便获取事件然后针对每个事件进行相应的处理。这样就可以只用一个单线程去管理多个通道，也就是管理多个连接和请求。只有在 连接&#x2F;通道 真正有读写事件发生时，才会进行读写，就大大地减少<br>了系统开销，并且不必为每个连接都创建一个线程，不用去维护多个线程避免了多线程之间的上下文切换导致的开销。</p>
<p><strong>选择器的应用</strong></p>
<p>创建 Selector ：通过调用 Selector.open() 方法创建一个 Selector。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Selector</span> <span class="variable">selector</span> <span class="operator">=</span> Selector.open();</span><br><span class="line"><span class="comment">//向选择器注册通道</span></span><br><span class="line">SelectableChannel.register(Selector sel, <span class="type">int</span> ops)</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1. 获取通道</span></span><br><span class="line"><span class="type">ServerSocketChannel</span> <span class="variable">ssChannel</span> <span class="operator">=</span> ServerSocketChannel.open();</span><br><span class="line"><span class="comment">//2. 切换非阻塞模式</span></span><br><span class="line">ssChannel.configureBlocking(<span class="literal">false</span>);</span><br><span class="line"><span class="comment">//3. 绑定连接</span></span><br><span class="line">ssChannel.bind(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="number">9898</span>));</span><br><span class="line"><span class="comment">//4. 获取选择器</span></span><br><span class="line"><span class="type">Selector</span> <span class="variable">selector</span> <span class="operator">=</span> Selector.open();</span><br><span class="line"><span class="comment">//5. 将通道注册到选择器上, 并且指定“监听接收事件”</span></span><br><span class="line">ssChannel.register(selector, SelectionKey.OP_ACCEPT);</span><br></pre></td></tr></table></figure>

<p>当调用 register(Selector sel, int ops) 将通道注册选择器时，选择器对通道的监听事件，需要通过第二个参<br>数 ops 指定。可以监听的事件类型（用 可使用 SelectionKey  的四个常量 表示）：</p>
<p>读 : SelectionKey.OP_READ （1）<br>写 : SelectionKey.OP_WRITE （4）<br>连接 : SelectionKey.OP_CONNECT （8）<br>接收 : SelectionKey.OP_ACCEPT （16）<br>若注册时不止监听一个事件，则可以使用“位或”操作符连接。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">interestSet</span> <span class="operator">=</span> SelectionKey.OP_READ|SelectionKey.OP_WRITE ;</span><br></pre></td></tr></table></figure>

<h5 id="NIO非阻塞式通络通信原理分析"><a href="#NIO非阻塞式通络通信原理分析" class="headerlink" title="NIO非阻塞式通络通信原理分析"></a>NIO非阻塞式通络通信原理分析</h5><p><strong>Selector 示意图和特点说明</strong></p>
<p>Selector可以实现： 一个 I&#x2F;O 线程可以并发处理 N 个客户端连接和读写操作，这从根本上解决了传统同步阻塞 I&#x2F;O 一连接一线程模型，架构的性能、弹性伸缩能力和可靠性都得到了极大的提升。</p>
<p><img src="/../images/g.png" alt="g"></p>
<p><strong>服务端流程</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> 当客户端连接服务端时，服务端会通过 </span><br><span class="line">ServerSocketChannel 得到 SocketChannel：<span class="number">1</span> 获取通道</span><br><span class="line"><span class="type">ServerSocketChannel</span> <span class="variable">ssChannel</span> <span class="operator">=</span> ServerSocketChannel.open();</span><br><span class="line"></span><br><span class="line"><span class="number">2</span> 切换非阻塞模式 </span><br><span class="line">ssChannel.configureBlocking(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line"><span class="number">3</span> 绑定连接</span><br><span class="line">  ssChannel.bind(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="number">9999</span>));</span><br><span class="line">  </span><br><span class="line"><span class="number">4</span> 获取选择器</span><br><span class="line"><span class="type">Selector</span> <span class="variable">selector</span> <span class="operator">=</span> Selector.open();</span><br><span class="line"></span><br><span class="line"><span class="number">5</span> 将通道注册到选择器上, 并且指定“监听接收事件”</span><br><span class="line">  ssChannel.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line"></span><br><span class="line"><span class="number">6</span>  轮询式的获取选择器上已经“准备就绪”的事件</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//轮询式的获取选择器上已经“准备就绪”的事件</span></span><br><span class="line"> <span class="keyword">while</span> (selector.select() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;轮一轮&quot;</span>);</span><br><span class="line">        <span class="comment">//7. 获取当前选择器中所有注册的“选择键(已就绪的监听事件)”</span></span><br><span class="line">        Iterator&lt;SelectionKey&gt; it = selector.selectedKeys().iterator();</span><br><span class="line">        <span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">            <span class="comment">//8. 获取准备“就绪”的是事件</span></span><br><span class="line">            <span class="type">SelectionKey</span> <span class="variable">sk</span> <span class="operator">=</span> it.next();</span><br><span class="line">            <span class="comment">//9. 判断具体是什么事件准备就绪</span></span><br><span class="line">            <span class="keyword">if</span> (sk.isAcceptable()) &#123;</span><br><span class="line">                <span class="comment">//10. 若“接收就绪”，获取客户端连接</span></span><br><span class="line">                <span class="type">SocketChannel</span> <span class="variable">sChannel</span> <span class="operator">=</span> ssChannel.accept();</span><br><span class="line">                <span class="comment">//11. 切换非阻塞模式</span></span><br><span class="line">                sChannel.configureBlocking(<span class="literal">false</span>);</span><br><span class="line">                <span class="comment">//12. 将该通道注册到选择器上</span></span><br><span class="line">                sChannel.register(selector, SelectionKey.OP_READ);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sk.isReadable()) &#123;</span><br><span class="line">                <span class="comment">//13. 获取当前选择器上“读就绪”状态的通道</span></span><br><span class="line">                <span class="type">SocketChannel</span> <span class="variable">sChannel</span> <span class="operator">=</span> (SocketChannel) sk.channel();</span><br><span class="line">                <span class="comment">//14. 读取数据</span></span><br><span class="line">                <span class="type">ByteBuffer</span> <span class="variable">buf</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">                <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">while</span> ((len = sChannel.read(buf)) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    buf.flip();</span><br><span class="line">                    System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(buf.array(), <span class="number">0</span>, len));</span><br><span class="line">                    buf.clear();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//15. 取消选择键 SelectionKey</span></span><br><span class="line">            it.remove();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>客户端流程</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> 获取通道</span><br><span class="line"><span class="type">SocketChannel</span> <span class="variable">sChannel</span> <span class="operator">=</span> SocketChannel.open(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">9999</span>));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="number">2</span> 切换非阻塞模式</span><br><span class="line">sChannel.configureBlocking(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line"><span class="number">3</span> 分配指定大小的缓冲区</span><br><span class="line"></span><br><span class="line"><span class="type">ByteBuffer</span> <span class="variable">buf</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line"></span><br><span class="line"><span class="number">4</span> 发送数据给服务端</span><br><span class="line"></span><br><span class="line">  	<span class="type">Scanner</span> <span class="variable">scan</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">  	<span class="keyword">while</span>(scan.hasNext())&#123;</span><br><span class="line">  		<span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> scan.nextLine();</span><br><span class="line">  		buf.put((<span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy/MM/dd HH:mm:ss&quot;</span>).format(System.currentTimeMillis())</span><br><span class="line">  				+ <span class="string">&quot;\n&quot;</span> + str).getBytes());</span><br><span class="line">  		buf.flip();</span><br><span class="line">  		sChannel.write(buf);</span><br><span class="line">  		buf.clear();</span><br><span class="line">  	&#125;</span><br><span class="line">  	<span class="comment">//关闭通道</span></span><br><span class="line">  	sChannel.close();</span><br></pre></td></tr></table></figure>

<h5 id="NIO非阻塞式网络通信入门案例"><a href="#NIO非阻塞式网络通信入门案例" class="headerlink" title="NIO非阻塞式网络通信入门案例"></a>NIO非阻塞式网络通信入门案例</h5><p>需求：服务端接收客户端的连接请求，并接收多个客户端发送过来的事件。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  客户端</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">		<span class="comment">//1. 获取通道</span></span><br><span class="line">		<span class="type">SocketChannel</span> <span class="variable">sChannel</span> <span class="operator">=</span> SocketChannel.open(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">9999</span>));</span><br><span class="line">		<span class="comment">//2. 切换非阻塞模式</span></span><br><span class="line">		sChannel.configureBlocking(<span class="literal">false</span>);</span><br><span class="line">		<span class="comment">//3. 分配指定大小的缓冲区</span></span><br><span class="line">		<span class="type">ByteBuffer</span> <span class="variable">buf</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">		<span class="comment">//4. 发送数据给服务端</span></span><br><span class="line">		<span class="type">Scanner</span> <span class="variable">scan</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">		<span class="keyword">while</span>(scan.hasNext())&#123;</span><br><span class="line">			<span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> scan.nextLine();</span><br><span class="line">			buf.put((<span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy/MM/dd HH:mm:ss&quot;</span>).format(System.currentTimeMillis())</span><br><span class="line">					+ <span class="string">&quot;\n&quot;</span> + str).getBytes());</span><br><span class="line">			buf.flip();</span><br><span class="line">			sChannel.write(buf);</span><br><span class="line">			buf.clear();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//5. 关闭通道</span></span><br><span class="line">		sChannel.close();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 服务端</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Server</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">//1. 获取通道</span></span><br><span class="line">        <span class="type">ServerSocketChannel</span> <span class="variable">ssChannel</span> <span class="operator">=</span> ServerSocketChannel.open();</span><br><span class="line">        <span class="comment">//2. 切换非阻塞模式</span></span><br><span class="line">        ssChannel.configureBlocking(<span class="literal">false</span>);</span><br><span class="line">        <span class="comment">//3. 绑定连接</span></span><br><span class="line">        ssChannel.bind(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="number">9999</span>));</span><br><span class="line">        <span class="comment">//4. 获取选择器</span></span><br><span class="line">        <span class="type">Selector</span> <span class="variable">selector</span> <span class="operator">=</span> Selector.open();</span><br><span class="line">        <span class="comment">//5. 将通道注册到选择器上, 并且指定“监听接收事件”</span></span><br><span class="line">        ssChannel.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line">        <span class="comment">//6. 轮询式的获取选择器上已经“准备就绪”的事件</span></span><br><span class="line">        <span class="keyword">while</span> (selector.select() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;轮一轮&quot;</span>);</span><br><span class="line">            <span class="comment">//7. 获取当前选择器中所有注册的“选择键(已就绪的监听事件)”</span></span><br><span class="line">            Iterator&lt;SelectionKey&gt; it = selector.selectedKeys().iterator();</span><br><span class="line">            <span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">                <span class="comment">//8. 获取准备“就绪”的是事件</span></span><br><span class="line">                <span class="type">SelectionKey</span> <span class="variable">sk</span> <span class="operator">=</span> it.next();</span><br><span class="line">                <span class="comment">//9. 判断具体是什么事件准备就绪</span></span><br><span class="line">                <span class="keyword">if</span> (sk.isAcceptable()) &#123;</span><br><span class="line">                    <span class="comment">//10. 若“接收就绪”，获取客户端连接</span></span><br><span class="line">                    <span class="type">SocketChannel</span> <span class="variable">sChannel</span> <span class="operator">=</span> ssChannel.accept();</span><br><span class="line">                    <span class="comment">//11. 切换非阻塞模式</span></span><br><span class="line">                    sChannel.configureBlocking(<span class="literal">false</span>);</span><br><span class="line">                    <span class="comment">//12. 将该通道注册到选择器上</span></span><br><span class="line">                    sChannel.register(selector, SelectionKey.OP_READ);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sk.isReadable()) &#123;</span><br><span class="line">                    <span class="comment">//13. 获取当前选择器上“读就绪”状态的通道</span></span><br><span class="line">                    <span class="type">SocketChannel</span> <span class="variable">sChannel</span> <span class="operator">=</span> (SocketChannel) sk.channel();</span><br><span class="line">                    <span class="comment">//14. 读取数据</span></span><br><span class="line">                    <span class="type">ByteBuffer</span> <span class="variable">buf</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">                    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">while</span> ((len = sChannel.read(buf)) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                        buf.flip();</span><br><span class="line">                        System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(buf.array(), <span class="number">0</span>, len));</span><br><span class="line">                        buf.clear();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//15. 取消选择键 SelectionKey</span></span><br><span class="line">                it.remove();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="NIO网络编程应用实例-群聊系统"><a href="#NIO网络编程应用实例-群聊系统" class="headerlink" title="NIO网络编程应用实例-群聊系统"></a>NIO网络编程应用实例-群聊系统</h5><p>需求:进一步理解 NIO 非阻塞网络编程机制，实现多人群聊</p>
<p>编写一个 NIO 群聊系统，实现客户端与客户端的通信需求（非阻塞）</p>
<p>服务器端：可以监测用户上线，离线，并实现消息转发功能<br>客户端：通过 channel 可以无阻塞发送消息给其它所有客户端用户，同时可以接受其它客户端用户通过服务端转发来的消息。</p>
<p><strong>服务端代码实现</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Server</span> &#123;</span><br><span class="line">    <span class="comment">//定义属性</span></span><br><span class="line">    <span class="keyword">private</span> Selector selector;</span><br><span class="line">    <span class="keyword">private</span> ServerSocketChannel ssChannel;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">PORT</span> <span class="operator">=</span> <span class="number">9999</span>;</span><br><span class="line">    <span class="comment">//构造器</span></span><br><span class="line">    <span class="comment">//初始化工作</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Server</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 1、获取通道</span></span><br><span class="line">            ssChannel = ServerSocketChannel.open();</span><br><span class="line">            <span class="comment">// 2、切换为非阻塞模式</span></span><br><span class="line">            ssChannel.configureBlocking(<span class="literal">false</span>);</span><br><span class="line">            <span class="comment">// 3、绑定连接的端口</span></span><br><span class="line">            ssChannel.bind(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(PORT));</span><br><span class="line">            <span class="comment">// 4、获取选择器Selector</span></span><br><span class="line">            selector = Selector.open();</span><br><span class="line">            <span class="comment">// 5、将通道都注册到选择器上去，并且开始指定监听接收事件</span></span><br><span class="line">            ssChannel.register(selector , SelectionKey.OP_ACCEPT);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//监听</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listen</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;监听线程: &quot;</span> + Thread.currentThread().getName());</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (selector.select() &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;开始一轮事件处理~~~&quot;</span>);</span><br><span class="line">                <span class="comment">// 7、获取选择器中的所有注册的通道中已经就绪好的事件</span></span><br><span class="line">                Iterator&lt;SelectionKey&gt; it = selector.selectedKeys().iterator();</span><br><span class="line">                <span class="comment">// 8、开始遍历这些准备好的事件</span></span><br><span class="line">                <span class="keyword">while</span> (it.hasNext())&#123;</span><br><span class="line">                    <span class="comment">// 提取当前这个事件</span></span><br><span class="line">                    <span class="type">SelectionKey</span> <span class="variable">sk</span> <span class="operator">=</span> it.next();</span><br><span class="line">                    <span class="comment">// 9、判断这个事件具体是什么</span></span><br><span class="line">                    <span class="keyword">if</span>(sk.isAcceptable())&#123;</span><br><span class="line">                        <span class="comment">// 10、直接获取当前接入的客户端通道</span></span><br><span class="line">                        <span class="type">SocketChannel</span> <span class="variable">schannel</span> <span class="operator">=</span> ssChannel.accept();</span><br><span class="line">                        <span class="comment">// 11 、切换成非阻塞模式</span></span><br><span class="line">                        schannel.configureBlocking(<span class="literal">false</span>);</span><br><span class="line">                        <span class="comment">// 12、将本客户端通道注册到选择器</span></span><br><span class="line">                        System.out.println(schannel.getRemoteAddress() + <span class="string">&quot; 上线 &quot;</span>);</span><br><span class="line">                        schannel.register(selector , SelectionKey.OP_READ);</span><br><span class="line">                        <span class="comment">//提示</span></span><br><span class="line">                    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(sk.isReadable())&#123;</span><br><span class="line">                        <span class="comment">//处理读 (专门写方法..)</span></span><br><span class="line">                        readData(sk);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    it.remove(); <span class="comment">// 处理完毕之后需要移除当前事件</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//发生异常处理....</span></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//读取客户端消息</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">readData</span><span class="params">(SelectionKey key)</span> &#123;</span><br><span class="line">        <span class="comment">//取到关联的channle</span></span><br><span class="line">        <span class="type">SocketChannel</span> <span class="variable">channel</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="comment">//得到channel</span></span><br><span class="line">            channel = (SocketChannel) key.channel();</span><br><span class="line">            <span class="comment">//创建buffer</span></span><br><span class="line">            <span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">            <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> channel.read(buffer);</span><br><span class="line">            <span class="comment">//根据count的值做处理</span></span><br><span class="line">            <span class="keyword">if</span>(count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">//把缓存区的数据转成字符串</span></span><br><span class="line">                <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(buffer.array());</span><br><span class="line">                <span class="comment">//输出该消息</span></span><br><span class="line">                System.out.println(<span class="string">&quot;form 客户端: &quot;</span> + msg);</span><br><span class="line">                <span class="comment">//向其它的客户端转发消息(去掉自己), 专门写一个方法来处理</span></span><br><span class="line">                sendInfoToOtherClients(msg, channel);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(channel.getRemoteAddress() + <span class="string">&quot; 离线了..&quot;</span>);</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">                <span class="comment">//取消注册</span></span><br><span class="line">                key.cancel();</span><br><span class="line">                <span class="comment">//关闭通道</span></span><br><span class="line">                channel.close();</span><br><span class="line">            &#125;<span class="keyword">catch</span> (IOException e2) &#123;</span><br><span class="line">                e2.printStackTrace();;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//转发消息给其它客户(通道)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">sendInfoToOtherClients</span><span class="params">(String msg, SocketChannel self )</span> <span class="keyword">throws</span>  IOException&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;服务器转发消息中...&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;服务器转发数据给客户端线程: &quot;</span> + Thread.currentThread().getName());</span><br><span class="line">        <span class="comment">//遍历 所有注册到selector 上的 SocketChannel,并排除 self</span></span><br><span class="line">        <span class="keyword">for</span>(SelectionKey key: selector.keys()) &#123;</span><br><span class="line">            <span class="comment">//通过 key  取出对应的 SocketChannel</span></span><br><span class="line">            <span class="type">Channel</span> <span class="variable">targetChannel</span> <span class="operator">=</span> key.channel();</span><br><span class="line">            <span class="comment">//排除自己</span></span><br><span class="line">            <span class="keyword">if</span>(targetChannel <span class="keyword">instanceof</span>  SocketChannel &amp;&amp; targetChannel != self) &#123;</span><br><span class="line">                <span class="comment">//转型</span></span><br><span class="line">                <span class="type">SocketChannel</span> <span class="variable">dest</span> <span class="operator">=</span> (SocketChannel)targetChannel;</span><br><span class="line">                <span class="comment">//将msg 存储到buffer</span></span><br><span class="line">                <span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBuffer.wrap(msg.getBytes());</span><br><span class="line">                <span class="comment">//将buffer 的数据写入 通道</span></span><br><span class="line">                dest.write(buffer);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//创建服务器对象</span></span><br><span class="line">        <span class="type">Server</span> <span class="variable">groupChatServer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Server</span>();</span><br><span class="line">        groupChatServer.listen();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>客户端代码实现</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="comment">//定义相关的属性</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">HOST</span> <span class="operator">=</span> <span class="string">&quot;127.0.0.1&quot;</span>; <span class="comment">// 服务器的ip</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">PORT</span> <span class="operator">=</span> <span class="number">9999</span>; <span class="comment">//服务器端口</span></span><br><span class="line">    <span class="keyword">private</span> Selector selector;</span><br><span class="line">    <span class="keyword">private</span> SocketChannel socketChannel;</span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造器, 完成初始化工作</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Client</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line"></span><br><span class="line">        selector = Selector.open();</span><br><span class="line">        <span class="comment">//连接服务器</span></span><br><span class="line">        socketChannel = socketChannel.open(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="string">&quot;127.0.0.1&quot;</span>, PORT));</span><br><span class="line">        <span class="comment">//设置非阻塞</span></span><br><span class="line">        socketChannel.configureBlocking(<span class="literal">false</span>);</span><br><span class="line">        <span class="comment">//将channel 注册到selector</span></span><br><span class="line">        socketChannel.register(selector, SelectionKey.OP_READ);</span><br><span class="line">        <span class="comment">//得到username</span></span><br><span class="line">        username = socketChannel.getLocalAddress().toString().substring(<span class="number">1</span>);</span><br><span class="line">        System.out.println(username + <span class="string">&quot; is ok...&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//向服务器发送消息</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendInfo</span><span class="params">(String info)</span> &#123;</span><br><span class="line">        info = username + <span class="string">&quot; 说：&quot;</span> + info;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            socketChannel.write(ByteBuffer.wrap(info.getBytes()));</span><br><span class="line">        &#125;<span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//读取从服务器端回复的消息</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">readInfo</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">            <span class="type">int</span> <span class="variable">readChannels</span> <span class="operator">=</span> selector.select();</span><br><span class="line">            <span class="keyword">if</span>(readChannels &gt; <span class="number">0</span>) &#123;<span class="comment">//有可以用的通道</span></span><br><span class="line"></span><br><span class="line">                Iterator&lt;SelectionKey&gt; iterator = selector.selectedKeys().iterator();</span><br><span class="line">                <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line"></span><br><span class="line">                    <span class="type">SelectionKey</span> <span class="variable">key</span> <span class="operator">=</span> iterator.next();</span><br><span class="line">                    <span class="keyword">if</span>(key.isReadable()) &#123;</span><br><span class="line">                        <span class="comment">//得到相关的通道</span></span><br><span class="line">                       <span class="type">SocketChannel</span> <span class="variable">sc</span> <span class="operator">=</span> (SocketChannel) key.channel();</span><br><span class="line">                       <span class="comment">//得到一个Buffer</span></span><br><span class="line">                        <span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">                        <span class="comment">//读取</span></span><br><span class="line">                        sc.read(buffer);</span><br><span class="line">                        <span class="comment">//把读到的缓冲区的数据转成字符串</span></span><br><span class="line">                        <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(buffer.array());</span><br><span class="line">                        System.out.println(msg.trim());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                iterator.remove(); <span class="comment">//删除当前的selectionKey, 防止重复操作</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//System.out.println(&quot;没有可以用的通道...&quot;);</span></span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//启动我们客户端</span></span><br><span class="line">        <span class="type">Client</span> <span class="variable">chatClient</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Client</span>();</span><br><span class="line">        <span class="comment">//启动一个线程, 每个3秒，读取从服务器发送数据</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>() &#123;</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                    chatClient.readInfo();</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.currentThread().sleep(<span class="number">3000</span>);</span><br><span class="line">                    &#125;<span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//发送数据给服务器端</span></span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (scanner.hasNextLine()) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> scanner.nextLine();</span><br><span class="line">            chatClient.sendInfo(s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="JAVA-AIO深入剖析"><a href="#JAVA-AIO深入剖析" class="headerlink" title="JAVA AIO深入剖析"></a>JAVA AIO深入剖析</h4><h5 id="AIO编程"><a href="#AIO编程" class="headerlink" title="AIO编程"></a>AIO编程</h5><p>Java AIO(NIO.2) ： 异步非阻塞，服务器实现模式为一个有效请求一个线程，客户端的I&#x2F;O请求都是由OS先完成了再通知服务器应用去启动线程进行处理。</p>
<p>AIO<br>异步非阻塞，基于NIO的，可以称之为NIO2.0</p>
<table>
<thead>
<tr>
<th align="center">BIO</th>
<th align="center">NIO</th>
<th align="center">AIO</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Socket</td>
<td align="center">SocketChannel</td>
<td align="center">AsynchronousSocketChannel</td>
</tr>
<tr>
<td align="center">ServerSocket</td>
<td align="center">ServerSocketChannel</td>
<td align="center">AsynchronousServerSocketChannel</td>
</tr>
</tbody></table>
<p>与NIO不同，当进行读写操作时，只须直接调用API的read或write方法即可, 这两种方法均为异步的，对于<br>读操作而言，当有流可读取时，操作系统会将可读的流传入read方法的缓冲区,对于写操作而言，当操作系统将write方法传递的流写入完毕时，操作系统主动通知应用程序。</p>
<p>即可以理解为，read&#x2F;write方法都是异步的，完成后会主动调用回调函数。在JDK1.7中，这部分内容被称作NIO.2，主要在Java.nio.channels包下增加了下面四个异步通道：</p>
<ul>
<li>AsynchronousSocketChannel</li>
<li>AsynchronousServerSocketChannel</li>
<li>AsynchronousFileChannel</li>
<li>AsynchronousDatagramChannel</li>
</ul>
<h4 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h4><p>BIO、NIO、AIO：</p>
<ul>
<li>Java BIO ： 同步并阻塞，服务器实现模式为一个连接一个线程，即客户端有连接请求时服务器端就需要启动一个线程进行处理，如果这个连接不做任何事情会造成不必要的线程开销，当然可以通过线程池机制改善。</li>
<li>Java NIO ： 同步非阻塞，服务器实现模式为一个请求一个线程，即客户端发送的连接请求都会注册到多路复用器上，多路复用器轮询到连接有I&#x2F;O请求时才启动一个线程进行处理。</li>
<li>Java AIO(NIO.2) ： 异步非阻塞，服务器实现模式为一个有效请求一个线程，客户端的I&#x2F;O请求都是由OS先完成了再通知服务器应用去启动线程进行处理。</li>
</ul>
<p>BIO、NIO、AIO适用场景分析:</p>
<p>BIO方式适用于连接数目比较小且固定的架构，这种方式对服务器资源要求比较高，并发局限于应用中，JDK1.4以前的唯一选择，但程序直观简单易理解。NIO方式适用于连接数目多且连接比较短（轻操作）的架构，比如聊天服务器，并发局限于应用中，编程比较复杂，JDK1.4开始支持。AIO方式使用于连接数目多且连接比较长（重操作）的架构，比如相册服务器，充分调用OS参与并发操作，编程比较复杂，JDK7开始支持。Netty!</p>
]]></content>
      <categories>
        <category>集合</category>
      </categories>
  </entry>
  <entry>
    <title>java基础知识-反射机制详解 - java</title>
    <url>/2022/05/26/2022-05-26-java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86-%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<h1 id="反射机制详解"><a href="#反射机制详解" class="headerlink" title="反射机制详解"></a>反射机制详解</h1><span id="more"></span>

<h3 id="反射基础"><a href="#反射基础" class="headerlink" title="反射基础"></a>反射基础</h3><p>RTIT（Run-Time Type Identification）运行时类型识别。在《Thinking in Java》一书第十四章中有提到，其作用是在运行时识别一个对象的类型和类的信息。主要有两种方式：一种是“传统的”RTTI，它假定我们在编译时已经知道了所有的类型；另一种是“反射”机制，它允许我们在运行时发现和使用类的信息。</p>
<p>反射就是把java类中的各种成分映射成一个个的Java对象。</p>
<p>例如：一个类有：成员变量、方法、构造方法、包等等信息，利用反射技术可以对一个类进行解剖，把个个组成部分映射成一个个对象。</p>
<p>这里我们首先需要理解 Class类，以及类的加载机制； 然后基于此我们如何通过反射获取Class类以及类中的成员变量、方法、构造方法等。</p>
<h4 id="Class类"><a href="#Class类" class="headerlink" title="Class类"></a>Class类</h4><p>Class类，Class类也是一个实实在在的类，存在于JDK的java.lang包中。Class类的实例表示java应用运行时的类(class ans enum)或接口(interface and annotation)（每个java类运行时都在JVM里表现为一个class对象，可通过类名.class、类型.getClass()、Class.forName(“类名”)等方法获取class对象）。数组同样也被映射为class 对象的一个类，所有具有相同元素类型和维数的数组都共享该 Class 对象。基本类型boolean，byte，char，short，int，long，float，double和关键字void同样表现为 class  对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Class</span>&lt;T&gt; <span class="keyword">implements</span> <span class="title class_">java</span>.io.Serializable,</span><br><span class="line">                              GenericDeclaration,</span><br><span class="line">                              Type,</span><br><span class="line">                              AnnotatedElement &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> ANNOTATION= <span class="number">0x00002000</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">ENUM</span>      <span class="operator">=</span> <span class="number">0x00004000</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">SYNTHETIC</span> <span class="operator">=</span> <span class="number">0x00001000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">registerNatives</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        registerNatives();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Private constructor. Only the Java Virtual Machine creates Class objects.   //私有构造器，只有JVM才能调用创建Class对象</span></span><br><span class="line"><span class="comment">     * This constructor is not used and prevents the default constructor being</span></span><br><span class="line"><span class="comment">     * generated.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Class</span><span class="params">(ClassLoader loader)</span> &#123;</span><br><span class="line">        <span class="comment">// Initialize final field for classLoader.  The initialization value of non-null</span></span><br><span class="line">        <span class="comment">// prevents future JIT optimizations from assuming this final field is null.</span></span><br><span class="line">        classLoader = loader;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>到这我们也就可以得出以下几点信息：</p>
<ul>
<li>Class类也是类的一种，与class关键字是不一样的。</li>
<li>手动编写的类被编译后会产生一个Class对象，其表示的是创建的类的类型信息，而且这个Class对象保存在同名.class的文件中(字节码文件)</li>
<li>每个通过关键字class标识的类，在内存中有且只有一个与之对应的Class对象来描述其类型信息，无论创建多少个实例对象，其依据的都是用一个Class对象。</li>
<li>Class类只存私有构造函数，因此对应Class对象只能有JVM创建和加载</li>
<li>Class类的对象作用是运行时提供或获得某个对象的类型信息，这点对于反射技术很重要(关于反射稍后分析)。</li>
</ul>
<h4 id="类加载"><a href="#类加载" class="headerlink" title="类加载"></a>类加载</h4><p>其中，这里我们需要回顾的是：</p>
<ol>
<li>类加载机制流程</li>
</ol>
<p><img src="/../images/note39.png" alt="note39"></p>
<p>2.类的加载</p>
<p><img src="/../images/note40.png" alt="note40"></p>
<h3 id="反射的使用"><a href="#反射的使用" class="headerlink" title="反射的使用"></a>反射的使用</h3><p>在Java中，Class类与java.lang.reflect类库一起对反射技术进行了全力的支持。在反射包中，我们常用的类主要有Constructor类表示的是Class 对象所表示的类的构造方法，利用它可以在运行时动态创建对象、Field表示Class对象所表示的类的成员变量，通过它可以在运行时动态修改成员变量的属性值(包含private)、Method表示Class对象所表示的类的成员方法，通过它可以动态调用对象的方法(包含private)，下面将对这几个重要类进行分别说明。</p>
<h4 id="Class类对象的获取"><a href="#Class类对象的获取" class="headerlink" title="Class类对象的获取"></a>Class类对象的获取</h4><p>在类加载的时候，jvm会创建一个class对象</p>
<p>class对象是可以说是反射中最常用的，获取class对象的方式的主要有三种:</p>
<ul>
<li>根据类名：类名.class</li>
<li>根据对象：对象.getClass()</li>
<li>根据全限定类名：Class.forName(全限定类名)</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">classTest</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="comment">// 获取Class对象的三种方式</span></span><br><span class="line">    logger.info(<span class="string">&quot;根据类名:  \t&quot;</span> + User.class);</span><br><span class="line">    logger.info(<span class="string">&quot;根据对象:  \t&quot;</span> + <span class="keyword">new</span> <span class="title class_">User</span>().getClass());</span><br><span class="line">    logger.info(<span class="string">&quot;根据全限定类名:\t&quot;</span> + Class.forName(<span class="string">&quot;com.test.User&quot;</span>));</span><br><span class="line">    <span class="comment">// 常用的方法</span></span><br><span class="line">    logger.info(<span class="string">&quot;获取全限定类名:\t&quot;</span> + userClass.getName());</span><br><span class="line">    logger.info(<span class="string">&quot;获取类名:\t&quot;</span> + userClass.getSimpleName());</span><br><span class="line">    logger.info(<span class="string">&quot;实例化:\t&quot;</span> + userClass.newInstance());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">package</span> com.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;init&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">User</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">User</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>();</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;User [name=&quot;</span> + name + <span class="string">&quot;, age=&quot;</span> + age + <span class="string">&quot;]&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">根据类名:  	<span class="keyword">class</span> <span class="title class_">com</span>.test.User</span><br><span class="line">根据对象:  	<span class="keyword">class</span> <span class="title class_">com</span>.test.User</span><br><span class="line">根据全限定类名:	<span class="keyword">class</span> <span class="title class_">com</span>.test.User</span><br><span class="line">获取全限定类名:	com.test.User</span><br><span class="line">获取类名:	User</span><br><span class="line">实例化:	User [name=init, age=<span class="number">0</span>]</span><br></pre></td></tr></table></figure>

<ul>
<li>再来看看 <strong>Class类的方法</strong></li>
</ul>
<table>
<thead>
<tr>
<th align="center">方法名</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">forName()</td>
<td align="center">(1)获取Class对象的一个引用，但引用的类还没有加载(该类的第一个对象没有生成)就加载了这个类。(2)为了产生Class引用，forName()立即就进行了初始化。</td>
</tr>
<tr>
<td align="center">Object-getClass()</td>
<td align="center">获取Class对象的一个引用，返回表示该对象的实际类型的Class引用。</td>
</tr>
<tr>
<td align="center">getName()</td>
<td align="center">取全限定的类名(包括包名)，即类的完整名字。</td>
</tr>
<tr>
<td align="center">getSimpleName()</td>
<td align="center">获取全限定的类名(包括包名)</td>
</tr>
<tr>
<td align="center">isInterface()</td>
<td align="center">判断Class对象是否是表示一个接口</td>
</tr>
<tr>
<td align="center">getInterfaces()</td>
<td align="center">返回Class对象数组，表示Class对象所引用的类所实现的所有接口。</td>
</tr>
<tr>
<td align="center">getSupercalss()</td>
<td align="center">返回Class对象，表示Class对象所引用的类所继承的直接基类。应用该方法可在运行时发现一个对象完整的继承结构。</td>
</tr>
<tr>
<td align="center">newInstance()</td>
<td align="center">返回一个Oject对象，是实现“虚拟构造器”的一种途径。使用该方法创建的类，必须带有无参的构造器。</td>
</tr>
<tr>
<td align="center">getFields()</td>
<td align="center">获得某个类的所有的公共（public）的字段，包括继承自父类的所有公共字段。 类似的还有getMethods和getConstructors。</td>
</tr>
<tr>
<td align="center">getDeclaredFields</td>
<td align="center">获得某个类的自己声明的字段，即包括public、private和proteced，默认但是不包括父类声明的任何字段。类似的还有getDeclaredMethods和getDeclaredConstructors。</td>
</tr>
</tbody></table>
<p>简单测试下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.cry;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">I1</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">I2</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cell</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> mCellPublic;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> <span class="keyword">extends</span>  <span class="title class_">Cell</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> mAnimalPrivate;</span><br><span class="line">    <span class="keyword">protected</span> <span class="type">int</span> mAnimalProtected;</span><br><span class="line">    <span class="type">int</span> mAnimalDefault;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> mAnimalPublic;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> sAnimalPrivate;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">static</span> <span class="type">int</span> sAnimalProtected;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> sAnimalDefault;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> sAnimalPublic;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> <span class="keyword">implements</span> <span class="title class_">I1</span>, I2 &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> mDogPrivate;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> mDogPublic;</span><br><span class="line">    <span class="keyword">protected</span> <span class="type">int</span> mDogProtected;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> mDogDefault;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> sDogPrivate;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">static</span> <span class="type">int</span> sDogProtected;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> sDogDefault;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> sDogPublic;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IllegalAccessException, InstantiationException &#123;</span><br><span class="line">        Class&lt;Dog&gt; dog = Dog.class;</span><br><span class="line">        <span class="comment">//类名打印</span></span><br><span class="line">        System.out.println(dog.getName()); <span class="comment">//com.cry.Dog</span></span><br><span class="line">        System.out.println(dog.getSimpleName()); <span class="comment">//Dog</span></span><br><span class="line">        System.out.println(dog.getCanonicalName());<span class="comment">//com.cry.Dog</span></span><br><span class="line">        <span class="comment">//接口</span></span><br><span class="line">        System.out.println(dog.isInterface()); <span class="comment">//false</span></span><br><span class="line">        <span class="keyword">for</span> (Class iI : dog.getInterfaces()) &#123;</span><br><span class="line">            System.out.println(iI);</span><br><span class="line">        &#125;</span><br><span class="line">         <span class="comment">/*</span></span><br><span class="line"><span class="comment">          interface com.cry.I1</span></span><br><span class="line"><span class="comment">          interface com.cry.I2</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//父类</span></span><br><span class="line">        System.out.println(dog.getSuperclass());<span class="comment">//class com.cry.Animal</span></span><br><span class="line">        <span class="comment">//创建对象</span></span><br><span class="line">        <span class="type">Dog</span> <span class="variable">d</span> <span class="operator">=</span> dog.newInstance();</span><br><span class="line">        <span class="comment">//字段</span></span><br><span class="line">        <span class="keyword">for</span> (Field f : dog.getFields()) &#123;</span><br><span class="line">            System.out.println(f.getName());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            mDogPublic</span></span><br><span class="line"><span class="comment">            sDogPublic</span></span><br><span class="line"><span class="comment">            mAnimalPublic</span></span><br><span class="line"><span class="comment">            sAnimalPublic</span></span><br><span class="line"><span class="comment">            mCellPublic  //父类的父类的公共字段也打印出来了</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        System.out.println(<span class="string">&quot;---------&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (Field f : dog.getDeclaredFields()) &#123;</span><br><span class="line">            System.out.println(f.getName());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/** 只有自己类声明的字段</span></span><br><span class="line"><span class="comment">         mDogPrivate</span></span><br><span class="line"><span class="comment">         mDogPublic</span></span><br><span class="line"><span class="comment">         mDogProtected</span></span><br><span class="line"><span class="comment">         mDogDefault</span></span><br><span class="line"><span class="comment">         sDogPrivate</span></span><br><span class="line"><span class="comment">         sDogProtected</span></span><br><span class="line"><span class="comment">         sDogDefault</span></span><br><span class="line"><span class="comment">         sDogPublic</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>getName、getCanonicalName与getSimpleName的区别</strong>：</p>
<ul>
<li>getSimpleName：只获取类名</li>
<li>getName：类的全限定名，jvm中Class的表示，可以用于动态加载Class对象，例如Class.forName。</li>
<li>getCanonicalName：返回更容易理解的表示，主要用于输出（toString）或log打印，大多数情况下和getName一样，但是在内部类、数组等类型的表示形式就不同了。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.cry;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">private</span>  <span class="keyword">class</span> <span class="title class_">inner</span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        <span class="comment">//普通类</span></span><br><span class="line">        System.out.println(Test.class.getSimpleName()); <span class="comment">//Test</span></span><br><span class="line">        System.out.println(Test.class.getName()); <span class="comment">//com.cry.Test</span></span><br><span class="line">        System.out.println(Test.class.getCanonicalName()); <span class="comment">//com.cry.Test</span></span><br><span class="line">        <span class="comment">//内部类</span></span><br><span class="line">        System.out.println(inner.class.getSimpleName()); <span class="comment">//inner</span></span><br><span class="line">        System.out.println(inner.class.getName()); <span class="comment">//com.cry.Test$inner</span></span><br><span class="line">        System.out.println(inner.class.getCanonicalName()); <span class="comment">//com.cry.Test.inner</span></span><br><span class="line">        <span class="comment">//数组</span></span><br><span class="line">        System.out.println(args.getClass().getSimpleName()); <span class="comment">//String[]</span></span><br><span class="line">        System.out.println(args.getClass().getName()); <span class="comment">//[Ljava.lang.String;</span></span><br><span class="line">        System.out.println(args.getClass().getCanonicalName()); <span class="comment">//java.lang.String[]</span></span><br><span class="line">        <span class="comment">//我们不能用getCanonicalName去加载类对象，必须用getName</span></span><br><span class="line">        <span class="comment">//Class.forName(inner.class.getCanonicalName()); 报错</span></span><br><span class="line">        Class.forName(inner.class.getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Constructor类及其用法"><a href="#Constructor类及其用法" class="headerlink" title="Constructor类及其用法"></a>Constructor类及其用法</h4><p>Constructor类存在于反射包(java.lang.reflect)中，反映的是Class 对象所表示的类的构造方法。</p>
<p>获取Constructor对象是通过Class类中的方法获取的，Class类与Constructor相关的主要方法如下：</p>
<table>
<thead>
<tr>
<th align="center">方法返回值</th>
<th align="center">方法名称</th>
<th align="center">方法说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">static Class&lt;?&gt;</td>
<td align="center">forName(String className)</td>
<td align="center">返回与带有给定字符串名的类或接口相关联的 Class 对象。</td>
</tr>
<tr>
<td align="center">Constructor</td>
<td align="center">getConstructor(Class&lt;?&gt;… parameterTypes)</td>
<td align="center">返回指定参数类型、具有public访问权限的构造函数对象</td>
</tr>
<tr>
<td align="center">Constructor&lt;?&gt;[]</td>
<td align="center">getConstructors()</td>
<td align="center">返回所有具有public访问权限的构造函数的Constructor对象数组</td>
</tr>
<tr>
<td align="center">Constructor</td>
<td align="center">getDeclaredConstructor(Class&lt;?&gt;… parameterTypes)</td>
<td align="center">返回指定参数类型、所有声明的（包括private）构造函数对象</td>
</tr>
<tr>
<td align="center">Constructor&lt;?&gt;[]</td>
<td align="center">getDeclaredConstructor()</td>
<td align="center">返回所有声明的（包括private）构造函数对象</td>
</tr>
<tr>
<td align="center">T</td>
<td align="center">newInstance()</td>
<td align="center">调用无参构造器创建此 Class 对象所表示的类的一个新实例。</td>
</tr>
</tbody></table>
<p>下面看一个简单例子来了解Constructor对象的使用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConstructionTest</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">        Class&lt;?&gt; clazz = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取Class对象的引用</span></span><br><span class="line">        clazz = Class.forName(<span class="string">&quot;com.example.javabase.User&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//第一种方法，实例化默认构造方法，User必须无参构造函数,否则将抛异常</span></span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> (User) clazz.newInstance();</span><br><span class="line">        user.setAge(<span class="number">20</span>);</span><br><span class="line">        user.setName(<span class="string">&quot;Jack&quot;</span>);</span><br><span class="line">        System.out.println(user);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;--------------------------------------------&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取带String参数的public构造函数</span></span><br><span class="line">        <span class="type">Constructor</span> <span class="variable">cs1</span> <span class="operator">=</span>clazz.getConstructor(String.class);</span><br><span class="line">        <span class="comment">//创建User</span></span><br><span class="line">        User user1= (User) cs1.newInstance(<span class="string">&quot;hiway&quot;</span>);</span><br><span class="line">        user1.setAge(<span class="number">22</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;user1:&quot;</span>+user1.toString());</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;--------------------------------------------&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//取得指定带int和String参数构造函数,该方法是私有构造private</span></span><br><span class="line">        Constructor cs2=clazz.getDeclaredConstructor(<span class="type">int</span>.class,String.class);</span><br><span class="line">        <span class="comment">//由于是private必须设置可访问</span></span><br><span class="line">        cs2.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        <span class="comment">//创建user对象</span></span><br><span class="line">        User user2= (User) cs2.newInstance(<span class="number">25</span>,<span class="string">&quot;hiway2&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;user2:&quot;</span>+user2.toString());</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;--------------------------------------------&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取所有构造包含private</span></span><br><span class="line">        Constructor&lt;?&gt; cons[] = clazz.getDeclaredConstructors();</span><br><span class="line">        <span class="comment">// 查看每个构造方法需要的参数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; cons.length; i++) &#123;</span><br><span class="line">            <span class="comment">//获取构造函数参数类型</span></span><br><span class="line">            Class&lt;?&gt; clazzs[] = cons[i].getParameterTypes();</span><br><span class="line">            System.out.println(<span class="string">&quot;构造函数[&quot;</span>+i+<span class="string">&quot;]:&quot;</span>+cons[i].toString() );</span><br><span class="line">            System.out.print(<span class="string">&quot;参数类型[&quot;</span>+i+<span class="string">&quot;]:(&quot;</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; clazzs.length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (j == clazzs.length - <span class="number">1</span>)</span><br><span class="line">                    System.out.print(clazzs[j].getName());</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    System.out.print(clazzs[j].getName() + <span class="string">&quot;,&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;)&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">User</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">User</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>();</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 私有构造</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> age</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> name</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">User</span><span class="params">(<span class="type">int</span> age, String name)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>();</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;User&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;age=&quot;</span> + age +</span><br><span class="line">                <span class="string">&quot;, name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* output </span></span><br><span class="line"><span class="comment">User&#123;age=20, name=&#x27;Jack&#x27;&#125;</span></span><br><span class="line"><span class="comment">--------------------------------------------</span></span><br><span class="line"><span class="comment">user1:User&#123;age=22, name=&#x27;hiway&#x27;&#125;</span></span><br><span class="line"><span class="comment">--------------------------------------------</span></span><br><span class="line"><span class="comment">user2:User&#123;age=25, name=&#x27;hiway2&#x27;&#125;</span></span><br><span class="line"><span class="comment">--------------------------------------------</span></span><br><span class="line"><span class="comment">构造函数[0]:private com.example.javabase.User(int,java.lang.String)</span></span><br><span class="line"><span class="comment">参数类型[0]:(int,java.lang.String)</span></span><br><span class="line"><span class="comment">构造函数[1]:public com.example.javabase.User(java.lang.String)</span></span><br><span class="line"><span class="comment">参数类型[1]:(java.lang.String)</span></span><br><span class="line"><span class="comment">构造函数[2]:public com.example.javabase.User()</span></span><br><span class="line"><span class="comment">参数类型[2]:()</span></span><br></pre></td></tr></table></figure>

<p>关于<strong>Constructor类本身一些常用方法</strong>如下(仅部分，其他可查API)</p>
<table>
<thead>
<tr>
<th align="center">方法返回值</th>
<th align="center">方法名称</th>
<th align="center">方法说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Class</td>
<td align="center">getDeclaringClass()</td>
<td align="center">返回 Class 对象，该对象表示声明由此 Constructor 对象表示的构造方法的类,其实就是返回真实类型（不包含参数）</td>
</tr>
<tr>
<td align="center">Type[]</td>
<td align="center">getGenericParameterTypes()</td>
<td align="center">按照声明顺序返回一组 Type 对象，返回的就是 Constructor对象构造函数的形参类型。</td>
</tr>
<tr>
<td align="center">String</td>
<td align="center">getName()</td>
<td align="center">以字符串形式返回此构造方法的名称。</td>
</tr>
<tr>
<td align="center">Class&lt;?&gt;[]</td>
<td align="center">getParameterTypes()</td>
<td align="center">按照声明顺序返回一组 Class 对象，即返回Constructor 对象所表示构造方法的形参类型</td>
</tr>
<tr>
<td align="center">T</td>
<td align="center">newInstance(Object… initargs)</td>
<td align="center">使用此 Constructor对象表示的构造函数来创建新实例</td>
</tr>
<tr>
<td align="center">String</td>
<td align="center">toGenericString()</td>
<td align="center">返回描述此 Constructor 的字符串，其中包括类型参数。</td>
</tr>
</tbody></table>
<p>代码演示如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Constructor</span> <span class="variable">cs3</span> <span class="operator">=</span> clazz.getDeclaredConstructor(<span class="type">int</span>.class,String.class);</span><br><span class="line">System.out.println(<span class="string">&quot;-----getDeclaringClass-----&quot;</span>);</span><br><span class="line">Class uclazz=cs3.getDeclaringClass();</span><br><span class="line"><span class="comment">//Constructor对象表示的构造方法的类</span></span><br><span class="line">System.out.println(<span class="string">&quot;构造方法的类:&quot;</span>+uclazz.getName());</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;-----getGenericParameterTypes-----&quot;</span>);</span><br><span class="line"><span class="comment">//对象表示此 Constructor 对象所表示的方法的形参类型</span></span><br><span class="line">Type[] tps=cs3.getGenericParameterTypes();</span><br><span class="line"><span class="keyword">for</span> (Type tp:tps) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;参数名称tp:&quot;</span>+tp);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">&quot;-----getParameterTypes-----&quot;</span>);</span><br><span class="line"><span class="comment">//获取构造函数参数类型</span></span><br><span class="line">Class&lt;?&gt; clazzs[] = cs3.getParameterTypes();</span><br><span class="line"><span class="keyword">for</span> (Class claz:clazzs) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;参数名称:&quot;</span>+claz.getName());</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">&quot;-----getName-----&quot;</span>);</span><br><span class="line"><span class="comment">//以字符串形式返回此构造方法的名称</span></span><br><span class="line">System.out.println(<span class="string">&quot;getName:&quot;</span>+cs3.getName());</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;-----getoGenericString-----&quot;</span>);</span><br><span class="line"><span class="comment">//返回描述此 Constructor 的字符串，其中包括类型参数。</span></span><br><span class="line">System.out.println(<span class="string">&quot;getoGenericString():&quot;</span>+cs3.toGenericString());</span><br></pre></td></tr></table></figure>

<p>输出结果</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">-----getDeclaringClass-----</span><br><span class="line">构造方法的类:com.example.javabase.User</span><br><span class="line">-----getGenericParameterTypes-----</span><br><span class="line">参数名称tp:<span class="type">int</span></span><br><span class="line">参数名称tp:<span class="keyword">class</span> <span class="title class_">java</span>.lang.String</span><br><span class="line">-----getParameterTypes-----</span><br><span class="line">参数名称:<span class="type">int</span></span><br><span class="line">参数名称:java.lang.String</span><br><span class="line">-----getName-----</span><br><span class="line">getName:com.example.javabase.User</span><br><span class="line">-----getoGenericString-----</span><br><span class="line">getoGenericString():<span class="keyword">private</span> com.example.javabase.User(<span class="type">int</span>,java.lang.String)</span><br></pre></td></tr></table></figure>

<h4 id="Field类及其用法"><a href="#Field类及其用法" class="headerlink" title="Field类及其用法"></a>Field类及其用法</h4><p>Field 提供有关类或接口的单个字段的信息，以及对它的动态访问权限。反射的字段可能是一个类（静态）字段或实例字段。</p>
<p>同样的道理，我们可以通过Class类的提供的方法来获取代表字段信息的Field对象，Class类与Field对象相关方法如下：</p>
<table>
<thead>
<tr>
<th align="center">方法返回值</th>
<th align="center">方法名称</th>
<th align="center">方法说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Field</td>
<td align="center">getDeclaredField(String name)</td>
<td align="center">获取指定name名称的(包含private修饰的)字段，不包括继承的字段</td>
</tr>
<tr>
<td align="center">Field[]</td>
<td align="center">getDeclaredFields()</td>
<td align="center">获取Class对象所表示的类或接口的所有(包含private修饰的)字段,不包括继承的字段</td>
</tr>
<tr>
<td align="center">Field</td>
<td align="center">getField(String name)</td>
<td align="center">获取指定name名称、具有public修饰的字段，包含继承字段</td>
</tr>
<tr>
<td align="center">Field[]</td>
<td align="center">getFields()</td>
<td align="center">获取修饰符为public的字段，包含继承字段</td>
</tr>
</tbody></table>
<p>下面的代码演示了上述方法的使用过程</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReflectField</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException, NoSuchFieldException &#123;</span><br><span class="line">        Class&lt;?&gt; clazz = Class.forName(<span class="string">&quot;reflect.Student&quot;</span>);</span><br><span class="line">        <span class="comment">//获取指定字段名称的Field类,注意字段修饰符必须为public而且存在该字段,</span></span><br><span class="line">        <span class="comment">// 否则抛NoSuchFieldException</span></span><br><span class="line">        <span class="type">Field</span> <span class="variable">field</span> <span class="operator">=</span> clazz.getField(<span class="string">&quot;age&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;field:&quot;</span>+field);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取所有修饰符为public的字段,包含父类字段,注意修饰符为public才会获取</span></span><br><span class="line">        Field fields[] = clazz.getFields();</span><br><span class="line">        <span class="keyword">for</span> (Field f:fields) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;f:&quot;</span>+f.getDeclaringClass());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;================getDeclaredFields====================&quot;</span>);</span><br><span class="line">        <span class="comment">//获取当前类所字段(包含private字段),注意不包含父类的字段</span></span><br><span class="line">        Field fields2[] = clazz.getDeclaredFields();</span><br><span class="line">        <span class="keyword">for</span> (Field f:fields2) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;f2:&quot;</span>+f.getDeclaringClass());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//获取指定字段名称的Field类,可以是任意修饰符的自动,注意不包含父类的字段</span></span><br><span class="line">        <span class="type">Field</span> <span class="variable">field2</span> <span class="operator">=</span> clazz.getDeclaredField(<span class="string">&quot;desc&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;field2:&quot;</span>+field2);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">      输出结果: </span></span><br><span class="line"><span class="comment">     field:public int reflect.Person.age</span></span><br><span class="line"><span class="comment">     f:public java.lang.String reflect.Student.desc</span></span><br><span class="line"><span class="comment">     f:public int reflect.Person.age</span></span><br><span class="line"><span class="comment">     f:public java.lang.String reflect.Person.name</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     ================getDeclaredFields====================</span></span><br><span class="line"><span class="comment">     f2:public java.lang.String reflect.Student.desc</span></span><br><span class="line"><span class="comment">     f2:private int reflect.Student.score</span></span><br><span class="line"><span class="comment">     field2:public java.lang.String reflect.Student.desc</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="comment">//省略set和get方法</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">extends</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String desc;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> score;</span><br><span class="line">    <span class="comment">//省略set和get方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述方法需要注意的是，如果我们不期望获取其父类的字段，则需使用Class类的getDeclaredField&#x2F;getDeclaredFields方法来获取字段即可，倘若需要连带获取到父类的字段，那么请使用Class类的getField&#x2F;getFields，但是也只能获取到public修饰的的字段，无法获取父类的私有字段。下面将通过Field类本身的方法对指定类属性赋值，代码演示如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//获取Class对象引用</span></span><br><span class="line">Class&lt;?&gt; clazz = Class.forName(<span class="string">&quot;reflect.Student&quot;</span>);</span><br><span class="line"></span><br><span class="line">Student st= (Student) clazz.newInstance();</span><br><span class="line"><span class="comment">//获取父类public字段并赋值</span></span><br><span class="line"><span class="type">Field</span> <span class="variable">ageField</span> <span class="operator">=</span> clazz.getField(<span class="string">&quot;age&quot;</span>);</span><br><span class="line">ageField.set(st,<span class="number">18</span>);</span><br><span class="line"><span class="type">Field</span> <span class="variable">nameField</span> <span class="operator">=</span> clazz.getField(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">nameField.set(st,<span class="string">&quot;Lily&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//只获取当前类的字段,不获取父类的字段</span></span><br><span class="line"><span class="type">Field</span> <span class="variable">descField</span> <span class="operator">=</span> clazz.getDeclaredField(<span class="string">&quot;desc&quot;</span>);</span><br><span class="line">descField.set(st,<span class="string">&quot;I am student&quot;</span>);</span><br><span class="line"><span class="type">Field</span> <span class="variable">scoreField</span> <span class="operator">=</span> clazz.getDeclaredField(<span class="string">&quot;score&quot;</span>);</span><br><span class="line"><span class="comment">//设置可访问，score是private的</span></span><br><span class="line">scoreField.setAccessible(<span class="literal">true</span>);</span><br><span class="line">scoreField.set(st,<span class="number">88</span>);</span><br><span class="line">System.out.println(st.toString());</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出结果：Student&#123;age=18, name=&#x27;Lily ,desc=&#x27;I am student&#x27;, score=88&#125; </span></span><br><span class="line"></span><br><span class="line"><span class="comment">//获取字段值</span></span><br><span class="line">System.out.println(scoreField.get(st));</span><br><span class="line"><span class="comment">// 88</span></span><br></pre></td></tr></table></figure>

<p>其中的set(Object obj, Object value)方法是Field类本身的方法，用于设置字段的值，而get(Object obj)则是获取字段的值，当然关于Field类还有其他常用的方法如下：</p>
<table>
<thead>
<tr>
<th align="center">方法返回值</th>
<th align="center">方法名称</th>
<th align="center">方法说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">void</td>
<td align="center">set(Object obj, Object value)</td>
<td align="center">将指定对象变量上此 Field 对象表示的字段设置为指定的新值。</td>
</tr>
<tr>
<td align="center">Object</td>
<td align="center">get(Object obj)</td>
<td align="center">返回指定对象上此 Field 表示的字段的值</td>
</tr>
<tr>
<td align="center">Class&lt;?&gt;</td>
<td align="center">getType()</td>
<td align="center">返回一个 Class 对象，它标识了此Field 对象所表示字段的声明类型。</td>
</tr>
<tr>
<td align="center">boolean</td>
<td align="center">isEnumConstant()</td>
<td align="center">如果此字段表示枚举类型的元素则返回 true；否则返回 false</td>
</tr>
<tr>
<td align="center">String</td>
<td align="center">toGenericString()</td>
<td align="center">返回一个描述此 Field（包括其一般类型）的字符串</td>
</tr>
<tr>
<td align="center">String</td>
<td align="center">getName()</td>
<td align="center">返回此 Field 对象表示的字段的名称</td>
</tr>
<tr>
<td align="center">Class&lt;?&gt;</td>
<td align="center">getDeclaringClass()</td>
<td align="center">返回表示类或接口的 Class 对象，该类或接口声明由此 Field 对象表示的字段</td>
</tr>
<tr>
<td align="center">void</td>
<td align="center">setAccessible(boolean flag)</td>
<td align="center">将此对象的 accessible 标志设置为指示的布尔值,即设置其可访问性</td>
</tr>
</tbody></table>
<p>上述方法可能是较为常用的，事实上在设置值的方法上，Field类还提供了专门针对基本数据类型的方法，如<code>setInt()/getInt()</code>、<code>setBoolean()/getBoolean</code>、<code>setChar()/getChar()</code>等等方法，这里就不全部列出了，需要时查API文档即可。需要特别注意的是被final关键字修饰的Field字段是安全的，在运行时可以接收任何修改，但最终其实际值是不会发生改变的。</p>
<h4 id="Method类及其用法"><a href="#Method类及其用法" class="headerlink" title="Method类及其用法"></a>Method类及其用法</h4><p>Method 提供关于类或接口上单独某个方法（以及如何访问该方法）的信息，所反映的方法可能是类方法或实例方法（包括抽象方法）。</p>
<p>下面是Class类获取Method对象相关的方法：</p>
<table>
<thead>
<tr>
<th align="center">方法返回值</th>
<th align="center">方法名称</th>
<th align="center">方法说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Method</td>
<td align="center">getDeclaredMethod(String name, Class&lt;?&gt;… parameterTypes)</td>
<td align="center">返回一个指定参数的Method对象，该对象反映此 Class 对象所表示的类或接口的指定已声明方法。</td>
</tr>
<tr>
<td align="center">Method[]</td>
<td align="center">getDeclaredMethod()</td>
<td align="center">返回 Method 对象的一个数组，这些对象反映此 Class 对象表示的类或接口声明的所有方法，包括公共、保护、默认（包）访问和私有方法，但不包括继承的方法。</td>
</tr>
<tr>
<td align="center">Method</td>
<td align="center">getMethod(String name, Class&lt;?&gt;… parameterTypes)</td>
<td align="center">返回一个 Method 对象，它反映此 Class 对象所表示的类或接口的指定公共成员方法。</td>
</tr>
<tr>
<td align="center">Method[]</td>
<td align="center">getMethods()</td>
<td align="center">返回一个包含某些 Method 对象的数组，这些对象反映此 Class 对象所表示的类或接口（包括那些由该类或接口声明的以及从超类和超接口继承的那些的类或接口）的公共 member 方法。</td>
</tr>
</tbody></table>
<p>同样通过案例演示上述方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReflectMethod</span>  &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException, NoSuchMethodException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;reflect.Circle&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//根据参数获取public的Method,包含继承自父类的方法</span></span><br><span class="line">        <span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> clazz.getMethod(<span class="string">&quot;draw&quot;</span>,<span class="type">int</span>.class,String.class);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;method:&quot;</span>+method);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取所有public的方法:</span></span><br><span class="line">        Method[] methods =clazz.getMethods();</span><br><span class="line">        <span class="keyword">for</span> (Method m:methods)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;m::&quot;</span>+m);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;=========================================&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取当前类的方法包含private,该方法无法获取继承自父类的method</span></span><br><span class="line">        <span class="type">Method</span> <span class="variable">method1</span> <span class="operator">=</span> clazz.getDeclaredMethod(<span class="string">&quot;drawCircle&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;method1::&quot;</span>+method1);</span><br><span class="line">        <span class="comment">//获取当前类的所有方法包含private,该方法无法获取继承自父类的method</span></span><br><span class="line">        Method[] methods1=clazz.getDeclaredMethods();</span><br><span class="line">        <span class="keyword">for</span> (Method m:methods1)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;m1::&quot;</span>+m);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;draw&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">(<span class="type">int</span> count , String name)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;draw &quot;</span>+ name +<span class="string">&quot;,count=&quot;</span>+count);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Circle</span> <span class="keyword">extends</span> <span class="title class_">Shape</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">drawCircle</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;drawCircle&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAllCount</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">100</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">method:<span class="keyword">public</span> <span class="keyword">void</span> reflect.Shape.draw(<span class="type">int</span>,java.lang.String)</span><br><span class="line"></span><br><span class="line">m::<span class="keyword">public</span> <span class="type">int</span> reflect.Circle.getAllCount()</span><br><span class="line">m::<span class="keyword">public</span> <span class="keyword">void</span> reflect.Shape.draw()</span><br><span class="line">m::<span class="keyword">public</span> <span class="keyword">void</span> reflect.Shape.draw(<span class="type">int</span>,java.lang.String)</span><br><span class="line">m::<span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> java.lang.Object.wait(<span class="type">long</span>,<span class="type">int</span>) <span class="keyword">throws</span> java.lang.InterruptedException</span><br><span class="line">m::<span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> java.lang.Object.wait(<span class="type">long</span>) <span class="keyword">throws</span> java.lang.InterruptedException</span><br><span class="line">m::<span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> java.lang.Object.wait() <span class="keyword">throws</span> java.lang.InterruptedException</span><br><span class="line">m::<span class="keyword">public</span> <span class="type">boolean</span> java.lang.Object.equals(java.lang.Object)</span><br><span class="line">m::<span class="keyword">public</span> java.lang.String java.lang.Object.toString()</span><br><span class="line">m::<span class="keyword">public</span> <span class="keyword">native</span> <span class="type">int</span> java.lang.Object.hashCode()</span><br><span class="line">m::<span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> java.lang.Class java.lang.Object.getClass()</span><br><span class="line">m::<span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> java.lang.Object.notify()</span><br><span class="line">m::<span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> java.lang.Object.notifyAll()</span><br><span class="line"></span><br><span class="line">=========================================</span><br><span class="line">method1::<span class="keyword">private</span> <span class="keyword">void</span> reflect.Circle.drawCircle()</span><br><span class="line"></span><br><span class="line">m1::<span class="keyword">public</span> <span class="type">int</span> reflect.Circle.getAllCount()</span><br><span class="line">m1::<span class="keyword">private</span> <span class="keyword">void</span> reflect.Circle.drawCircle()</span><br></pre></td></tr></table></figure>

<p>在通过getMethods方法获取Method对象时，会把父类的方法也获取到，如上的输出结果，把Object类的方法都打印出来了。而<code>getDeclaredMethod/getDeclaredMethods</code>方法都只能获取当前类的方法。我们在使用时根据情况选择即可。下面将演示通过Method对象调用指定类的方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;reflect.Circle&quot;</span>);</span><br><span class="line"><span class="comment">//创建对象</span></span><br><span class="line"><span class="type">Circle</span> <span class="variable">circle</span> <span class="operator">=</span> (Circle) clazz.newInstance();</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取指定参数的方法对象Method</span></span><br><span class="line"><span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> clazz.getMethod(<span class="string">&quot;draw&quot;</span>,<span class="type">int</span>.class,String.class);</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过Method对象的invoke(Object obj,Object... args)方法调用</span></span><br><span class="line">method.invoke(circle,<span class="number">15</span>,<span class="string">&quot;圈圈&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//对私有无参方法的操作</span></span><br><span class="line"><span class="type">Method</span> <span class="variable">method1</span> <span class="operator">=</span> clazz.getDeclaredMethod(<span class="string">&quot;drawCircle&quot;</span>);</span><br><span class="line"><span class="comment">//修改私有方法的访问标识</span></span><br><span class="line">method1.setAccessible(<span class="literal">true</span>);</span><br><span class="line">method1.invoke(circle);</span><br><span class="line"></span><br><span class="line"><span class="comment">//对有返回值得方法操作</span></span><br><span class="line"><span class="type">Method</span> <span class="variable">method2</span> <span class="operator">=</span>clazz.getDeclaredMethod(<span class="string">&quot;getAllCount&quot;</span>);</span><br><span class="line"><span class="type">Integer</span> <span class="variable">count</span> <span class="operator">=</span> (Integer) method2.invoke(circle);</span><br><span class="line">System.out.println(<span class="string">&quot;count:&quot;</span>+count);</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">draw 圈圈,count=<span class="number">15</span></span><br><span class="line">drawCircle</span><br><span class="line">count:<span class="number">100</span></span><br></pre></td></tr></table></figure>

<p>在上述代码中调用方法，使用了Method类的<code>invoke(Object obj,Object... args)</code>第一个参数代表调用的对象，第二个参数传递的调用方法的参数。这样就完成了类方法的动态调用。</p>
<table>
<thead>
<tr>
<th align="center">方法返回值</th>
<th align="center">方法名称</th>
<th align="center">方法说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Object</td>
<td align="center">invoke(Object obj, Object… args)</td>
<td align="center">对带有指定参数的指定对象调用由此 Method 对象表示的底层方法。</td>
</tr>
<tr>
<td align="center">Class&lt;?&gt;</td>
<td align="center">getReturnType()</td>
<td align="center">返回一个 Class 对象，该对象描述了此 Method 对象所表示的方法的正式返回类型,即方法的返回类型</td>
</tr>
<tr>
<td align="center">Type</td>
<td align="center">getGenericReturnType()</td>
<td align="center">返回表示由此 Method 对象所表示方法的正式返回类型的 Type 对象，也是方法的返回类型。</td>
</tr>
<tr>
<td align="center">Class&lt;?&gt;[]</td>
<td align="center">getParameterTypes()</td>
<td align="center">按照声明顺序返回 Class 对象的数组，这些对象描述了此 Method 对象所表示的方法的形参类型。即返回方法的参数类型组成的数组</td>
</tr>
<tr>
<td align="center">Type[]</td>
<td align="center">getGenericParameterTypes()</td>
<td align="center">按照声明顺序返回 Type 对象的数组，这些对象描述了此 Method 对象所表示的方法的形参类型的，也是返回方法的参数类型</td>
</tr>
<tr>
<td align="center">String</td>
<td align="center">getName()</td>
<td align="center">以 String 形式返回此 Method 对象表示的方法名称，即返回方法的名称</td>
</tr>
<tr>
<td align="center">boolean</td>
<td align="center">isVarArgs()</td>
<td align="center">判断方法是否带可变参数，如果将此方法声明为带有可变数量的参数，则返回 true；否则，返回 false。</td>
</tr>
<tr>
<td align="center">String</td>
<td align="center">toGenericString()</td>
<td align="center">返回描述此 Method 的字符串，包括类型参数。</td>
</tr>
</tbody></table>
<p><code>getReturnType方法/getGenericReturnType方法</code>都是获取Method对象表示的方法的返回类型，只不过前者返回的Class类型后者返回的Type(前面已分析过)，Type就是一个接口而已，在Java8中新增一个默认的方法实现，返回的就参数类型信息。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Type</span> &#123;</span><br><span class="line">    <span class="comment">//1.8新增</span></span><br><span class="line">    <span class="keyword">default</span> String <span class="title function_">getTypeName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而<code>getParameterTypes/getGenericParameterTypes</code>也是同样的道理，都是获取Method对象所表示的方法的参数类型，其他方法与前面的Field和Constructor是类似的。</p>
<h3 id="反射机制执行的流程"><a href="#反射机制执行的流程" class="headerlink" title="反射机制执行的流程"></a>反射机制执行的流程</h3><p><strong>先看个例子</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloReflect</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 1. 使用外部配置的实现，进行动态加载类</span></span><br><span class="line">            <span class="type">TempFunctionTest</span> <span class="variable">test</span> <span class="operator">=</span> (TempFunctionTest)Class.forName(<span class="string">&quot;com.tester.HelloReflect&quot;</span>).newInstance();</span><br><span class="line">            test.sayHello(<span class="string">&quot;call directly&quot;</span>);</span><br><span class="line">            <span class="comment">// 2. 根据配置的函数名，进行方法调用（不需要通用的接口抽象）</span></span><br><span class="line">            <span class="type">Object</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TempFunctionTest</span>();</span><br><span class="line">            <span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> t2.getClass().getDeclaredMethod(<span class="string">&quot;sayHello&quot;</span>, String.class);</span><br><span class="line">            method.invoke(test, <span class="string">&quot;method invoke&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InstantiationException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchMethodException e ) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InvocationTargetException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sayHello</span><span class="params">(String word)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello,&quot;</span> + word);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>来看执行流程</strong></p>
<p><img src="/../images/note41.png" alt="note41"></p>
<h4 id="反射获取类实例"><a href="#反射获取类实例" class="headerlink" title="反射获取类实例"></a>反射获取类实例</h4><p>首先调用了 java.lang.Class 的静态方法，获取类信息。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@CallerSensitive</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Class&lt;?&gt; forName(String className)</span><br><span class="line">            <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">    <span class="comment">// 先通过反射，获取调用进来的类信息，从而获取当前的 classLoader</span></span><br><span class="line">    Class&lt;?&gt; caller = Reflection.getCallerClass();</span><br><span class="line">    <span class="comment">// 调用native方法进行获取class信息</span></span><br><span class="line">    <span class="keyword">return</span> forName0(className, <span class="literal">true</span>, ClassLoader.getClassLoader(caller), caller);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>forName()反射获取类信息，并没有将实现留给了java,而是交给了jvm去加载。</p>
<p>主要是先获取 ClassLoader, 然后调用 native 方法，获取信息，加载类则是回调 java.lang.ClassLoader.</p>
<p>最后，jvm又会回调 ClassLoader 进类加载。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="keyword">public</span> Class&lt;?&gt; loadClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">    <span class="keyword">return</span> loadClass(name, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// sun.misc.Launcher</span></span><br><span class="line">    <span class="keyword">public</span> Class&lt;?&gt; loadClass(String var1, <span class="type">boolean</span> var2) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">var3</span> <span class="operator">=</span> var1.lastIndexOf(<span class="number">46</span>);</span><br><span class="line">        <span class="keyword">if</span>(var3 != -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="type">SecurityManager</span> <span class="variable">var4</span> <span class="operator">=</span> System.getSecurityManager();</span><br><span class="line">            <span class="keyword">if</span>(var4 != <span class="literal">null</span>) &#123;</span><br><span class="line">                var4.checkPackageAccess(var1.substring(<span class="number">0</span>, var3));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">this</span>.ucp.knownToNotExist(var1)) &#123;</span><br><span class="line">            <span class="type">Class</span> <span class="variable">var5</span> <span class="operator">=</span> <span class="built_in">this</span>.findLoadedClass(var1);</span><br><span class="line">            <span class="keyword">if</span>(var5 != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span>(var2) &#123;</span><br><span class="line">                    <span class="built_in">this</span>.resolveClass(var5);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> var5;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ClassNotFoundException</span>(var1);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">super</span>.loadClass(var1, var2);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// java.lang.ClassLoader</span></span><br><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="type">boolean</span> resolve)</span><br><span class="line">    <span class="keyword">throws</span> ClassNotFoundException</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 先获取锁</span></span><br><span class="line">    <span class="keyword">synchronized</span> (getClassLoadingLock(name)) &#123;</span><br><span class="line">        <span class="comment">// First, check if the class has already been loaded</span></span><br><span class="line">        <span class="comment">// 如果已经加载了的话，就不用再加载了</span></span><br><span class="line">        Class&lt;?&gt; c = findLoadedClass(name);</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">long</span> <span class="variable">t0</span> <span class="operator">=</span> System.nanoTime();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 双亲委托加载</span></span><br><span class="line">                <span class="keyword">if</span> (parent != <span class="literal">null</span>) &#123;</span><br><span class="line">                    c = parent.loadClass(name, <span class="literal">false</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    c = findBootstrapClassOrNull(name);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">                <span class="comment">// ClassNotFoundException thrown if class not found</span></span><br><span class="line">                <span class="comment">// from the non-null parent class loader</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 父类没有加载到时，再自己加载</span></span><br><span class="line">            <span class="keyword">if</span> (c == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">// If still not found, then invoke findClass in order</span></span><br><span class="line">                <span class="comment">// to find the class.</span></span><br><span class="line">                <span class="type">long</span> <span class="variable">t1</span> <span class="operator">=</span> System.nanoTime();</span><br><span class="line">                c = findClass(name);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// this is the defining class loader; record the stats</span></span><br><span class="line">                sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);</span><br><span class="line">                sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);</span><br><span class="line">                sun.misc.PerfCounter.getFindClasses().increment();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (resolve) &#123;</span><br><span class="line">            resolveClass(c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> Object <span class="title function_">getClassLoadingLock</span><span class="params">(String className)</span> &#123;</span><br><span class="line">    <span class="type">Object</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="built_in">this</span>;</span><br><span class="line">    <span class="keyword">if</span> (parallelLockMap != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 使用 ConcurrentHashMap来保存锁</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">newLock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">        lock = parallelLockMap.putIfAbsent(className, newLock);</span><br><span class="line">        <span class="keyword">if</span> (lock == <span class="literal">null</span>) &#123;</span><br><span class="line">            lock = newLock;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> lock;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> Class&lt;?&gt; findLoadedClass(String name) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!checkName(name))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">return</span> findLoadedClass0(name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面来看一下 newInstance() 的实现方式。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 首先肯定是 Class.newInstance</span></span><br><span class="line"><span class="meta">@CallerSensitive</span></span><br><span class="line"><span class="keyword">public</span> T <span class="title function_">newInstance</span><span class="params">()</span></span><br><span class="line">    <span class="keyword">throws</span> InstantiationException, IllegalAccessException</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (System.getSecurityManager() != <span class="literal">null</span>) &#123;</span><br><span class="line">        checkMemberAccess(Member.PUBLIC, Reflection.getCallerClass(), <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// <span class="doctag">NOTE:</span> the following code may not be strictly correct under</span></span><br><span class="line">    <span class="comment">// the current Java memory model.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Constructor lookup</span></span><br><span class="line">    <span class="comment">// newInstance() 其实相当于调用类的无参构造函数，所以，首先要找到其无参构造器</span></span><br><span class="line">    <span class="keyword">if</span> (cachedConstructor == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span> == Class.class) &#123;</span><br><span class="line">            <span class="comment">// 不允许调用 Class 的 newInstance() 方法</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalAccessException</span>(</span><br><span class="line">                <span class="string">&quot;Can not call newInstance() on the Class for java.lang.Class&quot;</span></span><br><span class="line">            );</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 获取无参构造器</span></span><br><span class="line">            Class&lt;?&gt;[] empty = &#123;&#125;;</span><br><span class="line">            <span class="keyword">final</span> Constructor&lt;T&gt; c = getConstructor0(empty, Member.DECLARED);</span><br><span class="line">            <span class="comment">// Disable accessibility checks on the constructor</span></span><br><span class="line">            <span class="comment">// since we have to do the security check here anyway</span></span><br><span class="line">            <span class="comment">// (the stack depth is wrong for the Constructor&#x27;s</span></span><br><span class="line">            <span class="comment">// security check to work)</span></span><br><span class="line">            java.security.AccessController.doPrivileged(</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">java</span>.security.PrivilegedAction&lt;Void&gt;() &#123;</span><br><span class="line">                    <span class="keyword">public</span> Void <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                            c.setAccessible(<span class="literal">true</span>);</span><br><span class="line">                            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">            cachedConstructor = c;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchMethodException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> (InstantiationException)</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InstantiationException</span>(getName()).initCause(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Constructor&lt;T&gt; tmpConstructor = cachedConstructor;</span><br><span class="line">    <span class="comment">// Security check (same as in java.lang.reflect.Constructor)</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">modifiers</span> <span class="operator">=</span> tmpConstructor.getModifiers();</span><br><span class="line">    <span class="keyword">if</span> (!Reflection.quickCheckMemberAccess(<span class="built_in">this</span>, modifiers)) &#123;</span><br><span class="line">        Class&lt;?&gt; caller = Reflection.getCallerClass();</span><br><span class="line">        <span class="keyword">if</span> (newInstanceCallerCache != caller) &#123;</span><br><span class="line">            Reflection.ensureMemberAccess(caller, <span class="built_in">this</span>, <span class="literal">null</span>, modifiers);</span><br><span class="line">            newInstanceCallerCache = caller;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Run constructor</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 调用无参构造器</span></span><br><span class="line">        <span class="keyword">return</span> tmpConstructor.newInstance((Object[])<span class="literal">null</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InvocationTargetException e) &#123;</span><br><span class="line">        Unsafe.getUnsafe().throwException(e.getTargetException());</span><br><span class="line">        <span class="comment">// Not reached</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>newInstance() 主要做了三件事：</p>
<ul>
<li><ol>
<li>权限检测，如果不通过直接抛出异常；</li>
</ol>
</li>
<li><ol>
<li>查找无参构造器，并将其缓存起来；</li>
</ol>
</li>
<li><ol>
<li>调用具体方法的无参构造方法，生成实例并返回；</li>
</ol>
</li>
</ul>
<p>下面是获取构造器的过程：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> Constructor&lt;T&gt; <span class="title function_">getConstructor0</span><span class="params">(Class&lt;?&gt;[] parameterTypes,</span></span><br><span class="line"><span class="params">                                    <span class="type">int</span> which)</span> <span class="keyword">throws</span> NoSuchMethodException</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 获取所有构造器</span></span><br><span class="line">    Constructor&lt;T&gt;[] constructors = privateGetDeclaredConstructors((which == Member.PUBLIC));</span><br><span class="line">    <span class="keyword">for</span> (Constructor&lt;T&gt; constructor : constructors) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arrayContentsEq(parameterTypes,</span><br><span class="line">                            constructor.getParameterTypes())) &#123;</span><br><span class="line">            <span class="keyword">return</span> getReflectionFactory().copyConstructor(constructor);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NoSuchMethodException</span>(getName() + <span class="string">&quot;.&lt;init&gt;&quot;</span> + argumentTypesToString(parameterTypes));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>getConstructor0() 为获取匹配的构造方器；分三步：</p>
<ul>
<li><ol>
<li>先获取所有的constructors, 然后通过进行参数类型比较；</li>
</ol>
</li>
<li><ol>
<li>找到匹配后，通过 ReflectionFactory copy一份constructor返回；</li>
</ol>
</li>
<li><ol>
<li>否则抛出 NoSuchMethodException;</li>
</ol>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 获取当前类所有的构造方法，通过jvm或者缓存</span></span><br><span class="line"><span class="comment">// Returns an array of &quot;root&quot; constructors. These Constructor</span></span><br><span class="line"><span class="comment">// objects must NOT be propagated to the outside world, but must</span></span><br><span class="line"><span class="comment">// instead be copied via ReflectionFactory.copyConstructor.</span></span><br><span class="line"><span class="keyword">private</span> Constructor&lt;T&gt;[] privateGetDeclaredConstructors(<span class="type">boolean</span> publicOnly) &#123;</span><br><span class="line">    checkInitted();</span><br><span class="line">    Constructor&lt;T&gt;[] res;</span><br><span class="line">    <span class="comment">// 调用 reflectionData(), 获取保存的信息，使用软引用保存，从而使内存不够可以回收</span></span><br><span class="line">    ReflectionData&lt;T&gt; rd = reflectionData();</span><br><span class="line">    <span class="keyword">if</span> (rd != <span class="literal">null</span>) &#123;</span><br><span class="line">        res = publicOnly ? rd.publicConstructors : rd.declaredConstructors;</span><br><span class="line">        <span class="comment">// 存在缓存，则直接返回</span></span><br><span class="line">        <span class="keyword">if</span> (res != <span class="literal">null</span>) <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// No cached value available; request value from VM</span></span><br><span class="line">    <span class="keyword">if</span> (isInterface()) &#123;</span><br><span class="line">        <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">        Constructor&lt;T&gt;[] temporaryRes = (Constructor&lt;T&gt;[]) <span class="keyword">new</span> <span class="title class_">Constructor</span>&lt;?&gt;[<span class="number">0</span>];</span><br><span class="line">        res = temporaryRes;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 使用native方法从jvm获取构造器</span></span><br><span class="line">        res = getDeclaredConstructors0(publicOnly);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (rd != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 最后，将从jvm中读取的内容，存入缓存</span></span><br><span class="line">        <span class="keyword">if</span> (publicOnly) &#123;</span><br><span class="line">            rd.publicConstructors = res;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            rd.declaredConstructors = res;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Lazily create and cache ReflectionData</span></span><br><span class="line"><span class="keyword">private</span> ReflectionData&lt;T&gt; <span class="title function_">reflectionData</span><span class="params">()</span> &#123;</span><br><span class="line">    SoftReference&lt;ReflectionData&lt;T&gt;&gt; reflectionData = <span class="built_in">this</span>.reflectionData;</span><br><span class="line">    <span class="type">int</span> <span class="variable">classRedefinedCount</span> <span class="operator">=</span> <span class="built_in">this</span>.classRedefinedCount;</span><br><span class="line">    ReflectionData&lt;T&gt; rd;</span><br><span class="line">    <span class="keyword">if</span> (useCaches &amp;&amp;</span><br><span class="line">        reflectionData != <span class="literal">null</span> &amp;&amp;</span><br><span class="line">        (rd = reflectionData.get()) != <span class="literal">null</span> &amp;&amp;</span><br><span class="line">        rd.redefinedCount == classRedefinedCount) &#123;</span><br><span class="line">        <span class="keyword">return</span> rd;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// else no SoftReference or cleared SoftReference or stale ReflectionData</span></span><br><span class="line">    <span class="comment">// -&gt; create and replace new instance</span></span><br><span class="line">    <span class="keyword">return</span> newReflectionData(reflectionData, classRedefinedCount);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 新创建缓存，保存反射信息</span></span><br><span class="line"><span class="keyword">private</span> ReflectionData&lt;T&gt; <span class="title function_">newReflectionData</span><span class="params">(SoftReference&lt;ReflectionData&lt;T&gt;&gt; oldReflectionData,</span></span><br><span class="line"><span class="params">                                            <span class="type">int</span> classRedefinedCount)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!useCaches) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用cas保证更新的线程安全性，所以反射是保证线程安全的</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        ReflectionData&lt;T&gt; rd = <span class="keyword">new</span> <span class="title class_">ReflectionData</span>&lt;&gt;(classRedefinedCount);</span><br><span class="line">        <span class="comment">// try to CAS it...</span></span><br><span class="line">        <span class="keyword">if</span> (Atomic.casReflectionData(<span class="built_in">this</span>, oldReflectionData, <span class="keyword">new</span> <span class="title class_">SoftReference</span>&lt;&gt;(rd))) &#123;</span><br><span class="line">            <span class="keyword">return</span> rd;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 先使用CAS更新，如果更新成功，则立即返回，否则测查当前已被其他线程更新的情况，如果和自己想要更新的状态一致，则也算是成功了</span></span><br><span class="line">        oldReflectionData = <span class="built_in">this</span>.reflectionData;</span><br><span class="line">        classRedefinedCount = <span class="built_in">this</span>.classRedefinedCount;</span><br><span class="line">        <span class="keyword">if</span> (oldReflectionData != <span class="literal">null</span> &amp;&amp;</span><br><span class="line">            (rd = oldReflectionData.get()) != <span class="literal">null</span> &amp;&amp;</span><br><span class="line">            rd.redefinedCount == classRedefinedCount) &#123;</span><br><span class="line">            <span class="keyword">return</span> rd;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如上，privateGetDeclaredConstructors(), 获取所有的构造器主要步骤；</p>
<ul>
<li><ol>
<li>先尝试从缓存中获取；</li>
</ol>
</li>
<li><ol>
<li>如果缓存没有，则从jvm中重新获取，并存入缓存，缓存使用软引用进行保存，保证内存可用；</li>
</ol>
</li>
</ul>
<p>另外，使用 relactionData() 进行缓存保存；ReflectionData 的数据结构如下。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// reflection data that might get invalidated when JVM TI RedefineClasses() is called</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">ReflectionData</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">volatile</span> Field[] declaredFields;</span><br><span class="line">    <span class="keyword">volatile</span> Field[] publicFields;</span><br><span class="line">    <span class="keyword">volatile</span> Method[] declaredMethods;</span><br><span class="line">    <span class="keyword">volatile</span> Method[] publicMethods;</span><br><span class="line">    <span class="keyword">volatile</span> Constructor&lt;T&gt;[] declaredConstructors;</span><br><span class="line">    <span class="keyword">volatile</span> Constructor&lt;T&gt;[] publicConstructors;</span><br><span class="line">    <span class="comment">// Intermediate results for getFields and getMethods</span></span><br><span class="line">    <span class="keyword">volatile</span> Field[] declaredPublicFields;</span><br><span class="line">    <span class="keyword">volatile</span> Method[] declaredPublicMethods;</span><br><span class="line">    <span class="keyword">volatile</span> Class&lt;?&gt;[] interfaces;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Value of classRedefinedCount when we created this ReflectionData instance</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> redefinedCount;</span><br><span class="line"></span><br><span class="line">    ReflectionData(<span class="type">int</span> redefinedCount) &#123;</span><br><span class="line">        <span class="built_in">this</span>.redefinedCount = redefinedCount;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中，还有一个点，就是如何比较构造是否是要查找构造器，其实就是比较类型完成相等就完了，有一个不相等则返回false。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">arrayContentsEq</span><span class="params">(Object[] a1, Object[] a2)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (a1 == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="type">return</span> <span class="variable">a2</span> <span class="operator">=</span>= <span class="literal">null</span> || a2.length == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (a2 == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> a1.length == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (a1.length != a2.length) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; a1.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (a1[i] != a2[i]) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// sun.reflect.ReflectionFactory</span></span><br><span class="line"><span class="comment">/** Makes a copy of the passed constructor. The returned</span></span><br><span class="line"><span class="comment">    constructor is a &quot;child&quot; of the passed one; see the comments</span></span><br><span class="line"><span class="comment">    in Constructor.java for details. */</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; Constructor&lt;T&gt; <span class="title function_">copyConstructor</span><span class="params">(Constructor&lt;T&gt; arg)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> langReflectAccess().copyConstructor(arg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// java.lang.reflect.Constructor, copy 其实就是新new一个 Constructor 出来</span></span><br><span class="line">Constructor&lt;T&gt; <span class="title function_">copy</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// This routine enables sharing of ConstructorAccessor objects</span></span><br><span class="line">    <span class="comment">// among Constructor objects which refer to the same underlying</span></span><br><span class="line">    <span class="comment">// method in the VM. (All of this contortion is only necessary</span></span><br><span class="line">    <span class="comment">// because of the &quot;accessibility&quot; bit in AccessibleObject,</span></span><br><span class="line">    <span class="comment">// which implicitly requires that new java.lang.reflect</span></span><br><span class="line">    <span class="comment">// objects be fabricated for each reflective call on Class</span></span><br><span class="line">    <span class="comment">// objects.)</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.root != <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Can not copy a non-root Constructor&quot;</span>);</span><br><span class="line"></span><br><span class="line">    Constructor&lt;T&gt; res = <span class="keyword">new</span> <span class="title class_">Constructor</span>&lt;&gt;(clazz,</span><br><span class="line">                                           parameterTypes,</span><br><span class="line">                                           exceptionTypes, modifiers, slot,</span><br><span class="line">                                           signature,</span><br><span class="line">                                           annotations,</span><br><span class="line">                                           parameterAnnotations);</span><br><span class="line">    <span class="comment">// root 指向当前 constructor</span></span><br><span class="line">    res.root = <span class="built_in">this</span>;</span><br><span class="line">    <span class="comment">// Might as well eagerly propagate this if already present</span></span><br><span class="line">    res.constructorAccessor = constructorAccessor;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过上面，获取到 Constructor 了。</p>
<p>接下来就只需调用其相应构造器的 newInstance()，即返回实例了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// return tmpConstructor.newInstance((Object[])null); </span></span><br><span class="line"><span class="comment">// java.lang.reflect.Constructor</span></span><br><span class="line"><span class="meta">@CallerSensitive</span></span><br><span class="line"><span class="keyword">public</span> T <span class="title function_">newInstance</span><span class="params">(Object ... initargs)</span></span><br><span class="line">    <span class="keyword">throws</span> InstantiationException, IllegalAccessException,</span><br><span class="line">           IllegalArgumentException, InvocationTargetException</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!override) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!Reflection.quickCheckMemberAccess(clazz, modifiers)) &#123;</span><br><span class="line">            Class&lt;?&gt; caller = Reflection.getCallerClass();</span><br><span class="line">            checkAccess(caller, clazz, <span class="literal">null</span>, modifiers);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ((clazz.getModifiers() &amp; Modifier.ENUM) != <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Cannot reflectively create enum objects&quot;</span>);</span><br><span class="line">    <span class="type">ConstructorAccessor</span> <span class="variable">ca</span> <span class="operator">=</span> constructorAccessor;   <span class="comment">// read volatile</span></span><br><span class="line">    <span class="keyword">if</span> (ca == <span class="literal">null</span>) &#123;</span><br><span class="line">        ca = acquireConstructorAccessor();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">    <span class="type">T</span> <span class="variable">inst</span> <span class="operator">=</span> (T) ca.newInstance(initargs);</span><br><span class="line">    <span class="keyword">return</span> inst;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// sun.reflect.DelegatingConstructorAccessorImpl</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">newInstance</span><span class="params">(Object[] args)</span></span><br><span class="line">  <span class="keyword">throws</span> InstantiationException,</span><br><span class="line">         IllegalArgumentException,</span><br><span class="line">         InvocationTargetException</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> delegate.newInstance(args);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// sun.reflect.NativeConstructorAccessorImpl</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">newInstance</span><span class="params">(Object[] args)</span></span><br><span class="line">    <span class="keyword">throws</span> InstantiationException,</span><br><span class="line">           IllegalArgumentException,</span><br><span class="line">           InvocationTargetException</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// We can&#x27;t inflate a constructor belonging to a vm-anonymous class</span></span><br><span class="line">    <span class="comment">// because that kind of class can&#x27;t be referred to by name, hence can&#x27;t</span></span><br><span class="line">    <span class="comment">// be found from the generated bytecode.</span></span><br><span class="line">    <span class="keyword">if</span> (++numInvocations &gt; ReflectionFactory.inflationThreshold()</span><br><span class="line">            &amp;&amp; !ReflectUtil.isVMAnonymousClass(c.getDeclaringClass())) &#123;</span><br><span class="line">        <span class="type">ConstructorAccessorImpl</span> <span class="variable">acc</span> <span class="operator">=</span> (ConstructorAccessorImpl)</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">MethodAccessorGenerator</span>().</span><br><span class="line">                generateConstructor(c.getDeclaringClass(),</span><br><span class="line">                                    c.getParameterTypes(),</span><br><span class="line">                                    c.getExceptionTypes(),</span><br><span class="line">                                    c.getModifiers());</span><br><span class="line">        parent.setDelegate(acc);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用native方法，进行调用 constructor</span></span><br><span class="line">    <span class="keyword">return</span> newInstance0(c, args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>返回构造器的实例后，可以根据外部进行进行类型转换，从而使用接口或方法进行调用实例功能了。</p>
<h4 id="反射获取方法"><a href="#反射获取方法" class="headerlink" title="反射获取方法"></a>反射获取方法</h4><ul>
<li><strong>第一步，先获取 Method</strong>;</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// java.lang.Class</span></span><br><span class="line"><span class="meta">@CallerSensitive</span></span><br><span class="line"><span class="keyword">public</span> Method <span class="title function_">getDeclaredMethod</span><span class="params">(String name, Class&lt;?&gt;... parameterTypes)</span></span><br><span class="line">    <span class="keyword">throws</span> NoSuchMethodException, SecurityException &#123;</span><br><span class="line">    checkMemberAccess(Member.DECLARED, Reflection.getCallerClass(), <span class="literal">true</span>);</span><br><span class="line">    <span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> searchMethods(privateGetDeclaredMethods(<span class="literal">false</span>), name, parameterTypes);</span><br><span class="line">    <span class="keyword">if</span> (method == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NoSuchMethodException</span>(getName() + <span class="string">&quot;.&quot;</span> + name + argumentTypesToString(parameterTypes));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> method;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>忽略第一个检查权限，剩下就只有两个动作了。</p>
<ul>
<li><ol>
<li>获取所有方法列表；</li>
</ol>
</li>
<li><ol>
<li>根据方法名称和方法列表，选出符合要求的方法；</li>
</ol>
</li>
<li><ol>
<li>如果没有找到相应方法，抛出异常，否则返回对应方法；</li>
</ol>
</li>
</ul>
<p>所以，先看一下怎样获取类声明的所有方法？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Returns an array of &quot;root&quot; methods. These Method objects must NOT</span></span><br><span class="line"><span class="comment">// be propagated to the outside world, but must instead be copied</span></span><br><span class="line"><span class="comment">// via ReflectionFactory.copyMethod.</span></span><br><span class="line"><span class="keyword">private</span> Method[] privateGetDeclaredMethods(<span class="type">boolean</span> publicOnly) &#123;</span><br><span class="line">    checkInitted();</span><br><span class="line">    Method[] res;</span><br><span class="line">    ReflectionData&lt;T&gt; rd = reflectionData();</span><br><span class="line">    <span class="keyword">if</span> (rd != <span class="literal">null</span>) &#123;</span><br><span class="line">        res = publicOnly ? rd.declaredPublicMethods : rd.declaredMethods;</span><br><span class="line">        <span class="keyword">if</span> (res != <span class="literal">null</span>) <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// No cached value available; request value from VM</span></span><br><span class="line">    res = Reflection.filterMethods(<span class="built_in">this</span>, getDeclaredMethods0(publicOnly));</span><br><span class="line">    <span class="keyword">if</span> (rd != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (publicOnly) &#123;</span><br><span class="line">            rd.declaredPublicMethods = res;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            rd.declaredMethods = res;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>很相似，和获取所有构造器的方法很相似，都是先从缓存中获取方法，如果没有，则从jvm中获取。</p>
<p>不同的是，方法列表需要进行过滤 Reflection.filterMethods;当然后面看来，这个方法我们一般不会派上用场。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// sun.misc.Reflection</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Method[] filterMethods(Class&lt;?&gt; containingClass, Method[] methods) &#123;</span><br><span class="line">    <span class="keyword">if</span> (methodFilterMap == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// Bootstrapping</span></span><br><span class="line">        <span class="keyword">return</span> methods;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (Method[])filter(methods, methodFilterMap.get(containingClass));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 可以过滤指定的方法，一般为空，如果要指定过滤，可以调用 registerMethodsToFilter(), 或者...</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Member[] filter(Member[] members, String[] filteredNames) &#123;</span><br><span class="line">    <span class="keyword">if</span> ((filteredNames == <span class="literal">null</span>) || (members.length == <span class="number">0</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> members;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">numNewMembers</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (Member member : members) &#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">shouldSkip</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (String filteredName : filteredNames) &#123;</span><br><span class="line">            <span class="keyword">if</span> (member.getName() == filteredName) &#123;</span><br><span class="line">                shouldSkip = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!shouldSkip) &#123;</span><br><span class="line">            ++numNewMembers;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Member[] newMembers =</span><br><span class="line">        (Member[])Array.newInstance(members[<span class="number">0</span>].getClass(), numNewMembers);</span><br><span class="line">    <span class="type">int</span> <span class="variable">destIdx</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (Member member : members) &#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">shouldSkip</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (String filteredName : filteredNames) &#123;</span><br><span class="line">            <span class="keyword">if</span> (member.getName() == filteredName) &#123;</span><br><span class="line">                shouldSkip = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!shouldSkip) &#123;</span><br><span class="line">            newMembers[destIdx++] = member;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newMembers;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>第二步，根据方法名和参数类型过滤指定方法返回</strong>：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Method <span class="title function_">searchMethods</span><span class="params">(Method[] methods,</span></span><br><span class="line"><span class="params">                                    String name,</span></span><br><span class="line"><span class="params">                                    Class&lt;?&gt;[] parameterTypes)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">Method</span> <span class="variable">res</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">// 使用常量池，避免重复创建String</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">internedName</span> <span class="operator">=</span> name.intern();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; methods.length; i++) &#123;</span><br><span class="line">        <span class="type">Method</span> <span class="variable">m</span> <span class="operator">=</span> methods[i];</span><br><span class="line">        <span class="keyword">if</span> (m.getName() == internedName</span><br><span class="line">            &amp;&amp; arrayContentsEq(parameterTypes, m.getParameterTypes())</span><br><span class="line">            &amp;&amp; (res == <span class="literal">null</span></span><br><span class="line">                || res.getReturnType().isAssignableFrom(m.getReturnType())))</span><br><span class="line">            res = m;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (res == <span class="literal">null</span> ? res : getReflectionFactory().copyMethod(res));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>大概意思看得明白，就是匹配到方法名，然后参数类型匹配，才可以。</p>
<ul>
<li>但是可以看到，匹配到一个方法，并没有退出for循环，而是继续进行匹配。</li>
<li>这里是匹配最精确的子类进行返回（最优匹配）</li>
<li>最后，还是通过 ReflectionFactory, copy 方法后返回。</li>
</ul>
<h4 id="调用-method-invoke-方法"><a href="#调用-method-invoke-方法" class="headerlink" title="调用 method.invoke() 方法"></a>调用 method.invoke() 方法</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@CallerSensitive</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object obj, Object... args)</span></span><br><span class="line">    <span class="keyword">throws</span> IllegalAccessException, IllegalArgumentException,</span><br><span class="line">       InvocationTargetException</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!override) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!Reflection.quickCheckMemberAccess(clazz, modifiers)) &#123;</span><br><span class="line">            Class&lt;?&gt; caller = Reflection.getCallerClass();</span><br><span class="line">            checkAccess(caller, clazz, obj, modifiers);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">MethodAccessor</span> <span class="variable">ma</span> <span class="operator">=</span> methodAccessor;             <span class="comment">// read volatile</span></span><br><span class="line">    <span class="keyword">if</span> (ma == <span class="literal">null</span>) &#123;</span><br><span class="line">        ma = acquireMethodAccessor();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ma.invoke(obj, args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>invoke时，是通过 MethodAccessor 进行调用的，而 MethodAccessor 是个接口，在第一次时调用 acquireMethodAccessor() 进行新创建。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// probably make the implementation more scalable.</span></span><br><span class="line"><span class="keyword">private</span> MethodAccessor <span class="title function_">acquireMethodAccessor</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// First check to see if one has been created yet, and take it</span></span><br><span class="line">    <span class="comment">// if so</span></span><br><span class="line">    <span class="type">MethodAccessor</span> <span class="variable">tmp</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (root != <span class="literal">null</span>) tmp = root.getMethodAccessor();</span><br><span class="line">    <span class="keyword">if</span> (tmp != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 存在缓存时，存入 methodAccessor，否则调用 ReflectionFactory 创建新的 MethodAccessor</span></span><br><span class="line">        methodAccessor = tmp;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Otherwise fabricate one and propagate it up to the root</span></span><br><span class="line">        tmp = reflectionFactory.newMethodAccessor(<span class="built_in">this</span>);</span><br><span class="line">        setMethodAccessor(tmp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// sun.reflect.ReflectionFactory</span></span><br><span class="line"><span class="keyword">public</span> MethodAccessor <span class="title function_">newMethodAccessor</span><span class="params">(Method method)</span> &#123;</span><br><span class="line">    checkInitted();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (noInflation &amp;&amp; !ReflectUtil.isVMAnonymousClass(method.getDeclaringClass())) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MethodAccessorGenerator</span>().</span><br><span class="line">            generateMethod(method.getDeclaringClass(),</span><br><span class="line">                           method.getName(),</span><br><span class="line">                           method.getParameterTypes(),</span><br><span class="line">                           method.getReturnType(),</span><br><span class="line">                           method.getExceptionTypes(),</span><br><span class="line">                           method.getModifiers());</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="type">NativeMethodAccessorImpl</span> <span class="variable">acc</span> <span class="operator">=</span></span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">NativeMethodAccessorImpl</span>(method);</span><br><span class="line">        <span class="type">DelegatingMethodAccessorImpl</span> <span class="variable">res</span> <span class="operator">=</span></span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">DelegatingMethodAccessorImpl</span>(acc);</span><br><span class="line">        acc.setParent(res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>两个Accessor详情：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//     NativeMethodAccessorImpl / DelegatingMethodAccessorImpl</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NativeMethodAccessorImpl</span> <span class="keyword">extends</span> <span class="title class_">MethodAccessorImpl</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Method method;</span><br><span class="line">    <span class="keyword">private</span> DelegatingMethodAccessorImpl parent;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> numInvocations;</span><br><span class="line"></span><br><span class="line">    NativeMethodAccessorImpl(Method method) &#123;</span><br><span class="line">        <span class="built_in">this</span>.method = method;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object obj, Object[] args)</span></span><br><span class="line">        <span class="keyword">throws</span> IllegalArgumentException, InvocationTargetException</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// We can&#x27;t inflate methods belonging to vm-anonymous classes because</span></span><br><span class="line">        <span class="comment">// that kind of class can&#x27;t be referred to by name, hence can&#x27;t be</span></span><br><span class="line">        <span class="comment">// found from the generated bytecode.</span></span><br><span class="line">        <span class="keyword">if</span> (++numInvocations &gt; ReflectionFactory.inflationThreshold()</span><br><span class="line">                &amp;&amp; !ReflectUtil.isVMAnonymousClass(method.getDeclaringClass())) &#123;</span><br><span class="line">            <span class="type">MethodAccessorImpl</span> <span class="variable">acc</span> <span class="operator">=</span> (MethodAccessorImpl)</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">MethodAccessorGenerator</span>().</span><br><span class="line">                    generateMethod(method.getDeclaringClass(),</span><br><span class="line">                                   method.getName(),</span><br><span class="line">                                   method.getParameterTypes(),</span><br><span class="line">                                   method.getReturnType(),</span><br><span class="line">                                   method.getExceptionTypes(),</span><br><span class="line">                                   method.getModifiers());</span><br><span class="line">            parent.setDelegate(acc);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> invoke0(method, obj, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">setParent</span><span class="params">(DelegatingMethodAccessorImpl parent)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.parent = parent;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">native</span> Object <span class="title function_">invoke0</span><span class="params">(Method m, Object obj, Object[] args)</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DelegatingMethodAccessorImpl</span> <span class="keyword">extends</span> <span class="title class_">MethodAccessorImpl</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> MethodAccessorImpl delegate;</span><br><span class="line"></span><br><span class="line">    DelegatingMethodAccessorImpl(MethodAccessorImpl delegate) &#123;</span><br><span class="line">        setDelegate(delegate);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object obj, Object[] args)</span></span><br><span class="line">        <span class="keyword">throws</span> IllegalArgumentException, InvocationTargetException</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> delegate.invoke(obj, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">setDelegate</span><span class="params">(MethodAccessorImpl delegate)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.delegate = delegate;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>进行 ma.invoke(obj, args); 调用时，调用 DelegatingMethodAccessorImpl.invoke();</p>
<p>最后被委托到 NativeMethodAccessorImpl.invoke(), 即：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object obj, Object[] args)</span></span><br><span class="line">    <span class="keyword">throws</span> IllegalArgumentException, InvocationTargetException</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// We can&#x27;t inflate methods belonging to vm-anonymous classes because</span></span><br><span class="line">    <span class="comment">// that kind of class can&#x27;t be referred to by name, hence can&#x27;t be</span></span><br><span class="line">    <span class="comment">// found from the generated bytecode.</span></span><br><span class="line">    <span class="keyword">if</span> (++numInvocations &gt; ReflectionFactory.inflationThreshold()</span><br><span class="line">            &amp;&amp; !ReflectUtil.isVMAnonymousClass(method.getDeclaringClass())) &#123;</span><br><span class="line">        <span class="type">MethodAccessorImpl</span> <span class="variable">acc</span> <span class="operator">=</span> (MethodAccessorImpl)</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">MethodAccessorGenerator</span>().</span><br><span class="line">                generateMethod(method.getDeclaringClass(),</span><br><span class="line">                               method.getName(),</span><br><span class="line">                               method.getParameterTypes(),</span><br><span class="line">                               method.getReturnType(),</span><br><span class="line">                               method.getExceptionTypes(),</span><br><span class="line">                               method.getModifiers());</span><br><span class="line">        parent.setDelegate(acc);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// invoke0 是个 native 方法，由jvm进行调用业务方法。从而完成反射调用功能。</span></span><br><span class="line">    <span class="keyword">return</span> invoke0(method, obj, args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中， generateMethod() 是生成具体类的方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** This routine is not thread-safe */</span></span><br><span class="line"><span class="keyword">public</span> MethodAccessor <span class="title function_">generateMethod</span><span class="params">(Class&lt;?&gt; declaringClass,</span></span><br><span class="line"><span class="params">                                     String   name,</span></span><br><span class="line"><span class="params">                                     Class&lt;?&gt;[] parameterTypes,</span></span><br><span class="line"><span class="params">                                     Class&lt;?&gt;   returnType,</span></span><br><span class="line"><span class="params">                                     Class&lt;?&gt;[] checkedExceptions,</span></span><br><span class="line"><span class="params">                                     <span class="type">int</span> modifiers)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> (MethodAccessor) generate(declaringClass,</span><br><span class="line">                                     name,</span><br><span class="line">                                     parameterTypes,</span><br><span class="line">                                     returnType,</span><br><span class="line">                                     checkedExceptions,</span><br><span class="line">                                     modifiers,</span><br><span class="line">                                     <span class="literal">false</span>,</span><br><span class="line">                                     <span class="literal">false</span>,</span><br><span class="line">                                     <span class="literal">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>generate() 戳详情。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** This routine is not thread-safe */</span></span><br><span class="line"><span class="keyword">private</span> MagicAccessorImpl <span class="title function_">generate</span><span class="params">(<span class="keyword">final</span> Class&lt;?&gt; declaringClass,</span></span><br><span class="line"><span class="params">                                   String name,</span></span><br><span class="line"><span class="params">                                   Class&lt;?&gt;[] parameterTypes,</span></span><br><span class="line"><span class="params">                                   Class&lt;?&gt;   returnType,</span></span><br><span class="line"><span class="params">                                   Class&lt;?&gt;[] checkedExceptions,</span></span><br><span class="line"><span class="params">                                   <span class="type">int</span> modifiers,</span></span><br><span class="line"><span class="params">                                   <span class="type">boolean</span> isConstructor,</span></span><br><span class="line"><span class="params">                                   <span class="type">boolean</span> forSerialization,</span></span><br><span class="line"><span class="params">                                   Class&lt;?&gt; serializationTargetClass)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">ByteVector</span> <span class="variable">vec</span> <span class="operator">=</span> ByteVectorFactory.create();</span><br><span class="line">    asm = <span class="keyword">new</span> <span class="title class_">ClassFileAssembler</span>(vec);</span><br><span class="line">    <span class="built_in">this</span>.declaringClass = declaringClass;</span><br><span class="line">    <span class="built_in">this</span>.parameterTypes = parameterTypes;</span><br><span class="line">    <span class="built_in">this</span>.returnType = returnType;</span><br><span class="line">    <span class="built_in">this</span>.modifiers = modifiers;</span><br><span class="line">    <span class="built_in">this</span>.isConstructor = isConstructor;</span><br><span class="line">    <span class="built_in">this</span>.forSerialization = forSerialization;</span><br><span class="line"></span><br><span class="line">    asm.emitMagicAndVersion();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Constant pool entries:</span></span><br><span class="line">    <span class="comment">// ( * = Boxing information: optional)</span></span><br><span class="line">    <span class="comment">// (+  = Shared entries provided by AccessorGenerator)</span></span><br><span class="line">    <span class="comment">// (^  = Only present if generating SerializationConstructorAccessor)</span></span><br><span class="line">    <span class="comment">//     [UTF-8] [This class&#x27;s name]</span></span><br><span class="line">    <span class="comment">//     [CONSTANT_Class_info] for above</span></span><br><span class="line">    <span class="comment">//     [UTF-8] &quot;sun/reflect/&#123;MethodAccessorImpl,ConstructorAccessorImpl,SerializationConstructorAccessorImpl&#125;&quot;</span></span><br><span class="line">    <span class="comment">//     [CONSTANT_Class_info] for above</span></span><br><span class="line">    <span class="comment">//     [UTF-8] [Target class&#x27;s name]</span></span><br><span class="line">    <span class="comment">//     [CONSTANT_Class_info] for above</span></span><br><span class="line">    <span class="comment">// ^   [UTF-8] [Serialization: Class&#x27;s name in which to invoke constructor]</span></span><br><span class="line">    <span class="comment">// ^   [CONSTANT_Class_info] for above</span></span><br><span class="line">    <span class="comment">//     [UTF-8] target method or constructor name</span></span><br><span class="line">    <span class="comment">//     [UTF-8] target method or constructor signature</span></span><br><span class="line">    <span class="comment">//     [CONSTANT_NameAndType_info] for above</span></span><br><span class="line">    <span class="comment">//     [CONSTANT_Methodref_info or CONSTANT_InterfaceMethodref_info] for target method</span></span><br><span class="line">    <span class="comment">//     [UTF-8] &quot;invoke&quot; or &quot;newInstance&quot;</span></span><br><span class="line">    <span class="comment">//     [UTF-8] invoke or newInstance descriptor</span></span><br><span class="line">    <span class="comment">//     [UTF-8] descriptor for type of non-primitive parameter 1</span></span><br><span class="line">    <span class="comment">//     [CONSTANT_Class_info] for type of non-primitive parameter 1</span></span><br><span class="line">    <span class="comment">//     ...</span></span><br><span class="line">    <span class="comment">//     [UTF-8] descriptor for type of non-primitive parameter n</span></span><br><span class="line">    <span class="comment">//     [CONSTANT_Class_info] for type of non-primitive parameter n</span></span><br><span class="line">    <span class="comment">// +   [UTF-8] &quot;java/lang/Exception&quot;</span></span><br><span class="line">    <span class="comment">// +   [CONSTANT_Class_info] for above</span></span><br><span class="line">    <span class="comment">// +   [UTF-8] &quot;java/lang/ClassCastException&quot;</span></span><br><span class="line">    <span class="comment">// +   [CONSTANT_Class_info] for above</span></span><br><span class="line">    <span class="comment">// +   [UTF-8] &quot;java/lang/NullPointerException&quot;</span></span><br><span class="line">    <span class="comment">// +   [CONSTANT_Class_info] for above</span></span><br><span class="line">    <span class="comment">// +   [UTF-8] &quot;java/lang/IllegalArgumentException&quot;</span></span><br><span class="line">    <span class="comment">// +   [CONSTANT_Class_info] for above</span></span><br><span class="line">    <span class="comment">// +   [UTF-8] &quot;java/lang/InvocationTargetException&quot;</span></span><br><span class="line">    <span class="comment">// +   [CONSTANT_Class_info] for above</span></span><br><span class="line">    <span class="comment">// +   [UTF-8] &quot;&lt;init&gt;&quot;</span></span><br><span class="line">    <span class="comment">// +   [UTF-8] &quot;()V&quot;</span></span><br><span class="line">    <span class="comment">// +   [CONSTANT_NameAndType_info] for above</span></span><br><span class="line">    <span class="comment">// +   [CONSTANT_Methodref_info] for NullPointerException&#x27;s constructor</span></span><br><span class="line">    <span class="comment">// +   [CONSTANT_Methodref_info] for IllegalArgumentException&#x27;s constructor</span></span><br><span class="line">    <span class="comment">// +   [UTF-8] &quot;(Ljava/lang/String;)V&quot;</span></span><br><span class="line">    <span class="comment">// +   [CONSTANT_NameAndType_info] for &quot;&lt;init&gt;(Ljava/lang/String;)V&quot;</span></span><br><span class="line">    <span class="comment">// +   [CONSTANT_Methodref_info] for IllegalArgumentException&#x27;s constructor taking a String</span></span><br><span class="line">    <span class="comment">// +   [UTF-8] &quot;(Ljava/lang/Throwable;)V&quot;</span></span><br><span class="line">    <span class="comment">// +   [CONSTANT_NameAndType_info] for &quot;&lt;init&gt;(Ljava/lang/Throwable;)V&quot;</span></span><br><span class="line">    <span class="comment">// +   [CONSTANT_Methodref_info] for InvocationTargetException&#x27;s constructor</span></span><br><span class="line">    <span class="comment">// +   [CONSTANT_Methodref_info] for &quot;super()&quot;</span></span><br><span class="line">    <span class="comment">// +   [UTF-8] &quot;java/lang/Object&quot;</span></span><br><span class="line">    <span class="comment">// +   [CONSTANT_Class_info] for above</span></span><br><span class="line">    <span class="comment">// +   [UTF-8] &quot;toString&quot;</span></span><br><span class="line">    <span class="comment">// +   [UTF-8] &quot;()Ljava/lang/String;&quot;</span></span><br><span class="line">    <span class="comment">// +   [CONSTANT_NameAndType_info] for &quot;toString()Ljava/lang/String;&quot;</span></span><br><span class="line">    <span class="comment">// +   [CONSTANT_Methodref_info] for Object&#x27;s toString method</span></span><br><span class="line">    <span class="comment">// +   [UTF-8] &quot;Code&quot;</span></span><br><span class="line">    <span class="comment">// +   [UTF-8] &quot;Exceptions&quot;</span></span><br><span class="line">    <span class="comment">//  *  [UTF-8] &quot;java/lang/Boolean&quot;</span></span><br><span class="line">    <span class="comment">//  *  [CONSTANT_Class_info] for above</span></span><br><span class="line">    <span class="comment">//  *  [UTF-8] &quot;(Z)V&quot;</span></span><br><span class="line">    <span class="comment">//  *  [CONSTANT_NameAndType_info] for above</span></span><br><span class="line">    <span class="comment">//  *  [CONSTANT_Methodref_info] for above</span></span><br><span class="line">    <span class="comment">//  *  [UTF-8] &quot;booleanValue&quot;</span></span><br><span class="line">    <span class="comment">//  *  [UTF-8] &quot;()Z&quot;</span></span><br><span class="line">    <span class="comment">//  *  [CONSTANT_NameAndType_info] for above</span></span><br><span class="line">    <span class="comment">//  *  [CONSTANT_Methodref_info] for above</span></span><br><span class="line">    <span class="comment">//  *  [UTF-8] &quot;java/lang/Byte&quot;</span></span><br><span class="line">    <span class="comment">//  *  [CONSTANT_Class_info] for above</span></span><br><span class="line">    <span class="comment">//  *  [UTF-8] &quot;(B)V&quot;</span></span><br><span class="line">    <span class="comment">//  *  [CONSTANT_NameAndType_info] for above</span></span><br><span class="line">    <span class="comment">//  *  [CONSTANT_Methodref_info] for above</span></span><br><span class="line">    <span class="comment">//  *  [UTF-8] &quot;byteValue&quot;</span></span><br><span class="line">    <span class="comment">//  *  [UTF-8] &quot;()B&quot;</span></span><br><span class="line">    <span class="comment">//  *  [CONSTANT_NameAndType_info] for above</span></span><br><span class="line">    <span class="comment">//  *  [CONSTANT_Methodref_info] for above</span></span><br><span class="line">    <span class="comment">//  *  [UTF-8] &quot;java/lang/Character&quot;</span></span><br><span class="line">    <span class="comment">//  *  [CONSTANT_Class_info] for above</span></span><br><span class="line">    <span class="comment">//  *  [UTF-8] &quot;(C)V&quot;</span></span><br><span class="line">    <span class="comment">//  *  [CONSTANT_NameAndType_info] for above</span></span><br><span class="line">    <span class="comment">//  *  [CONSTANT_Methodref_info] for above</span></span><br><span class="line">    <span class="comment">//  *  [UTF-8] &quot;charValue&quot;</span></span><br><span class="line">    <span class="comment">//  *  [UTF-8] &quot;()C&quot;</span></span><br><span class="line">    <span class="comment">//  *  [CONSTANT_NameAndType_info] for above</span></span><br><span class="line">    <span class="comment">//  *  [CONSTANT_Methodref_info] for above</span></span><br><span class="line">    <span class="comment">//  *  [UTF-8] &quot;java/lang/Double&quot;</span></span><br><span class="line">    <span class="comment">//  *  [CONSTANT_Class_info] for above</span></span><br><span class="line">    <span class="comment">//  *  [UTF-8] &quot;(D)V&quot;</span></span><br><span class="line">    <span class="comment">//  *  [CONSTANT_NameAndType_info] for above</span></span><br><span class="line">    <span class="comment">//  *  [CONSTANT_Methodref_info] for above</span></span><br><span class="line">    <span class="comment">//  *  [UTF-8] &quot;doubleValue&quot;</span></span><br><span class="line">    <span class="comment">//  *  [UTF-8] &quot;()D&quot;</span></span><br><span class="line">    <span class="comment">//  *  [CONSTANT_NameAndType_info] for above</span></span><br><span class="line">    <span class="comment">//  *  [CONSTANT_Methodref_info] for above</span></span><br><span class="line">    <span class="comment">//  *  [UTF-8] &quot;java/lang/Float&quot;</span></span><br><span class="line">    <span class="comment">//  *  [CONSTANT_Class_info] for above</span></span><br><span class="line">    <span class="comment">//  *  [UTF-8] &quot;(F)V&quot;</span></span><br><span class="line">    <span class="comment">//  *  [CONSTANT_NameAndType_info] for above</span></span><br><span class="line">    <span class="comment">//  *  [CONSTANT_Methodref_info] for above</span></span><br><span class="line">    <span class="comment">//  *  [UTF-8] &quot;floatValue&quot;</span></span><br><span class="line">    <span class="comment">//  *  [UTF-8] &quot;()F&quot;</span></span><br><span class="line">    <span class="comment">//  *  [CONSTANT_NameAndType_info] for above</span></span><br><span class="line">    <span class="comment">//  *  [CONSTANT_Methodref_info] for above</span></span><br><span class="line">    <span class="comment">//  *  [UTF-8] &quot;java/lang/Integer&quot;</span></span><br><span class="line">    <span class="comment">//  *  [CONSTANT_Class_info] for above</span></span><br><span class="line">    <span class="comment">//  *  [UTF-8] &quot;(I)V&quot;</span></span><br><span class="line">    <span class="comment">//  *  [CONSTANT_NameAndType_info] for above</span></span><br><span class="line">    <span class="comment">//  *  [CONSTANT_Methodref_info] for above</span></span><br><span class="line">    <span class="comment">//  *  [UTF-8] &quot;intValue&quot;</span></span><br><span class="line">    <span class="comment">//  *  [UTF-8] &quot;()I&quot;</span></span><br><span class="line">    <span class="comment">//  *  [CONSTANT_NameAndType_info] for above</span></span><br><span class="line">    <span class="comment">//  *  [CONSTANT_Methodref_info] for above</span></span><br><span class="line">    <span class="comment">//  *  [UTF-8] &quot;java/lang/Long&quot;</span></span><br><span class="line">    <span class="comment">//  *  [CONSTANT_Class_info] for above</span></span><br><span class="line">    <span class="comment">//  *  [UTF-8] &quot;(J)V&quot;</span></span><br><span class="line">    <span class="comment">//  *  [CONSTANT_NameAndType_info] for above</span></span><br><span class="line">    <span class="comment">//  *  [CONSTANT_Methodref_info] for above</span></span><br><span class="line">    <span class="comment">//  *  [UTF-8] &quot;longValue&quot;</span></span><br><span class="line">    <span class="comment">//  *  [UTF-8] &quot;()J&quot;</span></span><br><span class="line">    <span class="comment">//  *  [CONSTANT_NameAndType_info] for above</span></span><br><span class="line">    <span class="comment">//  *  [CONSTANT_Methodref_info] for above</span></span><br><span class="line">    <span class="comment">//  *  [UTF-8] &quot;java/lang/Short&quot;</span></span><br><span class="line">    <span class="comment">//  *  [CONSTANT_Class_info] for above</span></span><br><span class="line">    <span class="comment">//  *  [UTF-8] &quot;(S)V&quot;</span></span><br><span class="line">    <span class="comment">//  *  [CONSTANT_NameAndType_info] for above</span></span><br><span class="line">    <span class="comment">//  *  [CONSTANT_Methodref_info] for above</span></span><br><span class="line">    <span class="comment">//  *  [UTF-8] &quot;shortValue&quot;</span></span><br><span class="line">    <span class="comment">//  *  [UTF-8] &quot;()S&quot;</span></span><br><span class="line">    <span class="comment">//  *  [CONSTANT_NameAndType_info] for above</span></span><br><span class="line">    <span class="comment">//  *  [CONSTANT_Methodref_info] for above</span></span><br><span class="line"></span><br><span class="line">    <span class="type">short</span> <span class="variable">numCPEntries</span> <span class="operator">=</span> NUM_BASE_CPOOL_ENTRIES + NUM_COMMON_CPOOL_ENTRIES;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">usesPrimitives</span> <span class="operator">=</span> usesPrimitiveTypes();</span><br><span class="line">    <span class="keyword">if</span> (usesPrimitives) &#123;</span><br><span class="line">        numCPEntries += NUM_BOXING_CPOOL_ENTRIES;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (forSerialization) &#123;</span><br><span class="line">        numCPEntries += NUM_SERIALIZATION_CPOOL_ENTRIES;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Add in variable-length number of entries to be able to describe</span></span><br><span class="line">    <span class="comment">// non-primitive parameter types and checked exceptions.</span></span><br><span class="line">    numCPEntries += (<span class="type">short</span>) (<span class="number">2</span> * numNonPrimitiveParameterTypes());</span><br><span class="line"></span><br><span class="line">    asm.emitShort(add(numCPEntries, S1));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="type">String</span> <span class="variable">generatedName</span> <span class="operator">=</span> generateName(isConstructor, forSerialization);</span><br><span class="line">    asm.emitConstantPoolUTF8(generatedName);</span><br><span class="line">    asm.emitConstantPoolClass(asm.cpi());</span><br><span class="line">    thisClass = asm.cpi();</span><br><span class="line">    <span class="keyword">if</span> (isConstructor) &#123;</span><br><span class="line">        <span class="keyword">if</span> (forSerialization) &#123;</span><br><span class="line">            asm.emitConstantPoolUTF8</span><br><span class="line">                (<span class="string">&quot;sun/reflect/SerializationConstructorAccessorImpl&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            asm.emitConstantPoolUTF8(<span class="string">&quot;sun/reflect/ConstructorAccessorImpl&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        asm.emitConstantPoolUTF8(<span class="string">&quot;sun/reflect/MethodAccessorImpl&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    asm.emitConstantPoolClass(asm.cpi());</span><br><span class="line">    superClass = asm.cpi();</span><br><span class="line">    asm.emitConstantPoolUTF8(getClassName(declaringClass, <span class="literal">false</span>));</span><br><span class="line">    asm.emitConstantPoolClass(asm.cpi());</span><br><span class="line">    targetClass = asm.cpi();</span><br><span class="line">    <span class="type">short</span> <span class="variable">serializationTargetClassIdx</span> <span class="operator">=</span> (<span class="type">short</span>) <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (forSerialization) &#123;</span><br><span class="line">        asm.emitConstantPoolUTF8(getClassName(serializationTargetClass, <span class="literal">false</span>));</span><br><span class="line">        asm.emitConstantPoolClass(asm.cpi());</span><br><span class="line">        serializationTargetClassIdx = asm.cpi();</span><br><span class="line">    &#125;</span><br><span class="line">    asm.emitConstantPoolUTF8(name);</span><br><span class="line">    asm.emitConstantPoolUTF8(buildInternalSignature());</span><br><span class="line">    asm.emitConstantPoolNameAndType(sub(asm.cpi(), S1), asm.cpi());</span><br><span class="line">    <span class="keyword">if</span> (isInterface()) &#123;</span><br><span class="line">        asm.emitConstantPoolInterfaceMethodref(targetClass, asm.cpi());</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (forSerialization) &#123;</span><br><span class="line">            asm.emitConstantPoolMethodref(serializationTargetClassIdx, asm.cpi());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            asm.emitConstantPoolMethodref(targetClass, asm.cpi());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    targetMethodRef = asm.cpi();</span><br><span class="line">    <span class="keyword">if</span> (isConstructor) &#123;</span><br><span class="line">        asm.emitConstantPoolUTF8(<span class="string">&quot;newInstance&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        asm.emitConstantPoolUTF8(<span class="string">&quot;invoke&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    invokeIdx = asm.cpi();</span><br><span class="line">    <span class="keyword">if</span> (isConstructor) &#123;</span><br><span class="line">        asm.emitConstantPoolUTF8(<span class="string">&quot;([Ljava/lang/Object;)Ljava/lang/Object;&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        asm.emitConstantPoolUTF8</span><br><span class="line">            (<span class="string">&quot;(Ljava/lang/Object;[Ljava/lang/Object;)Ljava/lang/Object;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    invokeDescriptorIdx = asm.cpi();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Output class information for non-primitive parameter types</span></span><br><span class="line">    nonPrimitiveParametersBaseIdx = add(asm.cpi(), S2);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; parameterTypes.length; i++) &#123;</span><br><span class="line">        Class&lt;?&gt; c = parameterTypes[i];</span><br><span class="line">        <span class="keyword">if</span> (!isPrimitive(c)) &#123;</span><br><span class="line">            asm.emitConstantPoolUTF8(getClassName(c, <span class="literal">false</span>));</span><br><span class="line">            asm.emitConstantPoolClass(asm.cpi());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Entries common to FieldAccessor, MethodAccessor and ConstructorAccessor</span></span><br><span class="line">    emitCommonConstantPoolEntries();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Boxing entries</span></span><br><span class="line">    <span class="keyword">if</span> (usesPrimitives) &#123;</span><br><span class="line">        emitBoxingContantPoolEntries();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (asm.cpi() != numCPEntries) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InternalError</span>(<span class="string">&quot;Adjust this code (cpi = &quot;</span> + asm.cpi() +</span><br><span class="line">                                <span class="string">&quot;, numCPEntries = &quot;</span> + numCPEntries + <span class="string">&quot;)&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Access flags</span></span><br><span class="line">    asm.emitShort(ACC_PUBLIC);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// This class</span></span><br><span class="line">    asm.emitShort(thisClass);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Superclass</span></span><br><span class="line">    asm.emitShort(superClass);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Interfaces count and interfaces</span></span><br><span class="line">    asm.emitShort(S0);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Fields count and fields</span></span><br><span class="line">    asm.emitShort(S0);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Methods count and methods</span></span><br><span class="line">    asm.emitShort(NUM_METHODS);</span><br><span class="line"></span><br><span class="line">    emitConstructor();</span><br><span class="line">    emitInvoke();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Additional attributes (none)</span></span><br><span class="line">    asm.emitShort(S0);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Load class</span></span><br><span class="line">    vec.trim();</span><br><span class="line">    <span class="keyword">final</span> <span class="type">byte</span>[] bytes = vec.getData();</span><br><span class="line">    <span class="comment">// Note: the class loader is the only thing that really matters</span></span><br><span class="line">    <span class="comment">// here -- it&#x27;s important to get the generated code into the</span></span><br><span class="line">    <span class="comment">// same namespace as the target class. Since the generated code</span></span><br><span class="line">    <span class="comment">// is privileged anyway, the protection domain probably doesn&#x27;t</span></span><br><span class="line">    <span class="comment">// matter.</span></span><br><span class="line">    <span class="keyword">return</span> AccessController.doPrivileged(</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">PrivilegedAction</span>&lt;MagicAccessorImpl&gt;() &#123;</span><br><span class="line">            <span class="keyword">public</span> MagicAccessorImpl <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> (MagicAccessorImpl)</span><br><span class="line">                    ClassDefiner.defineClass</span><br><span class="line">                            (generatedName,</span><br><span class="line">                             bytes,</span><br><span class="line">                             <span class="number">0</span>,</span><br><span class="line">                             bytes.length,</span><br><span class="line">                             declaringClass.getClassLoader()).newInstance();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InstantiationException | IllegalAccessException e) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InternalError</span>(e);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>咱们主要看这一句：<code>ClassDefiner.defineClass(xx, declaringClass.getClassLoader()).newInstance()</code>;</p>
<p>在<code>ClassDefiner.defineClass</code>方法实现中，每被调用一次都会生成一个DelegatingClassLoader类加载器对象 ，这里每次都生成新的类加载器，是为了性能考虑，在某些情况下可以卸载这些生成的类，因为类的卸载是只有在类加载器可以被回收的情况下才会被回收的，如果用了原来的类加载器，那可能导致这些新创建的类一直无法被卸载。</p>
<p>而反射生成的类，有时候可能用了就可以卸载了，所以使用其独立的类加载器，从而使得更容易控制反射类的生命周期。</p>
<h3 id="反射调用流程小结"><a href="#反射调用流程小结" class="headerlink" title="反射调用流程小结"></a>反射调用流程小结</h3><p>最后，用几句话总结反射的实现原理：</p>
<ol>
<li>反射类及反射方法的获取，都是通过从列表中搜寻查找匹配的方法，所以查找性能会随类的大小方法多少而变化；</li>
<li>每个类都会有一个与之对应的Class实例，从而每个类都可以获取method反射方法，并作用到其他实例身上；</li>
<li>反射也是考虑了线程安全的，放心使用；</li>
<li>反射使用软引用relectionData缓存class信息，避免每次重新从jvm获取带来的开销；</li>
<li>反射调用多次生成新代理Accessor, 而通过字节码生存的则考虑了卸载功能，所以会使用独立的类加载器；</li>
<li>当找到需要的方法，都会copy一份出来，而不是使用原来的实例，从而保证数据隔离；</li>
<li>调度反射方法，最终是由jvm执行invoke0()执行；</li>
</ol>
]]></content>
      <categories>
        <category>java</category>
      </categories>
  </entry>
  <entry>
    <title>深入理解JVM</title>
    <url>/2022/04/20/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM/</url>
    <content><![CDATA[<h3 id="深入理解JVM"><a href="#深入理解JVM" class="headerlink" title="深入理解JVM"></a>深入理解JVM</h3><span id="more"></span>

<h3 id="1-什么是JVM？"><a href="#1-什么是JVM？" class="headerlink" title="1.什么是JVM？"></a>1.什么是JVM？</h3><p><strong>定义</strong>：Java Virtual Machine-java程序的运行环境（java二进制码的运行环境）</p>
<p><strong>好处</strong>：</p>
<ul>
<li>一次编写，到处运行</li>
<li>自动内存管理，垃圾回收功能</li>
<li>数组下标越界检查</li>
<li>多态</li>
</ul>
<p><strong>比较</strong>：JVM、JRE、JDK</p>
<p><img src="/../images/93.PNG" alt="93"></p>
<h3 id="2-常见的JVM"><a href="#2-常见的JVM" class="headerlink" title="2.常见的JVM"></a>2.常见的JVM</h3><p><img src="/../images/94.PNG" alt="94"></p>
<h3 id="3-学习路线"><a href="#3-学习路线" class="headerlink" title="3.学习路线"></a>3.学习路线</h3><p><img src="/../images/95.PNG" alt="95"></p>
<h3 id="4-内存结构"><a href="#4-内存结构" class="headerlink" title="4.内存结构"></a>4.内存结构</h3><h4 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a><strong>程序计数器</strong></h4><p><img src="/../images/96.PNG" alt="96"></p>
<p>定义：Program Counter Register，是一块较小的内存空间，可以看作是当前线程所执行的字节码的行号指示器。</p>
<p>作用：在jvm指令的执行过程中，记住下一条jvm指令的地址。</p>
<p><img src="/../images/97.PNG" alt="97"></p>
<p>流程：jvm指令 -&gt; 解释器 -&gt; 机器码 -&gt; cpu</p>
<p>特点：是线程私有的；不会存在内存溢出的区（OutOfMemoryError）</p>
<h4 id="虚拟机栈"><a href="#虚拟机栈" class="headerlink" title="虚拟机栈"></a><strong>虚拟机栈</strong></h4><p><img src="/../images/98.PNG" alt="98"></p>
<p>先进后出（FILO）</p>
<p><img src="/../images/99.PNG" alt="99"></p>
<p>当每个方法被调用到执行完毕的过程，就对应一个栈帧这在虚拟机栈中从入栈到出栈的过程。</p>
<p><strong>定义</strong>：Java Virtual Machine Stacks</p>
<ul>
<li>每个线程运行时所需要的内存，称为虚拟机栈</li>
<li>每个栈由多个栈帧组成，对应着每次方法调用时所占的内存</li>
<li>每个线程只能有一个活动栈帧，对应着当前正在执行的方法</li>
</ul>
<p>示例：</p>
<p><img src="/../images/100.PNG" alt="100"></p>
<p>问题辨析：</p>
<p>1.垃圾回收是否涉及栈内存？</p>
<p>2.栈内存分配越大越好吗？</p>
<p>3.方法内的局部变量是否线程安全？</p>
<ul>
<li>如果方法内的局部变量没有逃离方法作用范围，它是线程安全的。</li>
<li>如果是局部变量引用了对象，并逃离了方法的作用范围，需要考虑线程安全问题。</li>
</ul>
<p><strong>栈内存溢出</strong></p>
<ul>
<li>栈帧过多导致栈内存溢出（方法的递归调用，可以设置VM options&#x3D;-Xss256k）。</li>
<li>栈帧过大导致栈内存溢出。</li>
</ul>
<p><strong>线程运行诊断</strong></p>
<ul>
<li><p>cpu占用过多</p>
<p>用top定位哪个进程对cpu的占用过高。</p>
<p>ps H -eo pid，tid，%cpu | grep进程id（用ps命令进一步定位是哪个线程引起的cpu占用过高）。</p>
<p>jstack进程id：可以根据线程id找到有问题的线程，进一步定位到问题代码的源码行号。</p>
</li>
<li><p>程序运行时间很长。</p>
</li>
</ul>
<h4 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h4><p>给本地方法的运行提供内存空间。是为虚拟机使用的本地方法服务。</p>
<h4 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h4><p><strong>定义</strong></p>
<ul>
<li>通过new关键字，创建对象都会使用堆内存。</li>
<li>它是线程共享的，在虚拟机启动时创建，堆中对象都需要考虑线程安全的问题。</li>
<li>有垃圾回收机制。</li>
</ul>
<p><strong>堆内存溢出</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.tzd;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> tianzedeng</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2022/4/21 - 16:37</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 堆内存溢出</span></span><br><span class="line"><span class="comment"> * VM options： -Xmx8m</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo1</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">            <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">                list.add(s);</span><br><span class="line">                s = s + s;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Throwable e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            System.out.println(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>效果：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">java.lang.OutOfMemoryError: Java heap space</span><br><span class="line">	at java.util.Arrays.copyOf(Arrays.java:<span class="number">3332</span>)</span><br><span class="line">	at java.lang.AbstractStringBuilder.expandCapacity(AbstractStringBuilder.java:<span class="number">137</span>)</span><br><span class="line">	at java.lang.AbstractStringBuilder.ensureCapacityInternal(AbstractStringBuilder.java:<span class="number">121</span>)</span><br><span class="line">	at java.lang.AbstractStringBuilder.append(AbstractStringBuilder.java:<span class="number">421</span>)</span><br><span class="line">	at java.lang.StringBuilder.append(StringBuilder.java:<span class="number">136</span>)</span><br><span class="line">	at com.tzd.Demo1.main(Demo1.java:<span class="number">23</span>)</span><br><span class="line"><span class="number">22</span></span><br></pre></td></tr></table></figure>

<p><strong>堆内存诊断</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.tzd;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> tianzedeng</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2022/4/21 - 16:51</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 演示堆内存</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo2</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;1......&quot;</span>);</span><br><span class="line">        Thread.sleep(<span class="number">20000</span>);</span><br><span class="line">        <span class="type">byte</span>[] array = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>*<span class="number">1024</span>*<span class="number">10</span>];</span><br><span class="line">        System.out.println(<span class="string">&quot;2....&quot;</span>);</span><br><span class="line">        array = <span class="literal">null</span>;</span><br><span class="line">        System.gc();</span><br><span class="line">        System.out.println(<span class="string">&quot;3...&quot;</span>);</span><br><span class="line">        Thread.sleep(<span class="number">1000000L</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>jps工具：查看当前系统中有哪些java进程—–jps</p>
<p>jmap工具：查看堆内存占用情况—-jmap -heap 进程id</p>
<p>jconsole工具：图形界面的，多功能的检测工具，可以连续检测—–jconsole</p>
<p><strong>案例</strong></p>
<p>垃圾回收后，内存占用仍然很高</p>
<h4 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h4><p><strong>定义</strong>：</p>
<p><strong>组成</strong>：</p>
<p><img src="/../images/img1.PNG" alt="img1"></p>
<p><strong>方法区内存溢出</strong></p>
<p>1.8以前会导致永久代内存溢出</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">java.lang.OutOfMemoryError:PermGen space</span><br><span class="line">-XX:MaxPermSize=8m</span><br></pre></td></tr></table></figure>

<p>1.8以后会导致元空间内存溢出</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">java.lang.OutOfMemoryError:Metaspace</span><br><span class="line">-XX:MaxMetaspaceSize=8m</span><br></pre></td></tr></table></figure>

<p>场景</p>
<ul>
<li>spring</li>
<li>mybatis</li>
</ul>
<p><strong>运行时常量池</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> xxxxxx;</span><br><span class="line"><span class="comment">//二进制字节码（类基本信息，常量池，类定义方法，包含虚拟机指令）</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloWorld</span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//反编译</span><br><span class="line">javap -c HelloWorld.class</span><br></pre></td></tr></table></figure>

<ul>
<li>常量池，就是一张表，虚拟机指令根据这张常量表找到要执行的类名，方法名，参数类型，字面量等信息。</li>
<li>运行时常量池，常量池是*.class文件中的，当该类被加载，它的常量池信息就会放入运行时常量池，并把里面的符号地址变为真实地址。</li>
</ul>
<p><strong>StringTable</strong></p>
<p><img src="/../images/img2.PNG" alt="img2"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.tzd;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> tianzedeng</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2022/4/25 - 15:48</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//hashtable结构，不能扩容</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo3</span> &#123;</span><br><span class="line">    <span class="comment">//常量池中的信息，都会被加载到运行时常量池,这时a，b，ab都是常量池中的符号，还没有变为java字符串对象</span></span><br><span class="line">    <span class="comment">//ldc #2会把a符号变为“a”字符串对象</span></span><br><span class="line">    <span class="comment">//ldc #3会把a符号变为“b”字符串对象</span></span><br><span class="line">    <span class="comment">//ldc #4会把a符号变为“ab”字符串对象</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;a&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;b&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="string">&quot;ab&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">E:\Java\jdk1<span class="number">.8</span><span class="number">.0_66</span>\bin\javap.exe -verbose com.tzd.Demo3</span><br><span class="line">Classfile /G:/jvm/out/production/jvm/com/tzd/Demo3.<span class="keyword">class</span></span><br><span class="line">  <span class="title class_">Last</span> modified <span class="number">2022</span>-<span class="number">4</span>-<span class="number">25</span>; size <span class="number">483</span> bytes</span><br><span class="line">  MD5 checksum 7836650fdf343fc671c54dc6807c6c47</span><br><span class="line">  Compiled from <span class="string">&quot;Demo3.java&quot;</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">com</span>.tzd.Demo3</span><br><span class="line">  minor version: <span class="number">0</span></span><br><span class="line">  major version: <span class="number">52</span></span><br><span class="line">  flags: ACC_PUBLIC, ACC_SUPER</span><br><span class="line">Constant pool:</span><br><span class="line">   #<span class="number">1</span> = Methodref          #<span class="number">6.</span>#<span class="number">24</span>         <span class="comment">// java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">   #<span class="number">2</span> = String             #<span class="number">25</span>            <span class="comment">// a</span></span><br><span class="line">   #<span class="number">3</span> = String             #<span class="number">26</span>            <span class="comment">// b</span></span><br><span class="line">   #<span class="number">4</span> = String             #<span class="number">27</span>            <span class="comment">// ab</span></span><br><span class="line">   #<span class="number">5</span> = Class              #<span class="number">28</span>            <span class="comment">// com/tzd/Demo3</span></span><br><span class="line">   #<span class="number">6</span> = Class              #<span class="number">29</span>            <span class="comment">// java/lang/Object</span></span><br><span class="line">   #<span class="number">7</span> = Utf8               &lt;init&gt;</span><br><span class="line">   #<span class="number">8</span> = Utf8               ()V</span><br><span class="line">   #<span class="number">9</span> = Utf8               Code</span><br><span class="line">  #<span class="number">10</span> = Utf8               LineNumberTable</span><br><span class="line">  #<span class="number">11</span> = Utf8               LocalVariableTable</span><br><span class="line">  #<span class="number">12</span> = Utf8               <span class="built_in">this</span></span><br><span class="line">  #<span class="number">13</span> = Utf8               Lcom/tzd/Demo3;</span><br><span class="line">  #<span class="number">14</span> = Utf8               main</span><br><span class="line">  #<span class="number">15</span> = Utf8               ([Ljava/lang/String;)V</span><br><span class="line">  #<span class="number">16</span> = Utf8               args</span><br><span class="line">  #<span class="number">17</span> = Utf8               [Ljava/lang/String;</span><br><span class="line">  #<span class="number">18</span> = Utf8               s1</span><br><span class="line">  #<span class="number">19</span> = Utf8               Ljava/lang/String;</span><br><span class="line">  #<span class="number">20</span> = Utf8               s2</span><br><span class="line">  #<span class="number">21</span> = Utf8               s3</span><br><span class="line">  #<span class="number">22</span> = Utf8               SourceFile</span><br><span class="line">  #<span class="number">23</span> = Utf8               Demo3.java</span><br><span class="line">  #<span class="number">24</span> = NameAndType        #<span class="number">7</span>:#<span class="number">8</span>          <span class="comment">// &quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">  #<span class="number">25</span> = Utf8               a</span><br><span class="line">  #<span class="number">26</span> = Utf8               b</span><br><span class="line">  #<span class="number">27</span> = Utf8               ab</span><br><span class="line">  #<span class="number">28</span> = Utf8               com/tzd/Demo3</span><br><span class="line">  #<span class="number">29</span> = Utf8               java/lang/Object</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">public</span> com.tzd.Demo3();</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">1</span>, locals=<span class="number">1</span>, args_size=<span class="number">1</span></span><br><span class="line">         <span class="number">0</span>: aload_0</span><br><span class="line">         <span class="number">1</span>: invokespecial #<span class="number">1</span>                  <span class="comment">// Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">         <span class="number">4</span>: <span class="keyword">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">7</span>: <span class="number">0</span></span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            <span class="number">0</span>       <span class="number">5</span>     <span class="number">0</span>  <span class="built_in">this</span>   Lcom/tzd/Demo3;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(java.lang.String[])</span>;</span><br><span class="line">    descriptor: ([Ljava/lang/String;)V</span><br><span class="line">    flags: ACC_PUBLIC, ACC_STATIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">1</span>, locals=<span class="number">4</span>, args_size=<span class="number">1</span></span><br><span class="line">         <span class="number">0</span>: ldc           #<span class="number">2</span>                  <span class="comment">// String a</span></span><br><span class="line">         <span class="number">2</span>: astore_1</span><br><span class="line">         <span class="number">3</span>: ldc           #<span class="number">3</span>                  <span class="comment">// String b</span></span><br><span class="line">         <span class="number">5</span>: astore_2</span><br><span class="line">         <span class="number">6</span>: ldc           #<span class="number">4</span>                  <span class="comment">// String ab</span></span><br><span class="line">         <span class="number">8</span>: astore_3</span><br><span class="line">         <span class="number">9</span>: <span class="keyword">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">10</span>: <span class="number">0</span></span><br><span class="line">        line <span class="number">11</span>: <span class="number">3</span></span><br><span class="line">        line <span class="number">12</span>: <span class="number">6</span></span><br><span class="line">        line <span class="number">13</span>: <span class="number">9</span></span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            <span class="number">0</span>      <span class="number">10</span>     <span class="number">0</span>  args   [Ljava/lang/String;</span><br><span class="line">            <span class="number">3</span>       <span class="number">7</span>     <span class="number">1</span>    s1   Ljava/lang/String;</span><br><span class="line">            <span class="number">6</span>       <span class="number">4</span>     <span class="number">2</span>    s2   Ljava/lang/String;</span><br><span class="line">            <span class="number">9</span>       <span class="number">1</span>     <span class="number">3</span>    s3   Ljava/lang/String;</span><br><span class="line">&#125;</span><br><span class="line">SourceFile: <span class="string">&quot;Demo3.java&quot;</span></span><br><span class="line"></span><br><span class="line">Process finished with exit code <span class="number">0</span></span><br></pre></td></tr></table></figure>

<p>拼接1：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.tzd;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> tianzedeng</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2022/4/25 - 15:48</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo3</span> &#123;</span><br><span class="line">    <span class="comment">//常量池中的信息，都会被加载到运行时常量池</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;a&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;b&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="string">&quot;ab&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s4</span> <span class="operator">=</span> s1 + s2;<span class="comment">//new StringBuilder().append(&quot;a&quot;).append(&quot;b&quot;).toString()</span></span><br><span class="line">        System.out.println(s3 == s4);<span class="comment">//false,这时两个对象，s3存放在常量池，s4存放在堆里</span></span><br><span class="line">        System.out.println(s3.equals(s4));<span class="comment">//true</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">E:\Java\jdk1<span class="number">.8</span><span class="number">.0_66</span>\bin\javap.exe -verbose com.tzd.Demo3</span><br><span class="line">Classfile /G:/jvm/out/production/jvm/com/tzd/Demo3.<span class="keyword">class</span></span><br><span class="line">  <span class="title class_">Last</span> modified <span class="number">2022</span>-<span class="number">4</span>-<span class="number">25</span>; size <span class="number">667</span> bytes</span><br><span class="line">  MD5 checksum c054a85e2cde0118cd48bc0ce5d665bb</span><br><span class="line">  Compiled from <span class="string">&quot;Demo3.java&quot;</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">com</span>.tzd.Demo3</span><br><span class="line">  minor version: <span class="number">0</span></span><br><span class="line">  major version: <span class="number">52</span></span><br><span class="line">  flags: ACC_PUBLIC, ACC_SUPER</span><br><span class="line">Constant pool:</span><br><span class="line">   #<span class="number">1</span> = Methodref          #<span class="number">10.</span>#<span class="number">29</span>        <span class="comment">// java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">   #<span class="number">2</span> = String             #<span class="number">30</span>            <span class="comment">// a</span></span><br><span class="line">   #<span class="number">3</span> = String             #<span class="number">31</span>            <span class="comment">// b</span></span><br><span class="line">   #<span class="number">4</span> = String             #<span class="number">32</span>            <span class="comment">// ab</span></span><br><span class="line">   #<span class="number">5</span> = Class              #<span class="number">33</span>            <span class="comment">// java/lang/StringBuilder</span></span><br><span class="line">   #<span class="number">6</span> = Methodref          #<span class="number">5.</span>#<span class="number">29</span>         <span class="comment">// java/lang/StringBuilder.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">   #<span class="number">7</span> = Methodref          #<span class="number">5.</span>#<span class="number">34</span>         <span class="comment">// java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;</span></span><br><span class="line">   #<span class="number">8</span> = Methodref          #<span class="number">5.</span>#<span class="number">35</span>         <span class="comment">// java/lang/StringBuilder.toString:()Ljava/lang/String;</span></span><br><span class="line">   #<span class="number">9</span> = Class              #<span class="number">36</span>            <span class="comment">// com/tzd/Demo3</span></span><br><span class="line">  #<span class="number">10</span> = Class              #<span class="number">37</span>            <span class="comment">// java/lang/Object</span></span><br><span class="line">  #<span class="number">11</span> = Utf8               &lt;init&gt;</span><br><span class="line">  #<span class="number">12</span> = Utf8               ()V</span><br><span class="line">  #<span class="number">13</span> = Utf8               Code</span><br><span class="line">  #<span class="number">14</span> = Utf8               LineNumberTable</span><br><span class="line">  #<span class="number">15</span> = Utf8               LocalVariableTable</span><br><span class="line">  #<span class="number">16</span> = Utf8               <span class="built_in">this</span></span><br><span class="line">  #<span class="number">17</span> = Utf8               Lcom/tzd/Demo3;</span><br><span class="line">  #<span class="number">18</span> = Utf8               main</span><br><span class="line">  #<span class="number">19</span> = Utf8               ([Ljava/lang/String;)V</span><br><span class="line">  #<span class="number">20</span> = Utf8               args</span><br><span class="line">  #<span class="number">21</span> = Utf8               [Ljava/lang/String;</span><br><span class="line">  #<span class="number">22</span> = Utf8               s1</span><br><span class="line">  #<span class="number">23</span> = Utf8               Ljava/lang/String;</span><br><span class="line">  #<span class="number">24</span> = Utf8               s2</span><br><span class="line">  #<span class="number">25</span> = Utf8               s3</span><br><span class="line">  #<span class="number">26</span> = Utf8               s4</span><br><span class="line">  #<span class="number">27</span> = Utf8               SourceFile</span><br><span class="line">  #<span class="number">28</span> = Utf8               Demo3.java</span><br><span class="line">  #<span class="number">29</span> = NameAndType        #<span class="number">11</span>:#<span class="number">12</span>        <span class="comment">// &quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">  #<span class="number">30</span> = Utf8               a</span><br><span class="line">  #<span class="number">31</span> = Utf8               b</span><br><span class="line">  #<span class="number">32</span> = Utf8               ab</span><br><span class="line">  #<span class="number">33</span> = Utf8               java/lang/StringBuilder</span><br><span class="line">  #<span class="number">34</span> = NameAndType        #<span class="number">38</span>:#<span class="number">39</span>        <span class="comment">// append:(Ljava/lang/String;)Ljava/lang/StringBuilder;</span></span><br><span class="line">  #<span class="number">35</span> = NameAndType        #<span class="number">40</span>:#<span class="number">41</span>        <span class="comment">// toString:()Ljava/lang/String;</span></span><br><span class="line">  #<span class="number">36</span> = Utf8               com/tzd/Demo3</span><br><span class="line">  #<span class="number">37</span> = Utf8               java/lang/Object</span><br><span class="line">  #<span class="number">38</span> = Utf8               append</span><br><span class="line">  #<span class="number">39</span> = Utf8               (Ljava/lang/String;)Ljava/lang/StringBuilder;</span><br><span class="line">  #<span class="number">40</span> = Utf8               toString</span><br><span class="line">  #<span class="number">41</span> = Utf8               ()Ljava/lang/String;</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">public</span> com.tzd.Demo3();</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">1</span>, locals=<span class="number">1</span>, args_size=<span class="number">1</span></span><br><span class="line">         <span class="number">0</span>: aload_0</span><br><span class="line">         <span class="number">1</span>: invokespecial #<span class="number">1</span>                  <span class="comment">// Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">         <span class="number">4</span>: <span class="keyword">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">7</span>: <span class="number">0</span></span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            <span class="number">0</span>       <span class="number">5</span>     <span class="number">0</span>  <span class="built_in">this</span>   Lcom/tzd/Demo3;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(java.lang.String[])</span>;</span><br><span class="line">    descriptor: ([Ljava/lang/String;)V</span><br><span class="line">    flags: ACC_PUBLIC, ACC_STATIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">2</span>, locals=<span class="number">5</span>, args_size=<span class="number">1</span></span><br><span class="line">         <span class="number">0</span>: ldc           #<span class="number">2</span>                  <span class="comment">// String a</span></span><br><span class="line">         <span class="number">2</span>: astore_1</span><br><span class="line">         <span class="number">3</span>: ldc           #<span class="number">3</span>                  <span class="comment">// String b</span></span><br><span class="line">         <span class="number">5</span>: astore_2</span><br><span class="line">         <span class="number">6</span>: ldc           #<span class="number">4</span>                  <span class="comment">// String ab</span></span><br><span class="line">         <span class="number">8</span>: astore_3</span><br><span class="line">         <span class="number">9</span>: <span class="keyword">new</span>           #<span class="number">5</span>                  <span class="comment">// class java/lang/StringBuilder</span></span><br><span class="line">        <span class="number">12</span>: dup</span><br><span class="line">        <span class="number">13</span>: invokespecial #<span class="number">6</span>                  <span class="comment">// Method java/lang/StringBuilder.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">        <span class="number">16</span>: aload_1</span><br><span class="line">        <span class="number">17</span>: invokevirtual #<span class="number">7</span>                  <span class="comment">// Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;</span></span><br><span class="line">        <span class="number">20</span>: aload_2</span><br><span class="line">        <span class="number">21</span>: invokevirtual #<span class="number">7</span>                  <span class="comment">// Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;</span></span><br><span class="line">        <span class="number">24</span>: invokevirtual #<span class="number">8</span>                  <span class="comment">// Method java/lang/StringBuilder.toString:()Ljava/lang/String;</span></span><br><span class="line">        <span class="number">27</span>: astore        <span class="number">4</span></span><br><span class="line">        <span class="number">29</span>: <span class="keyword">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">10</span>: <span class="number">0</span></span><br><span class="line">        line <span class="number">11</span>: <span class="number">3</span></span><br><span class="line">        line <span class="number">12</span>: <span class="number">6</span></span><br><span class="line">        line <span class="number">13</span>: <span class="number">9</span></span><br><span class="line">        line <span class="number">14</span>: <span class="number">29</span></span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            <span class="number">0</span>      <span class="number">30</span>     <span class="number">0</span>  args   [Ljava/lang/String;</span><br><span class="line">            <span class="number">3</span>      <span class="number">27</span>     <span class="number">1</span>    s1   Ljava/lang/String;</span><br><span class="line">            <span class="number">6</span>      <span class="number">24</span>     <span class="number">2</span>    s2   Ljava/lang/String;</span><br><span class="line">            <span class="number">9</span>      <span class="number">21</span>     <span class="number">3</span>    s3   Ljava/lang/String;</span><br><span class="line">           <span class="number">29</span>       <span class="number">1</span>     <span class="number">4</span>    s4   Ljava/lang/String;</span><br><span class="line">&#125;</span><br><span class="line">SourceFile: <span class="string">&quot;Demo3.java&quot;</span></span><br><span class="line"></span><br><span class="line">Process finished with exit code <span class="number">0</span></span><br></pre></td></tr></table></figure>

<p>拼接2：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.tzd;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> tianzedeng</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2022/4/25 - 15:48</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo3</span> &#123;</span><br><span class="line">    <span class="comment">//常量池中的信息，都会被加载到运行时常量池</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;a&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;b&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="string">&quot;ab&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s4</span> <span class="operator">=</span> s1 + s2;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s5</span> <span class="operator">=</span> <span class="string">&quot;a&quot;</span> + <span class="string">&quot;b&quot;</span>;<span class="comment">//javac在编译期间的优化，结果已经在编译期间确定为ab</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">E:\Java\jdk1<span class="number">.8</span><span class="number">.0_66</span>\bin\javap.exe -verbose com.tzd.Demo3</span><br><span class="line">Classfile /G:/jvm/out/production/jvm/com/tzd/Demo3.<span class="keyword">class</span></span><br><span class="line">  <span class="title class_">Last</span> modified <span class="number">2022</span>-<span class="number">4</span>-<span class="number">25</span>; size <span class="number">690</span> bytes</span><br><span class="line">  MD5 checksum 29cb4a3211d139fd5fcfdce40e137c25</span><br><span class="line">  Compiled from <span class="string">&quot;Demo3.java&quot;</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">com</span>.tzd.Demo3</span><br><span class="line">  minor version: <span class="number">0</span></span><br><span class="line">  major version: <span class="number">52</span></span><br><span class="line">  flags: ACC_PUBLIC, ACC_SUPER</span><br><span class="line">Constant pool:</span><br><span class="line">   #<span class="number">1</span> = Methodref          #<span class="number">10.</span>#<span class="number">30</span>        <span class="comment">// java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">   #<span class="number">2</span> = String             #<span class="number">31</span>            <span class="comment">// a</span></span><br><span class="line">   #<span class="number">3</span> = String             #<span class="number">32</span>            <span class="comment">// b</span></span><br><span class="line">   #<span class="number">4</span> = String             #<span class="number">33</span>            <span class="comment">// ab</span></span><br><span class="line">   #<span class="number">5</span> = Class              #<span class="number">34</span>            <span class="comment">// java/lang/StringBuilder</span></span><br><span class="line">   #<span class="number">6</span> = Methodref          #<span class="number">5.</span>#<span class="number">30</span>         <span class="comment">// java/lang/StringBuilder.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">   #<span class="number">7</span> = Methodref          #<span class="number">5.</span>#<span class="number">35</span>         <span class="comment">// java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;</span></span><br><span class="line">   #<span class="number">8</span> = Methodref          #<span class="number">5.</span>#<span class="number">36</span>         <span class="comment">// java/lang/StringBuilder.toString:()Ljava/lang/String;</span></span><br><span class="line">   #<span class="number">9</span> = Class              #<span class="number">37</span>            <span class="comment">// com/tzd/Demo3</span></span><br><span class="line">  #<span class="number">10</span> = Class              #<span class="number">38</span>            <span class="comment">// java/lang/Object</span></span><br><span class="line">  #<span class="number">11</span> = Utf8               &lt;init&gt;</span><br><span class="line">  #<span class="number">12</span> = Utf8               ()V</span><br><span class="line">  #<span class="number">13</span> = Utf8               Code</span><br><span class="line">  #<span class="number">14</span> = Utf8               LineNumberTable</span><br><span class="line">  #<span class="number">15</span> = Utf8               LocalVariableTable</span><br><span class="line">  #<span class="number">16</span> = Utf8               <span class="built_in">this</span></span><br><span class="line">  #<span class="number">17</span> = Utf8               Lcom/tzd/Demo3;</span><br><span class="line">  #<span class="number">18</span> = Utf8               main</span><br><span class="line">  #<span class="number">19</span> = Utf8               ([Ljava/lang/String;)V</span><br><span class="line">  #<span class="number">20</span> = Utf8               args</span><br><span class="line">  #<span class="number">21</span> = Utf8               [Ljava/lang/String;</span><br><span class="line">  #<span class="number">22</span> = Utf8               s1</span><br><span class="line">  #<span class="number">23</span> = Utf8               Ljava/lang/String;</span><br><span class="line">  #<span class="number">24</span> = Utf8               s2</span><br><span class="line">  #<span class="number">25</span> = Utf8               s3</span><br><span class="line">  #<span class="number">26</span> = Utf8               s4</span><br><span class="line">  #<span class="number">27</span> = Utf8               s5</span><br><span class="line">  #<span class="number">28</span> = Utf8               SourceFile</span><br><span class="line">  #<span class="number">29</span> = Utf8               Demo3.java</span><br><span class="line">  #<span class="number">30</span> = NameAndType        #<span class="number">11</span>:#<span class="number">12</span>        <span class="comment">// &quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">  #<span class="number">31</span> = Utf8               a</span><br><span class="line">  #<span class="number">32</span> = Utf8               b</span><br><span class="line">  #<span class="number">33</span> = Utf8               ab</span><br><span class="line">  #<span class="number">34</span> = Utf8               java/lang/StringBuilder</span><br><span class="line">  #<span class="number">35</span> = NameAndType        #<span class="number">39</span>:#<span class="number">40</span>        <span class="comment">// append:(Ljava/lang/String;)Ljava/lang/StringBuilder;</span></span><br><span class="line">  #<span class="number">36</span> = NameAndType        #<span class="number">41</span>:#<span class="number">42</span>        <span class="comment">// toString:()Ljava/lang/String;</span></span><br><span class="line">  #<span class="number">37</span> = Utf8               com/tzd/Demo3</span><br><span class="line">  #<span class="number">38</span> = Utf8               java/lang/Object</span><br><span class="line">  #<span class="number">39</span> = Utf8               append</span><br><span class="line">  #<span class="number">40</span> = Utf8               (Ljava/lang/String;)Ljava/lang/StringBuilder;</span><br><span class="line">  #<span class="number">41</span> = Utf8               toString</span><br><span class="line">  #<span class="number">42</span> = Utf8               ()Ljava/lang/String;</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">public</span> com.tzd.Demo3();</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">1</span>, locals=<span class="number">1</span>, args_size=<span class="number">1</span></span><br><span class="line">         <span class="number">0</span>: aload_0</span><br><span class="line">         <span class="number">1</span>: invokespecial #<span class="number">1</span>                  <span class="comment">// Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">         <span class="number">4</span>: <span class="keyword">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">7</span>: <span class="number">0</span></span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            <span class="number">0</span>       <span class="number">5</span>     <span class="number">0</span>  <span class="built_in">this</span>   Lcom/tzd/Demo3;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(java.lang.String[])</span>;</span><br><span class="line">    descriptor: ([Ljava/lang/String;)V</span><br><span class="line">    flags: ACC_PUBLIC, ACC_STATIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">2</span>, locals=<span class="number">6</span>, args_size=<span class="number">1</span></span><br><span class="line">         <span class="number">0</span>: ldc           #<span class="number">2</span>                  <span class="comment">// String a</span></span><br><span class="line">         <span class="number">2</span>: astore_1</span><br><span class="line">         <span class="number">3</span>: ldc           #<span class="number">3</span>                  <span class="comment">// String b</span></span><br><span class="line">         <span class="number">5</span>: astore_2</span><br><span class="line">         <span class="number">6</span>: ldc           #<span class="number">4</span>                  <span class="comment">// String ab</span></span><br><span class="line">         <span class="number">8</span>: astore_3</span><br><span class="line">         <span class="number">9</span>: <span class="keyword">new</span>           #<span class="number">5</span>                  <span class="comment">// class java/lang/StringBuilder</span></span><br><span class="line">        <span class="number">12</span>: dup</span><br><span class="line">        <span class="number">13</span>: invokespecial #<span class="number">6</span>                  <span class="comment">// Method java/lang/StringBuilder.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">        <span class="number">16</span>: aload_1</span><br><span class="line">        <span class="number">17</span>: invokevirtual #<span class="number">7</span>                  <span class="comment">// Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;</span></span><br><span class="line">        <span class="number">20</span>: aload_2</span><br><span class="line">        <span class="number">21</span>: invokevirtual #<span class="number">7</span>                  <span class="comment">// Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;</span></span><br><span class="line">        <span class="number">24</span>: invokevirtual #<span class="number">8</span>                  <span class="comment">// Method java/lang/StringBuilder.toString:()Ljava/lang/String;</span></span><br><span class="line">        <span class="number">27</span>: astore        <span class="number">4</span></span><br><span class="line">        <span class="number">29</span>: ldc           #<span class="number">4</span>                  <span class="comment">// String ab</span></span><br><span class="line">        <span class="number">31</span>: astore        <span class="number">5</span></span><br><span class="line">        <span class="number">33</span>: <span class="keyword">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">10</span>: <span class="number">0</span></span><br><span class="line">        line <span class="number">11</span>: <span class="number">3</span></span><br><span class="line">        line <span class="number">12</span>: <span class="number">6</span></span><br><span class="line">        line <span class="number">13</span>: <span class="number">9</span></span><br><span class="line">        line <span class="number">14</span>: <span class="number">29</span></span><br><span class="line">        line <span class="number">16</span>: <span class="number">33</span></span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            <span class="number">0</span>      <span class="number">34</span>     <span class="number">0</span>  args   [Ljava/lang/String;</span><br><span class="line">            <span class="number">3</span>      <span class="number">31</span>     <span class="number">1</span>    s1   Ljava/lang/String;</span><br><span class="line">            <span class="number">6</span>      <span class="number">28</span>     <span class="number">2</span>    s2   Ljava/lang/String;</span><br><span class="line">            <span class="number">9</span>      <span class="number">25</span>     <span class="number">3</span>    s3   Ljava/lang/String;</span><br><span class="line">           <span class="number">29</span>       <span class="number">5</span>     <span class="number">4</span>    s4   Ljava/lang/String;</span><br><span class="line">           <span class="number">33</span>       <span class="number">1</span>     <span class="number">5</span>    s5   Ljava/lang/String;</span><br><span class="line">&#125;</span><br><span class="line">SourceFile: <span class="string">&quot;Demo3.java&quot;</span></span><br><span class="line"></span><br><span class="line">Process finished with exit code <span class="number">0</span></span><br></pre></td></tr></table></figure>

<p><strong>StringTable特性</strong></p>
<ul>
<li><p>常量池中的字符串仅是符号，第一次用到时才变为对象</p>
</li>
<li><p>利用串池的机制，来避免重复创建字符串对象</p>
</li>
<li><p>字符串变量拼接的原理是StringBuilder【1.8】</p>
</li>
<li><p>字符串常量拼接的原理是编译期优化</p>
</li>
<li><p>可以使用Intern方法，主动将串池中还没有的字符串对象放入串池</p>
<ul>
<li>1.8将这个字符串对象尝试放入串池，如果有则并不会放入，如果没有则放入串池，会把串池的对象返回。</li>
<li>1.6将这个字符串对象尝试放入串池，如果有则并不会放入，如果没有会把此对象复制一份，放入串池，会把串池中的对象返回。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.tzd;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> tianzedeng</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2022/4/25 - 17:09</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo4</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//[&quot;a&quot;,&quot;b&quot;,&quot;ab&quot;]常量池中</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;a&quot;</span>) + <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;b&quot;</span>);<span class="comment">//new String(&quot;ab&quot;)</span></span><br><span class="line">        <span class="comment">//堆 new String(&quot;a&quot;)  new String(&quot;b&quot;) new String(&quot;ab&quot;)</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> s.intern();<span class="comment">//将这个字符串对象尝试放入串池，如果有则不会放入，如果没有则放入串池，会把串池中的对象返回</span></span><br><span class="line"></span><br><span class="line">        System.out.println(s2 == <span class="string">&quot;ab&quot;</span>);<span class="comment">//true</span></span><br><span class="line">        System.out.println(s == <span class="string">&quot;ab&quot;</span>);<span class="comment">//true</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">E:\Java\jdk1<span class="number">.8</span><span class="number">.0_66</span>\bin\javap.exe -verbose com.tzd.Demo4</span><br><span class="line">Classfile /G:/jvm/out/production/jvm/com/tzd/Demo4.<span class="keyword">class</span></span><br><span class="line">  <span class="title class_">Last</span> modified <span class="number">2022</span>-<span class="number">4</span>-<span class="number">25</span>; size <span class="number">921</span> bytes</span><br><span class="line">  MD5 checksum 2fb9c3469df09bca2ff3346b40c872b7</span><br><span class="line">  Compiled from <span class="string">&quot;Demo4.java&quot;</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">com</span>.tzd.Demo4</span><br><span class="line">  minor version: <span class="number">0</span></span><br><span class="line">  major version: <span class="number">52</span></span><br><span class="line">  flags: ACC_PUBLIC, ACC_SUPER</span><br><span class="line">Constant pool:</span><br><span class="line">   #<span class="number">1</span> = Methodref          #<span class="number">15.</span>#<span class="number">36</span>        <span class="comment">// java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">   #<span class="number">2</span> = Class              #<span class="number">37</span>            <span class="comment">// java/lang/StringBuilder</span></span><br><span class="line">   #<span class="number">3</span> = Methodref          #<span class="number">2.</span>#<span class="number">36</span>         <span class="comment">// java/lang/StringBuilder.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">   #<span class="number">4</span> = Class              #<span class="number">38</span>            <span class="comment">// java/lang/String</span></span><br><span class="line">   #<span class="number">5</span> = String             #<span class="number">39</span>            <span class="comment">// a</span></span><br><span class="line">   #<span class="number">6</span> = Methodref          #<span class="number">4.</span>#<span class="number">40</span>         <span class="comment">// java/lang/String.&quot;&lt;init&gt;&quot;:(Ljava/lang/String;)V</span></span><br><span class="line">   #<span class="number">7</span> = Methodref          #<span class="number">2.</span>#<span class="number">41</span>         <span class="comment">// java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;</span></span><br><span class="line">   #<span class="number">8</span> = String             #<span class="number">42</span>            <span class="comment">// b</span></span><br><span class="line">   #<span class="number">9</span> = Methodref          #<span class="number">2.</span>#<span class="number">43</span>         <span class="comment">// java/lang/StringBuilder.toString:()Ljava/lang/String;</span></span><br><span class="line">  #<span class="number">10</span> = Methodref          #<span class="number">4.</span>#<span class="number">44</span>         <span class="comment">// java/lang/String.intern:()Ljava/lang/String;</span></span><br><span class="line">  #<span class="number">11</span> = Fieldref           #<span class="number">45.</span>#<span class="number">46</span>        <span class="comment">// java/lang/System.out:Ljava/io/PrintStream;</span></span><br><span class="line">  #<span class="number">12</span> = String             #<span class="number">47</span>            <span class="comment">// ab</span></span><br><span class="line">  #<span class="number">13</span> = Methodref          #<span class="number">48.</span>#<span class="number">49</span>        <span class="comment">// java/io/PrintStream.println:(Z)V</span></span><br><span class="line">  #<span class="number">14</span> = Class              #<span class="number">50</span>            <span class="comment">// com/tzd/Demo4</span></span><br><span class="line">  #<span class="number">15</span> = Class              #<span class="number">51</span>            <span class="comment">// java/lang/Object</span></span><br><span class="line">  #<span class="number">16</span> = Utf8               &lt;init&gt;</span><br><span class="line">  #<span class="number">17</span> = Utf8               ()V</span><br><span class="line">  #<span class="number">18</span> = Utf8               Code</span><br><span class="line">  #<span class="number">19</span> = Utf8               LineNumberTable</span><br><span class="line">  #<span class="number">20</span> = Utf8               LocalVariableTable</span><br><span class="line">  #<span class="number">21</span> = Utf8               <span class="built_in">this</span></span><br><span class="line">  #<span class="number">22</span> = Utf8               Lcom/tzd/Demo4;</span><br><span class="line">  #<span class="number">23</span> = Utf8               main</span><br><span class="line">  #<span class="number">24</span> = Utf8               ([Ljava/lang/String;)V</span><br><span class="line">  #<span class="number">25</span> = Utf8               args</span><br><span class="line">  #<span class="number">26</span> = Utf8               [Ljava/lang/String;</span><br><span class="line">  #<span class="number">27</span> = Utf8               s</span><br><span class="line">  #<span class="number">28</span> = Utf8               Ljava/lang/String;</span><br><span class="line">  #<span class="number">29</span> = Utf8               s2</span><br><span class="line">  #<span class="number">30</span> = Utf8               StackMapTable</span><br><span class="line">  #<span class="number">31</span> = Class              #<span class="number">26</span>            <span class="comment">// &quot;[Ljava/lang/String;&quot;</span></span><br><span class="line">  #<span class="number">32</span> = Class              #<span class="number">38</span>            <span class="comment">// java/lang/String</span></span><br><span class="line">  #<span class="number">33</span> = Class              #<span class="number">52</span>            <span class="comment">// java/io/PrintStream</span></span><br><span class="line">  #<span class="number">34</span> = Utf8               SourceFile</span><br><span class="line">  #<span class="number">35</span> = Utf8               Demo4.java</span><br><span class="line">  #<span class="number">36</span> = NameAndType        #<span class="number">16</span>:#<span class="number">17</span>        <span class="comment">// &quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">  #<span class="number">37</span> = Utf8               java/lang/StringBuilder</span><br><span class="line">  #<span class="number">38</span> = Utf8               java/lang/String</span><br><span class="line">  #<span class="number">39</span> = Utf8               a</span><br><span class="line">  #<span class="number">40</span> = NameAndType        #<span class="number">16</span>:#<span class="number">53</span>        <span class="comment">// &quot;&lt;init&gt;&quot;:(Ljava/lang/String;)V</span></span><br><span class="line">  #<span class="number">41</span> = NameAndType        #<span class="number">54</span>:#<span class="number">55</span>        <span class="comment">// append:(Ljava/lang/String;)Ljava/lang/StringBuilder;</span></span><br><span class="line">  #<span class="number">42</span> = Utf8               b</span><br><span class="line">  #<span class="number">43</span> = NameAndType        #<span class="number">56</span>:#<span class="number">57</span>        <span class="comment">// toString:()Ljava/lang/String;</span></span><br><span class="line">  #<span class="number">44</span> = NameAndType        #<span class="number">58</span>:#<span class="number">57</span>        <span class="comment">// intern:()Ljava/lang/String;</span></span><br><span class="line">  #<span class="number">45</span> = Class              #<span class="number">59</span>            <span class="comment">// java/lang/System</span></span><br><span class="line">  #<span class="number">46</span> = NameAndType        #<span class="number">60</span>:#<span class="number">61</span>        <span class="comment">// out:Ljava/io/PrintStream;</span></span><br><span class="line">  #<span class="number">47</span> = Utf8               ab</span><br><span class="line">  #<span class="number">48</span> = Class              #<span class="number">52</span>            <span class="comment">// java/io/PrintStream</span></span><br><span class="line">  #<span class="number">49</span> = NameAndType        #<span class="number">62</span>:#<span class="number">63</span>        <span class="comment">// println:(Z)V</span></span><br><span class="line">  #<span class="number">50</span> = Utf8               com/tzd/Demo4</span><br><span class="line">  #<span class="number">51</span> = Utf8               java/lang/Object</span><br><span class="line">  #<span class="number">52</span> = Utf8               java/io/PrintStream</span><br><span class="line">  #<span class="number">53</span> = Utf8               (Ljava/lang/String;)V</span><br><span class="line">  #<span class="number">54</span> = Utf8               append</span><br><span class="line">  #<span class="number">55</span> = Utf8               (Ljava/lang/String;)Ljava/lang/StringBuilder;</span><br><span class="line">  #<span class="number">56</span> = Utf8               toString</span><br><span class="line">  #<span class="number">57</span> = Utf8               ()Ljava/lang/String;</span><br><span class="line">  #<span class="number">58</span> = Utf8               intern</span><br><span class="line">  #<span class="number">59</span> = Utf8               java/lang/System</span><br><span class="line">  #<span class="number">60</span> = Utf8               out</span><br><span class="line">  #<span class="number">61</span> = Utf8               Ljava/io/PrintStream;</span><br><span class="line">  #<span class="number">62</span> = Utf8               println</span><br><span class="line">  #<span class="number">63</span> = Utf8               (Z)V</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">public</span> com.tzd.Demo4();</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">1</span>, locals=<span class="number">1</span>, args_size=<span class="number">1</span></span><br><span class="line">         <span class="number">0</span>: aload_0</span><br><span class="line">         <span class="number">1</span>: invokespecial #<span class="number">1</span>                  <span class="comment">// Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">         <span class="number">4</span>: <span class="keyword">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">7</span>: <span class="number">0</span></span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            <span class="number">0</span>       <span class="number">5</span>     <span class="number">0</span>  <span class="built_in">this</span>   Lcom/tzd/Demo4;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(java.lang.String[])</span>;</span><br><span class="line">    descriptor: ([Ljava/lang/String;)V</span><br><span class="line">    flags: ACC_PUBLIC, ACC_STATIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">4</span>, locals=<span class="number">3</span>, args_size=<span class="number">1</span></span><br><span class="line">         <span class="number">0</span>: <span class="keyword">new</span>           #<span class="number">2</span>                  <span class="comment">// class java/lang/StringBuilder</span></span><br><span class="line">         <span class="number">3</span>: dup</span><br><span class="line">         <span class="number">4</span>: invokespecial #<span class="number">3</span>                  <span class="comment">// Method java/lang/StringBuilder.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">         <span class="number">7</span>: <span class="keyword">new</span>           #<span class="number">4</span>                  <span class="comment">// class java/lang/String</span></span><br><span class="line">        <span class="number">10</span>: dup</span><br><span class="line">        <span class="number">11</span>: ldc           #<span class="number">5</span>                  <span class="comment">// String a</span></span><br><span class="line">        <span class="number">13</span>: invokespecial #<span class="number">6</span>                  <span class="comment">// Method java/lang/String.&quot;&lt;init&gt;&quot;:(Ljava/lang/String;)V</span></span><br><span class="line">        <span class="number">16</span>: invokevirtual #<span class="number">7</span>                  <span class="comment">// Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;</span></span><br><span class="line">        <span class="number">19</span>: <span class="keyword">new</span>           #<span class="number">4</span>                  <span class="comment">// class java/lang/String</span></span><br><span class="line">        <span class="number">22</span>: dup</span><br><span class="line">        <span class="number">23</span>: ldc           #<span class="number">8</span>                  <span class="comment">// String b</span></span><br><span class="line">        <span class="number">25</span>: invokespecial #<span class="number">6</span>                  <span class="comment">// Method java/lang/String.&quot;&lt;init&gt;&quot;:(Ljava/lang/String;)V</span></span><br><span class="line">        <span class="number">28</span>: invokevirtual #<span class="number">7</span>                  <span class="comment">// Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;</span></span><br><span class="line">        <span class="number">31</span>: invokevirtual #<span class="number">9</span>                  <span class="comment">// Method java/lang/StringBuilder.toString:()Ljava/lang/String;</span></span><br><span class="line">        <span class="number">34</span>: astore_1</span><br><span class="line">        <span class="number">35</span>: aload_1</span><br><span class="line">        <span class="number">36</span>: invokevirtual #<span class="number">10</span>                 <span class="comment">// Method java/lang/String.intern:()Ljava/lang/String;</span></span><br><span class="line">        <span class="number">39</span>: astore_2</span><br><span class="line">        <span class="number">40</span>: getstatic     #<span class="number">11</span>                 <span class="comment">// Field java/lang/System.out:Ljava/io/PrintStream;</span></span><br><span class="line">        <span class="number">43</span>: aload_2</span><br><span class="line">        <span class="number">44</span>: ldc           #<span class="number">12</span>                 <span class="comment">// String ab</span></span><br><span class="line">        <span class="number">46</span>: if_acmpne     <span class="number">53</span></span><br><span class="line">        <span class="number">49</span>: iconst_1</span><br><span class="line">        <span class="number">50</span>: goto          <span class="number">54</span></span><br><span class="line">        <span class="number">53</span>: iconst_0</span><br><span class="line">        <span class="number">54</span>: invokevirtual #<span class="number">13</span>                 <span class="comment">// Method java/io/PrintStream.println:(Z)V</span></span><br><span class="line">        <span class="number">57</span>: <span class="keyword">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">11</span>: <span class="number">0</span></span><br><span class="line">        line <span class="number">13</span>: <span class="number">35</span></span><br><span class="line">        line <span class="number">15</span>: <span class="number">40</span></span><br><span class="line">        line <span class="number">16</span>: <span class="number">57</span></span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            <span class="number">0</span>      <span class="number">58</span>     <span class="number">0</span>  args   [Ljava/lang/String;</span><br><span class="line">           <span class="number">35</span>      <span class="number">23</span>     <span class="number">1</span>     s   Ljava/lang/String;</span><br><span class="line">           <span class="number">40</span>      <span class="number">18</span>     <span class="number">2</span>    s2   Ljava/lang/String;</span><br><span class="line">      StackMapTable: number_of_entries = <span class="number">2</span></span><br><span class="line">        frame_type = <span class="number">255</span> <span class="comment">/* full_frame */</span></span><br><span class="line">          offset_delta = <span class="number">53</span></span><br><span class="line">          locals = [ class <span class="string">&quot;[Ljava/lang/String;&quot;</span>, <span class="keyword">class</span> <span class="title class_">java</span>/lang/String, <span class="keyword">class</span> <span class="title class_">java</span>/lang/String ]</span><br><span class="line">          stack = [ <span class="keyword">class</span> <span class="title class_">java</span>/io/PrintStream ]</span><br><span class="line">        frame_type = <span class="number">255</span> <span class="comment">/* full_frame */</span></span><br><span class="line">          offset_delta = <span class="number">0</span></span><br><span class="line">          locals = [ class <span class="string">&quot;[Ljava/lang/String;&quot;</span>, <span class="keyword">class</span> <span class="title class_">java</span>/lang/String, <span class="keyword">class</span> <span class="title class_">java</span>/lang/String ]</span><br><span class="line">          stack = [ <span class="keyword">class</span> <span class="title class_">java</span>/io/PrintStream, <span class="type">int</span> ]</span><br><span class="line">&#125;</span><br><span class="line">SourceFile: <span class="string">&quot;Demo4.java&quot;</span></span><br><span class="line"></span><br><span class="line">Process finished with exit code <span class="number">0</span></span><br></pre></td></tr></table></figure>

<p><strong>StringTable位置</strong></p>
<p><img src="/../images/img3.PNG" alt="img3"></p>
</li>
</ul>
<p><strong>StringTable垃圾回收</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.tzd;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> tianzedeng</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2022/4/25 - 20:22</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 演示StringTable垃圾回收</span></span><br><span class="line"><span class="comment"> * -Xmx10m(堆的最大参数)  -XX:+PrintStringTableStatistics  -XX:+PrintGCDetails -verbose:gc</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo5</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt;<span class="number">100</span> ; j++) &#123;</span><br><span class="line">                String.valueOf(j).intern();</span><br><span class="line">                i++;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Throwable e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="number">0</span></span><br><span class="line">Heap</span><br><span class="line"> def <span class="keyword">new</span> <span class="title class_">generation</span>   total 3072K, used 1462K [<span class="number">0x04a00000</span>, <span class="number">0x04d50000</span>, <span class="number">0x04d50000</span>)</span><br><span class="line">  eden space 2752K,  <span class="number">53</span>% used [<span class="number">0x04a00000</span>, <span class="number">0x04b6d9d8</span>, <span class="number">0x04cb0000</span>)</span><br><span class="line">  from space 320K,   <span class="number">0</span>% used [<span class="number">0x04cb0000</span>, <span class="number">0x04cb0000</span>, <span class="number">0x04d00000</span>)</span><br><span class="line">  to   space 320K,   <span class="number">0</span>% used [<span class="number">0x04d00000</span>, <span class="number">0x04d00000</span>, <span class="number">0x04d50000</span>)</span><br><span class="line"> tenured generation   total 6848K, used 0K [<span class="number">0x04d50000</span>, <span class="number">0x05400000</span>, <span class="number">0x05400000</span>)</span><br><span class="line">   the space 6848K,   <span class="number">0</span>% used [<span class="number">0x04d50000</span>, <span class="number">0x04d50000</span>, <span class="number">0x04d50200</span>, <span class="number">0x05400000</span>)</span><br><span class="line"> Metaspace       used 1920K, capacity 2280K, committed 2368K, reserved 4480K</span><br><span class="line">SymbolTable statistics:</span><br><span class="line">Number of buckets       :     <span class="number">20011</span> =     <span class="number">80044</span> bytes, avg   <span class="number">4.000</span></span><br><span class="line">Number of entries       :     <span class="number">12610</span> =    <span class="number">151320</span> bytes, avg  <span class="number">12.000</span></span><br><span class="line">Number of literals      :     <span class="number">12610</span> =    <span class="number">548304</span> bytes, avg  <span class="number">43.482</span></span><br><span class="line">Total footprint         :           =    <span class="number">779668</span> bytes</span><br><span class="line">Average bucket size     :     <span class="number">0.630</span></span><br><span class="line">Variance of bucket size :     <span class="number">0.628</span></span><br><span class="line">Std. dev. of bucket size:     <span class="number">0.793</span></span><br><span class="line">Maximum bucket size     :         <span class="number">6</span></span><br><span class="line">StringTable statistics:</span><br><span class="line">Number of buckets       :      <span class="number">1009</span> =      <span class="number">4036</span> bytes, avg   <span class="number">4.000</span></span><br><span class="line">Number of entries       :      <span class="number">1658</span> =     <span class="number">19896</span> bytes, avg  <span class="number">12.000</span></span><br><span class="line">Number of literals      :      <span class="number">1658</span> =    <span class="number">131192</span> bytes, avg  <span class="number">79.127</span></span><br><span class="line">Total footprint         :           =    <span class="number">155124</span> bytes</span><br><span class="line">Average bucket size     :     <span class="number">1.643</span></span><br><span class="line">Variance of bucket size :     <span class="number">1.571</span></span><br><span class="line">Std. dev. of bucket size:     <span class="number">1.254</span></span><br><span class="line">Maximum bucket size     :         <span class="number">6</span></span><br><span class="line"></span><br><span class="line">Process finished with exit code <span class="number">0</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="number">100</span></span><br><span class="line">Heap</span><br><span class="line"> def <span class="keyword">new</span> <span class="title class_">generation</span>   total 3072K, used 1628K [<span class="number">0x04a00000</span>, <span class="number">0x04d50000</span>, <span class="number">0x04d50000</span>)</span><br><span class="line">  eden space 2752K,  <span class="number">59</span>% used [<span class="number">0x04a00000</span>, <span class="number">0x04b97368</span>, <span class="number">0x04cb0000</span>)</span><br><span class="line">  from space 320K,   <span class="number">0</span>% used [<span class="number">0x04cb0000</span>, <span class="number">0x04cb0000</span>, <span class="number">0x04d00000</span>)</span><br><span class="line">  to   space 320K,   <span class="number">0</span>% used [<span class="number">0x04d00000</span>, <span class="number">0x04d00000</span>, <span class="number">0x04d50000</span>)</span><br><span class="line"> tenured generation   total 6848K, used 0K [<span class="number">0x04d50000</span>, <span class="number">0x05400000</span>, <span class="number">0x05400000</span>)</span><br><span class="line">   the space 6848K,   <span class="number">0</span>% used [<span class="number">0x04d50000</span>, <span class="number">0x04d50000</span>, <span class="number">0x04d50200</span>, <span class="number">0x05400000</span>)</span><br><span class="line"> Metaspace       used 1991K, capacity 2280K, committed 2368K, reserved 4480K</span><br><span class="line">SymbolTable statistics:</span><br><span class="line">Number of buckets       :     <span class="number">20011</span> =     <span class="number">80044</span> bytes, avg   <span class="number">4.000</span></span><br><span class="line">Number of entries       :     <span class="number">12957</span> =    <span class="number">155484</span> bytes, avg  <span class="number">12.000</span></span><br><span class="line">Number of literals      :     <span class="number">12957</span> =    <span class="number">560000</span> bytes, avg  <span class="number">43.220</span></span><br><span class="line">Total footprint         :           =    <span class="number">795528</span> bytes</span><br><span class="line">Average bucket size     :     <span class="number">0.647</span></span><br><span class="line">Variance of bucket size :     <span class="number">0.648</span></span><br><span class="line">Std. dev. of bucket size:     <span class="number">0.805</span></span><br><span class="line">Maximum bucket size     :         <span class="number">6</span></span><br><span class="line">StringTable statistics:</span><br><span class="line">Number of buckets       :      <span class="number">1009</span> =      <span class="number">4036</span> bytes, avg   <span class="number">4.000</span></span><br><span class="line">Number of entries       :      <span class="number">1782</span> =     <span class="number">21384</span> bytes, avg  <span class="number">12.000</span></span><br><span class="line">Number of literals      :      <span class="number">1782</span> =    <span class="number">135696</span> bytes, avg  <span class="number">76.148</span></span><br><span class="line">Total footprint         :           =    <span class="number">161116</span> bytes</span><br><span class="line">Average bucket size     :     <span class="number">1.766</span></span><br><span class="line">Variance of bucket size :     <span class="number">1.719</span></span><br><span class="line">Std. dev. of bucket size:     <span class="number">1.311</span></span><br><span class="line">Maximum bucket size     :         <span class="number">6</span></span><br><span class="line"></span><br><span class="line">Process finished with exit code <span class="number">0</span></span><br></pre></td></tr></table></figure>

<p><strong>StringTable性能调优</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.tzd;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> tianzedeng</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2022/4/25 - 20:42</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * -XX:StringTableSize=200000 -XX:+PrintStringTableStatistics -XX:StringTableSize=20000(桶的个数)//调整参数大小</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo6</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> (<span class="type">BufferedReader</span> <span class="variable">reader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;linux.words&quot;</span>),<span class="string">&quot;utf-8&quot;</span>)))&#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">line</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">            <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.nanoTime();</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">                line = reader.readLine();</span><br><span class="line">                <span class="keyword">if</span> (line == <span class="literal">null</span>)&#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                line.intern();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;cost:&quot;</span> + (System.nanoTime() - start)/<span class="number">1000000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (UnsupportedEncodingException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="直接内存"><a href="#直接内存" class="headerlink" title="直接内存"></a>直接内存</h4><p><strong>定义</strong></p>
<ul>
<li>常见于NIO操作，用于数据缓冲区</li>
<li>分配回收成本较高，但读写性能高</li>
<li>不受JVM内存回收管理</li>
</ul>
<p><img src="/../images/img4.PNG" alt="img4"></p>
<p><img src="/../images/img5.PNG" alt="img5"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.tzd;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> tianzedeng</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2022/4/25 - 21:27</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 直接内存溢出</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo7</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">_100Mb</span> <span class="operator">=</span> <span class="number">1024</span> * <span class="number">1024</span> * <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        List&lt;ByteBuffer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">                <span class="type">ByteBuffer</span> <span class="variable">byteBuffer</span> <span class="operator">=</span> ByteBuffer.allocateDirect(_100Mb);</span><br><span class="line">                list.add(byteBuffer);</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">2</span></span><br><span class="line">Exception in thread <span class="string">&quot;main&quot;</span> java.lang.OutOfMemoryError: Direct buffer memory</span><br><span class="line">	at java.nio.Bits.reserveMemory(Bits.java:<span class="number">658</span>)</span><br><span class="line">	at java.nio.DirectByteBuffer.&lt;init&gt;(DirectByteBuffer.java:<span class="number">123</span>)</span><br><span class="line">	at java.nio.ByteBuffer.allocateDirect(ByteBuffer.java:<span class="number">311</span>)</span><br><span class="line">	at com.tzd.Demo7.main(Demo7.java:<span class="number">25</span>)</span><br><span class="line"></span><br><span class="line">Process finished with exit code <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p><strong>分配和回收原理</strong></p>
<p>分配内存和释放内存通过unsafe对象来管理的。并且回收需要主动调用freeMemory方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Unsafe</span> <span class="variable">unsafe</span> <span class="operator">=</span> getUnsafe();</span><br><span class="line"><span class="comment">//分配内存</span></span><br><span class="line"><span class="type">long</span> <span class="variable">base</span> <span class="operator">=</span> unsafe.allocateMemory(静态成员变量);</span><br><span class="line">unsafe.setMemory(base,静态成员变量,(<span class="type">byte</span>)<span class="number">0</span>);</span><br><span class="line">System.in.read();</span><br><span class="line"></span><br><span class="line"><span class="comment">//释放内存</span></span><br><span class="line">unsafe.freeMemory(base);</span><br><span class="line">System.in.read();</span><br></pre></td></tr></table></figure>

<p>ByteBuffer的实现类内部，使用了Cleaner（虚引用）来监测ByteBuffer对象，一旦ByteBuffer对象被垃圾回收，那么就会由ReferenceHandler线程通过Cleaner的clean方法调用freeMemory来释放直接内存。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.tzd;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> tianzedeng</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2022/4/25 - 21:58</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * -XX:+DisableExplicitGC  显式的</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo8</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">_1Gb</span> <span class="operator">=</span> <span class="number">1024</span> * <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="type">ByteBuffer</span> <span class="variable">byteBuffer</span> <span class="operator">=</span> ByteBuffer.allocateDirect(_1Gb);</span><br><span class="line">        System.out.println(<span class="string">&quot;分配完毕。。。。。&quot;</span>);</span><br><span class="line">        System.in.read();</span><br><span class="line">        System.out.println(<span class="string">&quot;开始释放。。。。。&quot;</span>);</span><br><span class="line">        byteBuffer = <span class="literal">null</span>;</span><br><span class="line">        System.gc();<span class="comment">//显式的垃圾回收</span></span><br><span class="line">        System.in.read();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-垃圾回收"><a href="#5-垃圾回收" class="headerlink" title="5.垃圾回收"></a>5.垃圾回收</h3><h4 id="如何判断对象可以回收"><a href="#如何判断对象可以回收" class="headerlink" title="如何判断对象可以回收"></a><strong>如何判断对象可以回收</strong></h4><p><strong>引用计数法</strong></p>
<p><strong>可达性分析算法</strong></p>
<ul>
<li><p>Java虚拟机中的垃圾回收器采用可达性分析来探索所有存活的对象</p>
</li>
<li><p>扫描堆中的对象，看是否能够沿着GC Root对象为起点的引用链找到该对象，找不到，表示可以回收</p>
</li>
<li><p>哪些对象可以作为GC Root？(Eclipse Memory Analyzer工具)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.tzd;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> tianzedeng</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2022/4/26 - 16:22</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 演示GC Roots</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo9</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException, IOException &#123;</span><br><span class="line"></span><br><span class="line">        List&lt;Object&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        list.add(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">        System.out.println(<span class="number">1</span>);</span><br><span class="line">        System.in.read();</span><br><span class="line"></span><br><span class="line">        list = <span class="literal">null</span>;</span><br><span class="line">        System.out.println(<span class="number">2</span>);</span><br><span class="line">        System.in.read();</span><br><span class="line">        System.out.println(<span class="string">&quot;end..........&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">G:\jvm&gt;jmap -dump:format=b,live,file=<span class="number">1.</span>bin <span class="number">6340</span></span><br><span class="line">Dumping heap to G:\jvm\<span class="number">1.</span>bin ...</span><br><span class="line">Heap dump file created</span><br><span class="line"></span><br><span class="line">G:\jvm&gt;jmap -dump:format=b,live,file=<span class="number">2.</span>bin <span class="number">6340</span></span><br><span class="line">Dumping heap to G:\jvm\<span class="number">2.</span>bin ...</span><br><span class="line">Heap dump file created</span><br></pre></td></tr></table></figure>

<p><img src="/../images/img6.PNG" alt="img6"></p>
<p><img src="/../images/img7.PNG" alt="img7"></p>
<p><strong>四种引用</strong></p>
<p><img src="/../images/img8.PNG" alt="img8"></p>
<ol>
<li>强引用<ul>
<li>只有所有GC Roots对象都不通过【强引用】引用该对象，该对象才能被垃圾回收。</li>
</ul>
</li>
<li>软引用<ul>
<li>仅有软引用引用该对象时，在垃圾回收后，内存仍不足时会再次出发垃圾回收，回收软引用对象。</li>
<li>可以配合引用队列来释放软引用自身。</li>
</ul>
</li>
<li>弱引用<ul>
<li>仅有弱引用引用该对象时，在垃圾回收时，无论内存是否充足，都会回收弱引用对象。</li>
<li>可以配合引用队列来释放弱引用自身。</li>
</ul>
</li>
<li>虚引用(Cleaner)<ul>
<li>必须配合引用队列使用，主要配合ByteBuffer使用，被引用对象回收时，会将虚引用入队，由Reference Handler线程调用虚引用相关方法释放直接内存。</li>
</ul>
</li>
<li>终结器引用<ul>
<li>无需手动编码，但其内部配合引用队列使用，在垃圾回收时，终结器引用入队（被引用对象暂时没有被回收），再由Finalizer线程通过终结器引用找到被引用对象并调用它的finalize方法，第二次GC时才能被回收。</li>
</ul>
</li>
</ol>
<h4 id="垃圾回收算法"><a href="#垃圾回收算法" class="headerlink" title="垃圾回收算法"></a>垃圾回收算法</h4><p><strong>标记清除（Mark Sweep）</strong></p>
<ul>
<li>速度较快</li>
<li>会造成内存碎片</li>
</ul>
<p><img src="/../images/img9.PNG" alt="img9"></p>
<p><strong>标记整理（Mark Compact）</strong></p>
<ul>
<li>速度慢</li>
<li>没有内存碎片</li>
</ul>
<p><img src="/../images/img10.PNG" alt="img10"></p>
<p><strong>复制（Copy）</strong></p>
<ul>
<li>不会有内存碎片</li>
<li>需要占双倍的内存空间</li>
</ul>
<p><img src="/../images/img12.PNG" alt="img12"></p>
<p><img src="/../images/img13.PNG" alt="img13"></p>
<p><img src="/../images/img11.PNG" alt="img11"></p>
<h4 id="分代垃圾回收"><a href="#分代垃圾回收" class="headerlink" title="分代垃圾回收"></a>分代垃圾回收</h4><p><img src="/../images/img14.PNG" alt="img4"></p>
<p><img src="/../images/img15.PNG" alt="img15"></p>
<ul>
<li>对象首先分配在伊甸园区域。</li>
<li>新生代空间不足时，触发minor gc，伊甸园和from存活的对象使用copy算法复制到to中，存活的对象年龄加1，并且交换from to。</li>
<li>minor gc会引发stop the world，暂停其它用户的线程，等垃圾回收结束，用户线程恢复运行。</li>
<li>当对象寿命超过阈值时，会晋升至老年代，最大寿命是15（4bit）。</li>
<li>当老年代空间不足，会先尝试触发minor gc，如果之后空间仍不足，那么触发full gc。STW的时间更长。</li>
</ul>
<p><strong>相关VM参数</strong></p>
<p><img src="/../images/img16.PNG" alt="img16"></p>
<h4 id="垃圾回收器"><a href="#垃圾回收器" class="headerlink" title="垃圾回收器"></a>垃圾回收器</h4><p><strong>串行</strong></p>
<ul>
<li>单线程</li>
<li>堆内存较小，适合个人电脑</li>
</ul>
<p><img src="/../images/img17.PNG" alt="img17"></p>
<p><strong>吞吐量优先</strong></p>
<ul>
<li><p>多线程</p>
</li>
<li><p>堆内存较大的场景，多核cpu支持</p>
</li>
<li><p>让单位时间内，STW的时间最短</p>
<p><img src="/../images/img18.PNG" alt="img18"></p>
</li>
</ul>
<p><strong>响应时间优先</strong></p>
<ul>
<li>多线程</li>
<li>堆内存较大的场景，多核cpu支持</li>
<li>尽可能让单次的STW的时间最短</li>
</ul>
<p><img src="/../images/img19.PNG" alt="img19"></p>
<h4 id="Garbage-First"><a href="#Garbage-First" class="headerlink" title="Garbage First"></a>Garbage First</h4><p><strong>适用场景</strong></p>
<ul>
<li>同时注重吞吐量和低延迟，默认的暂停目标是200ms</li>
<li>超大堆内存，会将堆划分为多个大小相等的Region</li>
<li>整体上是标记+整理算法，两个区域之间是复制算法</li>
</ul>
<p><strong>相关参数</strong></p>
<p>-XX:+UseG1GC</p>
<p>-XX:G1HeapRegionSize&#x3D;size</p>
<p>-XX:MaxGCPauseMills&#x3D;time</p>
<p><strong>G1垃圾回收阶段</strong></p>
<p><img src="/../images/img20.PNG" alt="img20"></p>
<p><strong>Young Collection</strong></p>
<ul>
<li><p>会STW</p>
<p><img src="/../images/img21.PNG" alt="img21"></p>
</li>
</ul>
<p><img src="/../images/img22.PNG" alt="img22"></p>
<p><img src="/../images/img23.PNG" alt="img23"></p>
<p><strong>Young Collection + Concurrent Mark(CM)</strong></p>
<ul>
<li>在Young GC时会进行GC Root的初始标记</li>
<li>老年代占用堆空间比例达到阈值时，进行并发标记（不会STW），由下面的JVM参数决定</li>
<li>-XX:InitiatingHeapOccupancyPercent&#x3D;percent(默认45%)</li>
</ul>
<p><img src="/../images/img24.PNG" alt="img24"></p>
<p><strong>Mixed Collection</strong></p>
<p>会对E、S、O进行全面垃圾回收</p>
<ul>
<li>最终标记(Remark)会STW</li>
<li>拷贝存活(Evacuation)会STW</li>
<li>-XX:MaxGCPuaseMills&#x3D;ms</li>
</ul>
<p><img src="/../images/img25.PNG" alt="img25"></p>
<p><strong>Full GC</strong></p>
<ul>
<li>SerialGC<ul>
<li>新生代内存不足发生的垃圾收集-minor gc</li>
<li>老年代内存不足发生的垃圾回收-full gc</li>
</ul>
</li>
<li>ParallelGC<ul>
<li>新生代内存不足发生的垃圾收集-minor gc</li>
<li>老年代内存不足发生的垃圾回收-full gc</li>
</ul>
</li>
<li>CMS<ul>
<li>新生代内存不足发生的垃圾收集-minor gc</li>
<li>老年代内存不足</li>
</ul>
</li>
<li>G1<ul>
<li>新生代内存不足发生的垃圾收集-minor gc</li>
<li>老年代内存不足</li>
</ul>
</li>
</ul>
<p><strong>Young Collection跨代引用</strong></p>
<ul>
<li>新生代回收的跨代引用（老年代引用新生代）问题</li>
</ul>
<p><img src="/../images/img26.PNG" alt="img26"></p>
<p><strong>Remark</strong></p>
<ul>
<li>pre-write barrier(写屏障)    +    satb_mark_queue</li>
</ul>
<p><img src="/../images/img27.PNG" alt="img"></p>
<p><strong>JDK 8u20字符串去重</strong></p>
<ul>
<li>优点：节省大量内存</li>
<li>缺点：略微多占用了cpu时间，新生代回收时间略微增加</li>
<li>-XX:+UseStringDeduplication</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;hello&quot;</span>);<span class="comment">//char[]&#123;&#x27;h&#x27;,&#x27;e&#x27;,&#x27;l&#x27;,&#x27;l&#x27;,&#x27;o&#x27;&#125;</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;hello&quot;</span>);<span class="comment">//char[]&#123;&#x27;h&#x27;,&#x27;e&#x27;,&#x27;l&#x27;,&#x27;l&#x27;,&#x27;o&#x27;&#125;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>将所有新分配的字符串放入一个队列</li>
<li>当新生代回收时，G1并发检查是否有字符串重复</li>
<li>如果他们值一样，让他们引用同一个cha[]</li>
<li>注意，与String.intern()不一样，String.intern()关注的是字符串对象，而字符串去重关注的是char[],在JVM内部，使用了不同的字符串表</li>
</ul>
<p><strong>JDK 8u40并发标记类卸载</strong></p>
<p>所有对象都经过并发标记后，就能知道哪些类不再被使用，当一个类加载器的所有类都不再使用，则卸载它所加载的所有类。</p>
<p>-XX:+ClassUnloadingWithConcurrentMark默认启用</p>
<p><strong>JDK 8u60回收巨型对象</strong></p>
<ul>
<li>一个对象大于region的一半时，称之为巨型对象</li>
<li>G1不会对巨型对象拷贝</li>
<li>回收时会被优先考虑</li>
<li>G1会跟踪老年代所有incoming引用，这样老年代incoming引用为0的巨型对象就可以在新生代垃圾回收时处理掉</li>
</ul>
<p><strong>JDK 9并发标记起始时间的调整</strong></p>
<ul>
<li>并发标记必须在堆空间占满前完成，否则退化为FullGC</li>
<li>JDK 9之前需要使用-XX:InitiatingHeapOccupancyPercent</li>
<li>JDK 9可以动态调整<ul>
<li>-XX:InitiatingHeapOccupancyPercent用来设置初始值</li>
<li>进行数据采样并动态调整</li>
<li>总会添加一个安全的空档时间</li>
</ul>
</li>
</ul>
<h4 id="垃圾回收调优"><a href="#垃圾回收调优" class="headerlink" title="垃圾回收调优"></a><strong>垃圾回收调优</strong></h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//查看虚拟机运行参数</span></span><br><span class="line"><span class="string">&quot;E:\Java\jdk1.8.0_66\bin\java&quot;</span> -XX:+PrintFlagsFinal -version | findstr <span class="string">&quot;GC&quot;</span></span><br></pre></td></tr></table></figure>

<p>如下信息：    </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="type">uintx</span> <span class="variable">AdaptiveSizeMajorGCDecayTimeScale</span>         <span class="operator">=</span> <span class="number">10</span>                                  &#123;product&#125;</span><br><span class="line">    <span class="type">uintx</span> <span class="variable">AutoGCSelectPauseMillis</span>                   <span class="operator">=</span> <span class="number">5000</span>                                &#123;product&#125;</span><br><span class="line">     <span class="type">bool</span> <span class="variable">BindGCTaskThreadsToCPUs</span>                   <span class="operator">=</span> <span class="literal">false</span>                               &#123;product&#125;</span><br><span class="line">    <span class="type">uintx</span> <span class="variable">CMSFullGCsBeforeCompaction</span>                <span class="operator">=</span> <span class="number">0</span>                                   &#123;product&#125;</span><br><span class="line">    <span class="type">uintx</span> <span class="variable">ConcGCThreads</span>                             <span class="operator">=</span> <span class="number">0</span>                                   &#123;product&#125;</span><br><span class="line">     <span class="type">bool</span> <span class="variable">DisableExplicitGC</span>                         <span class="operator">=</span> <span class="literal">false</span>                               &#123;product&#125;</span><br><span class="line">     <span class="type">bool</span> <span class="variable">ExplicitGCInvokesConcurrent</span>               <span class="operator">=</span> <span class="literal">false</span>                               &#123;product&#125;</span><br><span class="line">     <span class="type">bool</span> <span class="variable">ExplicitGCInvokesConcurrentAndUnloadsClasses</span>  <span class="operator">=</span> <span class="literal">false</span>                               &#123;product&#125;</span><br><span class="line">    <span class="type">uintx</span> <span class="variable">G1MixedGCCountTarget</span>                      <span class="operator">=</span> <span class="number">8</span>                                   &#123;product&#125;</span><br><span class="line">    <span class="type">uintx</span> <span class="variable">GCDrainStackTargetSize</span>                    <span class="operator">=</span> <span class="number">64</span>                                  &#123;product&#125;</span><br><span class="line">    <span class="type">uintx</span> <span class="variable">GCHeapFreeLimit</span>                           <span class="operator">=</span> <span class="number">2</span>                                   &#123;product&#125;</span><br><span class="line">    <span class="type">uintx</span> <span class="variable">GCLockerEdenExpansionPercent</span>              <span class="operator">=</span> <span class="number">5</span>                                   &#123;product&#125;</span><br><span class="line">     <span class="type">bool</span> <span class="variable">GCLockerInvokesConcurrent</span>                 <span class="operator">=</span> <span class="literal">false</span>                               &#123;product&#125;</span><br><span class="line">    <span class="type">uintx</span> <span class="variable">GCLogFileSize</span>                             <span class="operator">=</span> <span class="number">8192</span>                                &#123;product&#125;</span><br><span class="line">    <span class="type">uintx</span> <span class="variable">GCPauseIntervalMillis</span>                     <span class="operator">=</span> <span class="number">0</span>                                   &#123;product&#125;</span><br><span class="line">    <span class="type">uintx</span> <span class="variable">GCTaskTimeStampEntries</span>                    <span class="operator">=</span> <span class="number">200</span>                                 &#123;product&#125;</span><br><span class="line">    <span class="type">uintx</span> <span class="variable">GCTimeLimit</span>                               <span class="operator">=</span> <span class="number">98</span>                                  &#123;product&#125;</span><br><span class="line">    <span class="type">uintx</span> <span class="variable">GCTimeRatio</span>                               <span class="operator">=</span> <span class="number">99</span>                                  &#123;product&#125;</span><br><span class="line">     <span class="type">bool</span> <span class="variable">HeapDumpAfterFullGC</span>                       <span class="operator">=</span> <span class="literal">false</span>                               &#123;manageable&#125;</span><br><span class="line">     <span class="type">bool</span> <span class="variable">HeapDumpBeforeFullGC</span>                      <span class="operator">=</span> <span class="literal">false</span>                               &#123;manageable&#125;</span><br><span class="line">    <span class="type">uintx</span> <span class="variable">HeapSizePerGCThread</span>                       <span class="operator">=</span> <span class="number">67108864</span>                            &#123;product&#125;</span><br><span class="line">    <span class="type">uintx</span> <span class="variable">MaxGCMinorPauseMillis</span>                     <span class="operator">=</span> <span class="number">4294967295</span>                          &#123;product&#125;</span><br><span class="line">    <span class="type">uintx</span> <span class="variable">MaxGCPauseMillis</span>                          <span class="operator">=</span> <span class="number">4294967295</span>                          &#123;product&#125;</span><br><span class="line">    <span class="type">uintx</span> <span class="variable">NumberOfGCLogFiles</span>                        <span class="operator">=</span> <span class="number">0</span>                                   &#123;product&#125;</span><br><span class="line">     <span class="type">intx</span> <span class="variable">ParGCArrayScanChunk</span>                       <span class="operator">=</span> <span class="number">50</span>                                  &#123;product&#125;</span><br><span class="line">    <span class="type">uintx</span> <span class="variable">ParGCDesiredObjsFromOverflowList</span>          <span class="operator">=</span> <span class="number">20</span>                                  &#123;product&#125;</span><br><span class="line">     <span class="type">bool</span> <span class="variable">ParGCTrimOverflow</span>                         <span class="operator">=</span> <span class="literal">true</span>                                &#123;product&#125;</span><br><span class="line">     <span class="type">bool</span> <span class="variable">ParGCUseLocalOverflow</span>                     <span class="operator">=</span> <span class="literal">false</span>                               &#123;product&#125;</span><br><span class="line">    <span class="type">uintx</span> <span class="variable">ParallelGCBufferWastePct</span>                  <span class="operator">=</span> <span class="number">10</span>                                  &#123;product&#125;</span><br><span class="line">    <span class="type">uintx</span> <span class="variable">ParallelGCThreads</span>                         <span class="operator">=</span> <span class="number">0</span>                                   &#123;product&#125;</span><br><span class="line">     <span class="type">bool</span> <span class="variable">ParallelGCVerbose</span>                         <span class="operator">=</span> <span class="literal">false</span>                               &#123;product&#125;</span><br><span class="line">     <span class="type">bool</span> <span class="variable">PrintClassHistogramAfterFullGC</span>            <span class="operator">=</span> <span class="literal">false</span>                               &#123;manageable&#125;</span><br><span class="line">     <span class="type">bool</span> <span class="variable">PrintClassHistogramBeforeFullGC</span>           <span class="operator">=</span> <span class="literal">false</span>                               &#123;manageable&#125;</span><br><span class="line">     <span class="type">bool</span> <span class="variable">PrintGC</span>                                   <span class="operator">=</span> <span class="literal">false</span>                               &#123;manageable&#125;</span><br><span class="line">     <span class="type">bool</span> <span class="variable">PrintGCApplicationConcurrentTime</span>          <span class="operator">=</span> <span class="literal">false</span>                               &#123;product&#125;</span><br><span class="line">     <span class="type">bool</span> <span class="variable">PrintGCApplicationStoppedTime</span>             <span class="operator">=</span> <span class="literal">false</span>                               &#123;product&#125;</span><br><span class="line">     <span class="type">bool</span> <span class="variable">PrintGCCause</span>                              <span class="operator">=</span> <span class="literal">true</span>                                &#123;product&#125;</span><br><span class="line">     <span class="type">bool</span> <span class="variable">PrintGCDateStamps</span>                         <span class="operator">=</span> <span class="literal">false</span>                               &#123;manageable&#125;</span><br><span class="line">     <span class="type">bool</span> <span class="variable">PrintGCDetails</span>                            <span class="operator">=</span> <span class="literal">false</span>                               &#123;manageable&#125;</span><br><span class="line">     <span class="type">bool</span> <span class="variable">PrintGCID</span>                                 <span class="operator">=</span> <span class="literal">false</span>                               &#123;manageable&#125;</span><br><span class="line">     <span class="type">bool</span> <span class="variable">PrintGCTaskTimeStamps</span>                     <span class="operator">=</span> <span class="literal">false</span>                               &#123;product&#125;</span><br><span class="line">     <span class="type">bool</span> <span class="variable">PrintGCTimeStamps</span>                         <span class="operator">=</span> <span class="literal">false</span>                               &#123;manageable&#125;</span><br><span class="line">     <span class="type">bool</span> <span class="variable">PrintHeapAtGC</span>                             <span class="operator">=</span> <span class="literal">false</span>                               &#123;product rw&#125;</span><br><span class="line">     <span class="type">bool</span> <span class="variable">PrintHeapAtGCExtended</span>                     <span class="operator">=</span> <span class="literal">false</span>                               &#123;product rw&#125;</span><br><span class="line">     <span class="type">bool</span> <span class="variable">PrintJNIGCStalls</span>                          <span class="operator">=</span> <span class="literal">false</span>                               &#123;product&#125;</span><br><span class="line">     <span class="type">bool</span> <span class="variable">PrintParallelOldGCPhaseTimes</span>              <span class="operator">=</span> <span class="literal">false</span>                               &#123;product&#125;</span><br><span class="line">     <span class="type">bool</span> <span class="variable">PrintReferenceGC</span>                          <span class="operator">=</span> <span class="literal">false</span>                               &#123;product&#125;</span><br><span class="line">     <span class="type">bool</span> <span class="variable">ScavengeBeforeFullGC</span>                      <span class="operator">=</span> <span class="literal">true</span>                                &#123;product&#125;</span><br><span class="line">     <span class="type">bool</span> <span class="variable">TraceDynamicGCThreads</span>                     <span class="operator">=</span> <span class="literal">false</span>                               &#123;product&#125;</span><br><span class="line">     <span class="type">bool</span> <span class="variable">TraceParallelOldGCTasks</span>                   <span class="operator">=</span> <span class="literal">false</span>                               &#123;product&#125;</span><br><span class="line">     <span class="type">bool</span> <span class="variable">UseAdaptiveGCBoundary</span>                     <span class="operator">=</span> <span class="literal">false</span>                               &#123;product&#125;</span><br><span class="line">     <span class="type">bool</span> <span class="variable">UseAdaptiveSizeDecayMajorGCCost</span>           <span class="operator">=</span> <span class="literal">true</span>                                &#123;product&#125;</span><br><span class="line">     <span class="type">bool</span> <span class="variable">UseAdaptiveSizePolicyWithSystemGC</span>         <span class="operator">=</span> <span class="literal">false</span>                               &#123;product&#125;</span><br><span class="line">     <span class="type">bool</span> <span class="variable">UseAutoGCSelectPolicy</span>                     <span class="operator">=</span> <span class="literal">false</span>                               &#123;product&#125;</span><br><span class="line">     <span class="type">bool</span> <span class="variable">UseConcMarkSweepGC</span>                        <span class="operator">=</span> <span class="literal">false</span>                               &#123;product&#125;</span><br><span class="line">     <span class="type">bool</span> <span class="variable">UseDynamicNumberOfGCThreads</span>               <span class="operator">=</span> <span class="literal">false</span>                               &#123;product&#125;</span><br><span class="line">     <span class="type">bool</span> <span class="variable">UseG1GC</span>                                   <span class="operator">=</span> <span class="literal">false</span>                               &#123;product&#125;</span><br><span class="line">     <span class="type">bool</span> <span class="variable">UseGCLogFileRotation</span>                      <span class="operator">=</span> <span class="literal">false</span>                               &#123;product&#125;</span><br><span class="line">     <span class="type">bool</span> <span class="variable">UseGCOverheadLimit</span>                        <span class="operator">=</span> <span class="literal">true</span>                                &#123;product&#125;</span><br><span class="line">     <span class="type">bool</span> <span class="variable">UseGCTaskAffinity</span>                         <span class="operator">=</span> <span class="literal">false</span>                               &#123;product&#125;</span><br><span class="line">     <span class="type">bool</span> <span class="variable">UseMaximumCompactionOnSystemGC</span>            <span class="operator">=</span> <span class="literal">true</span>                                &#123;product&#125;</span><br><span class="line">     <span class="type">bool</span> <span class="variable">UseParNewGC</span>                               <span class="operator">=</span> <span class="literal">false</span>                               &#123;product&#125;</span><br><span class="line">     <span class="type">bool</span> <span class="variable">UseParallelGC</span>                             <span class="operator">=</span> <span class="literal">false</span>                               &#123;product&#125;</span><br><span class="line">     <span class="type">bool</span> <span class="variable">UseParallelOldGC</span>                          <span class="operator">=</span> <span class="literal">false</span>                               &#123;product&#125;</span><br><span class="line">     <span class="type">bool</span> <span class="variable">UseSerialGC</span>                               <span class="operator">=</span> <span class="literal">false</span>                               &#123;product&#125;</span><br><span class="line">java version <span class="string">&quot;1.8.0_66&quot;</span></span><br><span class="line">Java(TM) SE Runtime <span class="title function_">Environment</span> <span class="params">(build <span class="number">1.8</span><span class="number">.0_66</span>-b17)</span></span><br><span class="line">Java <span class="title function_">HotSpot</span><span class="params">(TM)</span> Client <span class="title function_">VM</span> <span class="params">(build <span class="number">25.66</span>-b17, mixed mode)</span></span><br></pre></td></tr></table></figure>

<p><strong>调优领域</strong></p>
<ul>
<li>内存</li>
<li>锁竞争</li>
<li>cpu竞争</li>
<li>IO</li>
</ul>
<p><strong>确定目标</strong></p>
<ul>
<li>【低延迟】还是【高吞吐量】，选择合适的回收器</li>
<li>CMS，G1，ZGC（低延迟）</li>
<li>ParallelGC（高吞吐量）</li>
<li>Zing</li>
</ul>
<p><strong>最快的GC是不发生GC</strong></p>
<ul>
<li>查看FullGC前后的内存占用，考虑下面几个问题</li>
<li>数据是不是太多？（resultSet &#x3D; statement.executeQuery(“select * from table limit n”)）</li>
<li>数据表示是否太臃肿？（对象图、对象大小）16 Integer 24 int 4</li>
<li>是否存在内存泄漏？(第三方缓存实现redis，软引用，弱引用)</li>
</ul>
<p><strong>新生代调优</strong></p>
<ul>
<li><p>新生代的特点</p>
<p>所有的new操作的内存分配非常廉价</p>
<p>TLAB thread-local allocation buffer</p>
</li>
<li><p>死亡对象的回收代价是零</p>
</li>
<li><p>大部分对象用过即死</p>
</li>
<li><p>Minor GC的时间远远低于Full GC</p>
</li>
<li><p>新生代能容纳所有【并发量*（请求-响应）】的数据</p>
</li>
<li><p>幸存区大到能保留【当前活跃对象+需要晋升对象】</p>
</li>
<li><p>晋升阈值配置得当，让长时间存活对象尽快晋升</p>
<p>-XX:MaxTenuringThreshold&#x3D;threshold</p>
<p>-XX:+PrintTenuringDistribution</p>
<p><img src="/../images/img28.PNG" alt="img28"></p>
</li>
</ul>
<p><strong>老年代调优</strong></p>
<p>以CMS为例</p>
<ul>
<li>CMS的老年代内存越大越好</li>
<li>先尝试不做调优，如果没有Full GC那么已经……，否则先尝试调优新生代</li>
<li>观察发生Full GC时老年代内存占用，将老年代内存预设调大1&#x2F;4~1&#x2F;3</li>
<li>-XX:CMSInitiatingOccupancyFraction&#x3D;percent</li>
</ul>
<p><strong>案例</strong></p>
<ul>
<li>案例1：Full GC和Minor GC频繁</li>
<li>案例2：请求高峰期发生Full GC，单次暂停时间特别长（CMS）</li>
<li>案例3：老年代充裕情况下，发生Full GC（1.7）</li>
</ul>
<h4 id="类文件结构与字节码技术"><a href="#类文件结构与字节码技术" class="headerlink" title="类文件结构与字节码技术"></a>类文件结构与字节码技术</h4><p>详情见《深入理解java虚拟机》第三版。周志明。</p>
<p>当执行invokevirtual指令时，</p>
<ol>
<li>先通过栈帧中的对象引用找到对象</li>
<li>分析对象头，找到对象的实际class</li>
<li>class结构中有vtable，它在类加载的链接阶段就已经根据方法的重写规则生成好了</li>
<li>查表得到方法的具体地址</li>
<li>执行方法的字节码</li>
</ol>
<h4 id="编译期处理"><a href="#编译期处理" class="headerlink" title="编译期处理"></a>编译期处理</h4><ul>
<li>默认构造器</li>
<li>自动拆装箱</li>
<li>泛型集合取值</li>
<li>可变参数</li>
<li>foreach循环</li>
<li>switch字符串</li>
<li>switch枚举</li>
<li>枚举类</li>
<li>try-with-resources</li>
<li>方法重写时的桥接方法</li>
<li>匿名内部类</li>
</ul>
<h4 id="类加载阶段"><a href="#类加载阶段" class="headerlink" title="类加载阶段"></a>类加载阶段</h4><p><strong>加载</strong></p>
<p>将字节码载入方法区中，内部采用C++的InstanceKlass描述Java类，它的重要field有：</p>
<ul>
<li>_java_mirror即java的类镜像，例如对String来说，就是String.class，作用就是把Klass暴露给java使用</li>
<li>_super即父类</li>
<li>_fields即成员变量</li>
<li>_methods即方法</li>
<li>_constants即常量池</li>
<li>_class_loader即类加载器</li>
<li>_vtable虚方法表</li>
<li>_itable接口方法表</li>
</ul>
<p>如果这个类还有父类没有加载，先加载父类。</p>
<p>加载和链接可能是交替运行的。</p>
<p>注意：</p>
<ul>
<li>instanceKlass这样的【元数据】是存储在方法区（1.8后的元空间内），但_java_mirror是存储在堆中。</li>
<li>可以通过前面介绍的HSDB工具查看</li>
</ul>
<p><img src="/../images/img29.PNG" alt="img29"></p>
<p><strong>链接</strong></p>
<ul>
<li>验证：验证类是否符合JVM规范，安全性检查。用UE等支持二进制的编辑器修改HelloWorld.class的魔数，在控制台运行。</li>
</ul>
<p><img src="/../images/img30.PNG" alt="img30"></p>
<ul>
<li>准备：为static变量分配空间，设置默认值<ul>
<li>static变量在JDK7之前存储在InstanceKlass末尾，从JDK7开始，存储在_java_mirror末尾</li>
<li>static变量分配空间和赋值是两个步骤，分配空间在准备阶段完成，赋值在初始化阶段完成</li>
<li>如果static变量是final的基本类型以及字符串常量，那么编译阶段值就确定了，赋值在准备阶段完成</li>
<li>如果static变量是final的，但属于引用类型，那么赋值也会在初始化阶段完成</li>
</ul>
</li>
<li>解析：将常量池中的符号引用解析为直接引用</li>
</ul>
<p><img src="/../images/img31.PNG" alt="img31"></p>
<p><strong>初始化</strong></p>
<p><strong><cinit>()v方法</cinit></strong></p>
<p>初始化即调用<cinit>()v，虚拟机会保证这个类的构造方法的线程安全</cinit></p>
<p><strong>发生的时机</strong></p>
<p>概括的说，类初始化是懒惰的</p>
<ul>
<li>main方法所在的类，总会被首先初始化</li>
<li>首次访问这个类的静态变量或静态方法时</li>
<li>子类初始化，如果父类还没初始化，会引发</li>
<li>子类访问父类的静态变量，只会触发父类的初始化</li>
<li>Class.forName</li>
<li>new会导致初始化</li>
</ul>
<p>不会初始化的情况</p>
<ul>
<li>访问类的static final静态常量（基本类型和字符串）不会触发初始化</li>
<li>类对象.class不会触发初始化</li>
<li>创建类的数组不会触发初始化</li>
<li>类加载器的loadClass方法</li>
<li>Class.forName的参数2为false时</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.tzd;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> tianzedeng</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2022/5/6 - 16:49</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo10</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;main init&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 不会触发初始化</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="comment">//静态常量不会触发初始化</span></span><br><span class="line">        System.out.println(B.b);</span><br><span class="line">        <span class="comment">//类对象.class不会触发初始化</span></span><br><span class="line">        System.out.println(B.class);</span><br><span class="line">        <span class="comment">//创建该类的数组不会触发初始化</span></span><br><span class="line">        System.out.println(<span class="keyword">new</span> <span class="title class_">B</span>[<span class="number">0</span>]);</span><br><span class="line">        <span class="comment">//不会初始化类B，但会加载B、A</span></span><br><span class="line">        <span class="type">ClassLoader</span> <span class="variable">c1</span> <span class="operator">=</span> Thread.currentThread().getContextClassLoader();</span><br><span class="line">        c1.loadClass(<span class="string">&quot;cn.itcast.jvm.t3.load.B&quot;</span>);</span><br><span class="line">        <span class="comment">//不会初始化类B，但会加载B、A</span></span><br><span class="line">        <span class="type">ClassLoader</span> <span class="variable">c2</span> <span class="operator">=</span> Thread.currentThread().getContextClassLoader();</span><br><span class="line">        Class.forName(<span class="string">&quot;cn.itcast.jvm.t3.load.B&quot;</span>,<span class="literal">false</span>,c2);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 触发初始化</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="comment">//首次访问这个类的静态变量或静态方法时</span></span><br><span class="line">        System.out.println(A.a);</span><br><span class="line">        <span class="comment">//子类初始化，如果父类还没有初始化，会触发</span></span><br><span class="line">        System.out.println(B.c);</span><br><span class="line">        <span class="comment">//子类访问父类静态变量，只触发父类初始化</span></span><br><span class="line">        System.out.println(B.a);</span><br><span class="line">        <span class="comment">//会初始化类B，并先初始化A</span></span><br><span class="line">        Class.forName(<span class="string">&quot;cn.itcast.jvm.t3.load.B&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;a init&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">double</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">5.0</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">boolean</span> <span class="variable">c</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;b init&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>练习</strong></p>
<p>从字节码分析，使用a，b，c这三个常量是否会导致E初始化</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.tzd;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> tianzedeng</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2022/5/6 - 17:12</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo11</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(E.a);<span class="comment">//不会导致E初始化</span></span><br><span class="line">        System.out.println(E.b);<span class="comment">//不会导致E初始化</span></span><br><span class="line">        System.out.println(E.c);<span class="comment">//会导致E初始化</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">E</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">b</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Integer</span> <span class="variable">c</span> <span class="operator">=</span> <span class="number">20</span>;<span class="comment">//包装类型，Integer.valueOf(20)</span></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;init E&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> a;</span><br><span class="line">   descriptor: I</span><br><span class="line">   flags: ACC_PUBLIC, ACC_STATIC, ACC_FINAL</span><br><span class="line">   ConstantValue: <span class="type">int</span> <span class="number">10</span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> java.lang.String b;</span><br><span class="line">   descriptor: Ljava/lang/String;</span><br><span class="line">   flags: ACC_PUBLIC, ACC_STATIC, ACC_FINAL</span><br><span class="line">   ConstantValue: String hello</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> java.lang.Integer c;</span><br><span class="line">   descriptor: Ljava/lang/Integer;</span><br><span class="line">   flags: ACC_PUBLIC, ACC_STATIC, ACC_FINAL</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">static</span> &#123;&#125;;</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_STATIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">2</span>, locals=<span class="number">0</span>, args_size=<span class="number">0</span></span><br><span class="line">         <span class="number">0</span>: bipush        <span class="number">20</span></span><br><span class="line">         <span class="number">2</span>: invokestatic  #<span class="number">2</span>                  <span class="comment">// Method java/lang/Integer.valueOf:(I)Ljava/lang/Integer;</span></span><br><span class="line">         <span class="number">5</span>: putstatic     #<span class="number">3</span>                  <span class="comment">// Field c:Ljava/lang/Integer;</span></span><br><span class="line">         <span class="number">8</span>: getstatic     #<span class="number">4</span>                  <span class="comment">// Field java/lang/System.out:Ljava/io/PrintStream;</span></span><br><span class="line">        <span class="number">11</span>: ldc           #<span class="number">5</span>                  <span class="comment">// String init E</span></span><br><span class="line">        <span class="number">13</span>: invokevirtual #<span class="number">6</span>                  <span class="comment">// Method java/io/PrintStream.println:(Ljava/lang/String;)V</span></span><br><span class="line">        <span class="number">16</span>: <span class="keyword">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">20</span>: <span class="number">0</span></span><br><span class="line">        line <span class="number">22</span>: <span class="number">8</span></span><br><span class="line">        line <span class="number">23</span>: <span class="number">16</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>典型应用-完成懒惰初始化单例模式</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.tzd;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> tianzedeng</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2022/5/6 - 17:24</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo12</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//Singleton.test();</span></span><br><span class="line">        Singleton.getInstance();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;test&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">LazyHolder</span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Singleton</span> <span class="variable">SINGLETON</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">        <span class="keyword">static</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;lazy holder init&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> LazyHolder.SINGLETON;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h4><p><img src="/../images/img32.PNG" alt="img32"></p>
<p><strong>启动类加载器</strong></p>
<p>用BootStrap类加载器加载类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">F</span>&#123;</span><br><span class="line">	<span class="keyword">static</span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;bootstrap F init&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException&#123;</span><br><span class="line">		Class&lt;?&gt; aClass = Class.forName(<span class="string">&quot;包名.F&quot;</span>);</span><br><span class="line">		System.out.println(aClass.getClassLoader());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">bootstrap F init</span><br><span class="line"><span class="literal">null</span></span><br></pre></td></tr></table></figure>

<p><strong>扩展类加载器</strong></p>
<p>使用Extension加载器加载类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">G</span>&#123;</span><br><span class="line">	<span class="keyword">static</span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;classpath G init&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException&#123;</span><br><span class="line">		Class&lt;?&gt; aClass = Class.forName(<span class="string">&quot;包名.G&quot;</span>);</span><br><span class="line">		System.out.println(aClass.getClassLoader());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">classpath G init</span><br><span class="line">sun misc Launcher$AppClassLoader@18b4aac2</span><br></pre></td></tr></table></figure>

<p><strong>双亲委派模式</strong></p>
<p>所谓双亲委派，就是指调用类加载器的loadClass方法时，查找类的规则</p>
<p>注意：这里的双亲，翻译为上级似乎更为合适，因为它们并没有继承关系</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; loadClass(String name,<span class="type">boolean</span> resolve) </span><br><span class="line">         <span class="keyword">throws</span> ClassNotFoundException&#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(getClassLoadingLock(name))&#123;</span><br><span class="line">        <span class="comment">//1.检查该类是否已经加载</span></span><br><span class="line">        Class&lt;?&gt; c = findLoadedClass(name);</span><br><span class="line">        <span class="keyword">if</span>(c == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="type">long</span> <span class="variable">t0</span> <span class="operator">=</span> System.nanoTime();</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(parent != <span class="literal">null</span>)&#123;</span><br><span class="line">                    <span class="comment">//2.有上级的话，委派上级loadClass</span></span><br><span class="line">                    c = parent.loadClass(name,<span class="literal">false</span>);</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="comment">//3.如果没有上级了（ExtClassLoader）,则委派BootstrapClassLoader</span></span><br><span class="line">                    c = findBootstrapClassOrNull(name);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">catch</span>(ClassNotFoundException e)&#123;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(c == <span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="type">long</span> <span class="variable">t1</span> <span class="operator">=</span> System.nanoTime();</span><br><span class="line">                <span class="comment">//4.每一层找不到，调用findClass方法（每个类加载器自己扩展）来加载</span></span><br><span class="line">                c = findClass(name);</span><br><span class="line">                <span class="comment">//5.记录耗时</span></span><br><span class="line">                sun.misc.PerfCounter.getParentDelegationTime().addTime(t1-t0);</span><br><span class="line">                sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(resolve)&#123;</span><br><span class="line">            resolveClass(c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>线程上下文类加载器</strong></p>
<p>我们在使用JDBC时，都需要加载Driver驱动，不知道你注意没有，不写</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Class.forName(<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>也可以让com.mysql.jdbc.Driver正确加载。为什么？</p>
<p>追踪源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DriverManager</span>&#123;</span><br><span class="line">    <span class="comment">//注册驱动的集合</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> CopyOnWriteArrayList&lt;DriverInfo&gt; registeredDrivers</span><br><span class="line">        = <span class="keyword">new</span> <span class="title class_">CopyOnWriteArrayList</span>&lt;&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//初始化驱动</span></span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        loadInitialDriver();</span><br><span class="line">        println(<span class="string">&quot;JDBC DriverManager initialized&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>先不看别的，看看DriverManager的类加载器：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.println(DriverManager.class.getClassLoader());</span><br></pre></td></tr></table></figure>

<p>打印null，表示它的类加载器是Bootstrap ClassLoader，会到JAVA_HOME&#x2F;jre&#x2F;lib下搜索类，但JAVA_HOME&#x2F;jre&#x2F;lib下显然没有mysql-connector-java-版本号.jar包，那么，在DriverManager的静态代码块中，怎么能正确加载com.mysql.jdbc.Driver?——-打破双亲委派机制    </p>
<p>继续看loadInitialDrivers()方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">loadInitialDrivers</span><span class="params">()</span>&#123;</span><br><span class="line">    String drivers;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        drivers = AccessController.doPrivileged(<span class="keyword">new</span> <span class="title class_">PrivilegedAction</span>&lt;String&gt;()&#123;</span><br><span class="line">           <span class="keyword">public</span> String <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">               <span class="keyword">return</span> System.getProperty(<span class="string">&quot;jdbc.Driver&quot;</span>);</span><br><span class="line">           &#125; </span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;<span class="keyword">catch</span>(Exception ex)&#123;</span><br><span class="line">        drivers = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//1.使用ServiceLoader机制加载驱动，即SPI</span></span><br><span class="line">    AccessController.doPrivileged(<span class="keyword">new</span> <span class="title class_">PrivilegedAction</span>&lt;Void&gt;()&#123;</span><br><span class="line">       <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">           ServiceLoader&lt;Driver&gt; loadDrivers = ServiceLoader.load(Driver.class);</span><br><span class="line">           Iterator&lt;Driver&gt; driverIterator = loadedDrivers.iterator();</span><br><span class="line">           <span class="keyword">try</span>&#123;</span><br><span class="line">               <span class="keyword">while</span>(driversIterator.hasNext())&#123;</span><br><span class="line">                   driversIterator.next();</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;<span class="keyword">catch</span>()&#123;</span><br><span class="line">               <span class="comment">//Do nothing</span></span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">       &#125; </span><br><span class="line">    &#125;);</span><br><span class="line">    println(<span class="string">&quot;DriverManager.initialize:jdbc.drivers = &quot;</span> + drivers);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//2.使用jdbc.drivers定义驱动名加载驱动</span></span><br><span class="line">    <span class="keyword">if</span>(drivers == <span class="literal">null</span> || drivers.equals(<span class="string">&quot;&quot;</span>))&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    String[] driversList = drivers.split(<span class="string">&quot;:&quot;</span>);</span><br><span class="line">    println(<span class="string">&quot;number of Drivers:&quot;</span> + driversList.length);</span><br><span class="line">    <span class="keyword">for</span>(String aDriver:driversList)&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            println(<span class="string">&quot;DriverManager.Initialize: loading&quot;</span> + aDriver);</span><br><span class="line">            <span class="comment">//这里的ClassLoader.getSystemClassLoader()就是应用程序类加载器</span></span><br><span class="line">            Class.forName(aDriver,<span class="literal">true</span>,ClassLoader.getSystemClassLoader());</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception ex)&#123;</span><br><span class="line">            println(<span class="string">&quot;DriverManager.Initialize: load failed:&quot;</span> + ex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>自定义类加载器</strong></p>
<p>什么时候需要自定义类加载器？</p>
<ul>
<li>想加载菲classpath随意路径中的文件</li>
<li>都是通过接口来使用实现，希望解耦时，常用在框架设计</li>
<li>这些类希望予以隔离，不同应用的同名类都可以加载，不冲突，常见于tomcat容器</li>
</ul>
<p>步骤：</p>
<ol>
<li>继承ClassLoader父类</li>
<li>要遵循双亲委派机制，重写findClass方法。<strong>注意不是重写loadClass方法，否则不会走双亲委派机制</strong></li>
<li>读取类文件的字节码</li>
<li>调用父类的defineClass方法来加载类</li>
<li>使用者调用该类加载器的loadClass方法</li>
</ol>
<h3 id="6-内存模型"><a href="#6-内存模型" class="headerlink" title="6.内存模型"></a>6.内存模型</h3><h4 id="java内存模型（Java-Memory-Model）"><a href="#java内存模型（Java-Memory-Model）" class="headerlink" title="java内存模型（Java Memory Model）"></a><strong>java内存模型（Java Memory Model）</strong></h4><p>JMM定义了一套在多线程读写共享数据时（成员变量、数组）时，对数据的可见性、有序性、和原子性的规则和保障。</p>
<p><strong>原子性</strong></p>
<p>问题提出：两个线程对初始值为0的静态变量一个做自增，一个做自减，各做5000次，结果是0吗？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException&#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() - &gt; &#123;</span><br><span class="line">           <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;j &lt; <span class="number">5000</span>;j++)&#123;</span><br><span class="line">               i++;</span><br><span class="line">           &#125; </span><br><span class="line">        &#125;);</span><br><span class="line">        </span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() - &gt; &#123;</span><br><span class="line">           <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;j &lt; <span class="number">5000</span>;j++)&#123;</span><br><span class="line">               i--;</span><br><span class="line">           &#125; </span><br><span class="line">        &#125;);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        </span><br><span class="line">        t1.join();</span><br><span class="line">        t2.join();</span><br><span class="line">        System.out.println(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>问题分析</strong></p>
<p>以上结果可能是正数、负数、零，为什么？因为java中对静态变量的自增，自减并不是原子操作。</p>
<p>例如，对于i++而言（i是静态变量），实际会产生如下的JVM字节码指令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">getstatic	i	//获取静态变量i的值</span><br><span class="line">iconst_1		//准备常量1</span><br><span class="line">iadd			//自增</span><br><span class="line">putstatic	i	//将修改后的值存入静态变量i</span><br></pre></td></tr></table></figure>

<p>而对应i–也是类似：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">getstatic	i	//获取静态变量i的值</span><br><span class="line">iconst_1		//准备常量1</span><br><span class="line">isub			//自减</span><br></pre></td></tr></table></figure>

<p>而java的内存模型如下，完成静态变量的自增，自减需要在主存和线程内存中进行数据交换：</p>
<p><img src="/../images/img33.PNG" alt="img33"></p>
<p>如果是单线程以上8行代码是顺序执行（不会交错）没有问题：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//假设i的初始值为0</span><br><span class="line">getstatic	i	//线程1-获取静态变量i的值 线程内i=0</span><br><span class="line">iconst_1		//线程1-准备常量1</span><br><span class="line">iadd			//线程1-自增 线程内i=1</span><br><span class="line">putstatic	i	//线程1-将修改后的值存入静态变量i 静态变量i=1</span><br><span class="line">getstatic	i	//线程1-获取静态变量i的值 线程内i=1</span><br><span class="line">iconst_1		//准备常量1</span><br><span class="line">isub			//线程1-自减 线程内i=0</span><br><span class="line">putstatic	i	//线程1-将修改后的值存入静态变量i 静态变量i=0</span><br></pre></td></tr></table></figure>

<p>但多线程下这8行代码可能出现交错运行</p>
<p>出现负数的情况：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//假设i的初始值为0</span><br><span class="line">getstatic	i	//线程1-获取静态变量i的值 线程内i=0</span><br><span class="line">getstatic	i	//线程2-获取静态变量i的值 线程内i=0</span><br><span class="line">iconst_1		//线程1-准备常量1</span><br><span class="line">iadd			//线程1-自增 线程内i=1</span><br><span class="line">putstatic	i	//线程1-将修改后的值存入静态变量i 静态变量i=1</span><br><span class="line">iconst_1		//线程2-准备常量1</span><br><span class="line">isub			//线程2-自减 线程内i=-1</span><br><span class="line">putstatic	i	//线程2-将修改后的值存入静态变量i 静态变量i=-1</span><br></pre></td></tr></table></figure>

<p>出现正数的情况：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//假设i的初始值为0</span><br><span class="line">getstatic	i	//线程1-获取静态变量i的值 线程内i=0</span><br><span class="line">getstatic	i	//线程2-获取静态变量i的值 线程内i=0</span><br><span class="line">iconst_1		//线程1-准备常量1</span><br><span class="line">iadd			//线程1-自增 线程内i=1</span><br><span class="line">iconst_1		//线程2-准备常量1</span><br><span class="line">isub			//线程2-自减 线程内i=-1</span><br><span class="line">putstatic	i	//线程2-将修改后的值存入静态变量i 静态变量i=-1</span><br><span class="line">putstatic	i	//线程1-将修改后的值存入静态变量i 静态变量i=1</span><br></pre></td></tr></table></figure>

<p><strong>解决方法</strong></p>
<p>synchronized（同步关键字）</p>
<p>语法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(对象)&#123;</span><br><span class="line">    要作为原子操作代码</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>用synchronized解决并发问题：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException&#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() - &gt; &#123;</span><br><span class="line">           <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;j &lt; <span class="number">5000</span>;j++)&#123;</span><br><span class="line">               <span class="keyword">synchronized</span>(obj)&#123;</span><br><span class="line">                   i++;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125; </span><br><span class="line">        &#125;);</span><br><span class="line">        </span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() - &gt; &#123;</span><br><span class="line">           <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;j &lt; <span class="number">5000</span>;j++)&#123;</span><br><span class="line">               <span class="keyword">synchronized</span>(obj)&#123;</span><br><span class="line">                   i--;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125; </span><br><span class="line">        &#125;);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        </span><br><span class="line">        t1.join();</span><br><span class="line">        t2.join();</span><br><span class="line">        System.out.println(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果为：0</p>
<h4 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h4><p><strong>退不出的循环</strong></p>
<p>先看一个现象，main线程对run变量的修改对于t线程不可见，导致了t线程无法停止：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="type">boolean</span> <span class="variable">run</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() - &gt;&#123;</span><br><span class="line">        <span class="keyword">while</span>(run)&#123;</span><br><span class="line">            <span class="comment">//.....</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; );</span><br><span class="line">    t.start();</span><br><span class="line">    </span><br><span class="line">    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">    run = <span class="literal">false</span>;<span class="comment">//线程t不会如预想的停下来</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>分析：</strong></p>
<ol>
<li><p>初始状态，t线程刚开始从主内存读取了run的值到工作内存。</p>
<p><img src="/../images/img34.PNG" alt="img34"></p>
</li>
<li><p>因为t线程要频繁从主内存中读取run的值，JIT编译器会将run的值缓存至自己工作内存中的高速缓存中，减少对主存中run的访问，提高效率。</p>
<p><img src="/../images/img35.PNG" alt="img35"></p>
</li>
<li><p>1秒后，main线程修改了run的值，并同步至主存，而t是从自己工作内存中的高速缓存中读取这个变量的值，结果永远是旧值。</p>
<p><img src="/../images/img36.PNG" alt="img36"></p>
</li>
</ol>
<p><strong>解决方法</strong></p>
<p>volatile（易变关键字）</p>
<p>它可以用来修饰成员变量和静态成员变量，可以避免线程从自己的工作缓存中查找变量的值，必须到主存中获取它的值，线程操作volatile变量都是直接操作主存。</p>
<p><strong>可见性</strong></p>
<p>前面的例子体现的实际上就是可见性，它保证的是在多个线程之间，一个线程对volatile变量的修改对另一个线程可见，不能保证原子性，仅用在一个写线程，多个读线程情况：</p>
<p>上个例子从字节码理解是这样的：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">getstatic	run	//线程t获取run true</span><br><span class="line">getstatic	run	//线程t获取run true</span><br><span class="line">getstatic	run	//线程t获取run true</span><br><span class="line">getstatic	run	//线程t获取run true</span><br><span class="line">getstatic	run	//线程main修改run为false，仅此一次</span><br><span class="line">getstatic	run	//线程t获取run false</span><br></pre></td></tr></table></figure>

<p>比较一下之前的两个线程i++和i–</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//假设i的初始值为0</span><br><span class="line">getstatic	i	//线程1-获取静态变量i的值 线程内i=0</span><br><span class="line">getstatic	i	//线程2-获取静态变量i的值 线程内i=0</span><br><span class="line">iconst_1		//线程1-准备常量1</span><br><span class="line">iadd			//线程1-自增 线程内i=1</span><br><span class="line">putstatic	i	//线程1-将修改后的值存入静态变量i 静态变量i=1</span><br><span class="line">iconst_1		//线程2-准备常量1</span><br><span class="line">isub			//线程2-自减 线程内i=-1</span><br><span class="line">putstatic	i	//线程2-将修改后的值存入静态变量i 静态变量i=-1</span><br></pre></td></tr></table></figure>

<p>注意：synchronized语句块既可以保证代码块的原子性，也同时保证代码块内变量的可见性，但缺点是synchronized是属于重量级操作，性能相对较低。</p>
<h4 id="有序性"><a href="#有序性" class="headerlink" title="有序性"></a>有序性</h4><p><strong>诡异的结果</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="type">boolean</span> <span class="variable">ready</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//线程1执行此方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">actor1</span><span class="params">(I_Result r)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(ready)&#123;</span><br><span class="line">        r.r1 = num + num;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        r.r1 = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//线程2执行此方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">actor2</span><span class="params">(I_Result r)</span>&#123;</span><br><span class="line">    num = <span class="number">2</span>;</span><br><span class="line">    ready = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>I_Result是一个对象，有一个属性r1用来保存结果，可能的结果有几种？</p>
<p>情况1：线程1先执行，这时ready &#x3D; false，所以进入else分支结果为1；</p>
<p>情况2：线程2先执行num &#x3D; 2，但是没来得及执行ready &#x3D; true，线程1执行，还是进入else分支，结果为1；</p>
<p>情况3：线程2执行到ready &#x3D; true，线程1执行，这回进入if分支，结果为4（因为num已经执行过了）；</p>
<p>情况4：线程2执行ready &#x3D; true，切换到线程1，进入if分支，相加为0，再切回线程2执行num &#x3D; 2。</p>
<p>这种现象叫做指令重排，是JIT编译器在运行时的一些优化，这个现象需要大量测试才能复现。</p>
<p><strong>解决方法</strong>(volatile修饰)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@JCStressTest</span></span><br><span class="line"><span class="meta">@Outcome(id = &#123;&quot;1&quot;,&quot;4&quot;&#125;,expect = Expect.ACCEPTABLE,desc = &quot;ok&quot;)</span></span><br><span class="line"><span class="meta">@Outcome(id = &quot;0&quot;,expect = Expect.ACCEPTABLE_INTERESTING,desc = &quot;!!!!&quot;)</span></span><br><span class="line"><span class="meta">@State</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcurrentTest</span>&#123;</span><br><span class="line">	<span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">volatile</span> <span class="type">boolean</span> <span class="variable">ready</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//线程1执行此方法</span></span><br><span class="line">    <span class="meta">@Actor</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">actor1</span><span class="params">(I_Result r)</span>&#123;</span><br><span class="line">    	<span class="keyword">if</span>(ready)&#123;</span><br><span class="line">        	r.r1 = num + num;</span><br><span class="line">    	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        	r.r1 = <span class="number">1</span>;</span><br><span class="line">    	&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//线程2执行此方法</span></span><br><span class="line">    <span class="meta">@Actor</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">actor2</span><span class="params">(I_Result r)</span>&#123;</span><br><span class="line">    	num = <span class="number">2</span>;</span><br><span class="line">    	ready = <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mvn clean install</span><br><span class="line">java -jar target/jcstress.jar</span><br></pre></td></tr></table></figure>

<p>会输出我们感兴趣的结果，摘录其中一次结果：</p>
<p><img src="/../images/img37.PNG" alt="img37"></p>
<p><strong>有序性理解</strong></p>
<p>指令重排—&gt;double-checked locking</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Singleton</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Singleton</span> <span class="variable">INSTANCE</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//实例没创建，才会进入内部的synchronized代码块</span></span><br><span class="line">        <span class="keyword">if</span>（INSTANCE == <span class="literal">null</span>）&#123;</span><br><span class="line">            <span class="keyword">synchronized</span>(Singleton.class)&#123;</span><br><span class="line">                <span class="comment">//也许有其它线程已经创建实例，所以再判断一次</span></span><br><span class="line">                <span class="keyword">if</span>(INSATNCE == <span class="literal">null</span>)&#123;</span><br><span class="line">                    INSTANCE = <span class="keyword">new</span> <span class="title class_">Sinleton</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上实现特点是：</p>
<ul>
<li>懒惰实例化</li>
<li>首次使用getInstance()才使用synchronized加锁，后续使用时无需加锁</li>
</ul>
<p>但在多线程环境下，上面的代码是有问题的，INSTANCE &#x3D; new Singleton()对应的字节码为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0：new			#2</span><br><span class="line">3：dup</span><br><span class="line">4：invokespecial	#3</span><br><span class="line">7：putstatic		#4</span><br></pre></td></tr></table></figure>

<p><strong>happens-before</strong></p>
<p>happens-before规定了哪些写操作对其他线程的读操作性可见，它是可见性与有序性的一套规则总结：</p>
<ul>
<li>线程解锁m之前对变量的写，对于接下来对m加锁的其它线程对该变量的读可见</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="type">int</span> x;</span><br><span class="line"><span class="keyword">static</span> <span class="type">Object</span> <span class="variable">m</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(() - &gt; &#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(m)&#123;</span><br><span class="line">        x = <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,<span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(() - &gt; &#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(m)&#123;</span><br><span class="line">        System.out.println(x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,<span class="string">&quot;t2&quot;</span>).start();</span><br></pre></td></tr></table></figure>

<ul>
<li>线程对volatile变量的写，对接下来其它线程对该变量的读可见</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">volatile</span> <span class="keyword">static</span> <span class="type">int</span> x;</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(() - &gt;&#123;</span><br><span class="line">    x = <span class="number">10</span>;</span><br><span class="line">&#125;,<span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(() - &gt;&#123;</span><br><span class="line">    System.out.println(x);</span><br><span class="line">&#125;,<span class="string">&quot;t2&quot;</span>).start();</span><br></pre></td></tr></table></figure>

<ul>
<li>线程start前对变量的写，对该线程开始后对该变量的读可见</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="type">int</span> x;</span><br><span class="line"></span><br><span class="line">x = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(() - &gt; &#123;</span><br><span class="line">    System.out.println(x);</span><br><span class="line">&#125;,<span class="string">&quot;t2&quot;</span>).start();</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="type">int</span> x;</span><br><span class="line"></span><br><span class="line">x = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">    System.out.println(x);</span><br><span class="line">&#125;,<span class="string">&quot;t2&quot;</span>).start();</span><br></pre></td></tr></table></figure>

<ul>
<li>线程结束前对变量的写，对其它线程得知它结束后的读可见（比如其它线程调用t1.isAlive()或t1.join()等待它结束）</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="type">int</span> x;</span><br><span class="line"></span><br><span class="line"><span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">    x = <span class="number">10</span>;</span><br><span class="line">&#125;,<span class="string">&quot;t1&quot;</span>);</span><br><span class="line">t1.start();</span><br><span class="line"></span><br><span class="line">t1.join();</span><br><span class="line">System.out.println(x);</span><br></pre></td></tr></table></figure>

<ul>
<li>线程t1打断t2前对变量的写，对于其他线程得知t2被打断后对变量的读可见（通过t2.interrupted或t2.isInterrupted）</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="type">int</span> x;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(Thread.currentThread().isInterrupted())&#123;</span><br><span class="line">                System.out.prinln(x);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,<span class="string">&quot;t2&quot;</span>);</span><br><span class="line">    t2.start();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125;<span class="keyword">catch</span>(InterruptedException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        x = <span class="number">10</span>;</span><br><span class="line">        t2.interrupt();</span><br><span class="line">    &#125;,<span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(!t2.isInterrupted())&#123;</span><br><span class="line">        Thread.yield();</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="CAS与原子类"><a href="#CAS与原子类" class="headerlink" title="CAS与原子类"></a>CAS与原子类</h4><p><strong>CAS</strong></p>
<p>CAS即Compare and Swap，它体现的一种乐观锁的思想，比如多个线程要对一个共享的整型变量执行+1操作：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//需要不断尝试</span></span><br><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">    <span class="type">int</span> 旧值 = 共享变量；<span class="comment">//比如拿到当前值0</span></span><br><span class="line">    <span class="type">int</span> 结果 = 旧值 + <span class="number">1</span>；<span class="comment">//在旧值0的基础上增加1，正确结果是1</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    这时候如果别的线程把共享变量改成了5，本线程的正确结果就作废了，这时候</span></span><br><span class="line"><span class="comment">    CAS返回false，重新尝试，知道：</span></span><br><span class="line"><span class="comment">    CAS返回true，表示本线程做修改的同时，别的线程没有干扰</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">if</span>(compareAndSwap(旧值，结果))&#123;</span><br><span class="line">        <span class="comment">//成功，退出循环</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>获取共享变量时，为了保证该变量的可见性，需要使用volatile修饰。结合CAS和volatile可以实现无锁并发，使用于竞争不激烈，多核CPU的场景下。</p>
<ul>
<li>因为没有使用synchronized，所以线程不会陷入阻塞，这是效率提升的原因</li>
<li>但如果竞争激烈，可以想到重试必须频繁发生，反而效率会受影响</li>
</ul>
<p>CAS底层依赖于一个Unsafe类来直接调用操作系统底层的CAS指令，下面是直接使用Unsafe对象进行线程安全保护的例子。</p>
<p><strong>乐观锁与悲观锁</strong></p>
<ul>
<li>CAS是基于乐观锁思想：最乐观的估计，不怕别的线程来修改共享变量，就算改了也没关系，重试就好了。</li>
<li>synchronized是基于悲观锁的思想：最悲观的估计，得防着其它线程来修改共享变量，我上了锁你们都别想改，我改完了解开锁，你们才有机会。</li>
</ul>
<p><strong>原子操作类</strong></p>
<h3 id="7-synchronized优化"><a href="#7-synchronized优化" class="headerlink" title="7.synchronized优化"></a>7.synchronized优化</h3><p>Java HotSpot虚拟机中，每个对象都有对象头（包括class指针和Mark World）。Mark World平时存储这个对象的哈希码、分带年龄，当加锁时，这些信息就根据情况被替代为标记位、线程锁记录指针、重量级锁指针、线程ID等内容。</p>
<h4 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a><strong>轻量级锁</strong></h4><p>如果一个对象虽然有多线程访问，但多线程访问的时间是错开的（也就是没有竞争），那么可以使用轻量级锁来优化。这就好比：</p>
<p>学生（线程A）用课本占座，上了半节课，出门了（CPU时间到），回来一看，发现课本没变，说明没有竞争，继续上他的课。</p>
<p>如果这期间有其它学生（线程B）来了，会告知（线程A）有并发访问，线程A随即升级为重量级锁，进入重量级锁流程。</p>
<p>而重量级锁就不是那么用课本占座那么简单了，可以想象线程A走之前，把座位用一个铁栅栏围起来</p>
<p>假设有两个方法同步块，利用同一个对象加锁</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method1</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(obj)&#123;</span><br><span class="line">        <span class="comment">//同步块A</span></span><br><span class="line">        method2();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method2</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(obj)&#123;</span><br><span class="line">        <span class="comment">//同步块B</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>每个线程的栈帧都会包含一个锁记录的结构，内部可以存储锁定对象的Mark World。</p>
<p><img src="/../images/img38.PNG" alt="img38"></p>
<p><img src="/../images/img39.PNG" alt="img39"></p>
<h4 id="锁膨胀"><a href="#锁膨胀" class="headerlink" title="锁膨胀"></a><strong>锁膨胀</strong></h4><p>如果在尝试加轻量级锁的过程中，CAS操作无法成功，这时一种情况就是有其它线程为此对象加上了轻量级锁（有竞争），这时需要进行锁膨胀，将轻量级锁变成重量级锁。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method1</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(obj)&#123;</span><br><span class="line">        <span class="comment">//同步块</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/../images/img40.PNG" alt="img40"></p>
<p><img src="/../images/img41.PNG" alt="img41"></p>
<h4 id="重量锁"><a href="#重量锁" class="headerlink" title="重量锁"></a><strong>重量锁</strong></h4><p>重量级锁竞争的时候，还可以使用自旋来进行优化，如果当前线程自旋成功（即这个时候锁线程已经退出了同步块，释放了锁），这时当前线程就可以避免阻塞。</p>
<p>在Java6之后自旋锁是自适应的，比如对象刚刚的一次自旋操作成功过，那么认为这次自旋成功的可能性会高，就多自旋几次；反之，就少自旋甚至不自旋，总之，比较智能。</p>
<ul>
<li>自旋会占用CPU时间，单核CPU自旋就是浪费，多核CPU自旋才能发挥优势。</li>
<li>好比等红灯时汽车是不是熄火，不熄火相当于自旋（等待时间短了划算），熄火相当于阻塞（等待时间长了划算）</li>
<li>Java7之后不能控制是否开启自旋功能</li>
</ul>
<p>自旋重试成功的情况</p>
<p><img src="/../images/img42.PNG" alt="img42"></p>
<p> 自旋重试失败的情况</p>
<p><img src="/../images/img43.PNG" alt="img43"></p>
<h4 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a><strong>偏向锁</strong></h4><p>轻量级锁在没有竞争时（就自己这个线程），每次重入仍然需要执行CAS操作。Java6中引入了偏向锁来做进一步优化：只有第一次使用CAS将线程ID设置到对象的Mark World头，之后发现这个线程ID是自己的就表示没有竞争，不用重新使用CAS。</p>
<ul>
<li>撤销偏向需要将持锁线程升级为轻量级锁，这个过程中所有的线程需要暂停（STW）</li>
<li>访问对象的hashCode也会撤销偏向锁</li>
<li>如果对象虽然被多个线程访问，但没有竞争，这时偏向了线程T1的对象仍有机会重新偏向T2，之后重置对象的线程ID</li>
<li>撤销偏向和重偏向都是批量进行的，以类为单位</li>
<li>如果撤销偏向到达某个阈值，整个类的所有对象都会变为不可偏向的</li>
<li>可以主动使用-XX：-UseBiasedLocking禁用偏向锁</li>
</ul>
<p>假设有两个方法同步块，利用同一对象加锁</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method1</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(obj)&#123;</span><br><span class="line">        <span class="comment">//同步块A</span></span><br><span class="line">        method2();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method2</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(obj)&#123;</span><br><span class="line">        <span class="comment">//同步块B</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="其它优化"><a href="#其它优化" class="headerlink" title="其它优化"></a><strong>其它优化</strong></h4><ol>
<li><p>减少上锁时间</p>
<p>同步代码块中尽量短</p>
</li>
<li><p>减少锁的粒度</p>
<p>将一个锁拆分为多个锁提高并发度，例如：</p>
<ul>
<li>ConcurrentHashMap</li>
<li>LongAdder分为base和cells两部分。没有并发争用的时候或是cells数组正在初始化的时候，会使用CAS来累加值到base，有并发争用，会初始化cells数组，数组有多少个cell，就允许有多少个线程并行修改，最后将数组中每个cells累加，再加上base就是最终的值。</li>
<li>LinkedBlockingQueue入队和出队使用不同的锁，相对于LinkedBlockingArray只有一个锁效率要高。</li>
</ul>
</li>
<li><p>锁粗化</p>
<p>多次循环进入同步块不如同步块内多次循环</p>
<p>另外JVM可能会做如下优化，把多次append的加锁操作粗化为一次（因为都是对同一个对象加锁，没必要重入多次）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">StringBuffer</span>().append(<span class="string">&quot;a&quot;</span>).append(<span class="string">&quot;b&quot;</span>).append(<span class="string">&quot;c&quot;</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>锁消除</p>
<p>JVM会进行代码的逃逸分析，例如某个加锁对象时方法内局部变量，不会被其它线程访问到 ，这时候就会被即时编译器忽略掉所有同步操作。</p>
</li>
<li><p>读写分离</p>
<p>CopyOnWriteArrayList</p>
<p>ConvOnWriteSet</p>
</li>
</ol>
]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
</search>
