<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>JUC高并发编程</title>
    <url>/2022/03/15/JUC%E9%AB%98%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>多线程与高并发</category>
      </categories>
      <tags>
        <tag>多线程与高并发</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM概述</title>
    <url>/2022/03/14/JVM-%E7%A8%8B%E5%BA%8F%E8%AE%A1%E6%95%B0%E5%99%A8/</url>
    <content><![CDATA[<h3 id="JVM内存模型"><a href="#JVM内存模型" class="headerlink" title="JVM内存模型"></a>JVM内存模型</h3><span id="more"></span>

<h3 id="1、什么是JVM？"><a href="#1、什么是JVM？" class="headerlink" title="1、什么是JVM？"></a>1、什么是JVM？</h3><ul>
<li>JVM是一种用于计算设备的规范，它是一个虚构出来的机器，是通过在实际的计算机上仿真模拟各种功能实现的。</li>
<li>JVM包含一套字节码指令集，一组寄存器，一个栈，一个垃圾回收堆和一个存储方法域。</li>
<li>JVM屏蔽了与具体操作系统平台相关的信息，使java程序只需要生成在java虚拟机上运行的目标代码（字节码），就可以在多种平台上不加修改地运行。</li>
</ul>
<p>JVM在执行字节码时，实际上最终还是把字节码解释成具体平台上的机器指令执行。</p>
<h3 id="2、JDK、JRE、JVM是什么关系？"><a href="#2、JDK、JRE、JVM是什么关系？" class="headerlink" title="2、JDK、JRE、JVM是什么关系？"></a>2、JDK、JRE、JVM是什么关系？</h3><ul>
<li>JRE（Java Runtime Environment），也就是java平台。所有的java程序都要在JRE环境下才能运行。</li>
<li>JDK（Java Development  Kit），是开发者用来编译、调试程序用的开发包。JDK也是JAVA程序需要在JRE上运行的。</li>
<li>JVM（Java Virtual Machine），是JRE的一部分。它是一个虚构出来的计算机，是通过在实际的计算机上仿真模拟各种计算机功能来实现的。</li>
</ul>
<p>JVM有自己完善的硬件架构，如处理器、堆栈、寄存器等，还具有相应的指令系统。</p>
<p>Java语言最重要的特点就是跨平台运行。使用JVM就是为了支持与操作系统无关，实现跨平台。</p>
<h3 id="3、JVM原理"><a href="#3、JVM原理" class="headerlink" title="3、JVM原理"></a>3、JVM原理</h3><ul>
<li>jvm是java的核心和基础，在java编译器和os平台之间的虚拟处理器，可在上面执行字节码程序。</li>
<li>java编译器只要面向jvm，生成jvm能理解的字节码文件。java源文件经编译成字节码程序，通过jvm将每条指令翻译成不同的机器码，通过特定平台运行。</li>
</ul>
<p><img src="/../images/26.png" alt="26"></p>
<h3 id="4、JVM执行程序的过程"><a href="#4、JVM执行程序的过程" class="headerlink" title="4、JVM执行程序的过程"></a>4、JVM执行程序的过程</h3><ul>
<li>加载.class文件</li>
<li>管理并分配内存</li>
<li>执行垃圾收集</li>
</ul>
<p>JRE（java运行时环境）由JVM构造的java程序的运行环，也是Java程序运行的环境，但是他同时一个操作系统的一个应用程序一个进程，因此他也有他自己的运行的生命周期，也有自己的代码和数据空间。JVM在整个jdk中处于最底层，负责于操作系统的交互，用来屏蔽操作系统环境，提供一个完整的Java运行环境，因此也就虚拟计算机。</p>
<p>操作系统装入JVM是通过jdk中Java.exe来完成，<br>通过下面4步来完成JVM环境：</p>
<ul>
<li>创建JVM装载环境和配置</li>
<li>装载JVM.dll</li>
<li>初始化JVM.dll并挂界到JNIENV(JNI调用接口)实例</li>
<li>调用JNIEnv实例装载并处理class类。</li>
</ul>
<h3 id="5、JVM的生命周期"><a href="#5、JVM的生命周期" class="headerlink" title="5、JVM的生命周期"></a>5、JVM的生命周期</h3><ul>
<li><p>JVM实例对应了一个独立运行的java程序它是进程级别</p>
<p>a) 启动。启动一个Java程序时，一个JVM实例就产生了，任何一个拥有public static void<br>main(String[] args)函数的class都可以作为JVM实例运行的起点。<br>b) 运行。main()作为该程序初始线程的起点，任何其他线程均由该线程启动。JVM内部有两种线程：守护线程和非守护线程，main()属于非守护线程，守护线程通常由JVM自己使用，java程序也可以表明自己创建的线程是守护线程。<br>c) 消亡。当程序中的所有非守护线程都终止时，JVM才退出；若安全管理器允许，程序也可以使用Runtime类或者System.exit()来退出。</p>
</li>
<li><p>JVM执行引擎实例则对应了属于用户运行程序的线程它是线程级别的。</p>
</li>
</ul>
<h3 id="6、JVM内存模型"><a href="#6、JVM内存模型" class="headerlink" title="6、JVM内存模型"></a>6、JVM内存模型</h3><ul>
<li>java代码具体执行过程如下图，</li>
</ul>
<p><img src="/../images/27.png" alt="27"></p>
<ul>
<li>运行时数据区，即jvm内存结构图如下图，</li>
</ul>
<p><img src="/../images/28.png" alt="28"></p>
<ul>
<li><p>运行时数据区存储了哪些数据？</p>
</li>
<li><p><input disabled type="checkbox"> 
程序计数器(PC寄存器)</p>
<p>由于在JVM中，多线程是通过线程轮流切换来获得CPU执行时间的，因此，在任一具体时刻，一个CPU的内核只会执行一条线程中的指令，</p>
<p>因此，为了能够使得每个线程都在线程切换后能够恢复在切换之前的程序执行位置，每个线程都需要有自己独立的程序计数器，并且不能互相被干扰，</p>
<p>否则就会影响到程序的正常执行次序。因此，可以这么说，程序计数器是每个线程所私有的。由于程序计数器中存储的数据所占空间的大小不会随程序的执行而发生改变，</p>
<p>因此，对于程序计数器是不会发生内存溢出现象(OutOfMemory)的。</p>
</li>
<li><p><input disabled type="checkbox"> 
java栈</p>
<p>Java栈中存放的是一个个的栈帧，每个栈帧对应一个被调用的方法，在栈帧中包括局部变量表(Local Variables)、操作数栈(Operand Stack)、</p>
<p>指向当前方法所属的类的运行时常量池（运行时常量池的概念在方法区部分会谈到）的引用(Reference to runtime constant pool)、</p>
</li>
</ul>
<p>**方法返回地址(Return Address)**和一些额外的附加信息。当线程执行一个方法时，就会随之创建一个对应的栈帧，并将建立的栈帧压栈。当方法执行完毕之后，便会将栈帧出栈。</p>
<p><img src="/../images/29.png" alt="29"></p>
<ul>
<li><p><input disabled type="checkbox"> 
本地方法栈</p>
<p>本地方法栈与Java栈的作用和原理非常相似。区别只不过是Java栈是为执行Java方法服务的，而本地方法栈则是为执行本地方法（Native Method）服务的。</p>
</li>
<li><p><input disabled type="checkbox"> 
堆</p>
<p>Java中的堆是用来存储对象本身的以及数组（数组引用是存放在Java栈中的）。堆是被所有线程共享的，在JVM中只有一个堆。</p>
</li>
<li><p><input disabled type="checkbox"> 
方法区</p>
<p>与堆一样，是被线程共享的区域。在方法区中，存储了每个类的信息（包括类的名称、方法信息、字段信息）、静态变量、常量以及编译器编译后的代码等。</p>
<p>在Class文件中除了类的字段、方法、接口等描述信息外，还有一项信息是常量池，用来存储编译期间生成的字面量和符号引用。</p>
</li>
</ul>
<p>在方法区中有一个非常重要的部分就是运行时常量池，它是每一个类或接口的常量池的运行时表示形式，在类和接口被加载到JVM后，</p>
<p>对应的运行时常量池就被创建出来。当然并非Class文件常量池中的内容才能进入运行时常量池，在运行期间也可将新的常量放入运行时常量池中，比如String的intern方法。</p>
<h3 id="7、JVM内存溢出的情况"><a href="#7、JVM内存溢出的情况" class="headerlink" title="7、JVM内存溢出的情况"></a>7、JVM内存溢出的情况</h3><p><img src="/../images/30.png" alt="30"></p>
<ul>
<li><p>程序计数器（Program Counter Register）</p>
<p>每条线程都有一个独立的的程序计数器，各线程间的计数器互不影响，因此该区域是线程私有的。该内存区域是唯一一个在Java虚拟机规范中没有规定任何OOM（内存溢出：OutOfMemoryError）情况的区域。</p>
</li>
<li><p>java虚拟机栈（Java Virtual Machine Stacks）</p>
<p>在Java虚拟机规范中，对这个区域规定了两种异常情况：</p>
<p>1、如果线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOverflowError异常。</p>
<p>2、如果虚拟机在动态扩展栈时无法申请到足够的内存空间，则抛出OutOfMemoryError异常。这两种情况存在着一些互相重叠的地方：当栈空间无法继续分配时，到底是内存太小，还是已使用的栈空间太大，其本质上只是对同一件事情的两种描述而已。</p>
<p>在单线程的操作中，无论是由于栈帧太大，还是虚拟机栈空间太小，当栈空间无法分配时，虚拟机抛出的都是StackOverflowError异常，而不会得到OutOfMemoryError异常。</p>
<p>而在多线程环境下，则会抛出OutOfMemoryError异常。</p>
</li>
<li><p>堆（Java Heap）</p>
<p>Java Heap是Java虚拟机所管理的内存中最大的一块，它是所有线程共享的一块内存区域。几乎所有的对象实例和数组都在这类分配内存。Java Heap是垃圾收集器管理的主要区域，因此很多时候也被称为“GC堆”。</p>
<p>根据Java虚拟机规范的规定，Java堆可以处在物理上不连续的内存空间中，只要逻辑上是连续的即可。如果在堆中没有内存可分配时，并且堆也无法扩展时，将会抛出OutOfMemoryError异常。   </p>
</li>
<li><p>方法区域（Method Area）</p>
<p>方法区域，又被称为“永久代”，当方法区无法满足内存分配需求时，将抛出OutOfMemoryError异常。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring源码解析</title>
    <url>/2022/03/15/Spring%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot自动配置的原理及实现</title>
    <url>/2022/03/11/SpringBoot%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE%E7%9A%84%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo+github搭建个人博客</title>
    <url>/2022/03/02/hexo+github%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<h3 id="hexo-github保姆级教程搭建个人博客（适合windows系统，linux类似）"><a href="#hexo-github保姆级教程搭建个人博客（适合windows系统，linux类似）" class="headerlink" title="hexo+github保姆级教程搭建个人博客（适合windows系统，linux类似）"></a>hexo+github保姆级教程搭建个人博客（适合windows系统，linux类似）</h3><span id="more"></span>

<h4 id="1、前提条件"><a href="#1、前提条件" class="headerlink" title="1、前提条件"></a>1、前提条件</h4><p>（1）windows系统上安装node.js，自行百度。检验是否安装成功如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">node -v</span><br></pre></td></tr></table></figure>

<p><img src="/../images/1.PNG" alt="1"></p>
<p>（2）安装hexo框架，检验是否安装成功如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm i -g hexo #安装hexo</span><br><span class="line">hexo -v	#查看版本</span><br><span class="line">hexo init #初始化命令</span><br></pre></td></tr></table></figure>

<p><img src="/../images/2.PNG" alt="2"></p>
<p>（3）Git安装。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git --version</span><br></pre></td></tr></table></figure>

<p><img src="/../images/3.PNG" alt="3"></p>
<h4 id="2、准备注册号的github账号，创建本地仓库（https-username-github-io）"><a href="#2、准备注册号的github账号，创建本地仓库（https-username-github-io）" class="headerlink" title="2、准备注册号的github账号，创建本地仓库（https://username.github.io）"></a>2、准备注册号的github账号，创建本地仓库（<a href="https://username.github.io)/">https://username.github.io）</a></h4><p>由于github是国外网站，这一步就得看运气了！</p>
<p>（1）创建本地仓库</p>
<p><img src="/../images/4.png" alt="4"></p>
<p><img src="/../images/5.png" alt="5"></p>
<h4 id="3、生成SSH秘钥（须记住）"><a href="#3、生成SSH秘钥（须记住）" class="headerlink" title="3、生成SSH秘钥（须记住）"></a>3、生成SSH秘钥（须记住）</h4><h4 id="4、生成个人博客"><a href="#4、生成个人博客" class="headerlink" title="4、生成个人博客"></a>4、生成个人博客</h4><h4 id="5、修改及配置博客主题（NEXT）"><a href="#5、修改及配置博客主题（NEXT）" class="headerlink" title="5、修改及配置博客主题（NEXT）"></a>5、修改及配置博客主题（NEXT）</h4>]]></content>
      <categories>
        <category>教程</category>
      </categories>
      <tags>
        <tag>教程</tag>
      </tags>
  </entry>
  <entry>
    <title>springcloud五大核心组件</title>
    <url>/2022/03/03/springcloud/</url>
    <content><![CDATA[<h3 id="SpringCloud五大核心组件"><a href="#SpringCloud五大核心组件" class="headerlink" title="SpringCloud五大核心组件"></a>SpringCloud五大核心组件</h3><span id="more"></span>

<h4 id="1、Eureka（与之对应的是Dubbo框架的zookeeper）"><a href="#1、Eureka（与之对应的是Dubbo框架的zookeeper）" class="headerlink" title="1、Eureka（与之对应的是Dubbo框架的zookeeper）"></a>1、Eureka（与之对应的是Dubbo框架的zookeeper）</h4><p>作用：实现服务治理（服务注册与发现）</p>
<p>简介：Spring Cloud Eureka是Spring Cloud Netflix项目下的服务治理模块。</p>
<p>由两个组件组成：Eureka服务端和Eureka客户端。</p>
<p>Eureka服务端用作服务注册中心。支持集群部署。</p>
<p>Eureka客户端是一个java客户端，用来处理服务注册和发现。</p>
<p>在应用启动时，Eureka客户端向服务端注册自己的服务信息，同时将服务端的服务信息缓存在本地。客户端和服务端周期性的进行心跳交互，以更新服务租约和服务信息。</p>
<p><img src="/../images/6.png" alt="6"></p>
<h4 id="2、Ribbon"><a href="#2、Ribbon" class="headerlink" title="2、Ribbon"></a>2、Ribbon</h4><p>作用：Ribbon，主要提供客户侧的软件负载均衡算法。</p>
<p>简介：Spring Cloud Ribbon是一个基于HTTP和TCP的客户端负载均衡工具，它基于Netflix Ribbon实现。通过Spring Cloud的封装，可以让我们轻松地将面向服务的REST模版请求自动转换成客户端负载均衡的服务调用。</p>
<p>注意，关键点就是将外界的rest调用，根据负载均衡策略转换为微服务调用。Ribbon有比较多的负载均衡策略。</p>
<p><img src="/../images/7.png" alt="7"></p>
<h4 id="3、Hystrix"><a href="#3、Hystrix" class="headerlink" title="3、Hystrix"></a>3、Hystrix</h4><p>作用：断路器，保护系统，控制故障范围。</p>
<p>简介：为了保证其高可用，单个服务通常会集群部署。由于网络原因或者自身的原因，服务并不能保证100%可用，如果单个服务出现问题，调用这个服务就会出现线程阻塞，此时若有大量的请求涌入，Servlet容器的线程资源会被消耗完毕，导致服务瘫痪。服务与服务之间的依赖性，故障会传播，会对整个微服务系统造成灾难性的严重后果，这就是服务故障的“雪崩”效应。</p>
<p><img src="/../images/8.png" alt="8"></p>
<h4 id="4、Zuul"><a href="#4、Zuul" class="headerlink" title="4、Zuul"></a>4、Zuul</h4><p>作用：api网关，路由，负载均衡等多种作用</p>
<p>简介：类似nginx，反向代理的功能，不过netflix自己增加了一些配合其他组件的特性。</p>
<p>在微服务架构中，后端服务往往不直接开放给调用端，而是通过一个API网关根据请求的url，路由到相应的服务。当添加API网关后，在第三方调用端和服务提供方之间就创建了一面墙，这面墙直接与调用方通信进行权限控制，后将请求均衡分发给后台服务端。</p>
<p><img src="/../images/9.png" alt="9"></p>
<h4 id="5、Config"><a href="#5、Config" class="headerlink" title="5、Config"></a>5、Config</h4><p>作用：配置管理</p>
<p>简介：SpringCloud Config提供服务器端和客户端。服务器存储后端的默认实现使用git，因此它轻松支持标签版本的配置环境，以及可以访问用于管理内容的各种工具。</p>
<p>这个还是静态的，得配合Spring Cloud Bus实现动态的配置更新。</p>
<p><img src="/../images/10.png" alt="10"></p>
]]></content>
      <categories>
        <category>springcloud</category>
      </categories>
      <tags>
        <tag>springcloud</tag>
      </tags>
  </entry>
  <entry>
    <title>反向代理-Nginx</title>
    <url>/2022/03/10/%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86-Nginx/</url>
    <content><![CDATA[<h3 id="Nginx"><a href="#Nginx" class="headerlink" title="Nginx"></a>Nginx</h3><span id="more"></span>]]></content>
      <categories>
        <category>Nginx</category>
      </categories>
      <tags>
        <tag>Nginx</tag>
      </tags>
  </entry>
  <entry>
    <title>数据库优化</title>
    <url>/2022/03/02/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[<h3 id="数据库的优化（常见方法）"><a href="#数据库的优化（常见方法）" class="headerlink" title="数据库的优化（常见方法）"></a>数据库的优化（常见方法）</h3><span id="more"></span>

<p>1、对查询进行优化，要尽量避免全表扫描，首先应该考虑在where以及order by涉及的列上建立索引。形如：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tablename；#应该尽量避免这种方式</span><br></pre></td></tr></table></figure>

<p>修改为：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> id <span class="keyword">from</span> tablename <span class="keyword">where</span> name <span class="operator">=</span> <span class="string">&#x27;admin&#x27;</span></span><br></pre></td></tr></table></figure>

<p>2、应该尽量避免在where字句中对字段进行null判断，否则将导致引擎放弃索引而进行全表扫描。形如：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> id <span class="keyword">from</span> tablename <span class="keyword">where</span> num <span class="keyword">is</span> <span class="keyword">null</span>；</span><br></pre></td></tr></table></figure>

<p>最好不要给数据库留null，尽可能使用not null填充数据库。</p>
<p>3、应该尽量避免在where子句中使用！&#x3D;或&lt;&gt;操作符，否则引擎将放弃使用索引进行全表扫描。</p>
<p>4、应尽量避免在where子句中使用or来连接条件，如果一个字段有索引，一个字段没有索引，将导致引擎放弃使用索引而进行全表扫描。形如：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> id <span class="keyword">from</span> tablename <span class="keyword">where</span> num <span class="operator">=</span> <span class="number">10</span> <span class="keyword">or</span> name <span class="operator">=</span> <span class="string">&#x27;admin&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>修改为：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> id <span class="keyword">from</span> tablename <span class="keyword">where</span> num <span class="operator">=</span> <span class="number">10</span></span><br><span class="line"><span class="keyword">union</span> <span class="keyword">all</span></span><br><span class="line"><span class="keyword">select</span> id <span class="keyword">from</span> tablename <span class="keyword">where</span> name <span class="operator">=</span> <span class="string">&#x27;admin&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>5、in和not in也要慎用，否则会全表扫描。形如：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> id <span class="keyword">from</span> tablename <span class="keyword">where</span> num <span class="keyword">in</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>);</span><br></pre></td></tr></table></figure>

<p>对于连续的数值，能用between就不要用in</p>
<p>修改为：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> id <span class="keyword">from</span> tablename <span class="keyword">where</span> num <span class="keyword">between</span> <span class="number">1</span> <span class="keyword">and</span> <span class="number">3</span>; </span><br></pre></td></tr></table></figure>

<p>6、使用索引。索引是提高数据库性能的常用方法，它可以令数据库服务器以比没有索引快得多的速度检索特定的行，尤其是在查询语句当中包含有MAX(),MIN()和ORDERBY这些命令的时候，性能提高更为明显。</p>
<p>一般说来，索引应建立在那些将用于JOIN,WHERE判断和ORDERBY排序的字段上。尽量不要对数据库中某个含有大量重复的值的字段建立索引。对于一个ENUM类型的字段来说，出现大量重复值是很有可能的情况</p>
<p>例如customerinfo中的“province”..字段，在这样的字段上建立索引将不会有什么帮助；相反，还有可能降低数据库的性能。我们在创建表的时候可以同时创建合适的索引，也可以使用ALTERTABLE或CREATEINDEX在以后创建索引。此外，MySQL从版本3.23.23开始支持全文索引和搜索。全文索引在MySQL中是一个FULLTEXT类型索引，但仅能用于MyISAM类型的表。对于一个大的数据库，将数据装载到一个没有FULLTEXT索引的表中，然后再使用ALTERTABLE或CREATEINDEX创建索引，将是非常快的。但如果将数据装载到一个已经有FULLTEXT索引的表中，执行过程将会非常慢。</p>
<p>7、使用外键。锁定表的方法可以维护数据的完整性，但是它却不能保证数据的关联性。这个时候我们就可以使用外键。</p>
<p>例如：外键可以保证每一条销售记录都指向某一个存在的客户。在这里，外键可以把customerinfo表中的CustomerID映射到salesinfo表中CustomerID，任何一条没有合法CustomerID的记录都不会被更新或插入到salesinfo中。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> customerinfo(CustomerIDINT <span class="keyword">NOT</span> <span class="keyword">NULL</span>,PRIMARYKEY(CustomerID))TYPE<span class="operator">=</span>INNODB;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> salesinfo(SalesIDNT <span class="keyword">NOT</span> <span class="keyword">NULL</span>,CustomerIDINT <span class="keyword">NOT</span> <span class="keyword">NULL</span>,PRIMARYKEY(CustomerID,SalesID),</span><br><span class="line">FOREIGNKEY(CustomerID) <span class="keyword">REFERENCES</span> customerinfo(CustomerID) <span class="keyword">ON</span> <span class="keyword">DELETE</span>  CASCADE)TYPE<span class="operator">=</span>INNODB;                       </span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>浅谈微服务、Spring Cloud、Spring Boot三者之间的关系</title>
    <url>/2022/03/03/%E6%B5%85%E8%B0%88%E5%BE%AE%E6%9C%8D%E5%8A%A1%E3%80%81Spring-Cloud%E3%80%81Spring-Boot%E4%B8%89%E8%80%85%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB/</url>
    <content><![CDATA[<h3 id="微服务、Spring-Cloud、Spring-Boot三者之间的关系"><a href="#微服务、Spring-Cloud、Spring-Boot三者之间的关系" class="headerlink" title="微服务、Spring Cloud、Spring Boot三者之间的关系"></a>微服务、Spring Cloud、Spring Boot三者之间的关系</h3><span id="more"></span>

<p>1、SpringBoot专注于快速方便的开发单个个体微服务。</p>
<p>2、SpringCloud是关注全局的微服务协调整理治理框架，它将SpringBoot开发的一个个单体微服务整合并管理起来。</p>
<p>3、为各个服务之间提供，配置管理、服务发现、断路器、路由、微代理、事件总线、全局锁、精选决策、分布式会话等集成服务。</p>
<p>4、SpringBoot可以离开SpringCloud独立开发项目，但是SpringCloud离不开SpringBoot，属于依赖关系。</p>
]]></content>
      <categories>
        <category>spring</category>
      </categories>
      <tags>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式</title>
    <url>/2022/03/03/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h3 id="JAVA常见的几种设计模式解读"><a href="#JAVA常见的几种设计模式解读" class="headerlink" title="JAVA常见的几种设计模式解读"></a>JAVA常见的几种设计模式解读</h3><h4 id="1、策略模式（Strategy-Pattern）"><a href="#1、策略模式（Strategy-Pattern）" class="headerlink" title="1、策略模式（Strategy Pattern）"></a>1、策略模式（Strategy Pattern）</h4>]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>版本控制-Git</title>
    <url>/2022/03/10/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6-Git/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis常见面试题（一）</title>
    <url>/2022/03/09/Redis%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
    <content><![CDATA[<h3 id="Redis-常见面试题（一）"><a href="#Redis-常见面试题（一）" class="headerlink" title="Redis-常见面试题（一）"></a>Redis-常见面试题（一）</h3><span id="more"></span>

<h3 id="1、什么是Redis？（Remote-Dictionary-Server）"><a href="#1、什么是Redis？（Remote-Dictionary-Server）" class="headerlink" title="1、什么是Redis？（Remote Dictionary Server）"></a>1、什么是Redis？（Remote Dictionary Server）</h3><p>Redis是一个使用C语言编写的，开源的高性能非关系型（NoSQL）的key-value数据库。</p>
<p>Redis可以存储键和五种不同类型的值之间的映射。键的类型只能是字符串，值支持五种数据类型：字符串、列表、集合、散列表、有序集合。</p>
<p>与传统数据库不同的是：</p>
<p>（1）Redis的数据是存储在内存中的，所以读写速度非常快。因此Redis被广泛应用于缓存方向，每秒可以处理超过10万次读写操作，是已知最快的key-value数据库。</p>
<p>（2）另外，Redis也经常用来做分布式锁。</p>
<p>（3）除此之外，Redis支持事务、持久化、LUA脚本、LRU驱动事件、多种集群方案。</p>
<hr>
<h3 id="2、Redis有哪些优缺点？"><a href="#2、Redis有哪些优缺点？" class="headerlink" title="2、Redis有哪些优缺点？"></a>2、Redis有哪些优缺点？</h3><p>优点</p>
<ul>
<li>读写性能优异，Redis读的速度是110000次&#x2F;s，写的速度是81000&#x2F;s。</li>
<li>支持数据持久化，支持AOF和RDB两种持久化方式。</li>
<li>支持事务，Redis的所有操作都是原子性的，同时Redis还支持对几个操作合并后的原子性执行。</li>
<li>数据结构丰富，除了支持string类型的value，还支持hash、set、zset、list等数据结构。</li>
<li>支持主从复制，主机会自动将数据同步到从机，可以进行读写分离。</li>
</ul>
<p>缺点</p>
<ul>
<li><p>数据库容量受到物理内存的限制，不能用作海量数据的高性能读写，因此Redis适合的场景主要局限在较小数据量的高性能操作和运算上。</p>
</li>
<li><p>Redis不具备自动容错和恢复功能，主机从机的宕机都会导致前端部分读写请求失败，需要等待机器重启或手动切换前端的ip才能恢复。</p>
</li>
<li><p>主机宕机，宕机前有部分数据未能同步到从机，切换ip后还会引入数据不一致问题，降低了系统的可用性。</p>
</li>
<li><p>Redi较难支持在线扩容，在集群容量达到上限时，在线扩容会变得很复杂。为避免这一问题，运维人员在系统上线时必须确保有足够的空间，这对资源造成很大的浪费。</p>
</li>
</ul>
<hr>
<h3 id="3、为什么要用Redis-x2F-为什么要用缓存？"><a href="#3、为什么要用Redis-x2F-为什么要用缓存？" class="headerlink" title="3、为什么要用Redis&#x2F;为什么要用缓存？"></a>3、为什么要用Redis&#x2F;为什么要用缓存？</h3><p>主要从”高性能”和”高并发”两点来看待这个问题。</p>
<h4 id="高性能"><a href="#高性能" class="headerlink" title="高性能"></a>高性能</h4><p>加入用户第一次访问数据库的某些数据，这个过程会比较慢，因为是从硬盘上读取的。将该用户访问的数据存在缓存中，这样下一次访问这些数据的时候就可以直接从缓存中获取。操作缓存就是直接操作内存，所以速度很快。如果数据库中对应的数据改变后，同步改变缓存中相应的数据即可。</p>
<p><img src="/../images/11.png" alt="11"></p>
<h4 id="高并发"><a href="#高并发" class="headerlink" title="高并发"></a>高并发</h4><p>直接操作缓存能够承受的请求是远远大于直接访问数据库的，所以我们可以考虑把数据库中的部分数据转移到缓存中去，这样用户的一部分请求会直接到缓存这里而不经过数据库。</p>
<p><img src="/../images/12.png" alt="12"></p>
<hr>
<h3 id="4、为什么要用Redis而不用map-x2F-guava做缓存？"><a href="#4、为什么要用Redis而不用map-x2F-guava做缓存？" class="headerlink" title="4、为什么要用Redis而不用map&#x2F;guava做缓存？"></a>4、为什么要用Redis而不用map&#x2F;guava做缓存？</h3><p>缓存分为本地缓存和分布式缓存。以JAVA为例，使用自带的map或者guava实现的是本地缓存，最主要的特点是轻量以及快速，生命周期随着JVM的销毁而结束，并且在多实例的情况下，每个实例都需要各自保存一份缓存，缓存不具有一致性。</p>
<p>使用Redis或者memcached之类的称为分布式缓存，在多实例的情况下，各实例公用一份缓存数据，缓存具有一致性。缺点就是需要保持redis或memcached服务的高可用，整个程序架构上较为复杂。</p>
<hr>
<h3 id="5、Redis为什么这么快？"><a href="#5、Redis为什么这么快？" class="headerlink" title="5、Redis为什么这么快？"></a>5、Redis为什么这么快？</h3><ol>
<li><p>完全基于内存，绝大部分请求是纯粹的内存操作，非常快速。数据存在内存中，类似于HashMap，HashMap的优势就是查找和操作的时间复杂度都是O（1）。</p>
</li>
<li><p>数据结构简单，对数据操作也简单，Redis中的数据结构是专门进行设计的。</p>
</li>
<li><p>采用单线程，避免了不必要的上下文切换和竞争条件，也不存在多进程和多线程导致的切换而消耗CPU，不用去考虑各种锁的问题，不存在加锁释放锁的操作，没有因为出现死锁而导致的性能消耗。</p>
</li>
<li><p>使用多路复用I&#x2F;O模型，非阻塞IO。</p>
</li>
<li><p>使用底层模型不同，它们之间底层实现方式以及与客户端之间通信的应用协议不一样，Redis直接自己构建了VM机制，因为一般的系统调用系统函数的话，会浪费一定的时间去移动和请求。</p>
</li>
</ol>
<hr>
<h3 id="6、Redis常见的数据类型"><a href="#6、Redis常见的数据类型" class="headerlink" title="6、Redis常见的数据类型"></a>6、Redis常见的数据类型</h3><p>Redis主要有5种数据类型，包括String，List，Set，Zset，Hash。</p>
<table>
<thead>
<tr>
<th align="center">数据类型</th>
<th align="center">可存储的值</th>
<th align="center">操作</th>
<th align="center">应用场景</th>
</tr>
</thead>
<tbody><tr>
<td align="center">String</td>
<td align="center">字符串、整数或者浮点数</td>
<td align="center">对整个字符串或者字符串的其中一部分执行操作</td>
<td align="center">做简单的键值对缓存</td>
</tr>
<tr>
<td align="center">List</td>
<td align="center">列表</td>
<td align="center">从两端压入或者弹出元素，对单个或者多个元素进行修剪，只保留一个范围内的元素</td>
<td align="center">存储一些列表型的数据结构，类似粉丝列表、文章的评论列表之类的数据</td>
</tr>
<tr>
<td align="center">Set</td>
<td align="center">无序集合</td>
<td align="center">添加、获取、移除单个元素，检查一个元素是否存在于集合中，计算交集、并集、差集，从集合里面随机获取元素</td>
<td align="center">交集，并集，差集的操作，比如交集，可以把两个人的粉丝列表整一个交集</td>
</tr>
<tr>
<td align="center">Hash</td>
<td align="center">包含键值对的无序散列表</td>
<td align="center">添加、获取、移除单个键值对，获取所有键值对，检查某个键是否存在</td>
<td align="center">结构化的数据，比如一个对象</td>
</tr>
<tr>
<td align="center">Zset</td>
<td align="center">有序集合</td>
<td align="center">添加、获取、删除元素，根据分值范围或者成员来获取元素，计算一个键的排名</td>
<td align="center">去重但可以排序，如获取排名前几名的用户</td>
</tr>
</tbody></table>
<hr>
<h3 id="7、Redis的应用场景"><a href="#7、Redis的应用场景" class="headerlink" title="7、Redis的应用场景"></a>7、Redis的应用场景</h3><ol>
<li><p>缓存</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">String类型</span><br></pre></td></tr></table></figure>

<ul>
<li>例如：热点数据缓存（报表、明星出轨）、对象缓存、全页缓存、可以提升热点数据的访问数据。</li>
</ul>
</li>
<li><p>数据共享分布式</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">String类型，因为Redis是分布式的独立服务，可以在多个应用之间共享</span><br></pre></td></tr></table></figure>

<ul>
<li><p>例如：分布式session</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span> </span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.session<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span> </span><br><span class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-session-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>分布式锁</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">String类型setnx方法，只有不存在时才能添加成功，返回true</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">getLock</span><span class="params">(String key)</span> &#123;</span><br><span class="line">    <span class="type">Long</span> <span class="variable">flag</span> <span class="operator">=</span> jedis.setnx(key, <span class="string">&quot;1&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (flag == <span class="number">1</span>) &#123;</span><br><span class="line">        jedis.expire(key, <span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">return</span> <span class="variable">flag</span> <span class="operator">=</span>= <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">releaseLock</span><span class="params">(String key)</span> &#123;</span><br><span class="line">    jedis.del(key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>全局ID</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">incrby userid <span class="number">1000</span>  #<span class="type">int</span>类型，incrby，利用原子性</span><br></pre></td></tr></table></figure>
</li>
<li><p>计数器</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int类型，incr方法</span><br></pre></td></tr></table></figure>

<p>例如：文章的阅读量、微博点赞数、允许一定的延迟，先写入Redis再定时同步到数据库</p>
</li>
<li><p>限流</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int类型。incr方法</span><br></pre></td></tr></table></figure>

<p>以访问者的ip和其他信息作为key，访问一次增加一次计数，超过次数则返回false</p>
</li>
<li><p>位统计</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">String类型的bitcount</span><br><span class="line">字符是以8位二进制存储的</span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set</span> k1 a</span><br><span class="line">setbit k1 <span class="number">6</span> <span class="number">1</span></span><br><span class="line">setbit k1 <span class="number">7</span> <span class="number">0</span></span><br><span class="line"><span class="keyword">get</span> k1 </span><br><span class="line"><span class="comment">/* 6 7 代表的a的二进制位的修改</span></span><br><span class="line"><span class="comment">a 对应的ASCII码是97，转换为二进制数据是01100001</span></span><br><span class="line"><span class="comment">b 对应的ASCII码是98，转换为二进制数据是01100010</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">因为bit非常节省空间（1 MB=8388608 bit），可以用来做大数据量的统计。</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>例如：在线用户统计、留存用户统计</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">setbit onlineusers <span class="number">01</span> </span><br><span class="line">setbit onlineusers <span class="number">11</span> </span><br><span class="line">setbit onlineusers <span class="number">20</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>购物车</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">String或hash。所有String可以做的hash都可以做</span><br></pre></td></tr></table></figure>

<p><img src="/../images/13.png" alt="13"></p>
<p>key：用户id；</p>
<p>filed：商品id；</p>
<p>value：商品数量；</p>
<p>+1：hincr；</p>
<p>-1：hdecr；</p>
<p>全选：hgetall；</p>
<p>商品数：hlen。</p>
</li>
<li><p>用户消息时间线</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">list，双向链表，直接作为timeline。插入有序。</span><br></pre></td></tr></table></figure>
</li>
<li><p>消息队列</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">List提供了两个阻塞的弹出操作：blpop/brpop 可以设置超时时间</span><br></pre></td></tr></table></figure>

<p>blpop：blpop key1 timeout 移除并获取列表的第一个元素，如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止。</p>
<p>brpop：brpop key1 timeout 移除并获取列表的最后一个元素，如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止。</p>
<p>上面的操作。其实就是java的阻塞队列。学习的东西越多。学习成本越低</p>
<p>队列：先进先除：rpush blpop，左头右尾，右边进入队列，左边出队列</p>
<p>栈：先进后出：rpush brpop</p>
</li>
<li><p>抽奖</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">spop myset	#自带一个随机获得值</span><br></pre></td></tr></table></figure>
</li>
<li><p>点赞、签到、打卡</p>
<p><img src="/../images/14.png" alt="14"></p>
<ul>
<li>假如上面微博id是t1001，用户id是u3001</li>
<li>用like：t1001来维护t1001这条微博的所有点赞用户</li>
<li>点赞了这条微博：sadd like：t1001 u3001</li>
<li>取消点赞：srem like :t1001 u3001</li>
<li>是否点赞：sismember like：t1001 u3001</li>
<li>点赞的所有用户：smembers like：t1001</li>
<li>点赞数：scard like：t1001</li>
</ul>
</li>
<li><p>商品标签</p>
<p><img src="/../images/15.png" alt="15"></p>
<p>用tags：i5001来维护商品的所有标签。</p>
<ul>
<li>sadd tags：i5001 画面清晰细腻</li>
<li>sadd tags：i5001 真彩清晰显示屏</li>
<li>sadd tags：i5001 流程至极</li>
</ul>
</li>
<li><p>商品筛选</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="operator">/</span><span class="operator">/</span> 获取差集</span><br><span class="line">sdiff set1 set2</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span> 获取交集（<span class="keyword">intersection</span> ）</span><br><span class="line">sinter set1 set2</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span> 获取并集</span><br><span class="line">sunion set1 set2</span><br></pre></td></tr></table></figure>

<p>假如：iphone 11上市</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">sadd brand:apple iPhone11</span><br><span class="line"></span><br><span class="line">sadd brand:ios iPhone11</span><br><span class="line"></span><br><span class="line">sad screensize:<span class="number">6.0</span><span class="number">-6.24</span> iPhone11</span><br><span class="line"></span><br><span class="line">sad screentype:lcd iPhone <span class="number">11</span></span><br><span class="line"></span><br><span class="line">#筛选商品，苹果的、ios的、屏幕在<span class="number">6.0</span><span class="number">-6.24</span>之间的，屏幕材质是LCD屏幕</span><br><span class="line">sinter brand:apple brand:ios screensize:<span class="number">6.0</span><span class="number">-6.24</span> screentype:lcd</span><br></pre></td></tr></table></figure>
</li>
<li><p>用户关注、推荐模型</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">follow 关注 fans 粉丝</span><br></pre></td></tr></table></figure>

<ul>
<li>相互关注：<ul>
<li>sadd 1：follow 2</li>
<li>sadd 2：fans 1</li>
<li>sadd 1：fans 2</li>
<li>sadd 2：follow 1</li>
</ul>
</li>
<li>我关注的人也关注了他：<ul>
<li>sinter：follow 2：fans</li>
</ul>
</li>
<li>可能认识的人：<ul>
<li>用户1可能认识的人（差集）：sdiff 2：follow 1：follow</li>
<li>用户2可能认识的人（差集）：sdiff 1：follow 2：follow</li>
</ul>
</li>
</ul>
</li>
<li><p>排行榜</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">zincrby hotNews	：20190926 1 n6001	#id为6001的新闻点击数加1</span><br><span class="line">zrevrange hotNews:20190926 0 15 withscores	#获取今天点击最多的15条</span><br></pre></td></tr></table></figure></li>
</ol>
<hr>
<h3 id="8、Redis持久化（RDB和AOF）"><a href="#8、Redis持久化（RDB和AOF）" class="headerlink" title="8、Redis持久化（RDB和AOF）"></a>8、Redis持久化（RDB和AOF）</h3><p>持久化就是把内存的数据写到磁盘中去，防止服务宕机了内存数据丢失。</p>
<p>各自的优缺点：</p>
<h4 id="RDB：Redis-DataBase"><a href="#RDB：Redis-DataBase" class="headerlink" title="RDB：Redis DataBase"></a>RDB：Redis DataBase</h4><p>RDB是redis默认的持久化方式。按照一定的时间将内存的数据以快照的形式保存在硬盘中，对应产生的数据文件dump.rdb。通过配置文件中的save参数来定义快照的周期。</p>
<p><img src="/../images/16.png" alt="16"></p>
<p>优点：</p>
<ul>
<li>只有一个文件dump.rdb，方便持久化。</li>
<li>容灾性好，一个文件可以保存到安全的磁盘。</li>
<li>性能最大化，fork子进程来完成写操作，让主进程继续处理命令，所以是IO最大化。使用单独子进程来进行持久化，主进程不会进行任何IO操作，保证了reds的高性能。</li>
<li>相对于数据集大时，比AOF的启动效率更高。</li>
</ul>
<p>缺点：</p>
<ul>
<li>数据安全性低。RDB是间隔一段时间进行持久化，如果持久化之间redis发生故障，会发生数据丢失。所以这种方式更适合数据要求不严谨的时候。</li>
<li>AOF（appendonly file）持久化方式：是指所有的命令行记录以redis命令请求协议的格式完全持久化存储为aof文件。</li>
</ul>
<h4 id="AOF：持久化"><a href="#AOF：持久化" class="headerlink" title="AOF：持久化"></a>AOF：持久化</h4><p>AOF持久化，则是将Redis执行的每次写命令记录到单独的日志中，当重启Redis会重新将持久化日志中的文件恢复数据。当两种方式同时开启时，数据恢复Redis会优先选择AOF恢复。</p>
<p><img src="/../images/17.png" alt="17"></p>
<p>优点：</p>
<ul>
<li>数据安全，aof持久化可以配置appendsync属性，有always，每次进行命令操作就记录到aof文件中一次。</li>
<li>通过append模式写文件，即使中途服务器宕机，也可以通过redis-check-aof工具解决数据一致性问题。</li>
<li>AOF机制的rewrite模式。AOF文件没被rewrite之前，可以删除其中的某些命令。</li>
</ul>
<p>缺点：</p>
<ul>
<li>AOF文件比RDB文件大，恢复速度慢。</li>
<li>数据集大的时候，比rdb启动效率低。</li>
</ul>
<p>区别：</p>
<ul>
<li>AOF文件比RDB文件更新频率高，优先使用AOF还原数据。</li>
<li>AOF比RDB更安全也更大。</li>
<li>RDB性能比AOF好。</li>
<li>如果两个都配了优先加载AOF。</li>
</ul>
<h4 id="如何选择合适的持久化方式？"><a href="#如何选择合适的持久化方式？" class="headerlink" title="如何选择合适的持久化方式？"></a>如何选择合适的持久化方式？</h4><ul>
<li>一般来说，如果想达到足以媲美PostgreSQL的数据安全性，应该同时使用两种持久化功能。在这种情况下，当redis重启的时候，会优先载入AOF文件来恢复原始的数据，因为在通常情况下，AOF文件保存的数据集要比RDB文件保存的数据集要完整。</li>
<li>如果你非常关心你的数据，但仍然可以承受数分钟以内数据的丢失，那么你可以使用RDB持久化。</li>
<li>有很多用户只使用AOF持久化，但并不推荐这种方式，因为定时生成RDB快照（snopshot）非常便于进行数据库备份，并且RDB恢复数据集的速度也要比AOF恢复的速度要快，除此之外，使用RDB还可以避免AOF程序的bug。</li>
<li>如果你只希望你的数据在服务器运行的时候存在，你也可以不适用任何持久化方式。</li>
</ul>
<h4 id="Redis持久化数据和缓存怎么扩容？"><a href="#Redis持久化数据和缓存怎么扩容？" class="headerlink" title="Redis持久化数据和缓存怎么扩容？"></a>Redis持久化数据和缓存怎么扩容？</h4><ul>
<li>如果Redis被当做缓存使用，使用一致性哈希实现动态扩容缩容。</li>
<li>如果Redis被当做一个持久化存储使用，必须使用固定的keys-to-nodes映射关系，节点的数量一旦确定不能变化，否则的话（即redis节点需要动态变化的情况），必须使用可以在运行时进行数据再平衡的一套系统，而当前只有redis集群可以做到这样。</li>
</ul>
<hr>
<h3 id="9、Redis过期键的删除策略"><a href="#9、Redis过期键的删除策略" class="headerlink" title="9、Redis过期键的删除策略"></a>9、Redis过期键的删除策略</h3><p>过期策略通常有一下三种：</p>
<ul>
<li>定时过期：每个设置过期时间的key都需要创建一个定时器，到过期时间就会立即删除。该策略可以立即清除过期的数据，对内存很友好；但是会占用大量的CPU资源去处理过期的数据，从而影响缓存的相应时间和吞吐量。</li>
<li>惰性过期：只有当访问一个key时，才会判断该key是否已经过期，过期则清除。该策略可以最大化地节省CPU资源，却对内存很不友好。极端情况可能出现大量的过期key没有再次被访问，从而不会被清除，占用大量内存。</li>
</ul>
<p><img src="/../images/18.png" alt="18"></p>
<ul>
<li><p>定期过期：activeExpireCycle函数实现。每隔一段时间，会扫描一定数量的数据库的expires字典中一定数量的key，并清除其中已经过期的key。该策略是前两者的一个折中方案。通过调整定时扫描的时间间隔和每次扫描的限定耗时，可以在不同情况下使得CPU和内存资源达到最优的平衡效果。</p>
<p>（expires字典会保存所有设置了过期时间的key的过期时间数据，其中，key是指向键空间中的某个键的指针，value是改键的毫秒精度的UNIX时间戳的过期时间。键空间是指该Redis集群中保存的所有键。）</p>
</li>
</ul>
<p>Redis中同时使用了惰性过期和定期过期策略。</p>
<h4 id="Redis-key的过期时间和永久有效分别怎么设置？"><a href="#Redis-key的过期时间和永久有效分别怎么设置？" class="headerlink" title="Redis key的过期时间和永久有效分别怎么设置？"></a>Redis key的过期时间和永久有效分别怎么设置？</h4><p>EXPIRE和PERSIST命令。</p>
<h4 id="我们知道通过expire来设置key-的过期时间，那么对过期的数据怎么处理呢"><a href="#我们知道通过expire来设置key-的过期时间，那么对过期的数据怎么处理呢" class="headerlink" title="我们知道通过expire来设置key 的过期时间，那么对过期的数据怎么处理呢?"></a>我们知道通过expire来设置key 的过期时间，那么对过期的数据怎么处理呢?</h4><p>除了缓存服务器自带的缓存失效策略之外，我们还可以根据具体的业务需求进行自定义缓存淘汰，常见的策略有两种：</p>
<ul>
<li>定时去清理过期的缓存；</li>
<li>当有用户请求过来时，再判断这个请求所用到的缓存是否过期，过期的话就去底层系统得到新数据并更新缓存。</li>
</ul>
<hr>
<p>​    </p>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis常见面试题（三）</title>
    <url>/2022/03/11/Redis%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%88%E4%B8%89%EF%BC%89/</url>
    <content><![CDATA[<h3 id="Redis-常见面试题（三）"><a href="#Redis-常见面试题（三）" class="headerlink" title="Redis-常见面试题（三）"></a>Redis-常见面试题（三）</h3><span id="more"></span>

<h3 id="分区"><a href="#分区" class="headerlink" title="分区"></a>分区</h3><h3 id="1、Redis是单线程的，如何提高多核CPU的利用率？"><a href="#1、Redis是单线程的，如何提高多核CPU的利用率？" class="headerlink" title="1、Redis是单线程的，如何提高多核CPU的利用率？"></a>1、Redis是单线程的，如何提高多核CPU的利用率？</h3><p>可以在同一个服务器部署多个Redis的实例，并把它们当做不同的服务器来使用，在某些时候，无论如何一个服务器是不够的，所以，如果你想使用多个CPU，你可以考虑一下分片（shard）。</p>
<h3 id="2、为什么要做Redis分区？"><a href="#2、为什么要做Redis分区？" class="headerlink" title="2、为什么要做Redis分区？"></a>2、为什么要做Redis分区？</h3><p>分区可以让Redis管理更大的内存，Redis将可以使用所有机器的内存。如果没有分区，你最多使用一台机器的内存。分区使Redis的计算能力通过简单地增加计算机得到成倍提升，Redis的网络带宽也会随着计算机和网卡的增加而成倍增长。</p>
<h3 id="3、你知道有哪些Redis分区实现方案？"><a href="#3、你知道有哪些Redis分区实现方案？" class="headerlink" title="3、你知道有哪些Redis分区实现方案？"></a>3、你知道有哪些Redis分区实现方案？</h3><ul>
<li>客户端分区就是在客户端已经决定数据会被储存到哪个redis节点读取。大多数客户端已经实现了客户端分区。</li>
<li>代理分区意味着客户端将请求发送给代理，然后代理决定去哪个节点写数据或读数据。代理根据分区规则请求哪些Redis实例，然后根据redis的相应结果返回客户端。Redis和Memcached的一种代理实现就是Twenproxy。</li>
<li>查询路由（Query Route）的意思就是客户端随机地请求任意一个Redis 实例，然后由Redis请求转发给正确的Redis节点。Redis Cluster实现了一种混合形式的查询路由，但并不是直接将请求从一个redis节点转发到另一个Redis节点，而是在客户端的帮助下直接redirected到正确的节点。</li>
</ul>
<h3 id="4、Redis分区有什么缺点？"><a href="#4、Redis分区有什么缺点？" class="headerlink" title="4、Redis分区有什么缺点？"></a>4、Redis分区有什么缺点？</h3><ul>
<li>涉及多个key的操作通常不会支持。例如你不能对两个集合求交集，因为它们可能被存储到不同的Redis实例。</li>
<li>同时操作多个key，则不能使用Redis事务。</li>
<li>分区使用的粒度是key，不能使用一个非常长的排序key存储一个数据集。</li>
<li>当使用分区的时候，数据处理会非常复杂，例如为了备份你必须从不同的Redis实例和主机同时收集RDB&#x2F;AOF文件。</li>
<li>分区时动态扩容或缩容可能非常复杂，Redis集群在运行时增加或者删除Redis节点，能做到最大程度对用户透明地数据再平衡，但其他一些客户端分区或者代理分区方法则不支持这种特性。然而，有一种预分片的技术也可以很好解决这个问题。</li>
</ul>
<hr>
<h3 id="分布式问题"><a href="#分布式问题" class="headerlink" title="分布式问题"></a>分布式问题</h3><h3 id="5、Redis实现分布式锁"><a href="#5、Redis实现分布式锁" class="headerlink" title="5、Redis实现分布式锁"></a>5、Redis实现分布式锁</h3><p>Redis为单进程单线程模式，采用队列模式将并发访问变成串行访问，且客户端对Redis的连接并不存在竞争关系，Redis中可以使用SETNX命令实现分布式锁。</p>
<p>当且仅当key不存在，将key的值设置为value。若给定的key已经存在，则SETNX不做任何动作。</p>
<p><img src="/../images/25.png" alt="25"></p>
<p>使用SETNX完成同步锁的流程以及注意事项如下：</p>
<p>使用SETNX命令获取锁，若返回0（key已经存在，锁已经存在）则获取失败，反之获取成功。</p>
<p>为了防止获取锁后程序出现异常，导致其他进程&#x2F;线程调用SETNX命令总是返回0而进入死锁状态，需要为该key设置一个合理的过期时间。</p>
<p>释放锁，使用DEL命令将锁数据删除。</p>
<h3 id="6、如何解决Redis的并发竞争key问题？"><a href="#6、如何解决Redis的并发竞争key问题？" class="headerlink" title="6、如何解决Redis的并发竞争key问题？"></a>6、如何解决Redis的并发竞争key问题？</h3><p>所谓Redis的并发竞争key的问题也就是多个系统同时对一个key进行操作，但是最后执行的顺序和我们期望的顺序不同，这样也就导致了结果的不同。</p>
<p>推荐一种方案：分布式锁（zookeeper和redis都可以实现分布式锁）。</p>
<h3 id="7、分布式Redis是前期还是后期规模上来了在做好？为什么？"><a href="#7、分布式Redis是前期还是后期规模上来了在做好？为什么？" class="headerlink" title="7、分布式Redis是前期还是后期规模上来了在做好？为什么？"></a>7、分布式Redis是前期还是后期规模上来了在做好？为什么？</h3><p>既然Redis是如此的轻量，为防止以后的扩容，最好的办法就是一开始就启动较多实例。即便你只有一台服务器，你也可以一开始就让Redis以分布式的方式运行，使用分区，在同一台服务器上启动多个实例。</p>
<p>一开始就多设置几个Redis实例，这样的话，当你的数据不断增长，需要更多Redis服务器时，你需要做的仅仅是将Redis实例从一台服务迁移到另一台服务器而已。一旦你添加了另一台服务器，你需要将你一半的Redis实例从第一台机器迁移到第二台机器。</p>
<h3 id="8、什么是RedLock？"><a href="#8、什么是RedLock？" class="headerlink" title="8、什么是RedLock？"></a>8、什么是RedLock？</h3><p>Redis官方提出的一种权威的基于Redis实现分布式锁的方式，此种方式比原先的单节点的方法更安全。它可以保证以下特性：</p>
<ol>
<li>安全特性：互斥访问，即永远只有一个client能拿到锁。</li>
<li>避免死锁：最终client都可能拿到锁，不会出现死锁情况。</li>
<li>容错性：只要大部分Redis节点存活就可以正常提供服务。</li>
</ol>
<hr>
<h3 id="缓存异常"><a href="#缓存异常" class="headerlink" title="缓存异常"></a>缓存异常</h3><h3 id="9、缓存雪崩"><a href="#9、缓存雪崩" class="headerlink" title="9、缓存雪崩"></a>9、缓存雪崩</h3><p>缓存雪崩是指缓存同一时间大面积的失效，所以，后面的请求都会落到数据库上，造成数据库短时间内承受大量请求而崩掉。</p>
<p>解决方案：</p>
<ol>
<li>缓存数据的过期时间设置随机，防止同一时间大量数据过期现象发生。</li>
<li>一般并发量不是特别多的时候，使用最多的解决方案是加锁排队。</li>
<li>给每一个缓存数据增加相应的缓存标记，记录缓存的是否失效，如果缓存标记失效，则更新数据缓存。</li>
</ol>
<h3 id="10、缓存穿透"><a href="#10、缓存穿透" class="headerlink" title="10、缓存穿透"></a>10、缓存穿透</h3><p>缓存穿透是指缓存和数据库中都没有的数据，导致所有的请求都落到数据库上，造成数据库短时间内承受大量请求而崩掉。</p>
<p>解决方案：</p>
<ol>
<li>接口层增加校验，如用户鉴权校验，id做基础校验，id&lt;&#x3D;0的直接拦截。</li>
<li>从缓存取不到的数据，在数据库中也没有取到，这时也可以将key-value对写为key-null，缓存有效时间可以设置短点，如30秒（设置太长会导致正常情况也没法使用）。这样可以防止攻击用户反复用同一个id暴力攻击。</li>
<li>采用布隆过滤器，将所有可能存在的数据哈希到一个足够大的 bitmap 中，一个一定不存在的数据会被这个 bitmap 拦截掉，从而避免了对底层存储系统的查询压力。</li>
</ol>
<h3 id="附加"><a href="#附加" class="headerlink" title="附加"></a>附加</h3><p>对于空间的利用到达了一种极致，那就是Bitmap和布隆过滤器(Bloom Filter)。</p>
<p>Bitmap：典型的就是哈希表。</p>
<p>缺点是，Bitmap对于每个元素只能记录1bit信息，如果还想完成额外的功能，恐怕只能靠牺牲更多的空间、时间来完成了。</p>
<h4 id="布隆过滤器"><a href="#布隆过滤器" class="headerlink" title="布隆过滤器"></a>布隆过滤器</h4><p>就是引入了k(k&gt;1)k(k&gt;1)个相互独立的哈希函数，保证在给定的空间、误判率下，完成元素判重的过程。</p>
<p>它的优点是空间效率和查询时间都远远超过一般的算法，缺点是有一定的误识别率和删除困难。</p>
<p>Bloom-Filter算法的核心思想就是利用多个不同的Hash函数来解决“冲突”。</p>
<p>Hash存在一个冲突（碰撞）的问题，用同一个Hash得到的两个URL的值有可能相同。为了减少冲突，我们可以多引入几个Hash，如果通过其中的一个Hash值我们得出某元素不在集合中，那么该元素肯定不在集合中。只有在所有的Hash函数告诉我们该元素在集合中时，才能确定该元素存在于集合中。这便是Bloom-Filter的基本思想。</p>
<p>Bloom-Filter一般用于在大数据量的集合中判定某元素是否存在。</p>
<h3 id="11、缓存击穿"><a href="#11、缓存击穿" class="headerlink" title="11、缓存击穿"></a>11、缓存击穿</h3><p>缓存击穿是指缓存中没有但数据库中有的数据（一般是缓存时间到期），这时由于并发用户特别多，同时读缓存没读到数据，又同时去数据库去取数据，引起数据库压力瞬间增大，造成过大压力。和缓存雪崩不同的是，缓存击穿指并发查同一条数据，缓存雪崩是不同数据都过期了，很多数据都查不到从而查数据库。</p>
<p>解决方案：</p>
<ol>
<li>设置热点数据永远不过期。</li>
<li>加互斥锁，互斥锁。</li>
</ol>
<h3 id="12、缓存预热"><a href="#12、缓存预热" class="headerlink" title="12、缓存预热"></a>12、缓存预热</h3><p>缓存预热就是系统上线后，将相关的缓存数据直接加载到缓存系统。这样就可以避免在用户请求的时候，先查询数据库，然后再将数据缓存的问题！用户直接查询事先被预热的缓存数据！</p>
<p>解决方案：</p>
<ol>
<li>直接写个缓存刷新页面，上线时手工操作一下；</li>
<li>数据量不大，可以在项目启动的时候自动进行加载；</li>
<li>定时刷新缓存；</li>
</ol>
<h3 id="13、缓存降级"><a href="#13、缓存降级" class="headerlink" title="13、缓存降级"></a>13、缓存降级</h3><p>当访问量剧增、服务出现问题（如响应时间慢或不响应）或非核心服务影响到核心流程的性能时，仍然需要保证服务还是可用的，即使是有损服务。系统可以根据一些关键数据进行自动降级，也可以配置开关实现人工降级。</p>
<p>缓存降级的最终目的是保证核心服务可用，即使是有损的。而且有些服务是无法降级的（如加入购物车、结算）。</p>
<p>在进行降级之前要对系统进行梳理，看看系统是不是可以丢卒保帅；从而梳理出哪些必须誓死保护，哪些可降级；比如可以参考日志级别设置预案：</p>
<ol>
<li>一般：比如有些服务偶尔因为网络抖动或者服务正在上线而超时，可以自动降级；</li>
<li>警告：有些服务在一段时间内成功率有波动（如在95~100%之间），可以自动降级或人工降级，并发送告警；</li>
<li>错误：比如可用率低于90%，或者数据库连接池被打爆了，或者访问量突然猛增到系统能承受的最大阀值，此时可以根据情况自动降级或者人工降级；</li>
<li>严重错误：比如因为特殊原因数据错误了，此时需要紧急人工降级。</li>
</ol>
<p>服务降级的目的，是为了防止Redis服务故障，导致数据库跟着一起发生雪崩问题。因此，对于不重要的缓存数据，可以采取服务降级策略，例如一个比较常见的做法就是，Redis出现问题，不去数据库查询，而是直接返回默认值给用户。</p>
<h3 id="14、热点数据和冷数据"><a href="#14、热点数据和冷数据" class="headerlink" title="14、热点数据和冷数据"></a>14、热点数据和冷数据</h3><p>热点数据，缓存才有价值。</p>
<p>对于冷数据而言，大部分数据可能还没有再次访问到就已经被挤出内存，不仅占用内存，而且价值不大。频繁修改的数据，看情况考虑使用缓存。</p>
<p>对于热点数据，比如我们的某IM产品，生日祝福模块，当天的寿星列表，缓存以后可能读取数十万次。再举个例子，某导航产品，我们将导航信息，缓存以后可能读取数百万次。</p>
<p>数据更新前至少读取两次，缓存才有意义。这个是最基本的策略，如果缓存还没有起作用就失效了，那就没有太大价值了。</p>
<p>那存不存在，修改频率很高，但是又不得不考虑缓存的场景呢？有！比如，这个读取接口对数据库的压力很大，但是又是热点数据，这个时候就需要考虑通过缓存手段，减少数据库的压力，比如我们的某助手产品的，点赞数，收藏数，分享数等是非常典型的热点数据，但是又不断变化，此时就需要将数据同步保存到Redis缓存，减少数据库压力。</p>
<h3 id="15、缓存热点key"><a href="#15、缓存热点key" class="headerlink" title="15、缓存热点key"></a>15、缓存热点key</h3><p>缓存中的一个Key(比如一个促销商品)，在某个时间点过期的时候，恰好在这个时间点对这个Key有大量的并发请求过来，这些请求发现缓存过期一般都会从后端DB加载数据并回设到缓存，这个时候大并发的请求可能会瞬间把后端DB压垮。</p>
<p>解决方案：</p>
<p>对缓存查询加锁，如果KEY不存在，就加锁，然后查DB入缓存，然后解锁；其他进程如果发现有锁就等待，然后等解锁后返回数据或者进入DB查询。</p>
<hr>
<h3 id="常用工具"><a href="#常用工具" class="headerlink" title="常用工具"></a>常用工具</h3><h3 id="16、Redis支持的Java客户端都有哪些？官方推荐使用哪个？"><a href="#16、Redis支持的Java客户端都有哪些？官方推荐使用哪个？" class="headerlink" title="16、Redis支持的Java客户端都有哪些？官方推荐使用哪个？"></a>16、Redis支持的Java客户端都有哪些？官方推荐使用哪个？</h3><p>Redisson、Jedis、lettuce等等。官方推荐使用Redisson。</p>
<h3 id="17、Redis和Redisson有什么关系？"><a href="#17、Redis和Redisson有什么关系？" class="headerlink" title="17、Redis和Redisson有什么关系？"></a>17、Redis和Redisson有什么关系？</h3><p>Redisson是一个高级的分布式协调Redis客服端，能帮助用户在分布式环境中轻松实现一些Java的对象 (Bloom filter, BitSet, Set, SetMultimap, ScoredSortedSet, SortedSet, Map, ConcurrentMap, List, ListMultimap, Queue, BlockingQueue, Deque, BlockingDeque, Semaphore, Lock, ReadWriteLock, AtomicLong, CountDownLatch, Publish &#x2F; Subscribe, HyperLogLog)。</p>
<h3 id="18、Jedis和Redisson对比有什么缺点？"><a href="#18、Jedis和Redisson对比有什么缺点？" class="headerlink" title="18、Jedis和Redisson对比有什么缺点？"></a>18、Jedis和Redisson对比有什么缺点？</h3><p>Jedis是Redis的Java实现的客户端，其API提供了比较全面的Redis命令的支持；Redisson实现了分布式和可扩展的Java数据结构，和Jedis相比，功能较为简单，不支持字符串操作，不支持排序、事务、管道、分区等Redis特性。Redisson的宗旨是促进使用者对Redis的关注分离，从而让使用者能够将精力更集中地放在处理业务逻辑上。</p>
<hr>
<h3 id="其他问题"><a href="#其他问题" class="headerlink" title="其他问题"></a>其他问题</h3><h3 id="19、Redis和Memcached的区别"><a href="#19、Redis和Memcached的区别" class="headerlink" title="19、Redis和Memcached的区别"></a>19、Redis和Memcached的区别</h3><p>两者都是非关系型内存键值数据库，现在公司一般都是用 Redis 来实现缓存，而且 Redis 自身也越来越强大了！Redis 与 Memcached 主要有以下不同：</p>
<table>
<thead>
<tr>
<th align="center">对比参数</th>
<th align="center">Redis</th>
<th align="center">Memcached</th>
</tr>
</thead>
<tbody><tr>
<td align="center">类型</td>
<td align="center">支持内存  、非关系型数据库</td>
<td align="center">支持内存 、键值对形式 、缓存形式</td>
</tr>
<tr>
<td align="center">数据存储类型</td>
<td align="center">String 、List 、Set 、Hash 、Zset</td>
<td align="center">文本型、二进制型</td>
</tr>
<tr>
<td align="center">查询类型</td>
<td align="center">批量操作、事务支持、每个类型不同的CRUD</td>
<td align="center">常用的CRUD、少量的其它命令</td>
</tr>
<tr>
<td align="center">附加功能</td>
<td align="center">发布&#x2F;订阅模式、主从分区、序列化支持、脚本支持（LUA脚本）</td>
<td align="center">多线程服务支持</td>
</tr>
<tr>
<td align="center">网络IO模型</td>
<td align="center">单线程的多路IO复用模型</td>
<td align="center">多线程，非阻塞IO模式</td>
</tr>
<tr>
<td align="center">事件库</td>
<td align="center">自封转简易事件库AeEvent</td>
<td align="center">贵族血统的LibEvent事件库</td>
</tr>
<tr>
<td align="center">持久化支持</td>
<td align="center">RDB、AOF</td>
<td align="center">不支持</td>
</tr>
<tr>
<td align="center">集群模式</td>
<td align="center">原生支持cluster模式，可以实现主从复制，读写分离</td>
<td align="center">没有原生的集群模式，需要依靠客户端来实现往集群中分片写入数据</td>
</tr>
<tr>
<td align="center">内存管理机制</td>
<td align="center">在Redis中，并不是所有的数据都一直存储在内存中，可以将一些很久没用的value交换到磁盘</td>
<td align="center">数据会一直在内存中，将内存分割成特定长度的块来存储数据，以完全解决内存碎片问题，但是这种方式会使得内存的利用率不高。</td>
</tr>
<tr>
<td align="center">使用场景</td>
<td align="center">复杂数据结构、有持久化、高可用需求，value存储内容很大</td>
<td align="center">纯key-value，数据量非常大，并发量非常大的业务</td>
</tr>
</tbody></table>
<ul>
<li>memcached所有的值均是简单的字符串，redis作为其替代者，支持更为丰富的数据类型。</li>
<li>redis的速度比memcached快很多。</li>
<li>redis可以持久化其数据。</li>
</ul>
<h3 id="20、如何保证缓存与数据库双写时的数据一致性？"><a href="#20、如何保证缓存与数据库双写时的数据一致性？" class="headerlink" title="20、如何保证缓存与数据库双写时的数据一致性？"></a>20、如何保证缓存与数据库双写时的数据一致性？</h3><p>你只要用缓存，就可能会涉及到缓存与数据库双存储双写，你只要是双写，就一定会有数据一致性的问题，那么你如何解决一致性问题？</p>
<p>一般来说，就是如果你的系统不是严格要求缓存+数据库必须一致性的话，缓存可以稍微的跟数据库偶尔有不一致的情况，最好不要做这个方案，读请求和写请求串行化，串到一个内存队列里去，这样就可以保证一定不会出现不一致的情况</p>
<p>串行化之后，就会导致系统的吞吐量会大幅度的降低，用比正常情况下多几倍的机器去支撑线上的一个请求。</p>
<p>还有一种方式就是可能会暂时产生不一致的情况，但是发生的几率特别小，就是<strong>先更新数据库，然后再删除缓存。</strong></p>
<table>
<thead>
<tr>
<th align="center">问题场景</th>
<th align="center">描述</th>
<th align="center">解决</th>
</tr>
</thead>
<tbody><tr>
<td align="center">先写缓存，再写数据库，缓存写成功，数据库写失败</td>
<td align="center">缓存写成功，但写数据库失败或者响应延迟，则下次读取缓存时，就会出现脏读</td>
<td align="center">这个写缓存的方式本身就是错误的，需要改为先写数据库，把旧缓存置为失效；读取数据的时候，如果缓存不存在，则读取数据库再写缓存。</td>
</tr>
<tr>
<td align="center">先写数据库，再写缓存，数据库写成功，缓存写失败</td>
<td align="center">写数据库成功，但写缓存失败，则下次读取缓存时，则读不到数据</td>
<td align="center">缓存使用时，假如读缓存失败，先读数据库，再回写缓存的方式实现</td>
</tr>
<tr>
<td align="center">需要缓存异步刷新</td>
<td align="center">指数据库操作和写缓存不在一个操作步骤中，比如在分布式场景下，无法做到同时写缓存或需要异步刷新</td>
<td align="center">确定哪些数据适合此类场景，根据经验值确定合理的数据不一致时间，用户刷新的时间间隔</td>
</tr>
</tbody></table>
<h3 id="21、Redis常见性能问题和解决方案？"><a href="#21、Redis常见性能问题和解决方案？" class="headerlink" title="21、Redis常见性能问题和解决方案？"></a>21、Redis常见性能问题和解决方案？</h3><ol>
<li>Master最好不要做任何持久化工作，包括内存快照和AOF日志文件，特别是不要启用内存快照做持久化。</li>
<li>如果数据比较关键，某个Slave开启AOF备份数据，策略为每秒同步一次。</li>
<li>为了主从复制的速度和连接的稳定性，Slave和Master最好在同一个局域网内。</li>
<li>尽量避免在压力较大的主库上增加从库。</li>
<li>Master调用BGREWRITEAOF重写AOF文件，AOF在重写的时候会占大量的CPU和内存资源，导致服务load过高，出现短暂服务暂停现象。</li>
<li>为了Master的稳定性，主从复制不要用图状结构，用单向链表结构更稳定，即主从关系为：Master&lt;–Slave1&lt;–Slave2&lt;–Slave3…，这样的结构也方便解决单点故障问题，实现Slave对Master的替换，也即，如果Master挂了，可以立马启用Slave1做Master，其他不变。</li>
</ol>
<h3 id="22、Redis官方为什么不提供Windows版本？"><a href="#22、Redis官方为什么不提供Windows版本？" class="headerlink" title="22、Redis官方为什么不提供Windows版本？"></a>22、Redis官方为什么不提供Windows版本？</h3><p>因为目前Linux版本已经相当稳定，而且用户量很大，无需开发windows版本，反而会带来兼容性等问题。</p>
<h3 id="23、一个字符串类型的值能存储最大容量是多少？（512M）"><a href="#23、一个字符串类型的值能存储最大容量是多少？（512M）" class="headerlink" title="23、一个字符串类型的值能存储最大容量是多少？（512M）"></a>23、一个字符串类型的值能存储最大容量是多少？（512M）</h3><h3 id="24、Redis如何做大量数据插入？"><a href="#24、Redis如何做大量数据插入？" class="headerlink" title="24、Redis如何做大量数据插入？"></a>24、Redis如何做大量数据插入？</h3><p>Redis2.6开始redis-cli支持一种新的被称之为pipe mode的新模式用于执行大量数据插入工作。</p>
<h3 id="25、假如Redis里面有1个亿key，其中有10w个key是以某个固定的已知的前缀开头，如何将他们全部找出来？"><a href="#25、假如Redis里面有1个亿key，其中有10w个key是以某个固定的已知的前缀开头，如何将他们全部找出来？" class="headerlink" title="25、假如Redis里面有1个亿key，其中有10w个key是以某个固定的已知的前缀开头，如何将他们全部找出来？"></a>25、假如Redis里面有1个亿key，其中有10w个key是以某个固定的已知的前缀开头，如何将他们全部找出来？</h3><p>使用keys指令可以扫出指定模式的key列表。</p>
<p>对方接着追问：如果这个redis正在给线上的业务提供服务，那使用keys指令会有什么问题？</p>
<p>这个时候你要回答redis关键的一个特性：redis的单线程的。keys指令会导致线程阻塞一段时间，线上服务会停顿，直到指令执行完毕，服务才能恢复。这个时候可以使用scan指令，scan指令可以无阻塞的提取出指定模式的key列表，但是会有一定的重复概率，在客户端做一次去重就可以了，但是整体所花费的时间会比直接用keys指令长。</p>
<h3 id="26、使用Redis做过异步队列吗？是如何实现的？"><a href="#26、使用Redis做过异步队列吗？是如何实现的？" class="headerlink" title="26、使用Redis做过异步队列吗？是如何实现的？"></a>26、使用Redis做过异步队列吗？是如何实现的？</h3><p>使用list类型保存数据信息，rpush生产消息，lpop消费消息，当lpop没有消息时，可以sleep一段时间，然后再检查有没有信息，如果不想sleep的话，可以使用blpop, 在没有信息的时候，会一直阻塞，直到信息的到来。redis可以通过pub&#x2F;sub主题订阅模式实现一个生产者，多个消费者，当然也存在一定的缺点，当消费者下线时，生产的消息会丢失。</p>
<h3 id="27、Redis如何实现延时队列？"><a href="#27、Redis如何实现延时队列？" class="headerlink" title="27、Redis如何实现延时队列？"></a>27、Redis如何实现延时队列？</h3><p>使用sortedset，使用时间戳做score, 消息内容作为key,调用zadd来生产消息，消费者使用zrangbyscore获取n秒之前的数据做轮询处理。</p>
<h3 id="28、Redis回收进程如何工作的？"><a href="#28、Redis回收进程如何工作的？" class="headerlink" title="28、Redis回收进程如何工作的？"></a>28、Redis回收进程如何工作的？</h3><ol>
<li>一个客户端运行了新的命令，添加了新的数据。</li>
<li>Redis检查内存使用情况，如果大于maxmemory的限制， 则根据设定好的策略进行回收。</li>
<li>一个新的命令被执行，等等。</li>
<li>所以我们不断地穿越内存限制的边界，通过不断达到边界然后不断地回收回到边界以下。</li>
</ol>
<p>如果一个命令的结果导致大量内存被使用（例如很大的集合的交集保存到一个新的键），不用多久内存限制就会被这个内存使用量超越。</p>
<h3 id="29、Redis回收使用的是什么算法？"><a href="#29、Redis回收使用的是什么算法？" class="headerlink" title="29、Redis回收使用的是什么算法？"></a>29、Redis回收使用的是什么算法？</h3><p>LRU算法。</p>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis常见面试题（二）</title>
    <url>/2022/03/09/Redis%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
    <content><![CDATA[<h3 id="Redis-常见面试题（二）"><a href="#Redis-常见面试题（二）" class="headerlink" title="Redis-常见面试题（二）"></a>Redis-常见面试题（二）</h3><span id="more"></span>

<h3 id="内存相关"><a href="#内存相关" class="headerlink" title="内存相关"></a>内存相关</h3><h3 id="1、MySQL里有2000w数据，redis中只存20w的数据，如何保证redis的数据都是热点数据？"><a href="#1、MySQL里有2000w数据，redis中只存20w的数据，如何保证redis的数据都是热点数据？" class="headerlink" title="1、MySQL里有2000w数据，redis中只存20w的数据，如何保证redis的数据都是热点数据？"></a>1、MySQL里有2000w数据，redis中只存20w的数据，如何保证redis的数据都是热点数据？</h3><p>redis内存数据集大小上升到一定大小的时候，就会施行数据淘汰策略。</p>
<h3 id="2、Redis的内存淘汰策略有哪些？"><a href="#2、Redis的内存淘汰策略有哪些？" class="headerlink" title="2、Redis的内存淘汰策略有哪些？"></a>2、Redis的内存淘汰策略有哪些？</h3><p>Redis的内存淘汰策略是指在Redis的用于缓存的内存不足时，怎么处理需要重新写入且需要申请额外空间的数据。</p>
<p>全局的键空间选择性移除：</p>
<ul>
<li>noeviction：当内存不足以容纳新写入数据时，新写入操作会报错。</li>
<li>allkeys-lru：当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的key。（最常用）</li>
<li>allkeys-random：当内存不足以容纳新写入数据时，在设置了过期时间的空间中，有更早过期时间的可以优先移除。</li>
</ul>
<p>设置过期时间的键空间选择性移除：</p>
<ul>
<li>volatile-lru：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，移除最近最少使用的key。</li>
<li>volatile-random：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，随机移除某个key。</li>
<li>volatile-ttl：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，有更早过期时间的key优先移除。</li>
</ul>
<p>总结：</p>
<ul>
<li>Redis的内存淘汰策略的选取并不会影响过期的key的处理。</li>
<li>内存淘汰策略用于处理内存不足时的需要申请额外空间的数据。</li>
<li>过期策略用于处理过期的缓存数据。</li>
</ul>
<h3 id="3、Redis主要消耗什么物理资源？（内存）"><a href="#3、Redis主要消耗什么物理资源？（内存）" class="headerlink" title="3、Redis主要消耗什么物理资源？（内存）"></a>3、Redis主要消耗什么物理资源？（内存）</h3><h3 id="4、Redis的内存用完了会发生什么？"><a href="#4、Redis的内存用完了会发生什么？" class="headerlink" title="4、Redis的内存用完了会发生什么？"></a>4、Redis的内存用完了会发生什么？</h3><p>如果达到设置的上限，Redis的写命令会返回错误信息（但是读命令还可以正常返回）或者你可以配置内存淘汰机制，当Redis达到内存上限时会冲刷掉旧的内容。</p>
<h3 id="5、Redis如何做内存优化？"><a href="#5、Redis如何做内存优化？" class="headerlink" title="5、Redis如何做内存优化？"></a>5、Redis如何做内存优化？</h3><p>可以好好利用Hash，List，Zset，Set等数据结构，因为通常情况下，很多小的key-value可以用更紧凑的方式存放在一起。尽可能使用散列表，散列表使用的内存非常小，所以你应该尽可能的将你的数据模型抽象到一个散列表里面。例如，你的web系统中有一个用户对象，不要为这个用户的名称，姓氏，邮箱，密码设置单独的key，而是应该把这个用户的所有信息存储到一张散列表中。</p>
<hr>
<h3 id="线程模型"><a href="#线程模型" class="headerlink" title="线程模型"></a>线程模型</h3><h3 id="6、Redis线程模型"><a href="#6、Redis线程模型" class="headerlink" title="6、Redis线程模型"></a>6、Redis线程模型</h3><p>Redis基于Reactor模式开发了网络事件处理器，这个处理器被称为文件事件处理器（file event handler）。它的组成结构为4部分：多个套接字、IO多路复用程序、文件事件分派器、事件处理器。因为文件事件分派器队列的消费是单线程的，所以Redis才叫单线程模型。</p>
<ul>
<li>文件事件处理器使用I&#x2F;O多路复用程序来同时监听多个套接字，并根据套接字目前执行的任务来为套接字关联不同的事件处理器。</li>
<li>当被监听的套接字准备好执行连接应答、读取、写入、关闭等操作时，与操作相对应的文件事件就会产生，这时文件事件处理器就会调用套接字之前关联好的事件处理器来处理这些事情。</li>
</ul>
<p>虽然文件事件处理器以单线程方式运行，但通过使用I&#x2F;O多路复用程序来监听多个套接字，文件事件处理器既实现了高性能的网络通信模型，又可以很好的与redis服务器中其它同样以单线程方式运行的模块进行对接，这保持了Redis内部单线程设计的简单性。</p>
<hr>
<h3 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h3><h3 id="7、什么是事务？"><a href="#7、什么是事务？" class="headerlink" title="7、什么是事务？"></a>7、什么是事务？</h3><p>事务是一个单独的隔离操作：事务中的所有命令都会序列化、按顺序执行。事务在执行过程中，不会被其它客户端发送来的命令请求所打断。</p>
<p>事务是一个原子操作：事务中的命令要么全部被执行，要么全部不执行。</p>
<h3 id="8、Redis事务的概念"><a href="#8、Redis事务的概念" class="headerlink" title="8、Redis事务的概念"></a>8、Redis事务的概念</h3><p>Redis事务的本质是是通过MULTI、EXEC、WATCH等一组命令的集合。事务一次执行多个命令 ，一个事务中所有的命令都会被序列化。在事务的执行过程中，会按照顺序串行化执行队列中的命令，其它客户端提交的命令请求不会插入到事务执行名列序列中。</p>
<p>Redis事务就是一次性、顺序性、排他性的执行一个队列中的一系列命令。</p>
<h3 id="9、Redis事务的三个阶段"><a href="#9、Redis事务的三个阶段" class="headerlink" title="9、Redis事务的三个阶段"></a>9、Redis事务的三个阶段</h3><ol>
<li>事务开始MULTI</li>
<li>命令入队</li>
<li>事务执行EXEC</li>
</ol>
<p>事务执行过程中，如果服务端收到有EXEC、DISCARD、WATCH、MULTI之外的请求，将会把请求放入队列中排队。</p>
<h3 id="10、事务管理概述（ACID）"><a href="#10、事务管理概述（ACID）" class="headerlink" title="10、事务管理概述（ACID）"></a>10、事务管理概述（ACID）</h3><ul>
<li>原子性（Automicity）</li>
</ul>
<p>原子性是指事务是一个不可分割的工作单位，事务中的操作要么都发生，要么都不发生。</p>
<ul>
<li>一致性（Consistency）</li>
</ul>
<p>事务前后数据的完整性必须保证一致。</p>
<ul>
<li>隔离性（Isolation）</li>
</ul>
<p>多个事务并行执行时，一个事务的执行不应影响其他事务的执行。</p>
<ul>
<li>持久性</li>
</ul>
<p>持久性是指一个事务一旦被提交，它对数据库中的数据的改变是永久性的，接下来即使数据库发生故障也不应该对其有任何影响。</p>
<p>Redis的事务总是具有ACID中的一致性和隔离性，其他特性是不支持的。当服务器运行在AOF持久化模式下，并且appendfsync时，事务也具有耐久性。</p>
<h3 id="11、Redis事务支持隔离性吗？"><a href="#11、Redis事务支持隔离性吗？" class="headerlink" title="11、Redis事务支持隔离性吗？"></a>11、Redis事务支持隔离性吗？</h3><p>Redis是单线程程序，并且它保证在执行事务时，不会对事务进行中断，事务可以运行直到执行完所有事务队列中的命令为止。</p>
<h3 id="12、Redis事务保证原子性吗？支持回滚吗？"><a href="#12、Redis事务保证原子性吗？支持回滚吗？" class="headerlink" title="12、Redis事务保证原子性吗？支持回滚吗？"></a>12、Redis事务保证原子性吗？支持回滚吗？</h3><p>Redis中，单条命令是原子性执行的，但事务不保证原子性，且没有回滚。事务中任意命令执行失败，其余的命令仍会执行。</p>
<h3 id="13、Redis事务其它实现"><a href="#13、Redis事务其它实现" class="headerlink" title="13、Redis事务其它实现"></a>13、Redis事务其它实现</h3><ul>
<li>基于Lua脚本，Redis可以保证脚本内的命令一次性、按命令执行，其同时也不提供事务运行错误的回滚，执行过程中如果部分命令运行错误，剩下的，命令还是会继续执行。</li>
<li>基于中间标记变量，通过另外的标记变量来标识事务是否完成，读取数据时先读取该标记变量，判断是否事务执行完成。但这样会需要额外写代码实现，比较繁琐。</li>
</ul>
<hr>
<h3 id="集群方案"><a href="#集群方案" class="headerlink" title="集群方案"></a>集群方案</h3><h3 id="14、哨兵模式（sentinel）"><a href="#14、哨兵模式（sentinel）" class="headerlink" title="14、哨兵模式（sentinel）"></a>14、哨兵模式（sentinel）</h3><p><img src="/../images/19.png" alt="19"></p>
<ol>
<li><p>哨兵的介绍</p>
<p>sentinel，中文名是哨兵。哨兵是redis集群机构中非常重要的一个组件，主要有一下功能：</p>
<ul>
<li>集群监控：负责监控redis master和slave进程是否正常工作。</li>
<li>消息通知：如果某个redis实例有故障，那么哨兵负责发送消息作为警报通知给管理员。</li>
<li>故障转移：如果master node挂掉，会自动转移到slave node上。</li>
<li>配置中心：如果故障转移发生了，通知client客户端新的master地址。</li>
</ul>
</li>
<li><p>哨兵用于实现redis集群的高可用，本身也是分布式的，作为一个哨兵集群去运行，互相协同工作</p>
<ul>
<li>故障转移时，判断一个master node是否宕机了，需要大部分的哨兵都同意才行，涉及到了分布式选举的问题。</li>
<li>即使部分哨兵节点挂掉了，哨兵集群还是能正常工作的，因为如果一个作为高可用机制重要组成成分的故障转移系统本身是单点的，那就很坑了。</li>
</ul>
</li>
<li><p>哨兵的核心知识</p>
<ul>
<li>哨兵至少需要3个实例，来保证自己的健壮性。</li>
<li>哨兵+redis主从的部署架构，是不保证数据零丢失的，只能保证集群的高可用性。</li>
<li>对于哨兵+redis主从这种复杂的部署结构，尽量在测试环境和生产环境，都进行充足的测试和演练。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="15、官方Redis-Cluster方案（服务端路由查询）"><a href="#15、官方Redis-Cluster方案（服务端路由查询）" class="headerlink" title="15、官方Redis Cluster方案（服务端路由查询）"></a>15、官方Redis Cluster方案（服务端路由查询）</h3><p><img src="/../images/20.png" alt="20"></p>
<h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p>Redis Cluster是一种服务算sharding技术。Redis Cluster并没有使用一致性hash，而是采用slot（槽）的概念，一共分成16384个槽。将求情发送到任意节点，接收到请求的节点会将查询请求发送到正确的节点上执行。</p>
<h4 id="方案说明"><a href="#方案说明" class="headerlink" title="方案说明"></a>方案说明</h4><ol>
<li>通过hash的方式，将数据分片，每个节点均分存储一定哈希槽的数据，默认分配了16384个槽位。</li>
<li>每份数据分片会存储在多个互为主从的多节点上。</li>
<li>数据写入先写主节点，在同步到从节点（支持配置为阻塞同步）。</li>
<li>同一分片多个节点的数据不保持一致性。</li>
<li>读取数据时，当客户端的key没有分配在该节点时，redis会返回转向指令，指向正确的节点。</li>
<li>扩容时需要把旧节点的数据迁移到新节点。</li>
</ol>
<p>在redis cluster架构下，每个redis要放开两个端口号，比如一个是6379，另一个是加1w的端口号，比如16379。</p>
<p>16379端口号是用来进行节点间通信的，也就是cluster bus的东西，cluster bus的通信，用来进行故障检测，配置更新，故障转移授权。cluster bus用了另外一种二进制的协议，gossip协议，用于节点间进行高效的数据交换，占用更少的网络带宽和处理时间。</p>
<h4 id="节点间的内部通信机制"><a href="#节点间的内部通信机制" class="headerlink" title="节点间的内部通信机制"></a>节点间的内部通信机制</h4><p>基本通信原理</p>
<p>集群元数据的维护有两种方式：集中式、Gossip式。</p>
<p>分布式寻址算法</p>
<ul>
<li>hash算法（大量缓存重建）</li>
<li>一致性hash算法（自动缓存迁移）+虚拟节点（自动负载均衡）</li>
<li>redis cluster的hash slot算法</li>
</ul>
<p>优点</p>
<ul>
<li>无中心结构，支持动态扩容，对业务透明</li>
<li>只能使用0号数据库</li>
<li>不支持批量操作（pipeline管道操作）</li>
<li>分布式逻辑和存储模块耦合</li>
</ul>
<h3 id="16、基于客户端分配"><a href="#16、基于客户端分配" class="headerlink" title="16、基于客户端分配"></a>16、基于客户端分配</h3><p><img src="/../images/21.jpeg" alt="21"></p>
<h4 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h4><p>Redis Sharding是Redis Cluster出来之前，业界普遍使用的多Redis实例集群方法。其主要思想是采用哈希算法将Redis数据的key进行散列，通过hash函数，特定的key会映射到特定的Redis节点上。java redis客户端驱动jedis，支持Redis Sharding功能。</p>
<p>优点</p>
<ul>
<li>优势在于非常简单，服务端的Redis实例彼此独立，相互关联，每个Redis实例像单服务器一样运行，非常容易线性扩展，系统的灵活性很强。</li>
</ul>
<p>缺点</p>
<ul>
<li>由于sharding处理放到客户端，规模进一步扩大时给运维带来挑战。</li>
<li>客户端sharding不支持动态增删节点。服务端Redis实例群拓扑结构有变化时，每个客户都需要更新调整。连接不能共享，当应用规模增大时，资源浪费制约优化。</li>
</ul>
<h3 id="17、基于代理服务器分片"><a href="#17、基于代理服务器分片" class="headerlink" title="17、基于代理服务器分片"></a>17、基于代理服务器分片</h3><p><img src="/../images/22.jpeg" alt="22"></p>
<h4 id="简介-2"><a href="#简介-2" class="headerlink" title="简介"></a>简介</h4><p>客户端发送请求到一个代理组件，代理解析客户端的数据，并将请求转发至正确的节点，最后将结果回复给客户端。</p>
<h4 id="特征"><a href="#特征" class="headerlink" title="特征"></a>特征</h4><ul>
<li>透明接入，业务程序不用关心后端Redis实例，切换成本低</li>
<li>Proxy的逻辑和存储的逻辑是隔离的</li>
<li>代理层多了一次转发，性能有所损耗</li>
</ul>
<h4 id="业务开源方案"><a href="#业务开源方案" class="headerlink" title="业务开源方案"></a>业务开源方案</h4><ul>
<li>Twitter开源的Twenproxy</li>
<li>豌豆荚开源的Codis</li>
</ul>
<h3 id="18、Redis的主从架构"><a href="#18、Redis的主从架构" class="headerlink" title="18、Redis的主从架构"></a>18、Redis的主从架构</h3><p>单机的redis，能够承载的QPS大概就在上千万到几万不等。对于缓存来说，一般都支持读高并发的。因此架构做成主从（master-slave）架构，一主多从，主负责写，并且将数据复制到其他的slave节点，从节点负责读。所有的读请求全部走从节点。这样也可以很轻松实现水平扩容，支持读高并发。</p>
<p><img src="/../images/23.png" alt="23"></p>
<p>redis replication-&gt;主从架构-&gt;读写分离-&gt;水平扩容支持读高并发</p>
<h4 id="redis-replication的核心机制"><a href="#redis-replication的核心机制" class="headerlink" title="redis replication的核心机制"></a>redis replication的核心机制</h4><ul>
<li>redis采用异步方式复制数据到slave节点，不过从redis2.8开始，slave node会周期性地确认自己每次复制的数据量。</li>
<li>一个master node是可以配置多个slave node的。</li>
<li>slave node可以连接其他的slave node。</li>
<li>slave node做复制的时候，不会block master node的正常工作。</li>
<li>slave node在做复制的时候，也不会对自己的查询的操作，他会用旧的数据集来提供服务；但是复制完成的时候，需要删除数据集，加载新的数据集，这个时候，就会暂停对外服务。</li>
<li>slave node主要用来进行横向扩容，做读写分离，扩容的slave node可以提纲哦吞吐量。</li>
</ul>
<p>注意，如果采用了主从架构，那么建议必须开启 master node 的持久化，不建议用 slave node 作为 master node 的数据热备，因为那样的话，如果你关掉 master 的持久化，可能在 master 宕机重启的时候数据是空的，然后可能一经过复制， slave node 的数据也丢了。</p>
<p>另外，master 的各种备份方案，也需要做。万一本地的所有文件丢失了，从备份中挑选一份 rdb 去恢复master，这样才能确保启动的时候，是有数据的，即使采用了后续讲解的高可用机制，slave node 可以自动接管 master node，但也可能 sentinel 还没检测到 master failure，master node 就自动重启了，还是可能导致上面所有的 slave node 数据被清空。</p>
<h4 id="redis主从复制的核心原理"><a href="#redis主从复制的核心原理" class="headerlink" title="redis主从复制的核心原理"></a>redis主从复制的核心原理</h4><p>当启动一个slave node的时候，它会发送一个<code>PSYNC</code>命令给master node。</p>
<p>如果这是slave node初次连接到master node，那么会触发一次<code>full resynchronization</code>全量复制。此时，master会启动一个后台程序，开始生成一份<code>RDB</code>快照文件，同时还会将从客户端client新收到的所有写命令缓存在内存中。<code>RDB</code>文件生成完毕后，master会将这个<code>RDB</code>发送给slave，slave会写入本地磁盘，然后再从本地磁盘加载到内存中，接着master会将内存中缓存的写命令发送给slave，slave也会同步这些数据。slave node如果跟master node有网络故障，断开了连接，会自动重连，连接之后master node仅会复制给slave部分缺失的数据。</p>
<p><img src="/../images/24.png" alt="24"></p>
<p>过程原理</p>
<ul>
<li>当从库和主库建立MS关系后，会向主数据库发送<code>SYNC</code>命令。</li>
<li>主库接收到SYNC命令后，会开始在后台保存快照（RDB持久化过程），并将期间接收到的命令缓存起来。</li>
<li>当快照完成后，主Redis会将快照文件和所有缓存的写命令发送给从Redis。</li>
<li>从Redis接收到后，会载入快照文件并且执行收到的缓存命令。</li>
<li>主Redis每当接收到写命令时就会将命令发送给从Redis，从而保证数据的一致。</li>
</ul>
<p>缺点</p>
<ul>
<li>所有的slave节点数据的复制和同步都由master节点处理，会造成master节点压力过大。</li>
</ul>
<h3 id="19、Redis集群的主从复制模型是怎样的？"><a href="#19、Redis集群的主从复制模型是怎样的？" class="headerlink" title="19、Redis集群的主从复制模型是怎样的？"></a>19、Redis集群的主从复制模型是怎样的？</h3><p>为了使在部分节点失败或者大部分节点无法通信的情况下集群仍然可用，所以集群使用了主从复制模型，每个节点都会有N-1个复制品。</p>
<h3 id="20、生产环境中redis是怎么部署的？"><a href="#20、生产环境中redis是怎么部署的？" class="headerlink" title="20、生产环境中redis是怎么部署的？"></a>20、生产环境中redis是怎么部署的？</h3><p>redis cluster，10 台机器，5 台机器部署了 redis 主实例，另外 5 台机器部署了 redis 的从实例，每个主实例挂了一个从实例，5 个节点对外提供读写服务，每个节点的读写高峰qps可能可以达到每秒 5 万，5 台机器最多是 25 万读写请求&#x2F;s。</p>
<p>机器是什么配置？32G 内存+ 8 核 CPU + 1T 磁盘，但是分配给 redis 进程的是10g内存，一般线上生产环境，redis 的内存尽量不要超过 10g，超过 10g 可能会有问题。</p>
<p>5 台机器对外提供读写，一共有 50g 内存。</p>
<p>因为每个主实例都挂了一个从实例，所以是高可用的，任何一个主实例宕机，都会自动故障迁移，redis 从实例会自动变成主实例继续提供读写服务。</p>
<p>你往内存里写的是什么数据？每条数据的大小是多少？商品数据，每条数据是 10kb。100 条数据是 1mb，10 万条数据是 1g。常驻内存的是 200 万条商品数据，占用内存是 20g，仅仅不到总内存的 50%。目前高峰期每秒就是 3500 左右的请求量。</p>
<p>其实大型的公司，会有基础架构的 team 负责缓存集群的运维。</p>
<h3 id="21、说说Redis哈希槽的概念？"><a href="#21、说说Redis哈希槽的概念？" class="headerlink" title="21、说说Redis哈希槽的概念？"></a>21、说说Redis哈希槽的概念？</h3><p>Redis集群没有使用一致性hash,而是引入了哈希槽的概念，Redis集群有16384个哈希槽，每个key通过CRC16校验后对16384取模来决定放置哪个槽，集群的每个节点负责一部分hash槽。</p>
<h3 id="22、Redis集群会有写操作丢失吗？"><a href="#22、Redis集群会有写操作丢失吗？" class="headerlink" title="22、Redis集群会有写操作丢失吗？"></a>22、Redis集群会有写操作丢失吗？</h3><p>Redis并不能保证数据的强一致性，这意味这在实际中集群在特定的条件下可能会丢失写操作。</p>
<h3 id="23、Redis集群之间是如何复制的？"><a href="#23、Redis集群之间是如何复制的？" class="headerlink" title="23、Redis集群之间是如何复制的？"></a>23、Redis集群之间是如何复制的？</h3><p>异步复制。</p>
<h3 id="24、Redis集群最大节点个数是多少？"><a href="#24、Redis集群最大节点个数是多少？" class="headerlink" title="24、Redis集群最大节点个数是多少？"></a>24、Redis集群最大节点个数是多少？</h3><p>16384个。</p>
<h3 id="25、Redis集群如何选择数据库？"><a href="#25、Redis集群如何选择数据库？" class="headerlink" title="25、Redis集群如何选择数据库？"></a>25、Redis集群如何选择数据库？</h3><p>Redis集群目前无法做数据库选择，默认在0数据库。</p>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>消息中间件-RabbitMQ</title>
    <url>/2022/03/15/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6-RabbitMQ/</url>
    <content><![CDATA[<h3 id="消息中间件-RabbitMQ"><a href="#消息中间件-RabbitMQ" class="headerlink" title="消息中间件-RabbitMQ"></a>消息中间件-RabbitMQ</h3><p><strong>RabbitMQ</strong>是实现了高级消息队列协议（AMQP）的开源消息代理软件（亦称面向消息的中间件）。RabbitMQ服务器是用<a href="https://baike.baidu.com/item/Erlang">Erlang</a>语言编写的，而集群和故障转移是构建在<a href="https://baike.baidu.com/item/%E5%BC%80%E6%94%BE%E7%94%B5%E4%BF%A1%E5%B9%B3%E5%8F%B0">开放电信平台</a>框架上的。所有主要的<a href="https://baike.baidu.com/item/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/9845131">编程语言</a>均有与代理接口通讯的<a href="https://baike.baidu.com/item/%E5%AE%A2%E6%88%B7%E7%AB%AF/101081">客户端</a>库。</p>
<span id="more"></span>

<h3 id="1、什么是MQ？"><a href="#1、什么是MQ？" class="headerlink" title="1、什么是MQ？"></a>1、什么是MQ？</h3><p>MQ（message queue），从字面意思上看，本质是个队列，FIFO先入先出，只不过队列中存放的内容是message而已，还是一种跨进程的通信机制，用于上下游传递信息。在互联网架构中，MQ是一种非常常见的上下游“逻辑解耦+物理解耦”的消息通信服务。使用了MQ之后，消息发送上游只需要依赖MQ，不用依赖其他服务。</p>
<h3 id="2、为什么要用MQ？"><a href="#2、为什么要用MQ？" class="headerlink" title="2、为什么要用MQ？"></a>2、为什么要用MQ？</h3><p>流量消峰（优点：防止系统宕机；缺点：访问速率偏慢）</p>
<p><img src="/../images/31.PNG" alt="31"></p>
<p>应用解耦（如果订单系统出现故障，就会造成任意一个子系统出现下单异常；使用MQ,即使是出现异常，在MQ已经缓存完成，依然可以正常进行下单）</p>
<p><img src="/../images/32.PNG" alt="32"></p>
<p>异步处理</p>
<p><img src="/../images/33.PNG" alt="33"></p>
<p>分类</p>
<ul>
<li><p><input disabled type="checkbox"> 
ActiveMQ</p>
<p>优点：单机吞吐量万级，时效性ms级，可用性高，基于主从架构实现高可用性，消息可靠性较低的概率丢失数据</p>
<p>缺点：维护越来越少，高吞吐量场景较少使用。</p>
</li>
<li><p><input disabled type="checkbox"> 
Kafka</p>
<p>优点：吞吐量高，分布式，一个数据多个副本，少数机器宕机，不会丢失数据，日志采集。</p>
<p>缺点：社区更新较慢。消费失败不支持重试。</p>
</li>
<li><p><input disabled type="checkbox"> 
RocketMQ</p>
<p>优点：单机吞吐量十万级，分布式架构，消息0丢失。java语言实现的。</p>
<p>缺点：支持的客户端语言不多。</p>
</li>
<li><p><input disabled type="checkbox"> 
RabbitMQ</p>
<p>优点：高并发的特性，性能较好，支持多语言。</p>
<p>缺点：商业版需要收费，学习成本比较高。</p>
</li>
</ul>
<p>选择</p>
<ul>
<li><input disabled type="checkbox"> Kafka：大型公司，并且有日志采集功能。</li>
<li><input disabled type="checkbox"> RocketMQ：金融互联网，适合高并发场景。</li>
<li><input disabled type="checkbox"> RabbitMQ：中小型公司。</li>
</ul>
<h3 id="3、RabbitMQ"><a href="#3、RabbitMQ" class="headerlink" title="3、RabbitMQ"></a>3、RabbitMQ</h3><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><p>RabbitMQ是一个消息中间件，它接受并转发消息。可以当做一个快递站点，dangni要发送包裹时，把包裹方法哦站点，最后包裹会通过快递员送到指定地方，按照这种逻辑，RabbitMQ是一个快递站点，一个快递员帮你传递快件。RabbitMQ与快递站的主要区别在于，它不处理快件而是接收，存储和转发消息数据。</p>
<h4 id="四大核心组件（生产者、交换机、队列、消费者）"><a href="#四大核心组件（生产者、交换机、队列、消费者）" class="headerlink" title="四大核心组件（生产者、交换机、队列、消费者）"></a>四大核心组件（生产者、交换机、队列、消费者）</h4><p><img src="/../images/34.PNG" alt="34"></p>
<h4 id="RabbitMQ核心部分"><a href="#RabbitMQ核心部分" class="headerlink" title="RabbitMQ核心部分"></a>RabbitMQ核心部分</h4><p><img src="/../images/35.PNG" alt="35"></p>
<h4 id="RabbitMQ的工作原理"><a href="#RabbitMQ的工作原理" class="headerlink" title="RabbitMQ的工作原理"></a>RabbitMQ的工作原理</h4><p><img src="/../images/36.PNG" alt="36"></p>
<p>Broker：接收和分发消息的应用，，RabbitMQ server就是Message Broker。</p>
<p>Virtual host：出于多租户和安全因素设计的，把AMQP的基本组件划分到一个虚拟的分组中，类似于网络中的namespace概念。</p>
<p>Connection：publisher&#x2F;consumer和broker之间的TCP连接。</p>
<p>Channel：作为轻量级的Connection极大减少了操作系统建立TCP connection的开销。</p>
<p>Exchange：message到达broker的第一站，根据分发规则，匹配查询表中的routing key，分发消息到queue中去。常用的类型有：direct（point-to-point）、topic（publish-subscribe）和 fanout（multicast）。</p>
<h3 id="4、案例"><a href="#4、案例" class="headerlink" title="4、案例"></a>4、案例</h3><ul>
<li><input disabled type="checkbox"> 新建Producer.class；</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.tzd;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Channel;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Connection;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.ConnectionFactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeoutException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> tianzedeng</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2022/3/15 - 16:13</span></span><br><span class="line"><span class="comment"> * 生产者：发送消息</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Producer</span> &#123;</span><br><span class="line">    <span class="comment">//队列名称</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">QUEUE_NAME</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//发消息</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException &#123;</span><br><span class="line">        <span class="comment">//创建工厂</span></span><br><span class="line">        <span class="type">ConnectionFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConnectionFactory</span>();</span><br><span class="line">        <span class="comment">//工厂IP 连接RabbitMQ的队列</span></span><br><span class="line">        factory.setHost(<span class="string">&quot;本地ip&quot;</span>);</span><br><span class="line">        <span class="comment">//用户名</span></span><br><span class="line">        factory.setUsername(<span class="string">&quot;username&quot;</span>);</span><br><span class="line">        <span class="comment">//密码</span></span><br><span class="line">        factory.setPassword(<span class="string">&quot;password&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建连接</span></span><br><span class="line">        <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> factory.newConnection();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//通过连接获取信道</span></span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> connection.createChannel();</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 生成一个队列</span></span><br><span class="line"><span class="comment">         * 1.队列名称</span></span><br><span class="line"><span class="comment">         * 2.队列里面的消息是否持久化（磁盘） 默认情况消息存储在内存中</span></span><br><span class="line"><span class="comment">         * 3.该队列是否只供一个消费者进行消费 是否进行消息共享，</span></span><br><span class="line"><span class="comment">         * 4.是否自动删除 最后一个消费者端开连接后 该队列是否自动删除</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        channel.queueDeclare(QUEUE_NAME,<span class="literal">true</span>,<span class="literal">false</span>,<span class="literal">false</span>,<span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//发消息</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        * 1.发送到哪个交换机</span></span><br><span class="line"><span class="comment">        * 2.路由的key是哪个</span></span><br><span class="line"><span class="comment">        * 3.其它参数信息</span></span><br><span class="line"><span class="comment">        * 4.发送消息的消息体</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        channel.basicPublish(<span class="string">&quot;&quot;</span>,QUEUE_NAME,<span class="literal">null</span>,message.getBytes());</span><br><span class="line">        System.out.println(<span class="string">&quot;消息发送完毕&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">SLF4J: Failed to load class <span class="string">&quot;org.slf4j.impl.StaticLoggerBinder&quot;</span>.</span><br><span class="line">SLF4J: Defaulting to no-operation (NOP) logger implementation</span><br><span class="line">SLF4J: See http:<span class="comment">//www.slf4j.org/codes.html#StaticLoggerBinder for further details.</span></span><br><span class="line">消息发送完毕</span><br></pre></td></tr></table></figure>

<ul>
<li><input disabled type="checkbox"> 新建Consumer.class</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.tzd;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeoutException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> tianzedeng</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2022/3/15 - 16:36</span></span><br><span class="line"><span class="comment"> * 消费者:接收消息</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Consumer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//队列的名称</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">QUEUE_NAME</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//接收消息</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建连接工厂</span></span><br><span class="line">        <span class="type">ConnectionFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConnectionFactory</span>();</span><br><span class="line">        factory.setHost(<span class="string">&quot;本地IP&quot;</span>);</span><br><span class="line">        factory.setUsername(<span class="string">&quot;username&quot;</span>);</span><br><span class="line">        factory.setPassword(<span class="string">&quot;password&quot;</span>);</span><br><span class="line">        <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> factory.newConnection();</span><br><span class="line"></span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> connection.createChannel();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//声明 接收消息</span></span><br><span class="line">        <span class="type">DeliverCallback</span> <span class="variable">deliverCallback</span> <span class="operator">=</span> (consumerTag,message)-&gt;&#123;</span><br><span class="line">            System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(message.getBody()));</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">//取消消息时的回调</span></span><br><span class="line">        <span class="type">CancelCallback</span> <span class="variable">cancelCallback</span> <span class="operator">=</span> consumerTag -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;消息消费被中断&quot;</span>);</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        * 消费者接收消息</span></span><br><span class="line"><span class="comment">        * */</span></span><br><span class="line">        channel.basicConsume(QUEUE_NAME,<span class="literal">true</span>,deliverCallback,cancelCallback);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">SLF4J: Failed to load class <span class="string">&quot;org.slf4j.impl.StaticLoggerBinder&quot;</span>.</span><br><span class="line">SLF4J: Defaulting to no-operation (NOP) logger implementation</span><br><span class="line">SLF4J: See http:<span class="comment">//www.slf4j.org/codes.html#StaticLoggerBinder for further details.</span></span><br><span class="line">hello world</span><br></pre></td></tr></table></figure>

<p>后台控制器如图：</p>
<p><img src="/../images/37.PNG" alt="37"></p>
<h3 id="5、工作队列原理"><a href="#5、工作队列原理" class="headerlink" title="5、工作队列原理"></a>5、工作队列原理</h3><p><img src="/../images/38.PNG" alt="38"></p>
<p>重复的连接工厂方法用工具类封装RabbitMqUtils.class</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.tzd.rabbitmq.util;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Connection;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.ConnectionFactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Channel;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> tianzedeng</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2022/3/15 - 18:27</span></span><br><span class="line"><span class="comment"> * 工具类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RabbitMqUtils</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//得到一个连接的channel</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Channel <span class="title function_">getChannel</span><span class="params">()</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="comment">//创建一个连接工厂</span></span><br><span class="line">        <span class="type">ConnectionFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConnectionFactory</span>();</span><br><span class="line">        factory.setHost(<span class="string">&quot;本地IP&quot;</span>);</span><br><span class="line">        factory.setUsername(<span class="string">&quot;username&quot;</span>);</span><br><span class="line">        factory.setPassword(<span class="string">&quot;password&quot;</span>);</span><br><span class="line">        <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> factory.newConnection();</span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> connection.createChannel();</span><br><span class="line">        <span class="keyword">return</span> channel;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>新建工作线程类Work01.class</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.tzd.rabbitmq.demo2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.CancelCallback;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Channel;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.DeliverCallback;</span><br><span class="line"><span class="keyword">import</span> com.tzd.rabbitmq.util.RabbitMqUtils;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> tianzedeng</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2022/3/15 - 18:38</span></span><br><span class="line"><span class="comment"> * 这是一个工作线程，相当于消费者</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Worker01</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//队列名称</span></span><br><span class="line">    <span class="keyword">public</span>  <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">QUEUE_NAME</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//接收消息</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> RabbitMqUtils.getChannel();</span><br><span class="line"></span><br><span class="line">        <span class="type">DeliverCallback</span> <span class="variable">deliverCallback</span> <span class="operator">=</span> (consumerTag,message)-&gt;&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;接收到的消息：&quot;</span>+<span class="keyword">new</span> <span class="title class_">String</span>(message.getBody()));</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="type">CancelCallback</span> <span class="variable">cancelCallback</span> <span class="operator">=</span> (consumerTag)-&gt;&#123;</span><br><span class="line">            System.out.println(consumerTag+<span class="string">&quot;消费者取消消费者接口回调逻辑&quot;</span>);</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">//消息的接收</span></span><br><span class="line">        System.out.println(<span class="string">&quot;C2等待接收消息。。。。。&quot;</span>);</span><br><span class="line">        channel.basicConsume(QUEUE_NAME,<span class="literal">true</span>,deliverCallback,cancelCallback);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>新建生产者类Task01.class</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.tzd.rabbitmq.demo2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Channel;</span><br><span class="line"><span class="keyword">import</span> com.tzd.rabbitmq.util.RabbitMqUtils;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> tianzedeng</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2022/3/15 - 18:55</span></span><br><span class="line"><span class="comment"> * 生产者发送大量的消息</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Task01</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//队列名称</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">QUEUE_NAME</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> RabbitMqUtils.getChannel();</span><br><span class="line"></span><br><span class="line">        channel.queueDeclare(QUEUE_NAME,<span class="literal">true</span>,<span class="literal">false</span>,<span class="literal">false</span>,<span class="literal">null</span>);</span><br><span class="line">        <span class="comment">//从控制台接收信息</span></span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (scanner.hasNext())&#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> scanner.next();</span><br><span class="line">            channel.basicPublish(<span class="string">&quot;&quot;</span>,QUEUE_NAME,<span class="literal">null</span>,message.getBytes());</span><br><span class="line">            System.out.println(<span class="string">&quot;发送消息完成&quot;</span>+message);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<p>Task01：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">SLF4J: Failed to load class <span class="string">&quot;org.slf4j.impl.StaticLoggerBinder&quot;</span>.</span><br><span class="line">SLF4J: Defaulting to no-operation (NOP) logger implementation</span><br><span class="line">SLF4J: See http:<span class="comment">//www.slf4j.org/codes.html#StaticLoggerBinder for further details.</span></span><br><span class="line">AA</span><br><span class="line">发送消息完成AA</span><br><span class="line">BB</span><br><span class="line">发送消息完成BB</span><br><span class="line">CC</span><br><span class="line">发送消息完成CC</span><br><span class="line">DD</span><br><span class="line">发送消息完成DD</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>Work01：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">SLF4J: Failed to load class <span class="string">&quot;org.slf4j.impl.StaticLoggerBinder&quot;</span>.</span><br><span class="line">SLF4J: Defaulting to no-operation (NOP) logger implementation</span><br><span class="line">SLF4J: See http:<span class="comment">//www.slf4j.org/codes.html#StaticLoggerBinder for further details.</span></span><br><span class="line">C1等待接收消息。。。。。</span><br><span class="line">接收到的消息：AA</span><br><span class="line">接收到的消息：CC</span><br></pre></td></tr></table></figure>

<p>Work01：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">SLF4J: Failed to load class <span class="string">&quot;org.slf4j.impl.StaticLoggerBinder&quot;</span>.</span><br><span class="line">SLF4J: Defaulting to no-operation (NOP) logger implementation</span><br><span class="line">SLF4J: See http:<span class="comment">//www.slf4j.org/codes.html#StaticLoggerBinder for further details.</span></span><br><span class="line">C2等待接收消息。。。。。</span><br><span class="line">接收到的消息：BB</span><br><span class="line">接收到的消息：DD</span><br></pre></td></tr></table></figure>

<h3 id="6、消息应答"><a href="#6、消息应答" class="headerlink" title="6、消息应答"></a>6、消息应答</h3><p>为了保证消息在发送过程中不丢失，RabbitMQ引入消息应答机制，消息应答就是：消费者在接收到消息并且处理该消息之后，告诉RabbitMQ已经处理完毕，RabbitMQ可以删除该消息了。</p>
<ul>
<li><p><input disabled type="checkbox"> 
自动应答</p>
<p>仅适用在消费者可以高效并以某种速率能够处理这些消息的情况下使用。</p>
</li>
<li><p><input disabled type="checkbox"> 
手动应答</p>
<ul>
<li><p>Channel.basicAck（用于肯定确认）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">basicAck</span><span class="params">(<span class="type">long</span> deliveryTag,</span></span><br><span class="line"><span class="params">                              <span class="type">boolean</span> multiple)</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>Channel.basicNack（用于否定确认）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">basicNack</span><span class="params">(<span class="type">long</span> deliveryTag,</span></span><br><span class="line"><span class="params">                               <span class="type">boolean</span> multiple,</span></span><br><span class="line"><span class="params">                               <span class="type">boolean</span> requeue)</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>Channel.basicReject（用于否定确认）与Channel.basicNack相比少了一个参数，不处理该消息直接拒绝，可以将其丢弃。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">basicReject</span><span class="params">(<span class="type">long</span> deliveryTag,</span></span><br><span class="line"><span class="params">                                 <span class="type">boolean</span> requeue)</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><input disabled type="checkbox"> 
Multiple的解释</p>
<p>手动应答的好处是可以批量应答并且减少网络拥堵。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">channel.basicAck(deliverTag,<span class="literal">true</span>)</span><br></pre></td></tr></table></figure>

<p>true表示应答一次，就会应答所有进程里面的消息。</p>
<p>false表示只会应答当前的消息。</p>
<p><img src="/../images/39.PNG" alt="39"></p>
</li>
</ul>
</li>
</ul>
<h4 id="消息应答重新入队"><a href="#消息应答重新入队" class="headerlink" title="消息应答重新入队"></a>消息应答重新入队</h4><p><img src="/../images/40.PNG" alt="40"></p>
<p>新建Task.class</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.tzd.rabbitmq.demo3;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Channel;</span><br><span class="line"><span class="keyword">import</span> com.tzd.rabbitmq.util.RabbitMqUtils;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> tianzedeng</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2022/3/15 - 20:18</span></span><br><span class="line"><span class="comment"> * 消息在手动应答时是不丢失的，放回队列中重新消费</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">task2</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">TASK_QUEUE_NAME</span> <span class="operator">=</span> <span class="string">&quot;ack_queue&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> RabbitMqUtils.getChannel();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//声明队列</span></span><br><span class="line">        channel.queueDeclare(TASK_QUEUE_NAME,<span class="literal">false</span>,<span class="literal">false</span>,<span class="literal">false</span>,<span class="literal">null</span>);</span><br><span class="line">        <span class="comment">//从控制台输入信息</span></span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="keyword">while</span> (scanner.hasNext())&#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> scanner.next();</span><br><span class="line">            channel.basicPublish(<span class="string">&quot;&quot;</span>,TASK_QUEUE_NAME,<span class="literal">null</span>,message.getBytes(<span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">            System.out.println(<span class="string">&quot;生产者发出消息：&quot;</span>+message);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>新建Work03.class</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.tzd.rabbitmq.demo3;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Channel;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.DeliverCallback;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Delivery;</span><br><span class="line"><span class="keyword">import</span> com.tzd.rabbitmq.util.RabbitMqUtils;</span><br><span class="line"><span class="keyword">import</span> com.tzd.rabbitmq.util.SleepUtils;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> tianzedeng</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2022/3/15 - 20:26</span></span><br><span class="line"><span class="comment"> * 消息在手动应答时不允许丢失，放回队列中重新消费</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Work03</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">TASK_QUEUE_NAME</span> <span class="operator">=</span> <span class="string">&quot;ack_queue&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> RabbitMqUtils.getChannel();</span><br><span class="line">        System.out.println(<span class="string">&quot;C1等待接收消息处理时间较短&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">DeliverCallback</span> <span class="variable">deliverCallback</span> <span class="operator">=</span> (consumerTag,message)-&gt;&#123;</span><br><span class="line">            <span class="comment">//沉睡1秒</span></span><br><span class="line">            SleepUtils.sleep(<span class="number">1</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;接收到的消息：&quot;</span>+<span class="keyword">new</span> <span class="title class_">String</span>(message.getBody(),<span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">            <span class="comment">//手动应答</span></span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">            * 1.消息的标记 tag</span></span><br><span class="line"><span class="comment">            * 2.是否批量应答</span></span><br><span class="line"><span class="comment">            * */</span></span><br><span class="line">                    channel.basicAck(message.getEnvelope().getDeliveryTag(),<span class="literal">false</span>);</span><br><span class="line">                    &#125;;</span><br><span class="line">                    <span class="comment">//采用手动应答</span></span><br><span class="line">                    <span class="type">boolean</span> <span class="variable">autoAck</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">                    channel.basicConsume(TASK_QUEUE_NAME,autoAck,deliverCallback,(consumerTag -&gt; &#123;</span><br><span class="line">                    System.out.println(consumerTag+<span class="string">&quot;消费者取消消费接口回调逻辑&quot;</span>);</span><br><span class="line">                    &#125;));</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>新建Work04.class</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.tzd.rabbitmq.demo3;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Channel;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.DeliverCallback;</span><br><span class="line"><span class="keyword">import</span> com.tzd.rabbitmq.util.RabbitMqUtils;</span><br><span class="line"><span class="keyword">import</span> com.tzd.rabbitmq.util.SleepUtils;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> tianzedeng</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2022/3/15 - 20:26</span></span><br><span class="line"><span class="comment"> * 消息在手动应答时不允许丢失，放回队列中重新消费</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Work04</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">TASK_QUEUE_NAME</span> <span class="operator">=</span> <span class="string">&quot;ack_queue&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> RabbitMqUtils.getChannel();</span><br><span class="line">        System.out.println(<span class="string">&quot;C2等待接收消息处理时间较长&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">DeliverCallback</span> <span class="variable">deliverCallback</span> <span class="operator">=</span> (consumerTag,message)-&gt;&#123;</span><br><span class="line">            <span class="comment">//沉睡1秒</span></span><br><span class="line">            SleepUtils.sleep(<span class="number">30</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;接收到的消息：&quot;</span>+<span class="keyword">new</span> <span class="title class_">String</span>(message.getBody(),<span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">            <span class="comment">//手动应答</span></span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">            * 1.消息的标记 tag</span></span><br><span class="line"><span class="comment">            * 2.是否批量应答</span></span><br><span class="line"><span class="comment">            * */</span></span><br><span class="line">            channel.basicAck(message.getEnvelope().getDeliveryTag(),<span class="literal">false</span>);</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">//采用手动应答</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">autoAck</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        channel.basicConsume(TASK_QUEUE_NAME,autoAck,deliverCallback,(consumerTag -&gt; &#123;</span><br><span class="line">            System.out.println(consumerTag+<span class="string">&quot;消费者取消消费接口回调逻辑&quot;</span>);</span><br><span class="line">        &#125;));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>封装睡眠工具类SleepUtils.class</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.tzd.rabbitmq.util;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> tianzedeng</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2022/3/15 - 20:34</span></span><br><span class="line"><span class="comment"> * 睡眠工具类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SleepUtils</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sleep</span><span class="params">(<span class="type">int</span> second)</span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>*second);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (InterruptedException _ignored)&#123;</span><br><span class="line">            Thread.currentThread().interrupt();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<p>Task2：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">SLF4J: Failed to load class <span class="string">&quot;org.slf4j.impl.StaticLoggerBinder&quot;</span>.</span><br><span class="line">SLF4J: Defaulting to no-operation (NOP) logger implementation</span><br><span class="line">SLF4J: See http:<span class="comment">//www.slf4j.org/codes.html#StaticLoggerBinder for further details.</span></span><br><span class="line">aa</span><br><span class="line">生产者发出消息：aa</span><br><span class="line">bb</span><br><span class="line">生产者发出消息：bb</span><br><span class="line">cc</span><br><span class="line">生产者发出消息：cc</span><br><span class="line">dd</span><br><span class="line">生产者发出消息：dd</span><br></pre></td></tr></table></figure>

<p>Work03：在Work04没有接受到消息之前，手动打断Work04时，消息不会丢失，会回调到Work3重新消费。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">SLF4J: Failed to load class <span class="string">&quot;org.slf4j.impl.StaticLoggerBinder&quot;</span>.</span><br><span class="line">SLF4J: Defaulting to no-operation (NOP) logger implementation</span><br><span class="line">SLF4J: See http:<span class="comment">//www.slf4j.org/codes.html#StaticLoggerBinder for further details.</span></span><br><span class="line">C1等待接收消息处理时间较短</span><br><span class="line">接收到的消息：aa</span><br><span class="line">接收到的消息：cc</span><br><span class="line">接收到的消息：dd</span><br></pre></td></tr></table></figure>

<p>Work04：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">SLF4J: Failed to load class <span class="string">&quot;org.slf4j.impl.StaticLoggerBinder&quot;</span>.</span><br><span class="line">SLF4J: Defaulting to no-operation (NOP) logger implementation</span><br><span class="line">SLF4J: See http:<span class="comment">//www.slf4j.org/codes.html#StaticLoggerBinder for further details.</span></span><br><span class="line">C2等待接收消息处理时间较长</span><br><span class="line">接收到的消息：bb</span><br><span class="line"></span><br><span class="line">Process finished with exit code -<span class="number">1</span></span><br></pre></td></tr></table></figure>

<h3 id="7、RabbitMQ持久化"><a href="#7、RabbitMQ持久化" class="headerlink" title="7、RabbitMQ持久化"></a>7、RabbitMQ持久化</h3><h4 id="队列持久化（生产者告知）"><a href="#队列持久化（生产者告知）" class="headerlink" title="队列持久化（生产者告知）"></a>队列持久化（生产者告知）</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//让消息队列持久化</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">durable</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">channel.queueDeclare(ACK_QUEUE_NAME,durable,<span class="literal">false</span>,<span class="literal">false</span>,<span class="literal">null</span>);</span><br></pre></td></tr></table></figure>

<p><img src="/../images/41.PNG" alt="41"></p>
<h4 id="消息持久化（生产者就得提前告知队列要实行消息持久化，即要求保存在磁盘中）"><a href="#消息持久化（生产者就得提前告知队列要实行消息持久化，即要求保存在磁盘中）" class="headerlink" title="消息持久化（生产者就得提前告知队列要实行消息持久化，即要求保存在磁盘中）"></a>消息持久化（生产者就得提前告知队列要实行消息持久化，即要求保存在磁盘中）</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">channel.basicPublish(<span class="string">&quot;&quot;</span>,TASK_QUEUE_NAME,<span class="literal">null</span>,message.getBytes(<span class="string">&quot;UTF-8&quot;</span>));</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//当durable为true时</span></span><br><span class="line">channel.basicPublish(<span class="string">&quot;&quot;</span>,TASK_QUEUE_NAME,MessageProperties.PERSISTENT_TEXT_PLAIN,message.getBytes(<span class="string">&quot;UTF-8&quot;</span>));</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>RabbitMQ</category>
      </categories>
      <tags>
        <tag>RabbitMQ</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis</title>
    <url>/2021/05/02/Redis/</url>
    <content><![CDATA[<h1 id="Redis小试牛刀"><a href="#Redis小试牛刀" class="headerlink" title="Redis小试牛刀"></a>Redis小试牛刀</h1><span id="more"></span>

<h2 id="Redis概述"><a href="#Redis概述" class="headerlink" title="Redis概述"></a>Redis概述</h2><h3 id="Redis介绍"><a href="#Redis介绍" class="headerlink" title="Redis介绍"></a>Redis介绍</h3><ul>
<li>Redis是一个开源的key-value存储系统。</li>
<li>和Memcached类似，它支持存储的value类型相对更多，包括string(字符串)、list(链表)、set(集合)、zset(sorted set –有序集合)和hash（哈希类型）。</li>
<li>这些数据类型都支持push&#x2F;pop、add&#x2F;remove及取交集并集和差集及更丰富的操作，而且这些操作都是原子性的。</li>
<li>在此基础上，Redis支持各种不同方式的排序。</li>
<li>与memcached一样，为了保证效率，数据都是缓存在内存中。</li>
<li>区别的是Redis会周期性的把更新的数据写入磁盘或者把修改操作写入追加的记录文件。</li>
<li>并且在此基础上实现了master-slave(主从)同步。</li>
</ul>
<h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><p><strong>配合关系型数据库做高速缓存</strong></p>
<ul>
<li><p>高频次，热门访问的数据，降低数据库IO。</p>
</li>
<li><p>分布式架构，做session共享。</p>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210618160003509.png" alt="image-20210618160003509"></p>
<p><strong>多样的数据结构存储持久化数据</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210618160101040.png" alt="image-20210618160101040"></p>
<h3 id="相关技术"><a href="#相关技术" class="headerlink" title="相关技术"></a>相关技术</h3><p><strong>Redis使用的是单线程+多路IO复用技术：</strong></p>
<p>多路复用是指使用一个线程来检查多个文件描述符（Socket）的就绪状态，比如调用select和poll函数，传入多个文件描述符，如果有一个文件描述符就绪，则返回，否则阻塞直到超时。得到就绪状态后进行真正的操作可以在同一个线程里执行，也可以启动线程执行（比如使用线程池）。</p>
<p>**串行  vs  多线程+锁（memcached） vs  单线程+多路IO复用(Redis)**（与Memcache三点不同: 支持多数据类型，支持持久化，单线程+多路IO复用） 。</p>
<h2 id="Redis数据类型"><a href="#Redis数据类型" class="headerlink" title="Redis数据类型"></a>Redis数据类型</h2><h3 id="Redis字符串-String"><a href="#Redis字符串-String" class="headerlink" title="Redis字符串(String)"></a><strong>Redis</strong>字符串(String)</h3><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><ol>
<li><p>String是Redis最基本的类型，你可以理解成与Memcached一模一样的类型，一个key对应一个value。</p>
</li>
<li><p>String类型是二进制安全的。意味着Redis的string可以包含任何数据。比如jpg图片或者序列化的对象。</p>
</li>
<li><p>String类型是Redis最基本的数据类型，一个Redis中字符串value最多可以是512M。</p>
</li>
</ol>
<h4 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h4><p>String的数据结构为简单动态字符串(Simple Dynamic String,缩写SDS)，是可以修改的字符串，内部结构实现上类似于Java的ArrayList，采用预分配冗余空间的方式来减少内存的频繁分配.</p>
<img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210618162745983.png" alt="image-20210618162745983" style="zoom:120%;">

<p>如图中所示，内部为当前字符串实际分配的空间capacity一般要高于实际字符串长度len。当字符串长度小于1M时，扩容都是加倍现有的空间，如果超过1M，扩容时一次只会多扩1M的空间。需要注意的是字符串最大长度为512M。</p>
<h3 id="Redis列表（List"><a href="#Redis列表（List" class="headerlink" title="Redis列表（List)"></a>Redis列表（List)</h3><h4 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h4><p>单键多值：Redis 列表是简单的字符串列表，按照插入顺序排序。你可以添加一个元素到列表的头部（左边）或者尾部（右边）。它的底</p>
<p>层实际是个<strong>双向链表</strong>，对两端的操作性能很高，通过索引下标的操作中间的节点性能会较差。</p>
<img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210618163018649.png" alt="image-20210618163018649" style="zoom:120%;">

<h4 id="数据结构-1"><a href="#数据结构-1" class="headerlink" title="数据结构"></a>数据结构</h4><ul>
<li>List的数据结构为快速链表quickList。</li>
<li>首先在列表元素较少的情况下会使用一块连续的内存存储，这个结构是ziplist，也即是压缩列表。它将所有的元素紧挨着一起存储，分配的是一块连续的内存。</li>
<li>当数据量比较多的时候才会改成quicklist。因为普通的链表需要的附加指针空间太大，会比较浪费空间。比如这个列表里存的只是int类型的数据，结构上还需要两个额外的指针prev和next。</li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210618164459005.png" alt="image-20210618164459005" style="zoom:120%;">

<ul>
<li>Redis将链表和ziplist结合起来组成了quicklist。也就是将多个ziplist使用双向指针串起来使用。这样既满足了快速的插入删除性能，又不会出现太大的空间冗余。</li>
</ul>
<h3 id="Redis集合（Set）"><a href="#Redis集合（Set）" class="headerlink" title="Redis集合（Set）"></a>Redis集合（Set）</h3><h4 id="概述-2"><a href="#概述-2" class="headerlink" title="概述"></a>概述</h4><ul>
<li><p>Redis set对外提供的功能与list类似，是一个列表的功能，特殊之处在于set是可以<strong>自动排重</strong>的，当你需要存储一个列表数据，又不希望出现重复数据时，set是一个很好的选择，并且set提供了判断某个成员是否在一个set集合内的重要接口，这个也是list所不能提供的。</p>
</li>
<li><p>Redis的Set是string类型的无序集合。它底层其实是一个value为null的hash表，所以添加，删除，查找的**复杂度都是O(1)**。</p>
</li>
<li><p>一个算法，随着数据的增加，执行时间的长短，如果是O(1)，数据增加，查找数据的时间不变。</p>
</li>
</ul>
<h4 id="数据结构-2"><a href="#数据结构-2" class="headerlink" title="数据结构"></a>数据结构</h4><ul>
<li>Set数据结构是dict字典，字典是用哈希表实现的。</li>
<li>Java中HashSet的内部实现使用的是HashMap，只不过所有的value都指向同一个对象。Redis的set结构也是一样，它的内部也使用hash结构，所有的value都指向同一个内部值。</li>
</ul>
<h3 id="Redis哈希（Hash）"><a href="#Redis哈希（Hash）" class="headerlink" title="Redis哈希（Hash）"></a>Redis哈希（Hash）</h3><h4 id="概述-3"><a href="#概述-3" class="headerlink" title="概述"></a>概述</h4><ul>
<li><p>Redis hash 是一个键值对集合。</p>
</li>
<li><p>Redis hash是一个string类型的field和value的映射表，hash特别适合用于存储对象。</p>
</li>
<li><p>类似Java里面的Map&lt;String,Object&gt;。</p>
</li>
<li><p>用户ID为查找的key，存储的value用户对象包含姓名，年龄，生日等信息，如果用普通的key&#x2F;value结构来存储，主要有以下2种存储方式：</p>
<p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210618203434868.png" alt="image-20210618203434868" style="zoom:120%;">                    <img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210618203449210.png" alt="image-20210618203449210" style="zoom:120%;"></p>
<p>方法一：每次修改用户的某个属性需要，先反序列化改好后再序列化回去。开销较大。</p>
<p>方法二：用户ID数据冗余。</p>
</li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210618203718979.png" alt="image-20210618203718979" style="zoom:120%;">

<p>通过 key(用户ID) + field(属性标签) 就可以操作对应属性数据了，既不需要重复存储数据，也不会带来序列化和并发修改控制的问题。</p>
<h4 id="数据结构-3"><a href="#数据结构-3" class="headerlink" title="数据结构"></a>数据结构</h4><p>Hash类型对应的数据结构是两种：ziplist（压缩列表），hashtable（哈希表）。当field-value长度较短且个数较少时，使用ziplist，否则使用hashtable。</p>
<h3 id="Redis有序集合Zset（Sorted-set）"><a href="#Redis有序集合Zset（Sorted-set）" class="headerlink" title="Redis有序集合Zset（Sorted set）"></a>Redis有序集合Zset（Sorted set）</h3><h4 id="概述-4"><a href="#概述-4" class="headerlink" title="概述"></a>概述</h4><ul>
<li><p>Redis有序集合zset与普通集合set非常相似，是一个没有重复元素的字符串集合。</p>
</li>
<li><p>不同之处是有序集合的每个成员都关联了一个<strong>评分（</strong>score），这个评分（score）被用来按照从最低分到最高分的方式排序集合中的成员。集合的成员是唯一的，但是评分可以是重复了 。</p>
</li>
<li><p>因为元素是有序的，所以你也可以很快的根据评分（score）或者次序（position）来获取一个范围的元素。</p>
</li>
<li><p>访问有序集合的中间元素也是非常快的，因此你能够使用有序集合作为一个没有重复成员的智能列表。</p>
</li>
</ul>
<h4 id="数据结构-4"><a href="#数据结构-4" class="headerlink" title="数据结构"></a>数据结构</h4><p>SortedSet(zset)是Redis提供的一个非常特别的数据结构，一方面它等价于Java的数据结构Map&lt;String, Double&gt;，可以给每一个元素value赋予一个权重score，另一方面它又类似于TreeSet，内部的元素会按照权重score进行排序，可以得到每个元素的名次，还可以通过score的范围来获取元素的列表。</p>
<p>zset底层使用了两个数据结构：</p>
<ol>
<li><p>hash，hash的作用就是关联元素value和权重score，保障元素value的唯一性，可以通过元素value找到相应的score值。</p>
</li>
<li><p>跳跃表，跳跃表的目的在于给元素value排序，根据score的范围获取元素列表。</p>
</li>
</ol>
<h4 id="跳跃表"><a href="#跳跃表" class="headerlink" title="跳跃表"></a>跳跃表</h4><p><strong>简介</strong></p>
<p>有序集合在生活中比较常见，例如根据成绩对学生排名，根据得分对玩家排名等。对于有序集合的底层实现，可以用数组、平衡树、链表等。数组不便元素的插入、删除；平衡树或红黑树虽然效率高但结构复杂；链表查询需要遍历所有效率低。Redis采用的是跳跃表，跳跃表效率堪比红黑树，实现远比红黑树简单。</p>
<p><strong>实例</strong></p>
<p>对比有序链表和跳跃表，从链表中查询出51：</p>
<ol>
<li>有序链表</li>
</ol>
<img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210618205641992.png" alt="image-20210618205641992" style="zoom:120%;">

<p>​       要查找值为51的元素，需要从第一个元素开始依次查找、比较才能找到。共需要6次比较。</p>
<ol start="2">
<li>跳跃表</li>
</ol>
<img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210618205920332.png" alt="image-20210618205920332" style="zoom:120%;">

<ul>
<li><p>从第2层开始，1节点比51节点小，向后比较；</p>
</li>
<li><p>21节点比51节点小，继续向后比较，后面就是NULL了，所以从21节点向下到第1层；</p>
</li>
<li><p>在第1层，41节点比51节点小，继续向后，61节点比51节点大，所以从41向下；</p>
</li>
<li><p>在第0层，51节点为要查找的节点，节点被找到，共查找4次。</p>
</li>
</ul>
<p>从此可以看出跳跃表比有序链表效率要高。</p>
<h3 id="Redis-Bitmaps"><a href="#Redis-Bitmaps" class="headerlink" title="Redis Bitmaps"></a>Redis Bitmaps</h3><h4 id="概述-5"><a href="#概述-5" class="headerlink" title="概述"></a>概述</h4><p>Redis提供了Bitmaps这个“数据类型”可以实现对位的操作：</p>
<ul>
<li><p>Bitmaps本身不是一种数据类型， 实际上它就是字符串（key-value） ， 但是它可以对字符串的位进行操作。</p>
</li>
<li><p>Bitmaps单独提供了一套命令， 所以在Redis中使用Bitmaps和使用字符串的方法不太相同。 可以把Bitmaps想象成一个以位为单位的数组， 数组的每个单元只能存储0和1， 数组的下标在Bitmaps中叫做偏移量。</p>
 <img src="/.io//image-20210618212534639.png" alt="image-20210618212534639" style="zoom:120%;"></li>
</ul>
<h4 id="Bitmaps与set对比"><a href="#Bitmaps与set对比" class="headerlink" title="Bitmaps与set对比"></a><strong>Bitmaps</strong>与set对比</h4><p>假设网站有1亿用户， 每天独立访问的用户有5千万， 如果每天用集合类型和Bitmaps分别存储活跃用户可以得到表：</p>
<table>
<thead>
<tr>
<th>set和Bitmaps存储一天活跃用户对比</th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>数据类型</td>
<td>每个用户id占用空间</td>
<td>需要存储的用户量</td>
<td>全部内存量</td>
</tr>
<tr>
<td>集合</td>
<td>64位</td>
<td>50000000</td>
<td>64位*50000000 &#x3D; 400MB</td>
</tr>
<tr>
<td>Bitmaps</td>
<td>1位</td>
<td>100000000</td>
<td>1位*100000000 &#x3D; 12.5MB</td>
</tr>
</tbody></table>
<p>很明显， 这种情况下使用Bitmaps能节省很多的内存空间， 尤其是随着时间推移节省的内存还是非常可观的。</p>
<table>
<thead>
<tr>
<th>set和Bitmaps存储独立用户空间对比</th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>数据类型</td>
<td>一天</td>
<td>一个月</td>
<td>一年</td>
</tr>
<tr>
<td>集合</td>
<td>400MB</td>
<td>12GB</td>
<td>144GB</td>
</tr>
<tr>
<td>Bitmaps</td>
<td>12.5MB</td>
<td>375MB</td>
<td>4.5GB</td>
</tr>
</tbody></table>
<p>但Bitmaps并不是万金油， 假如该网站每天的独立访问用户很少， 例如只有10万（大量的僵尸用户） ， 那么两者的对比如下表所示， 很显然， 这时候使用Bitmaps就不太合适了， 因为基本上大部分位都是0。</p>
<table>
<thead>
<tr>
<th>set和Bitmaps存储一天活跃用户对比（用户比较少）</th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>数据类型</td>
<td>每个userid占用空间</td>
<td>需要存储的用户量</td>
<td>全部内存量</td>
</tr>
<tr>
<td>集合</td>
<td>64位</td>
<td>100000</td>
<td>64位*100000 &#x3D; 800KB</td>
</tr>
<tr>
<td>Bitmaps</td>
<td>1位</td>
<td>100000000</td>
<td>1位*100000000 &#x3D; 12.5MB</td>
</tr>
</tbody></table>
<h3 id="HyperLogLog"><a href="#HyperLogLog" class="headerlink" title="HyperLogLog"></a><strong>HyperLogLog</strong></h3><p> 在工作当中，我们经常会遇到与统计相关的功能需求，比如统计网站PV（PageView页面访问量），可以使用Redis的incr、incrby轻松实现。但像UV（UniqueVisitor独立访客）、独立IP数、搜索记录数等需要去重和计数的问题如何解决？这种求集合中不重复元素个数的问题称为基数问题。</p>
<p>解决基数问题有很多种方案：</p>
<ol>
<li><p>数据存储在MySQL表中，使用distinct count计算不重复个数。</p>
</li>
<li><p>使用Redis提供的hash、set、bitmaps等数据结构来处理。</p>
</li>
</ol>
<p>以上的方案结果精确，但随着数据不断增加，导致占用空间越来越大，对于非常大的数据集是不切实际的。能否能够降低一定的精度来平衡存储空间？Redis推出了HyperLogLog。</p>
<ul>
<li><p>Redis HyperLogLog 是用来做基数统计的算法，HyperLogLog 的优点是：在输入元素的数量或者体积非常非常大时，计算基数所需的空间总是固定的、并且是很小的。</p>
</li>
<li><p>在 Redis 里面，每个 HyperLogLog 键只需要花费 12 KB 内存，就可以计算接近 2^64 个不同元素的基数。这和计算基数时，元素越多耗费内存就越多的集合形成鲜明对比。</p>
</li>
<li><p>但是，因为 HyperLogLog 只会根据输入元素来计算基数，而不会储存输入元素本身，所以 HyperLogLog 不能像集合那样，返回输入的各个元素。</p>
</li>
</ul>
<p>什么是基数?</p>
<p>比如数据集 {1, 3, 5, 7, 5, 7, 8}，那么这个数据集的基数集为 {1, 3, 5 ,7, 8}，基数(不重复元素)为5。 基数估计就是在误差可接受的范围内，快速计算基数。</p>
<h3 id="Geospatial"><a href="#Geospatial" class="headerlink" title="Geospatial"></a><strong>Geospatial</strong></h3><p>Redis 3.2 中增加了对GEO类型的支持。GEO，Geographic，地理信息的缩写。该类型，就是元素的2维坐标，在地图上就是经纬度。redis基于该类型，提供了经纬度设置，查询，范围查询，距离查询，经纬度Hash等常见操作。</p>
<h2 id="Redis的发布和订阅"><a href="#Redis的发布和订阅" class="headerlink" title="Redis的发布和订阅"></a>Redis的发布和订阅</h2><h3 id="什么是发布和订阅"><a href="#什么是发布和订阅" class="headerlink" title="什么是发布和订阅"></a>什么是发布和订阅</h3><ul>
<li><p>Redis 发布订阅 (pub&#x2F;sub) 是一种消息通信模式：发送者 (pub) 发送消息，订阅者 (sub) 接收消息。</p>
</li>
<li><p>Redis 客户端可以订阅任意数量的频道。</p>
</li>
</ul>
<h3 id="Redis的发布和订阅-1"><a href="#Redis的发布和订阅-1" class="headerlink" title="Redis的发布和订阅"></a><strong>Redis</strong>的发布和订阅</h3><ol>
<li>客户端可以订阅频道如下图：</li>
</ol>
<img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210618211300027.png" alt="image-20210618211300027" style="zoom:150%;">

<ol start="2">
<li>当给这个频道发布消息后，消息就会发送给订阅的客户端：</li>
</ol>
<img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210618211401669.png" alt="image-20210618211401669" style="zoom:150%;">

<h3 id="发布订阅命令行实现"><a href="#发布订阅命令行实现" class="headerlink" title="发布订阅命令行实现"></a><strong>发布订阅命令行实现</strong></h3><ol>
<li><p>打开一个客户端订阅channel1：</p>
  <img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210618211907299.png" alt="image-20210618211907299" style="zoom: 60%;">
</li>
<li><p>打开另一个客户端，给channel1发布消息hello：</p>
  <img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210618212029799.png" alt="image-20210618212029799" style="zoom:50%;">
</li>
<li><p>打开第一个客户端可以看到发送的消息：</p>
</li>
</ol>
 <img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210618211941020.png" alt="image-20210618211941020" style="zoom: 55%;">



<h2 id="Redis事务、锁机制秒杀"><a href="#Redis事务、锁机制秒杀" class="headerlink" title="Redis事务、锁机制秒杀"></a>Redis事务、锁机制秒杀</h2><h3 id="Redis事务定义"><a href="#Redis事务定义" class="headerlink" title="Redis事务定义"></a>Redis事务定义</h3><p>Redis事务是一个单独的隔离操作：事务中的所有命令都会序列化、按顺序地执行。事务在执行的过程中，不会被其他客户端发送来的命令请求所打断。</p>
<p>Redis事务的主要作用就是<strong>串联多个命令</strong>防止别的命令插队。</p>
<h3 id="Multi、Exec、discard"><a href="#Multi、Exec、discard" class="headerlink" title="Multi、Exec、discard"></a>Multi、Exec、discard</h3><p>Redis事务中有Multi、Exec和discard三个指令，在Redis中，从输入Multi命令开始，输入的命令都会依次进入命令队列中，但不会执行，直到输入Exec后，Redis会将之前的命令队列中的命令依次执行。而组队的过程中可以通过discard来放弃组队。</p>
 <img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210619093306171.png" alt="image-20210619093306171" style="zoom:120%;">

<p>案例说明：</p>
 <img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210619093617872.png" alt="image-20210619093617872" style="zoom: 50%;">

<p>组队成功，提交成功。</p>
 <img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210619093741383.png" alt="image-20210619093741383" style="zoom: 50%;">

<p>组队阶段报错，提交失败。</p>
 <img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210619093941172.png" alt="image-20210619093941172" style="zoom:50%;">

<p>组队成功，提交有成功有失败情况。</p>
<h3 id="事务的错误处理"><a href="#事务的错误处理" class="headerlink" title="事务的错误处理"></a>事务的错误处理</h3><p>组队中某个命令出现了报告错误，执行时整个的所有队列都会被取消。</p>
 <img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210619094058710.png" alt="image-20210619094058710" style="zoom:130%;">

<p>如果执行阶段某个命令报出了错误，则只有报错的命令不会被执行，而其他的命令都会执行，不会回滚。</p>
 <img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210619094201203.png" alt="image-20210619094201203" style="zoom:130%;">

<h3 id="为什么要做成事务"><a href="#为什么要做成事务" class="headerlink" title="为什么要做成事务"></a><strong>为什么要做成事务</strong></h3><p>想想一个场景：有很多人有你的账户，同时去参加双十一抢购。</p>
<h3 id="事务冲突的问题"><a href="#事务冲突的问题" class="headerlink" title="事务冲突的问题"></a><strong>事务冲突的问题</strong></h3><p><strong>例子</strong></p>
<ul>
<li><p>一个请求想给金额减8000；</p>
</li>
<li><p>一个请求想给金额减5000；</p>
</li>
<li><p>一个请求想给金额减1000。</p>
<p>最终我们可以发现，总共金额是10000，如果请求全部执行，那最后的金额变为-4000，很明显不合理。</p>
</li>
</ul>
 <img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210619094341090.png" alt="image-20210619094341090" style="zoom:130%;">

<p><strong>悲观锁</strong></p>
 <img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210619094633896.png" alt="image-20210619094633896" style="zoom:130%;">

<p><strong>悲观锁(Pessimistic Lock)<strong>，顾名思义，就是很悲观，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会block直到它拿到锁。</strong>传统的关系型数据库里边就用到了很多这种锁机制</strong>，比如<strong>行锁</strong>，<strong>表锁</strong>等，<strong>读锁</strong>，<strong>写锁</strong>等，都是在做操作之前先上锁。</p>
<p><strong>乐观锁</strong></p>
 <img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210619094741479.png" alt="image-20210619094741479" style="zoom:130%;">

<p><strong>乐观锁(Optimistic Lock)<strong>，顾名思义，就是很乐观，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号等机制。</strong>乐观锁适用于多读的应用类型，这样可以提高吞吐量</strong>。Redis就是利用这种<strong>check-and-set机制</strong>实现事务的。</p>
<p><strong>WATCH</strong> <strong>key</strong> <strong>[key …]</strong></p>
<p>在执行multi之前，先执行watch key1 [key2]，可以监视一个(或多个) key ，如果在事务<strong>执行之前这个(或这些) key被其他命令所改动，那么事务将被打断。</strong></p>
 <img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210619095200164.png" alt="image-20210619095200164" style="zoom: 50%;">



<p> <strong>unwatch</strong></p>
<p>取消 WATCH 命令对所有 key 的监视。如果在执行 WATCH 命令之后，EXEC 命令或DISCARD 命令先被执行了的话，那么就不需要再执行UNWATCH 了。</p>
<h3 id="Redis事务三特性"><a href="#Redis事务三特性" class="headerlink" title="Redis事务三特性"></a>Redis事务三特性</h3><ul>
<li><p>单独的隔离操作 ：事务中的所有命令都会序列化、按顺序地执行。事务在执行的过程中，不会被其他客户端发送来的命令请求所打断。 </p>
</li>
<li><p>没有隔离级别的概念 ：队列中的命令没有提交之前都不会实际被执行，因为事务提交前任何指令都不会被实际执行。</p>
</li>
<li><p>不保证原子性 ：事务中如果有一条命令执行失败，其后的命令仍然会被执行，没有回滚 。</p>
</li>
</ul>
<h2 id="Redis-事务秒杀案例"><a href="#Redis-事务秒杀案例" class="headerlink" title="Redis_事务秒杀案例"></a>Redis_事务秒杀案例</h2><h3 id="解决计数器和人员记录的事务操作"><a href="#解决计数器和人员记录的事务操作" class="headerlink" title="解决计数器和人员记录的事务操作"></a><strong>解决计数器和人员记录的事务操作</strong></h3><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210619095633057.png" alt="image-20210619095633057" style="zoom:130%;">

<h3 id="Redis事务—秒杀并发模拟"><a href="#Redis事务—秒杀并发模拟" class="headerlink" title="Redis事务—秒杀并发模拟"></a>Redis事务—秒杀并发模拟</h3><blockquote>
<p><strong>使用工具ab模拟测试：</strong></p>
<ul>
<li><p>CentOS6 默认安装</p>
</li>
<li><p>CentOS7需要手动安装</p>
</li>
</ul>
</blockquote>
<p><strong>通过ab测试</strong></p>
<p>im postfile 模拟表单提交参数， 以&amp;符号结尾，存放当前目录。</p>
<p>内容：prodid&#x3D;0101&amp;</p>
<p>执行：ab -n 2000 -c 200 -k -p ~&#x2F;postfile -T application&#x2F;x-www-form-urlencoded</p>
<p>访问：<a href="http://192.168.2.115:8081/Seckill/doseckill">http://192.168.2.115:8081/Seckill/doseckill</a></p>
<p><strong>超卖</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210619100129431.png" alt="image-20210619100129431" style="zoom:120%;"><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210619100138313.png" alt="image-20210619100138313" style="zoom:120%;"></p>
<h3 id="超卖问题"><a href="#超卖问题" class="headerlink" title="超卖问题"></a>超卖问题</h3><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210619100303067.png" alt="image-20210619100303067" style="zoom:130%;">

<p><strong>利用乐观锁淘汰用户，解决超卖问题。</strong></p>
<img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210619100339429.png" alt="image-20210619100339429" style="zoom:130%;">

<p><strong>主要代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SecKill_redis</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="type">Jedis</span> <span class="variable">jedis</span> <span class="operator">=</span><span class="keyword">new</span> <span class="title class_">Jedis</span>(<span class="string">&quot;192.168.44.168&quot;</span>,<span class="number">6379</span>);</span><br><span class="line">		System.out.println(jedis.ping());</span><br><span class="line">		jedis.close();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//秒杀过程</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">doSecKill</span><span class="params">(String uid,String prodid)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">		<span class="comment">//1 uid和prodid非空判断</span></span><br><span class="line">		<span class="keyword">if</span>(uid == <span class="literal">null</span> || prodid == <span class="literal">null</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//2 连接redis</span></span><br><span class="line">		<span class="comment">//Jedis jedis = new Jedis(&quot;192.168.44.168&quot;,6379);</span></span><br><span class="line">		<span class="comment">//通过连接池得到jedis对象</span></span><br><span class="line">		<span class="type">JedisPool</span> <span class="variable">jedisPoolInstance</span> <span class="operator">=</span> JedisPoolUtil.getJedisPoolInstance();</span><br><span class="line">		<span class="type">Jedis</span> <span class="variable">jedis</span> <span class="operator">=</span> jedisPoolInstance.getResource();</span><br><span class="line"></span><br><span class="line">		<span class="comment">//3 拼接key</span></span><br><span class="line">		<span class="comment">// 3.1 库存key</span></span><br><span class="line">		<span class="type">String</span> <span class="variable">kcKey</span> <span class="operator">=</span> <span class="string">&quot;sk:&quot;</span>+prodid+<span class="string">&quot;:qt&quot;</span>;</span><br><span class="line">		<span class="comment">// 3.2 秒杀成功用户key</span></span><br><span class="line">		<span class="type">String</span> <span class="variable">userKey</span> <span class="operator">=</span> <span class="string">&quot;sk:&quot;</span>+prodid+<span class="string">&quot;:user&quot;</span>;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//监视库存</span></span><br><span class="line">		jedis.watch(kcKey);</span><br><span class="line"></span><br><span class="line">		<span class="comment">//4 获取库存，如果库存null，秒杀还没有开始</span></span><br><span class="line">		<span class="type">String</span> <span class="variable">kc</span> <span class="operator">=</span> jedis.get(kcKey);</span><br><span class="line">		<span class="keyword">if</span>(kc == <span class="literal">null</span>) &#123;</span><br><span class="line">			System.out.println(<span class="string">&quot;秒杀还没有开始，请等待&quot;</span>);</span><br><span class="line">			jedis.close();</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 5 判断用户是否重复秒杀操作</span></span><br><span class="line">		<span class="keyword">if</span>(jedis.sismember(userKey, uid)) &#123;</span><br><span class="line">			System.out.println(<span class="string">&quot;已经秒杀成功了，不能重复秒杀&quot;</span>);</span><br><span class="line">			jedis.close();</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//6 判断如果商品数量，库存数量小于1，秒杀结束</span></span><br><span class="line">		<span class="keyword">if</span>(Integer.parseInt(kc)&lt;=<span class="number">0</span>) &#123;</span><br><span class="line">			System.out.println(<span class="string">&quot;秒杀已经结束了&quot;</span>);</span><br><span class="line">			jedis.close();</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//7 秒杀过程</span></span><br><span class="line">		<span class="comment">//使用事务</span></span><br><span class="line">		<span class="type">Transaction</span> <span class="variable">multi</span> <span class="operator">=</span> jedis.multi();</span><br><span class="line"></span><br><span class="line">		<span class="comment">//组队操作</span></span><br><span class="line">		multi.decr(kcKey);</span><br><span class="line">		multi.sadd(userKey,uid);</span><br><span class="line"></span><br><span class="line">		<span class="comment">//执行</span></span><br><span class="line">		List&lt;Object&gt; results = multi.exec();</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span>(results == <span class="literal">null</span> || results.size()==<span class="number">0</span>) &#123;</span><br><span class="line">			System.out.println(<span class="string">&quot;秒杀失败了....&quot;</span>);</span><br><span class="line">			jedis.close();</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//7.1 库存-1</span></span><br><span class="line">		<span class="comment">//jedis.decr(kcKey);</span></span><br><span class="line">		<span class="comment">//7.2 把秒杀成功用户添加清单里面</span></span><br><span class="line">		<span class="comment">//jedis.sadd(userKey,uid);</span></span><br><span class="line"></span><br><span class="line">		System.out.println(<span class="string">&quot;秒杀成功了..&quot;</span>);</span><br><span class="line">		jedis.close();</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> <img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210619100941862.png" alt="image-20210619100941862" style="zoom:100%;"><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210619101004992.png" alt="image-20210619101004992"></p>
<h3 id="继续增加并发测试"><a href="#继续增加并发测试" class="headerlink" title="继续增加并发测试"></a>继续增加并发测试</h3><p> <strong>连接有限制</strong></p>
<p>增加-r参数，-r  Don’t exit on socket receive errors。</p>
<p> <strong>已经秒光，可是还有库存</strong></p>
<p>已经秒光，可是还有库存。原因：乐观锁导致很多请求都失败。先点的没秒到，后点的可能秒到了。</p>
 <img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210619101322601.png" alt="image-20210619101322601" style="zoom:150%;">

<p><strong>连接超时，通过连接池解决</strong></p>
<p>节省每次连接redis服务带来的消耗，把连接好的实例反复利用。通过参数管理连接的行为，代码见项目中：</p>
<p>连接池参数：</p>
<ul>
<li><p>MaxTotal：控制一个pool可分配多少个jedis实例，通过pool.getResource()来获取；如果赋值为-1，则表示不限制；如果pool已经分配了MaxTotal个jedis实例，则此时pool的状态为exhausted。</p>
</li>
<li><p>maxIdle：控制一个pool最多有多少个状态为idle(空闲)的jedis实例；</p>
</li>
<li><p>MaxWaitMillis：表示当borrow一个jedis实例时，最大的等待毫秒数，如果超过等待时间，则直接抛JedisConnectionException；</p>
</li>
<li><p>testOnBorrow：获得一个jedis实例的时候是否检查连接可用性（ping()）；如果为true，则得到的jedis实例均是可用的。</p>
</li>
</ul>
<h3 id="解决库存遗留问题"><a href="#解决库存遗留问题" class="headerlink" title="解决库存遗留问题"></a><strong>解决库存遗留问题</strong></h3><p><strong>LUA脚本在Redis中的优势</strong></p>
<ul>
<li><p>将复杂的或者多步的redis操作，写为一个脚本，一次提交给redis执行，减少反复连接redis的次数，提升性能。</p>
</li>
<li><p>LUA脚本是类似redis事务，有一定的原子性，不会被其他命令插队，可以完成一些redis事务性的操作。</p>
</li>
<li><p>但是注意redis的lua脚本功能，只有在Redis 2.6以上的版本才可以使用。</p>
</li>
<li><p>利用lua脚本淘汰用户，解决超卖问题，redis 2.6版本以后，通过lua脚本解决<strong>争抢问题</strong>，实际上是<strong>redis</strong> <strong>利用其单线程的特性，用任务队列的方式解决多任务并发问题</strong>。</p>
</li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210619101853376.png" alt="image-20210619101853376" style="zoom:130%;">

<h2 id="Redis持久化之RDB"><a href="#Redis持久化之RDB" class="headerlink" title="Redis持久化之RDB"></a><strong>Redis</strong>持久化之RDB</h2><h3 id="总体介绍"><a href="#总体介绍" class="headerlink" title="总体介绍"></a><strong>总体介绍</strong></h3><blockquote>
<p>官网介绍：<a href="http://www.redis.io/">http://www.redis.io</a></p>
</blockquote>
<p>Redis 提供了2个不同形式的持久化方式：</p>
<ul>
<li><p>RDB（Redis DataBase）</p>
</li>
<li><p>AOF（Append Of File）</p>
</li>
</ul>
<h3 id="RDB"><a href="#RDB" class="headerlink" title="RDB"></a><strong>RDB</strong></h3><h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a><strong>简介</strong></h4><p>在指定的时间间隔内将内存中的数据集快照写入磁盘， 也就是行话讲的Snapshot快照，它恢复时是将快照文件直接读到内存里。</p>
<h4 id="备份是如何执行的"><a href="#备份是如何执行的" class="headerlink" title="备份是如何执行的"></a><strong>备份是如何执行的</strong></h4><p>Redis会单独创建（fork）一个子进程来进行持久化，首先会将数据写入到一个临时文件中，待持久化过程都结束了，再用这个临时文件替换上次持久化好的文件。整个过程中，主进程是不进行任何IO操作的，这就确保了极高的性能。如果需要进行大规模数据的恢复，且对于数据恢复的完整性不是非常敏感，那RDB方式要比AOF方式更加的高效。<strong>RDB的缺点是最后一次持久化后的数据可能丢失</strong>。</p>
<h4 id="Fork"><a href="#Fork" class="headerlink" title="Fork"></a>Fork</h4><ul>
<li><p>Fork的作用是复制一个与当前进程一样的进程。新进程的所有数据（变量、环境变量、程序计数器等） 数值都和原进程一致，但是是一个全新的进程，并作为原进程的子进程。</p>
</li>
<li><p>在Linux程序中，fork()会产生一个和父进程完全相同的子进程，但子进程在此后多会exec系统调用，出于效率考虑，Linux中引入了“<strong>写时复制技术</strong>”。</p>
</li>
<li><p><strong>一般情况父进程和子进程会共用同一段物理内存</strong>，只有进程空间的各段的内容要发生变化时，才会将父进程的内容复制一份给子进程。</p>
</li>
</ul>
<h4 id="RDB持久化流程"><a href="#RDB持久化流程" class="headerlink" title="RDB持久化流程"></a><strong>RDB</strong>持久化流程</h4><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210619103155712.png" alt="image-20210619103155712" style="zoom:150%;">

<h4 id="dump-rdb文件"><a href="#dump-rdb文件" class="headerlink" title="dump.rdb文件"></a><strong>dump.rdb</strong>文件</h4><p>在redis.conf中配置文件名称，默认为dump.rdb。</p>
<p>rdb文件的保存路径，也可以修改。默认为Redis启动时命令行所在的目录下 “dir  .&#x2F;”</p>
<h4 id="如何触发RDB快照；保持策略"><a href="#如何触发RDB快照；保持策略" class="headerlink" title="如何触发RDB快照；保持策略"></a><strong>如何触发RDB快照；保持策略</strong></h4><p><strong>配置文件中默认的快照配置</strong></p>
<img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210619103558260.png" alt="image-20210619103558260" style="zoom:130%;">

<p><strong>命令save VS bgsave</strong></p>
<ul>
<li><p>save ：save时只管保存，其它不管，全部阻塞。手动保存，不建议。</p>
</li>
<li><p><strong>bgsave：Redis会在后台异步进行快照操作，</strong> <strong>快照同时还可以响应客户端请求。</strong></p>
</li>
<li><p>可以通过lastsave 命令获取最后一次成功执行快照的时间。</p>
</li>
</ul>
<p><strong>flushall命令</strong></p>
<p>执行flushall命令，也会产生dump.rdb文件，但里面是空的，无意义。</p>
<h4 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h4><ul>
<li><p>适合大规模的数据恢复</p>
</li>
<li><p>对数据完整性和一致性要求不高更适合使用</p>
</li>
<li><p>节省磁盘空间</p>
</li>
<li><p>恢复速度快</p>
</li>
</ul>
<p> <img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210619104039665.png" alt="image-20210619104039665"></p>
<h4 id="劣势"><a href="#劣势" class="headerlink" title="劣势"></a>劣势</h4><ul>
<li><p>Fork的时候，内存中的数据被克隆了一份，大致2倍的膨胀性需要考虑。</p>
</li>
<li><p>虽然Redis在fork时使用了<strong>写时拷贝技术</strong>，但是如果数据庞大时还是比较消耗性能。</p>
</li>
<li><p>在备份周期在一定间隔时间做一次备份，所以如果Redis意外down掉的话，就会丢失最后一次快照后的所有修改。</p>
</li>
</ul>
<h4 id="如何停止"><a href="#如何停止" class="headerlink" title="如何停止"></a>如何停止</h4><p>动态停止RDB：redis-cli config set save “”#save后给空值，表示禁用保存策略。</p>
<h4 id="小总结"><a href="#小总结" class="headerlink" title="小总结"></a>小总结</h4><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210619104309571.png" alt="image-20210619104309571" style="zoom:130%;">



<h2 id="Redis持久化之AOF"><a href="#Redis持久化之AOF" class="headerlink" title="Redis持久化之AOF"></a>Redis持久化之AOF</h2><h3 id="AOF（Append-Only-File）"><a href="#AOF（Append-Only-File）" class="headerlink" title="AOF（Append Only File）"></a>AOF<strong>（Append Only File）</strong></h3><p>以<strong>日志</strong>的形式来记录每个写操作（增量保存），将Redis执行过的所有写指令记录下来(<strong>读操作不记录</strong>)， <strong>只许追加文件但不可以改写文件</strong>，redis启动之初会读取该文件重新构建数据，换言之，redis 重启的话就根据日志文件的内容将写指令从前到后执行一次以完成数据的恢复工作。</p>
<h4 id="AOF持久化流程"><a href="#AOF持久化流程" class="headerlink" title="AOF持久化流程"></a><strong>AOF</strong>持久化流程</h4><ol>
<li><p>客户端的请求写命令会被append追加到AOF缓冲区内；</p>
</li>
<li><p>AOF缓冲区根据AOF持久化策略[always,everysec,no]将操作sync同步到磁盘的AOF文件中；</p>
</li>
<li><p>AOF文件大小超过重写策略或手动重写时，会对AOF文件rewrite重写，压缩AOF文件容量；</p>
</li>
<li><p>Redis服务重启时，会重新load加载AOF文件中的写操作达到数据恢复的目的。</p>
</li>
</ol>
<img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210619104813563.png" alt="image-20210619104813563" style="zoom:130%;">

<h4 id="AOF默认不开启"><a href="#AOF默认不开启" class="headerlink" title="AOF默认不开启"></a><strong>AOF</strong>默认不开启</h4><p>可以在redis.conf中配置文件名称默认为 appendonly.aof文件中开启，AOF文件的保存路径，同RDB的路径一致。</p>
<h4 id="AOF和RDB同时开启，redis听谁的？"><a href="#AOF和RDB同时开启，redis听谁的？" class="headerlink" title="AOF和RDB同时开启，redis听谁的？"></a>AOF和RDB同时开启，redis听谁的？</h4><p>AOF和RDB同时开启，系统默认取AOF的数据（数据不会存在丢失）。</p>
<h4 id="AOF启动、修复、恢复"><a href="#AOF启动、修复、恢复" class="headerlink" title="AOF启动、修复、恢复"></a><strong>AOF</strong>启动、修复、恢复</h4><ul>
<li><p>AOF的备份机制和性能虽然和RDB不同，但是备份和恢复的操作同RDB一样，都是拷贝备份文件，需要恢复时再拷贝到Redis工作目录下，启动系统即加载。</p>
</li>
<li><p>正常恢复</p>
<ul>
<li>修改默认的appendonly no，改为yes。</li>
<li>将有数据的aof文件复制一份保存到对应目录(查看目录：config get dir)。</li>
<li>恢复：重启redis然后重新加载。</li>
</ul>
</li>
<li><p>异常恢复</p>
<ul>
<li>修改默认的appendonly no，改为yes。</li>
<li>如遇到<strong>AOF文件损坏</strong>，通过&#x2F;usr&#x2F;local&#x2F;bin&#x2F;<strong>redis-check-aof–fix appendonly.aof</strong>进行恢复。</li>
<li>备份被写坏的AOF文件。</li>
<li>恢复：重启redis，然后重新加载。</li>
</ul>
</li>
</ul>
<h4 id="AOF同步频率设置"><a href="#AOF同步频率设置" class="headerlink" title="AOF同步频率设置"></a>AOF同步频率设置</h4><ul>
<li><p>appendfsync always：始终同步，每次Redis的写入都会立刻记入日志；性能较差但数据完整性比较好。</p>
</li>
<li><p>appendfsync everysec：每秒同步，每秒记入日志一次，如果宕机，本秒的数据可能丢失。</p>
</li>
<li><p>appendfsync no：redis不主动进行同步，把同步时机交给操作系统。</p>
</li>
</ul>
<h4 id="Rewrite压缩"><a href="#Rewrite压缩" class="headerlink" title="Rewrite压缩"></a><strong>Rewrite</strong>压缩</h4><p><strong>Rewrite压缩是什么</strong></p>
<p>AOF采用文件追加方式，文件会越来越大为避免出现此种情况，新增了重写机制，当AOF文件的大小超过所设定的阈值时，Redis就会启动AOF文件的内容压缩，只保留可以恢复数据的最小指令集，可以使用命令bgrewriteaof。</p>
<p><strong>重写原理，如何实现重写</strong></p>
<p>AOF文件持续增长而过大时，会fork出一条新进程来将文件重写(也是先写临时文件最后再rename)，redis4.0版本后的重写，是指把rdb 的快照，以二进制的形式附在新的aof头部，作为已有的历史数据，替换掉原来的流水账操作。</p>
<p><strong>no-appendfsync-on-rewrite：</strong></p>
<ul>
<li><p>如果 no-appendfsync-on-rewrite&#x3D;yes ，不写入aof文件只写入缓存，用户请求不会阻塞，但是在这段时间如果宕机会丢失这段时间的缓存数据。（降低数据安全性，提高性能）</p>
</li>
<li><p>如果 no-appendfsync-on-rewrite&#x3D;no，还是会把数据往磁盘里刷，但是遇到重写操作，可能会发生阻塞。（数据安全，但是性能降低）</p>
</li>
</ul>
<p><strong>触发机制，何时重写</strong></p>
<p>Redis会记录上次重写时的AOF大小，默认配置是当AOF文件大小是上次rewrite后大小的一倍且文件大于64M时触发。</p>
<p>重写虽然可以节约大量磁盘空间，减少恢复时间。但是每次重写还是有一定的负担的，因此设定Redis要满足一定条件才会进行重写。 </p>
<ul>
<li><p>auto-aof-rewrite-percentage：设置重写的基准值，文件达到100%时开始重写（文件是原来重写后文件的2倍时触发）。</p>
</li>
<li><p>auto-aof-rewrite-min-size：设置重写的基准值，最小文件64MB。达到这个值开始重写。</p>
</li>
<li><p>系统载入时或者上次重写完毕时，Redis会记录此时AOF大小，设为base_size,</p>
</li>
<li><p>如果Redis的AOF当前大小&gt;&#x3D; base_size +base_size*100% (默认)且当前大小&gt;&#x3D;64mb(默认)的情况下，Redis会对AOF进行重写。 </p>
</li>
<li><p>例如：文件达到70MB开始重写，降到50MB，下次什么时候开始重写？100MB</p>
</li>
</ul>
<p><strong>重写流程</strong></p>
<ol>
<li><p>bgrewriteaof触发重写，判断是否当前有bgsave或bgrewriteaof在运行，如果有，则等待该命令结束后再继续执行；</p>
</li>
<li><p>主进程fork出子进程执行重写操作，保证主进程不会阻塞；</p>
</li>
<li><p>子进程遍历redis内存中数据到临时文件，客户端的写请求同时写入aof_buf缓冲区和aof_rewrite_buf重写缓冲区，保证原AOF文件完整以及新AOF文件生成期间的新的数据修改动作不会丢失；</p>
</li>
<li><p>子进程写完新的AOF文件后，向主进程发信号，父进程更新统计信息。主进程把aof_rewrite_buf中的数据写入到新的AOF文件；</p>
</li>
<li><p>使用新的AOF文件覆盖旧的AOF文件，完成AOF重写。</p>
</li>
</ol>
<img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210619110418254.png" alt="image-20210619110418254" style="zoom:120%;">

<h4 id="优势-1"><a href="#优势-1" class="headerlink" title="优势"></a>优势</h4><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210619110452361.png" alt="image-20210619110452361" style="zoom:120%;">

<ul>
<li><p>备份机制更稳健，丢失数据概率更低。</p>
</li>
<li><p>可读的日志文本，通过操作AOF稳健，可以处理误操作。</p>
</li>
</ul>
<h4 id="劣势-1"><a href="#劣势-1" class="headerlink" title="劣势"></a>劣势</h4><ul>
<li><p>比起RDB占用更多的磁盘空间。</p>
</li>
<li><p>恢复备份速度要慢。</p>
</li>
<li><p>每次读写都同步的话，有一定的性能压力。</p>
</li>
<li><p>存在个别Bug，造成恢复不能。</p>
</li>
</ul>
<h4 id="小总结-1"><a href="#小总结-1" class="headerlink" title="小总结"></a>小总结</h4><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210619110629704.png" alt="image-20210619110629704" style="zoom:120%;">

<h3 id="总结-Which-one"><a href="#总结-Which-one" class="headerlink" title="总结(Which one)"></a><strong>总结</strong>(Which one)</h3><h4 id="用哪个好"><a href="#用哪个好" class="headerlink" title="用哪个好"></a><strong>用哪个好</strong></h4><p>官方推荐两个都启用：</p>
<ul>
<li><p>如果对数据不敏感，可以选单独用RDB。</p>
</li>
<li><p>不建议单独用 AOF，因为可能会出现Bug。</p>
</li>
<li><p>如果只是做纯内存缓存，可以都不用。</p>
</li>
</ul>
<h4 id="官网建议"><a href="#官网建议" class="headerlink" title="官网建议"></a>官网建议</h4><ul>
<li><p>RDB持久化方式能够在指定的时间间隔能对你的数据进行快照存储。</p>
</li>
<li><p>AOF持久化方式记录每次对服务器写的操作，当服务器重启的时候会重新执行这些命令来恢复原始的数据，AOF命令以redis协议追加保存每次写的操作到文件末尾。 </p>
</li>
<li><p>Redis还能对AOF文件进行后台重写，使得AOF文件的体积不至于过大。</p>
</li>
<li><p>只做缓存：如果你只希望你的数据在服务器运行的时候存在，你也可以不使用任何持久化方式。</p>
</li>
<li><p>同时开启两种持久化方式：在这种情况下，当redis重启的时候会优先载入AOF文件来恢复原始的数据，因为在通常情况下AOF文件保存的数据集要比RDB文件保存的数据集要完整。</p>
</li>
<li><p>RDB的数据不实时，同时使用两者时服务器重启也只会找AOF文件。那要不要只使用AOF呢？ </p>
</li>
<li><p>建议不要，因为RDB更适合用于备份数据库(AOF在不断变化不好备份)，快速重启，而且不会有AOF可能潜在的bug，留着作为一个万一的手段。</p>
</li>
<li><p>性能建议：</p>
<ul>
<li>因为RDB文件只用作后备用途，建议只在Slave上持久化RDB文件，而且只要15分钟备份一次就够了，只保留save 9001这条规则。    </li>
<li>如果使用AOF，好处是在最恶劣情况下也只会丢失不超过两秒数据，启动脚本较简单，只load自己的AOF文件就可以了。</li>
<li>aof代价：一是带来了持续的IO，二是AOF rewrite的最后，将rewrite过程中产生的新数据写到新文件造成的阻塞几乎是不可避免的。  </li>
<li>只要硬盘许可，应该尽量减少AOF  rewrite的频率，AOF重写的基础大小默认值64M太小了，可以设到5G以上。默认超过原大小100%大小时重写可以改到适当的数值。</li>
</ul>
</li>
</ul>
<h2 id="Redis主从复制"><a href="#Redis主从复制" class="headerlink" title="Redis主从复制"></a>Redis主从复制</h2><p>主机数据更新后根据配置和策略， 自动同步到备机的master&#x2F;slaver机制，<strong>Master以写为主，Slave以读为主</strong>，主从复制节点间数据是全量的。</p>
<p>作用：</p>
<ul>
<li><p>读写分离，性能扩展</p>
</li>
<li><p>容灾快速恢复</p>
</li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210619111652745.png" alt="image-20210619111652745" style="zoom:150%;">

<h3 id="复制原理"><a href="#复制原理" class="headerlink" title="复制原理"></a><strong>复制原理</strong></h3><ul>
<li><p>Slave启动成功连接到master后会发送一个sync命令；</p>
</li>
<li><p>Master接到命令启动后台的存盘进程，同时收集所有接收到的用于修改数据集命令，在后台进程执行完毕之后，master将传送整个数据文件到slave，以完成一次完全同步。</p>
</li>
<li><p>全量复制：slave服务器在接收到数据库文件数据后，将其存盘并加载到内存中。</p>
</li>
<li><p>增量复制：Master继续将新的所有收集到的修改命令依次传给slave，完成同步。</p>
</li>
<li><p>但是只要是重新连接master，一次完全同步（全量复制)将被自动执行。</p>
</li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210619112440704.png" alt="image-20210619112440704" style="zoom:150%;">

<h3 id="哨兵模式-sentinel"><a href="#哨兵模式-sentinel" class="headerlink" title="哨兵模式(sentinel)"></a><strong>哨兵模式</strong>(sentinel)</h3><p>反客为主：当一个master宕机后，后面的slave可以立刻升为master，其后面的slave不用做任何修改。用 slaveof no one 指令将从机变为主机。而哨兵模式是<strong>反客为主的自动版</strong>，能够后台监控主机是否故障，如果故障了根据投票数自动将从库转换为主库。</p>
<img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210619154258222.png" alt="image-20210619154258222" style="zoom:130%;">

<p> <strong>当主机挂掉，从机选举产生新的主机</strong></p>
<ul>
<li><p>哪个从机会被选举为主机呢？根据优先级别：slave-priority 。</p>
</li>
<li><p>原主机重启后会变为从机。</p>
</li>
</ul>
<p><strong>复制延时</strong></p>
<p>由于所有的写操作都是先在Master上操作，然后同步更新到Slave上，所以从Master同步到Slave机器有一定的延迟，当系统很繁忙的时</p>
<p>候，延迟问题会更加严重，Slave机器数量的增加也会使这个问题更加严重。</p>
<p><strong>故障恢复</strong></p>
<img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210619154850009.png" alt="image-20210619154850009" style="zoom:130%;">

<p>优先级：在redis.conf中默认 slave-priority 100，值越小优先级越高。</p>
<p>偏移量：指获得原主机数据最全的概率。</p>
<p>runid：每个redis实例启动后都会随机生成一个40位的runid。</p>
<h2 id="Redis集群（cluster模式）"><a href="#Redis集群（cluster模式）" class="headerlink" title="Redis集群（cluster模式）"></a>Redis集群（cluster模式）</h2><p>Redis 集群（包括很多小集群）实现了对Redis的水平扩容，即启动N个redis节点，将整个数据库分布存储在这N个节点中，每个节点存储总数据的1&#x2F;N，即一个小集群存储1&#x2F;N的数据，每个小集群里面维护好自己的1&#x2F;N的数据。</p>
<p>Redis 集群通过分区（partition）来提供一定程度的可用性（availability）： 即使集群中有一部分节点失效或者无法进行通讯， 集群也可以继续处理命令请求。</p>
<p>该模式的redis集群特点是：分治、分片。</p>
<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><ol>
<li><p>容量不够，redis如何进行扩容？</p>
</li>
<li><p>并发写操作， redis如何分摊？</p>
</li>
<li><p>另外，主从模式，薪火相传模式，主机宕机，导致ip地址发生变化，应用程序中配置需要修改对应的主机地址、端口等信息。</p>
</li>
<li><p>之前通过代理主机来解决，但是redis3.0中提供了解决方案。就是无中心化集群配置。</p>
</li>
</ol>
<h3 id="集群连接"><a href="#集群连接" class="headerlink" title="集群连接"></a>集群连接</h3><p>普通方式登录：可能直接进入读主机，存储数据时，会出现MOVED重定向操作，所以，应该以集群方式登录。</p>
 <img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210619162020586.png" alt="image-20210619162020586" style="zoom:150%;">

<p>集群登录：redis-cli -c -p 6379  采用集群策略连接，设置数据会自动切换到相应的写主机.</p>
<h3 id="redis-cluster-如何分配这六个节点"><a href="#redis-cluster-如何分配这六个节点" class="headerlink" title="redis cluster 如何分配这六个节点?"></a><strong>redis cluster</strong> <strong>如何分配这六个节点?</strong></h3><ul>
<li>一个集群至少要有三个主节点。</li>
<li>选项 –cluster-replicas 1 ：表示我们希望为集群中的每个主节点创建一个从节点。</li>
<li>分配原则尽量保证每个主数据库运行在不同的IP地址，每个从库和主库不在一个IP地址上。</li>
</ul>
<h3 id="什么是slots"><a href="#什么是slots" class="headerlink" title="什么是slots"></a>什么是slots</h3><p>一个 Redis 集群包含 16384 个插槽（hash slot），数据库中的每个键都属于这 16384 个插槽的其中一个。集群使用公式 CRC16(key) % 16384 来计算键 key 属于哪个槽， 其中 CRC16(key) 语句用于计算键 key 的 CRC16 校验和 。</p>
<p>集群中的每个节点负责处理一部分插槽。 举个例子， 如果一个集群可以有主节点， 其中：</p>
<ul>
<li>节点 A 负责处理 0 号至 5460 号插槽。</li>
<li>节点 B 负责处理 5461 号至 10922 号插槽。</li>
<li>节点 C 负责处理 10923 号至 16383 号插槽。</li>
</ul>
<h3 id="在集群中录入值"><a href="#在集群中录入值" class="headerlink" title="在集群中录入值"></a><strong>在集群中录入值</strong></h3><p>在redis-cli每次录入、查询键值，redis都会计算出该key应该送往的插槽，如果不是该客户端对应服务器的插槽，redis会报错，并告知应前往的redis实例地址和端口。</p>
<p>redis-cli客户端提供了 –c 参数实现自动重定向。如 redis-cli -c –p 6379 登入后，再录入、查询键值对可以自动重定向。不在一个slot下的键值，是不能使用mget,mset等多键操作。</p>
<h3 id="故障恢复"><a href="#故障恢复" class="headerlink" title="故障恢复"></a><strong>故障恢复</strong></h3><ul>
<li><p>如果主节点下线？从节点能否自动升为主节点？注意：<strong>15</strong>秒超时</p>
</li>
<li><p>主节点恢复后，主从关系会如何？主节点回来变成从机。</p>
</li>
</ul>
<p>如果所有某一段插槽的主从节点都宕掉，redis服务是否还能继续?</p>
<ul>
<li><p>如果某一段插槽的主从都挂掉，而cluster-require-full-coverage 为yes ，那么整个集群都挂掉。</p>
</li>
<li><p>如果某一段插槽的主从都挂掉，而cluster-require-full-coverage 为no ，那么，该插槽数据全都不能使用，也无法存储。</p>
</li>
</ul>
<h3 id="Redis-集群优点"><a href="#Redis-集群优点" class="headerlink" title="Redis 集群优点"></a><strong>Redis</strong> <strong>集群优点</strong></h3><ul>
<li><p>实现扩容</p>
</li>
<li><p>分摊压力</p>
</li>
<li><p>无中心配置相对简单</p>
</li>
</ul>
<h3 id="Redis-集群不足"><a href="#Redis-集群不足" class="headerlink" title="Redis 集群不足"></a><strong>Redis</strong> <strong>集群不足</strong></h3><ul>
<li><p>多键操作是不被支持的。</p>
</li>
<li><p>多键的Redis事务是不被支持的，lua脚本不被支持。</p>
</li>
<li><p>由于集群方案出现较晚，很多公司已经采用了其他的集群方案，而代理或者客户端分片的方案想要迁移至redis cluster，需要整体迁移而不是逐步过渡，复杂度较大。</p>
</li>
</ul>
<h2 id="Redis应用问题解决"><a href="#Redis应用问题解决" class="headerlink" title="Redis应用问题解决"></a>Redis应用问题解决</h2><h3 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h3><h4 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h4><p>key对应的数据在数据源并不存在，每次针对此key的请求从缓存获取不到，请求都会压到数据源（数据库），从而可能压垮数据源。比如</p>
<p>用一个不存在的用户id获取用户信息，不论缓存还是数据库都没有，若黑客利用此漏洞进行攻击可能压垮数据库。</p>
<p>缓存穿透发生的条件：</p>
<ol>
<li>应用服务器压力变大</li>
<li>redis命中率降低</li>
<li>一直查询数据库，使得数据库压力太大而压垮</li>
</ol>
<p>其实redis在这个过程中一直平稳运行，崩溃的是我们的数据库（如MySQL）。</p>
<p>缓存穿透发生的原因：黑客或者其他非正常用户频繁进行很多非正常的url访问，使得redis查询不到数据库。</p>
<img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210619163643698.png" alt="image-20210619163643698" style="zoom:120%;">

<h4 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h4><ol>
<li><p><strong>对空值缓存：</strong>如果一个查询返回的数据为空（不管是数据是否不存在），我们仍然把这个空结果（null）进行缓存，设置空结果的过期时间会很短，最长不超过五分钟。</p>
</li>
<li><p><strong>设置可访问的名单（白名单）：</strong>使用bitmaps类型定义一个可以访问的名单，名单id作为bitmaps的偏移量，每次访问和bitmap里面的id进行比较，如果访问id不在bitmaps里面，进行拦截，不允许访问。</p>
</li>
<li><p><strong>采用布隆过滤器</strong>：布隆过滤器（Bloom Filter）是1970年由布隆提出的。它实际上是一个很长的二进制向量(位图)和一系列随机映射函数（哈希函数）。布隆过滤器可以用于检索一个元素是否在一个集合中。它的优点是空间效率和查询时间都远远超过一般的算法，缺点是有一定的误识别率和删除困难。</p>
</li>
<li><p><strong>进行实时监控：</strong>当发现Redis的命中率开始急速降低，需要排查访问对象和访问的数据，和运维人员配合，可以设置黑名单限制服务。</p>
</li>
</ol>
<h3 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h3><h4 id="问题描述-1"><a href="#问题描述-1" class="headerlink" title="问题描述"></a>问题描述</h4><p>key对应的数据存在，但在redis中过期，此时若有大量并发请求过来，这些请求发现缓存过期一般都会从后端数据库加载数据并回设到缓存，这个时候大并发的请求可能会瞬间把后端数据库压垮。</p>
<p>缓存击穿的现象：</p>
<ol>
<li>数据库访问压力瞬时增加，数据库崩溃</li>
<li>redis里面没有出现大量key过期</li>
<li>redis正常运行</li>
</ol>
<p>缓存击穿发生的原因：redis某个key过期了，大量访问使用这个key（热门key）。</p>
<img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210619165201337.png" alt="image-20210619165201337" style="zoom:120%;">

<h4 id="解决方案-1"><a href="#解决方案-1" class="headerlink" title="解决方案"></a>解决方案</h4><p>key可能会在某些时间点被超高并发地访问，是一种非常“热点”的数据。</p>
<ol>
<li><p><strong>预先设置热门数据：</strong>在redis高峰访问之前，把一些热门数据提前存入到redis里面，加大这些热门数据key的时长。</p>
</li>
<li><p><strong>实时调整：</strong>现场监控哪些数据热门，实时调整key的过期时长。</p>
</li>
<li><p><strong>使用锁：</strong></p>
<ol>
<li>就是在缓存失效的时候（判断拿出来的值为空），不是立即去load db。</li>
<li>先使用缓存工具的某些带成功操作返回值的操作（比如Redis的SETNX）去set一个mutex key。</li>
<li>当操作返回成功时，再进行load db的操作，并回设缓存，最后删除mutex key；</li>
<li>当操作返回失败，证明有线程在load db，当前线程睡眠一段时间再重试整个get缓存的方法。</li>
</ol>
</li>
</ol>
<img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210619165505113.png" alt="image-20210619165505113" style="zoom:120%;">

<h3 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h3><h4 id="问题描述-2"><a href="#问题描述-2" class="headerlink" title="问题描述"></a>问题描述</h4><p>key对应的数据存在，但在redis中过期，此时若有大量并发请求过来，这些请求发现缓存过期一般都会从后端数据库加载数据并回设到缓存，这个时候大并发的请求可能会瞬间把后端数据库压垮。</p>
<p>缓存雪崩与缓存击穿的区别在于这里针对很多key缓存，前者则是某一个key正常访问。</p>
<img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210619170416116.png" alt="image-20210619170416116" style="zoom:120%;">

<p><strong>缓存失效瞬间：</strong></p>
<img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210619170456227.png" alt="image-20210619170456227" style="zoom:120%;">

<h4 id="解决方案-2"><a href="#解决方案-2" class="headerlink" title="解决方案"></a>解决方案</h4><ol>
<li><p><strong>构建多级缓存架构：</strong>nginx缓存 + redis缓存 +其他缓存（ehcache等）。</p>
</li>
<li><p><strong>使用锁或队列：</strong>用加锁或者队列的方式来保证不会有大量的线程对数据库一次性进行读写，从而避免失效时大量的并发请求落到底层存储系统上，该方法不适用高并发情况。</p>
</li>
<li><p><strong>设置过期标志更新缓存：</strong>记录缓存数据是否过期（设置提前量），如果过期会触发通知另外的线程在后台去更新实际key的缓存。</p>
</li>
<li><p><strong>将缓存失效时间分散开：</strong>比如可以在原有的失效时间基础上增加一个随机值，比如1-5分钟随机，这样每一个缓存的过期时间的重复率就会降低，就很难引发集体失效的事件。</p>
</li>
</ol>
<h3 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h3><h4 id="问题描述-3"><a href="#问题描述-3" class="headerlink" title="问题描述"></a>问题描述</h4><p>随着业务发展的需要，原单体单机部署的系统被演化成分布式集群系统后，由于分布式系统多线程的特点以及分布在不同机器上，这将使原单机部署情况下的并发控制锁策略失效，单纯的Java API并不能提供分布式锁的能力。为了解决这个问题就需要一种跨JVM的互斥机制来控制共享资源的访问，这就是分布式锁要解决的问题！</p>
<p>分布式锁主流的实现方案：</p>
<ol>
<li><p>基于数据库实现分布式锁</p>
</li>
<li><p>基于缓存（Redis等）</p>
</li>
<li><p>基于Zookeeper</p>
</li>
</ol>
<p>根据实现方式，分布式锁还可以分为类CAS自旋式分布式锁以及event事件类型分布式锁：</p>
<ul>
<li>类CAS自旋式分布式锁：询问的方式，类似java并发编程中的线程获询问的方式尝试加锁，如mysql、redis。</li>
<li>另外一类是event事件通知进程后续锁的变化，轮询向外的过程，如zookeeper、etcd。</li>
</ul>
<p>每一种分布式锁解决方案都有各自的优缺点：</p>
<ol>
<li><p>性能：redis最高</p>
</li>
<li><p>可靠性：zookeeper最高</p>
</li>
</ol>
<h4 id="解决方案：使用redis实现分布式锁"><a href="#解决方案：使用redis实现分布式锁" class="headerlink" title="解决方案：使用redis实现分布式锁"></a><strong>解决方案：使用redis实现分布式锁</strong></h4><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210619213926122.png" alt="image-20210619213926122" style="zoom:120%;">

<p>setnx：通过该命令尝试获得锁，没有获得锁的线程会不断等待尝试。</p>
<p>set key ex 3000nx：设置过期时间，自动释放锁，解决当某一个业务异常而导致锁无法释放的问题。但是当业务运行超过过期时间时，开辟监控线程增加该业务的运行时间，直到运行结束，释放锁。</p>
<p>uuid：设置uuid，释放前获取这个值，判断是否自己的锁，防止误删锁，造成没锁的情况。</p>
<h3 id="RedLock"><a href="#RedLock" class="headerlink" title="RedLock"></a>RedLock</h3><p>Redlock是一种算法，Redlock也就是 Redis Distributed Lock，可用实现多节点redis的分布式锁。RedLock官方推荐，Redisson完成了对Redlock算法封装。</p>
<p>此种方式具有以下特性：</p>
<ul>
<li>互斥访问：即永远只有一个 client 能拿到锁。</li>
<li>避免死锁：最终 client 都可能拿到锁，不会出现死锁的情况，即使锁定资源的服务崩溃或者分区，仍然能释放锁。</li>
<li>容错性：只要大部分 Redis 节点存活（一半以上），就可以正常提供服务</li>
</ul>
<p>RedLock原理（了解）</p>
<ol>
<li>获取当前Unix时间，以毫秒为单位。</li>
<li>依次尝试从N个实例，使用相同的key和随机值获取锁。在步骤2，当向Redis设置锁时，客户端应该设置一个网络连接和响应超时时间，这个超时时间应该小于锁的失效时间。例如你的锁自动失效时间为10秒，则超时时间应该在5-50毫秒之间。这样可以避免服务器端Redis已经挂掉的情况下，客户端还在死死地等待响应结果。如果服务器端没有在规定时间内响应，客户端应该尽快尝试另外一个Redis实例。</li>
<li>客户端使用当前时间减去开始获取锁时间（步骤1记录的时间）就得到获取锁使用的时间。当且仅当从大多数（这里是3个节点）的Redis节点都取到锁，并且使用的时间小于锁失效时间时，锁才算获取成功。</li>
<li>如果取到了锁，key的真正有效时间等于有效时间减去获取锁所使用的时间（步骤3计算的结果）。</li>
<li>如果因为某些原因，获取锁失败（没有在至少N&#x2F;2+1个Redis实例取到锁或者取锁时间已经超过了有效时间），客户端应该在所有的Redis实例上进行解锁（即便某些Redis实例根本就没有加锁成功）。</li>
</ol>
<h2 id="Redis-IO多线程"><a href="#Redis-IO多线程" class="headerlink" title="Redis IO多线程"></a>Redis IO多线程</h2><h3 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h3><p>Redis6终于支撑多线程了，告别单线程了吗？</p>
<p>IO多线程其实指<strong>客户端交互部分</strong>的<strong>网络IO</strong>交互处理模块<strong>多线程</strong>，而非<strong>执行命令多线程</strong>。Redis6执行命令依然是单线程。</p>
<h3 id="原理架构"><a href="#原理架构" class="headerlink" title="原理架构"></a><strong>原理架构</strong></h3><p>Redis 6 加入多线程，但跟 Memcached 这种从 IO处理到数据访问多线程的实现模式有些差异。Redis 的多线程部分只是用来处理网络数据的读写和协议解析，执行命令仍然是单线程。之所以这么设计是不想因为多线程而变得复杂，需要去控制 key、lua、事务，LPUSH&#x2F;LPOP 等等的并发问题。整体的设计大体如下:</p>
<img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210619215600452.png" alt="image-20210619215600452" style="zoom:120%;">

<p>另外，多线程IO默认也是不开启的，需要再配置文件中配置：</p>
<ul>
<li><p>io-threads-do-reads yes </p>
</li>
<li><p>io-threads 4</p>
</li>
</ul>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
</search>
